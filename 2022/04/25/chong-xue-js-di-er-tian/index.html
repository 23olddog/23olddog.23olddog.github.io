<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="重学JS第二天, 前端 | Android">
    <meta name="description" content="对象、类与面向对象编程Object.assign()接收一个目标对象和一个或多个元对象作为参数 然后将每个原对象中可枚举（Object.propertyIsEnumerable()返回 true）和自有（Object.hasOwnPrope">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    
    <style>
        body{
            background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>


    <title>重学JS第二天 | olddog</title>
    <link rel="icon" type="image/png" href="/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="olddog" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">olddog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">olddog</div>
        <div class="logo-desc">
            
            nothing but code
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/23olddog" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/23olddog" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">重学JS第二天</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JS/">
                                <span class="chip bg-color">JS</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" class="post-category">
                                前端基础
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-04-25
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-09-27
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    17.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    71 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p><code>Object.assign()</code>接收一个目标对象和一个或多个元对象作为参数 然后将每个原对象中可枚举（<code>Object.propertyIsEnumerable()</code>返回 true）和自有（<code>Object.hasOwnProperty()</code>返回 true）属性复制到目标对象以字符串和符号为键的属性 会被复制。对每个符合条件的属性，这个方法会使用源对象上的<code>[[Get]]</code>取得属性的值，然后使用目标 对象上的<code>[[Set]]</code>设置属性的值。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = { <span class="attr">id</span>: <span class="string">"src"</span> };</span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// Object.assign 修改目标对象</span></span><br><span class="line"><span class="comment">// 也会返回修改后的目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest === result); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest !== src); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// { id: src }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { id: src }</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dest = {</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">val</span>) {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Invoked dest setter with param <span class="subst">${val}</span>`</span>);</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">src = {</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">a</span>() {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Invoked src getter'</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 调用 src 的获取方法</span></span><br><span class="line"><span class="comment">// 调用 dest 的设置方法并传入参数"foo"</span></span><br><span class="line"><span class="comment">// 因为这里的设置函数不执行赋值操作</span></span><br><span class="line"><span class="comment">// 所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// Invoked src getter"</span></span><br><span class="line"><span class="string">"Invoked dest setter with param foo"</span> {}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = { <span class="attr">a</span>: {} };</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { a :{} }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest.<span class="property">a</span> === src.<span class="property">a</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest == src)<span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>assign()</code>是浅复制 意味着只会复制对象的引用</p>
</blockquote>
<p>如果赋值期间出错 操作会中止并退出 同时抛出错误 因此可能只完成部分复制</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = {</span><br><span class="line">  <span class="attr">a</span>: <span class="string">"foo"</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">b</span>() {</span><br><span class="line">    <span class="comment">// Object.assign()在调用这个获取函数时会抛出错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">c</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line">} <span class="keyword">catch</span> (e) {}</span><br><span class="line"><span class="comment">// Object.assign()没办法回滚已经完成的修改</span></span><br><span class="line"><span class="comment">// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { a: foo }</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>可计算属性表达式中抛出任何错误都会中断对象创建 如果计算属性的表达式有副作用就要小心 因为如果表达式抛出错误 那么之前完成的计算是不能回滚的</p>
</blockquote>
<p>解构并不要求变量必须在解构表达式中说明 不过 如果是事先声明的变量 则赋值表达式必须包含在一对括号中</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personName, personAge;</span><br><span class="line"><span class="keyword">let</span> person = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"Matt"</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line">};</span><br><span class="line">({ <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge } = person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName, personAge); <span class="comment">// Matt, 27</span></span><br><span class="line"><span class="comment">//vue的写法</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>({</span><br><span class="line">  <span class="attr">name</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">0</span>,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> response = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"olddog"</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">}(({ <span class="attr">name</span>: data.<span class="property">name</span>, <span class="attr">age</span>: data.<span class="property">age</span> } = response)); <span class="comment">//data:{name: 'olddog', age: 23}</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><p>可以通过解构来复制对象属性</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = {</span><br><span class="line"> <span class="attr">name</span>: <span class="string">'Matt'</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line"> <span class="attr">job</span>: {</span><br><span class="line"> <span class="attr">title</span>: <span class="string">'Software engineer'</span></span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> personCopy = {};</span><br><span class="line">({</span><br><span class="line"> <span class="attr">name</span>: personCopy.<span class="property">name</span>,</span><br><span class="line"> <span class="attr">age</span>: personCopy.<span class="property">age</span>,</span><br><span class="line"> <span class="attr">job</span>: personCopy.<span class="property">job</span></span><br><span class="line">} = person);</span><br><span class="line"><span class="comment">// 因为一个对象的引用被赋值给 personCopy，所以修改</span></span><br><span class="line"><span class="comment">// person.job 对象的属性也会影响 personCopy</span></span><br><span class="line">person.<span class="property">job</span>.<span class="property">title</span> = <span class="string">'Hacker'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line"><span class="comment">// { name: 'Matt', age: 27, job: { title: 'Hacker' } }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personCopy);</span><br><span class="line"><span class="comment">// { name: 'Matt', age: 27, job: { title: 'Hacker' } }</span></span><br><span class="line">--------------------------------</span><br><span class="line">vue的写法</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>({</span><br><span class="line">	<span class="attr">name</span>: <span class="string">''</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">address</span>:{</span><br><span class="line">  <span class="attr">home</span>:<span class="string">""</span></span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"><span class="keyword">const</span> response = {</span><br><span class="line">	<span class="attr">name</span>: <span class="string">'olddogewqeeqwweq'</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="attr">address</span>:{</span><br><span class="line">    <span class="attr">home</span>: <span class="string">'huilaieqw1341343'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  ({<span class="attr">name</span>: data.<span class="property">name</span>, <span class="attr">age</span>: data.<span class="property">age</span>, <span class="attr">address</span>:{<span class="attr">home</span>: data.<span class="property">address</span>.<span class="property">home</span>}} = response)<span class="comment">//data:{name: 'olddog', age: 23}</span></span><br><span class="line">  response.<span class="property">name</span> = <span class="string">"wdqdw"</span></span><br><span class="line">  response.<span class="property">address</span>.<span class="property">home</span> = <span class="string">'2132'</span></span><br><span class="line">  data.<span class="property">address</span>.<span class="property">home</span> = <span class="string">'qdewqdeqsw'</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="comment">//改变response不会影响data</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>涉及到多个属性的解构赋值是一个无关输出的顺序化操作 如果一个解构表达式涉及多个赋值 如果开始的赋值成功而后面的赋值出错 则整个赋值表达式只会完成一部分</p>
</blockquote>
<p><strong>Object.setPrototypeof()可能会严重影响代码性能</strong></p>
<p><code>hasOwnProprtty()</code>用于确定某个属性是实例上还是原型对象上（实例上返回<code>true</code>）</p>
<h5 id="原型和-in-操作符"><a href="#原型和-in-操作符" class="headerlink" title="原型和 in 操作符"></a>原型和 in 操作符</h5><p>单独使用<code>in</code>只要可以访问到对象指定属性时返回<code>true</code> 无论是在实例上还是在原型上</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以同时使用hasOwnProperty()和in()操作符来确定某个属性是否存在于原型上</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasPrototypePrototy</span>(<span class="params">object, name</span>) {</span><br><span class="line">  <span class="keyword">return</span> !object.<span class="title function_">hasOwnProprtty</span>(name) &amp;&amp; name <span class="keyword">in</span> object;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) {}</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">"Software Engineer"</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(person, <span class="string">"name"</span>)); <span class="comment">// true --对象在原型上</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">"Greg"</span>; <span class="comment">//重写name属性后 实例上也有这个属性了 即使原型上还有name属性 但是会被实例上的属性遮蔽 所以不会被用到</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(person, <span class="string">"name"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>for-in</code>只要能通过对象访问到并且可以被枚举的属性都会返回 包括实例属性和原型属性（遮蔽原型中不可枚举的实例属性也会被返回 因为默认情况下开发者定义的属性都是可枚举的）</p>
<p>如果要获得对象上的所有可枚举实例属性 可以使用<code>Object.keys()</code> (返回包含该对象所有可枚举属性名称的字符串数组)</p>
<blockquote>
<p><code>Object.keys()</code> 和 <code>Object.getOwnPropertyNames()</code> 在适当的时候都可以用来代替<code>for- in</code> 循环</p>
</blockquote>
<h5 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h5><p><code>for-in、Object.keys()</code>的枚举顺序是不确定的 <code>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign()</code> 的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中 定义的键以它们逗号分隔的顺序插入。</p>
<h4 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h4><p><code>Object.values()</code>返回对象值的数组 <code>Object.entries()</code>返回键值对的数组</p>
<blockquote>
<p>这两个方法执行对象浅复制</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"james"</span>,</span><br><span class="line">  <span class="attr">address</span>: {</span><br><span class="line">    <span class="attr">home</span>: <span class="string">"sga"</span>,</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> per1 = <span class="title class_">Object</span>.<span class="title function_">values</span>(data)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> per2 = <span class="title class_">Object</span>.<span class="title function_">values</span>(data)[<span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1); <span class="comment">//james</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per2);</span><br><span class="line">{</span><br><span class="line">  <span class="attr">home</span>: <span class="string">"sga"</span>;</span><br><span class="line">}</span><br><span class="line">data.<span class="property">name</span> = <span class="string">"curry"</span>;</span><br><span class="line">data.<span class="property">address</span>.<span class="property">home</span> = <span class="string">"school"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1); <span class="comment">//james</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per2); <span class="comment">//school</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>使用<code>new</code>调用类的构造函数会执行以下操作</p>
<ol>
<li>在内存中创建一个新对象</li>
<li>在这个新对象内部的<code>[[Prototype]]</code>指针被复制为构造函数的<code>prototype</code>属性</li>
<li>构造函数内部的 this 被赋值为这个新对象（即<code>this</code>指向新对象）</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li>如果构造函数返回非空对象 则返回该对象 否则 返回刚创建的新对象</li>
</ol>
<h1 id="代理和反射"><a href="#代理和反射" class="headerlink" title="代理和反射"></a>代理和反射</h1><p>在代理对象上执行的任何操作实际上都会应用到目标对象 唯一可以感知的不同就是代码中操作的是代理对象那个</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">	<span class="attr">id</span>: <span class="string">'target'</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> handler = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span> == proxy.<span class="property">id</span>)<span class="comment">//true; id属性会访问同一个值</span></span><br><span class="line">target.<span class="property">id</span> = <span class="string">'foo'</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span> == proxy.<span class="property">id</span>);<span class="comment">//true 给目标属性赋值会反映在两个对象上 因为两个对象访问的是同一个值</span></span><br><span class="line">proxy.<span class="property">id</span> = <span class="string">'bar'</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( target.<span class="property">id</span> == proxy.<span class="property">id</span>);<span class="comment">//true 给代理属性赋值会反映到两个对象上 因为这个赋值会转移到目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>);<span class="comment">//TypeError: Function has non-object prototype</span></span><br><span class="line"><span class="string">'undefined'</span> <span class="keyword">in</span> <span class="keyword">instanceof</span> check <span class="title class_">Proxy</span>.<span class="property"><span class="keyword">prototype</span></span>是<span class="literal">undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target == proxy)<span class="comment">//false 严格相等可以用来区分代理和目标</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h3><p>使用代理的主要目的是可以定义捕获器(trap)</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个get捕获器 在调用get（）时触发</span></span><br><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="comment">//捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"handler override"</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></tbody></table></figure>

<h5 id="捕获器参数和反射-API"><a href="#捕获器参数和反射-API" class="headerlink" title="捕获器参数和反射 API"></a>捕获器参数和反射 API</h5><p>所有捕获器都可以访问相应的参数 基于这些参数可以重建被捕获方法的原始行为</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) {</span><br><span class="line">    <span class="keyword">return</span> trapTarget[property];</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以调用全局<code>Reflect</code>对象上（封装了原始行为）的同名方法来轻松重建</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">'bar'</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"> <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"> }</span><br><span class="line"> <span class="comment">//简洁写法</span></span><br><span class="line"> <span class="attr">get</span>: <span class="title class_">Reflect</span>.<span class="property">get</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="comment">//反射API为开发者准备好了样板代码 在此基础上可以用最少的代码修改捕获的方法</span></span><br><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">'bar'</span>,</span><br><span class="line"> <span class="attr">baz</span>: <span class="string">'qux'</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"> <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) {</span><br><span class="line"> <span class="keyword">let</span> decoration = <span class="string">''</span>;</span><br><span class="line"> <span class="keyword">if</span> (property === <span class="string">'foo'</span>) {</span><br><span class="line"> decoration = <span class="string">'!!!'</span>;</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>) + decoration;</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar!!!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">baz</span>); <span class="comment">// qux</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">baz</span>); <span class="comment">// qux</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h4><p>捕获器应该遵守某些规范而不是出现过于反常的行为</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的</span><br><span class="line">值时，会抛出 <span class="title class_">TypeError</span>：</span><br><span class="line"><span class="keyword">const</span> target = {};</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">'foo'</span>, {</span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">value</span>: <span class="string">'bar'</span></span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"> <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line"> <span class="keyword">return</span> <span class="string">'qux'</span>;</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">//TypeError</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h5><p>使用<code>new Proxy()</code>创建的普通代理的联系在代理的生命周期内会一直持续纯在 可以使用<code>revocable()</code>来撤销代理对象和目标对象的联系 撤销时不可逆和幂等的（调用多少次都一样） 撤销后再调用代理就会抛出<code>TypeError</code></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//撤销函数和代理对象是在实例化时同时生成的</span></span><br><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"intercepted"</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> { proxy, revoke } = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// intercepted</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// TypeError</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="使用反射-API"><a href="#使用反射-API" class="headerlink" title="使用反射 API"></a>使用反射 API</h4><p>优先使用反射 API 的情况</p>
<p>Object 上的方法适用于通用程序 而反射方法适用于细粒度的对象控制与操作</p>
<h5 id="状态标记"><a href="#状态标记" class="headerlink" title="状态标记"></a>状态标记</h5><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始代码</span></span><br><span class="line"><span class="keyword">const</span> o = {};</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"success"</span>);</span><br><span class="line">} <span class="keyword">catch</span> (e) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"failure"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用反射方法重构</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(o, <span class="string">"foo"</span>, { <span class="attr">value</span>: <span class="string">"bar"</span> })) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"success"</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"failure"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以下反射方法都会提供状态标记：</p>
<ul>
<li><code>Reflect.defineProperty()</code></li>
<li><code>Reflect.preventExtensions()</code></li>
<li><code>Reflect.setPrototypeOf()</code></li>
<li><code>Reflect.set()</code></li>
<li><code>Reflect.deleteProperty(</code></li>
</ul>
<p>以下反射方法提供只有通过操作符才能完成的操作。</p>
<ul>
<li><code>Reflect.get()：</code>可以替代对象属性访问操作符</li>
<li><code>Reflect.set()</code>：可以替代=赋值操作符</li>
<li><code>Reflect.has()</code>：可以替代 in 操作符或 with()</li>
<li><code>Reflect.deleteProperty()</code>：可以替代 delete 操作符</li>
<li><code>Reflect.construct()</code>：可以替代 new 操作符</li>
</ul>
<p><strong>可以创建一个代理去代理另一个代理 这样就能在一个目标对象上构建多层拦截网</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> firstProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"first proxy"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> secondProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(firstProxy, {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"second proxy"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondProxy.<span class="property">foo</span>); <span class="comment">//second first bar</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="代理的问题与不足"><a href="#代理的问题与不足" class="headerlink" title="代理的问题与不足"></a>代理的问题与不足</h3><h5 id="代理中的-this"><a href="#代理中的-this" class="headerlink" title="代理中的 this"></a>代理中的 this</h5><p>如果目标对象依赖于对象标识 那么就可能出现问题</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入有一个weakMap</span></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">userId</span>) {</span><br><span class="line"> wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, userId);</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">id</span>(<span class="params">userId</span>) {</span><br><span class="line"> wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, userId);</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">id</span>() {</span><br><span class="line"> <span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">id</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">const</span> userInstanceProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, {});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInstanceProxy.<span class="property">id</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">//这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实</span></span><br><span class="line">例。要解决这个问题，就需要重新配置代理，把代理 <span class="title class_">User</span> 实例改为代理 <span class="title class_">User</span> 类本身。之后再创建代</span><br><span class="line">理的实例就会以代理实例作为 <span class="title class_">WeakMap</span> 的键了：</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserClassProxy</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, {});</span><br><span class="line"><span class="keyword">const</span> proxyUser = <span class="keyword">new</span> <span class="title class_">UserClassProxy</span>(<span class="number">456</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyUser.<span class="property">id</span>);</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代理与内部槽位"><a href="#代理与内部槽位" class="headerlink" title="代理与内部槽位"></a>代理与内部槽位</h5><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//，Date 类型方法的执行依赖 this 值上的</span></span><br><span class="line">内部槽位[[<span class="title class_">NumberDate</span>]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通</span><br><span class="line">的 <span class="title function_">get</span>()和 <span class="title function_">set</span>()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 <span class="title class_">TypeError</span></span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, {});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy <span class="keyword">instanceof</span> <span class="title class_">Date</span>); <span class="comment">// true</span></span><br><span class="line">proxy.<span class="title function_">getDate</span>(); <span class="comment">// TypeError: 'this' is not a Date object</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="代理捕获器和反射方法"><a href="#代理捕获器和反射方法" class="headerlink" title="代理捕获器和反射方法"></a>代理捕获器和反射方法</h2><blockquote>
<p>对于代理对象上执行的任何一种操作 只会有一个捕获程序会被调用 不存在重复捕获的情况</p>
</blockquote>
<h3 id="get（）方法"><a href="#get（）方法" class="headerlink" title="get（）方法"></a>get（）方法</h3><p><code>get()</code>捕获器会在获取属性值的操作中被调用 对应的反射 API 为<code>Reflect.get()</code></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, {</span><br><span class="line"> <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'get()'</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line">proxy.<span class="property">foo</span>;</span><br><span class="line"><span class="comment">//拦截的操作</span></span><br><span class="line">proxy.<span class="property">property</span></span><br><span class="line">proxy[property]</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(proxy)[property]</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(proxy, property, receiver)</span><br><span class="line"><span class="comment">//捕获不变式</span></span><br><span class="line">如果target.<span class="property">property</span>不可写且不可配置 则处理程序返回的值必须与target.<span class="property">property</span>匹配</span><br><span class="line">如果target.<span class="property">property</span>不可配置且[[<span class="title class_">Get</span>]]特性为<span class="literal">undefined</span> 处理程序的返回值也必须是<span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="set（）"><a href="#set（）" class="headerlink" title="set（）"></a>set（）</h3><p><code>set()</code>捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 <code>Reflect.set()。</code></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, {</span><br><span class="line"> <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'set()'</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">'bar'</span>;</span><br><span class="line"><span class="comment">// set()</span></span><br><span class="line"><span class="comment">//返回值：true 表示成功 false 表示失败</span></span><br><span class="line"><span class="comment">//拦截的操作</span></span><br><span class="line">proxy.<span class="property">property</span> = value;</span><br><span class="line">proxy[peoperty] = value;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(proxy)[property] = value</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(proxy, property, value, receiver)</span><br><span class="line"><span class="comment">//捕获器处理程序参数</span></span><br><span class="line"><span class="attr">target</span>: 目标对象</span><br><span class="line"><span class="attr">property</span>: 引用的目标对象上的字符串键属性</span><br><span class="line">value：要赋给属性的值</span><br><span class="line">receiver：接收最初赋值的对象</span><br><span class="line"><span class="comment">//捕获器不变式</span></span><br><span class="line">如果target.<span class="property">property</span>不可写且不可配置 则不修改目标属性的值</span><br><span class="line">如果target.<span class="property">property</span>不可配置且[[<span class="title class_">Set</span>]]特性为<span class="literal">undefined</span> 则不能修改目标属性的值</span><br><span class="line">在严格模式下 处理程序中返回<span class="literal">false</span>会抛出<span class="title class_">TypeError</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="has（）"><a href="#has（）" class="headerlink" title="has（）"></a>has（）</h3><p><code>has()</code>捕获器会在 in 操作符中被调用。对应的反射 API 方法为 <code>Reflect.has()。</code></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, {</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, property</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"has()"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="string">"foo"</span> <span class="keyword">in</span> proxy;</span><br><span class="line"><span class="comment">//返回值 必须返回布尔值 表示属性是否存在 返回非布尔值会被转型为布尔值</span></span><br><span class="line"><span class="comment">//捕获不变式：</span></span><br><span class="line"><span class="comment">//如果 target.property 存在且不可配置，则处理程序必须返回 true。</span></span><br><span class="line"><span class="comment">//如果 target.property 存在且目标对象不可扩展，则处理程序必须返回 true。</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>apply()捕获器会在调用函数时被调用 对应的反射 api 方法为 Reflect.apply()</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myTarget</span> = (<span class="params"></span>) =&gt; {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, {</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">target, thisArg, ...argumentsList</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"apply()"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// apply()</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h4 id="跟踪属性访问（很重要）"><a href="#跟踪属性访问（很重要）" class="headerlink" title="跟踪属性访问（很重要）"></a><strong>跟踪属性访问</strong>（很重要）</h4><p>通过捕获<code>get set 和has</code>等操作 可以知道对象属性说明时候被使用 查询的那个 把实现相应捕获器的某个对象代理放到应用中 就可以检测这个对象何时在何处被访问过</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = {</span><br><span class="line">	<span class="attr">name</span>: <span class="string">'Jack'</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, {</span><br><span class="line">	<span class="title function_">get</span>(<span class="params">target, property, receiver</span>) {</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Getting ${property}'</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) {</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Setting ${property} = ${value}'</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">	}</span><br><span class="line">})</span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// Getting name</span></span><br><span class="line">proxy.<span class="property">age</span> = <span class="number">27</span>; <span class="comment">// Setting age=27</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h4><p>代理的内部实现对外部代码是不可见的 因此可以用来隐藏目标对象上的属性</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">"foo"</span>, <span class="string">"bar"</span>];</span><br><span class="line"><span class="keyword">const</span> targetObject = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="number">3</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targetObject, {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property</span>) {</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, property</span>) {</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="comment">// get()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">bar</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">baz</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// has()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"foo"</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"bar"</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"baz"</span> <span class="keyword">in</span> proxy); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h4><p>因为所有的赋值操作都会触发<code>set（）</code>捕获器 所以可以根据所赋的值决定是允许还是拒绝赋值</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">onlyNumbersGoHere</span>: <span class="number">0</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, {</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value</span>) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">"number"</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="string">"2"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="函数与构造函数参数验证"><a href="#函数与构造函数参数验证" class="headerlink" title="函数与构造函数参数验证"></a>函数与构造函数参数验证</h4><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种 类型的值：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">median</span>(<span class="params">...nums</span>) {</span><br><span class="line"> <span class="keyword">return</span> nums.<span class="title function_">sort</span>()[<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>)];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(median, {</span><br><span class="line"> <span class="title function_">apply</span>(<span class="params">target, thisArg, argumentsList</span>) {</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> arg <span class="keyword">of</span> argumentsList) {</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'number'</span>) {</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">'Non-number argument provided'</span>;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">4</span>, <span class="string">'7'</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// Error: Non-number argument provided</span></span><br><span class="line">类似地，可以要求实例化时必须给构造函数传参：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">id</span>) {</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">id_</span> = id;</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, {</span><br><span class="line"> <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) {</span><br><span class="line"> <span class="keyword">if</span> (argumentsList[<span class="number">0</span>] === <span class="literal">undefined</span>) {</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">'User cannot be instantiated without id'</span>;</span><br><span class="line"> } <span class="keyword">else</span> {</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// Error: User cannot be instantiated without id</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="数据绑定和可观察对象"><a href="#数据绑定和可观察对象" class="headerlink" title="数据绑定和可观察对象"></a>数据绑定和可观察对象</h4><p>通过代理把运行中原本不相关的部分联系在一起 可以实现各种模式 从而让不同的代码互操作 比如 可以将代理的类绑定到一个全局实例集合 让所有创建的实例都被添加到这个集合中</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name_</span> = name;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, {</span><br><span class="line">  <span class="title function_">construct</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> newUser = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    userList.<span class="title function_">push</span>(nreUser);</span><br><span class="line">    <span class="keyword">return</span> newUser;</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="string">"John"</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="string">"Jacob"</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="string">"Jingqdqdk"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>另外 还可以将集合绑定到一个事件分派程序 每次插入新实例都会发送消息</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">emit</span>(<span class="params">newValue</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(userList, {</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) {</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">      <span class="title function_">emit</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="string">"John"</span>);</span><br><span class="line"><span class="comment">// John</span></span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="string">"Jacob"</span>);</span><br><span class="line"><span class="comment">// Jacob</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote>
<p>ECMAScript 中的所有参数都按值传递 不可能按引用传递 如果把对象作为参数重载 那么传递的值就是这个对象的引用</p>
</blockquote>
<p>JavaScript 引擎在任何代码执行之前 会先读取函数声明 并在执行上下文中生成函数定义 而函数表达式必须等到代码执行到它的那一行 才会在执行上下文中生成函数定义。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) {</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//函数声明提升：函数声明会在任何代码执行之前被读取并添加到上下文中</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span> (<span class="params">num1, num2</span>) {</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//提升的是sum变量 而不是函数</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>从一个函数内部返回另一个函数也是可以的 而且非常重要</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">object1, object2</span>) {</span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) {</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">"Zachary"</span>, <span class="attr">age</span>: <span class="number">28</span> },</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">age</span>: <span class="number">29</span> },</span><br><span class="line">];</span><br><span class="line"><span class="comment">//可以根据不同的属性来进行不同的比较规则</span></span><br><span class="line">data.<span class="title function_">sort</span>(<span class="title function_">createComparisonFunction</span>(<span class="string">"name"</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="number">0</span>].<span class="property">name</span>); <span class="comment">// Nicholas</span></span><br><span class="line">data.<span class="title function_">sort</span>(<span class="title function_">createComparisonFunction</span>(<span class="string">"age"</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="number">0</span>].<span class="property">name</span>); <span class="comment">// Zachary</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>箭头函数中的<code>this</code>引用的是定义箭头函数的上下文</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">let</span> o = {</span><br><span class="line">  <span class="attr">color</span>: <span class="string">"blue"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sayColor</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">//red</span></span><br><span class="line">o.<span class="property">sayColor</span> = sayColor;</span><br><span class="line">o.<span class="title function_">sayColor</span>(); <span class="comment">//red</span></span><br><span class="line"><span class="comment">//因为this是在window上下文中定义的 所以引用的都是window对象</span></span><br><span class="line"><span class="comment">//函数名只是保存指针的变量 因此全局定义的sayColor和o.sayColor是同一个函数 只不过执行的上下文不同</span></span><br></pre></td></tr></tbody></table></figure>

<p>ES6 新增：<code>new.target</code>如果是使用<code>new</code>关键字调用的 则 n<code>ew.target</code>将引用被调用的构造函数 否则值是<code>undefined</code> 可以用来规定某个函数只能通过<code>new</code>来构建</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">King</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'King must be instantiated using "new"'</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'King instantiated using "new"'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">King</span>(); <span class="comment">// King instantiated using "new"</span></span><br><span class="line"><span class="title class_">King</span>(); <span class="comment">// Error: King must be instantiated using "new"</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>可以使用命名表达式来完成递归</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num) {</span><br><span class="line"> if (num &lt;= 1) {</span><br><span class="line"> return 1;</span><br><span class="line"> } else {</span><br><span class="line"> return num * factorial(num - 1);</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">let anotherFactorial = factorial; //将函数保存在anthorPactorial中</span><br><span class="line">factorial = null;</span><br><span class="line">console.log(anotherFactorial(4)); // 报错 递归调用factorial 但是factoprial已经不是函数了</span><br><span class="line">//可以使用命名函数来解决</span><br><span class="line">const factorial = (function f(num) {</span><br><span class="line"> if (num &lt;= 1) {</span><br><span class="line"> return 1;</span><br><span class="line"> } else {</span><br><span class="line"> return num * f(num - 1);</span><br><span class="line"> }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>ES6 新增了一想内存管理优化机制 让 js 引擎在满足条件时可以重用栈帧 非常适合尾调用（外部函数的返回值时一个内部函数的返回值）</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) {</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">innerFunction</span>();<span class="comment">//尾调用</span></span><br><span class="line">}</span><br><span class="line"><span class="title class_">ES6</span>优化之前：</span><br><span class="line">(<span class="number">1</span>) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。</span><br><span class="line">(<span class="number">2</span>) 执行 outerFunction 函数体，到 <span class="keyword">return</span> 语句。计算返回值必须先计算 innerFunction。</span><br><span class="line">(<span class="number">3</span>) 执行到 innerFunction 函数体，第二个栈帧被推到栈上。</span><br><span class="line">(<span class="number">4</span>) 执行 innerFunction 函数体，计算其返回值。</span><br><span class="line">(<span class="number">5</span>) 将返回值传回 outerFunction，然后 outerFunction 再返回值。</span><br><span class="line">(<span class="number">6</span>) 将栈帧弹出栈外。</span><br><span class="line">在 <span class="title class_">ES6</span> 优化之后，执行这个例子会在内存中发生如下操作。</span><br><span class="line">(<span class="number">1</span>) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。</span><br><span class="line">(<span class="number">2</span>) 执行 outerFunction 函数体，到达 <span class="keyword">return</span> 语句。为求值返回语句，必须先求值 innerFunction。</span><br><span class="line">(<span class="number">3</span>) 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction</span><br><span class="line">的返回值。</span><br><span class="line">(<span class="number">4</span>) 弹出 outerFunction 的栈帧。</span><br><span class="line">(<span class="number">5</span>) 执行到 innerFunction 函数体，栈帧被推到栈上。</span><br><span class="line">(<span class="number">6</span>) 执行 innerFunction 函数体，计算其返回值。</span><br><span class="line">(<span class="number">7</span>) 将 innerFunction 的栈帧弹出栈外</span><br><span class="line">很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多</span><br><span class="line">少次嵌套函数，都只有一个栈帧。这就是 <span class="title class_">ES6</span> 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其</span><br><span class="line">销毁，则引擎就会那么做。</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个常见的递归尾调用优化的例子</span></span><br><span class="line"><span class="comment">// 基础框架</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fibImpl</span>(<span class="number">0</span>, <span class="number">1</span>, n);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 执行递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibImpl</span>(<span class="params">a, b, n</span>) {</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fibImpl</span>(b, a + b, n - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包指的是那些引用了另一个函数作用域中变量的函数 通常是在嵌套函数中实现的</p>
<blockquote>
<p>在调用一个函数的时候 会为这个函数调用创建一个执行上下文 并创建一个作用域链 然后用 arguments 和其他命名参数来初始化这个函数的所有活动对象 外部函数的活动对象是内部函数作用域链上的第二个对象 这个作用域链一直向外串起了所有包含函数的活动对象 知道全局执行上下文才终止</p>
</blockquote>
<h2 id="理解调用的函数表达式"><a href="#理解调用的函数表达式" class="headerlink" title="理解调用的函数表达式"></a>理解调用的函数表达式</h2><p>立即调用的匿名函数又称作立即调用的函数表达式（IIFE）ES6 之后没有使用的必要了</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IIFE可以模拟块级作用域 即在一个函数表达式内部声明变量然后立即调用这个函数 这样位于函数作用域的变量就相当于在块级作用域中一样</span></span><br><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  }</span><br><span class="line">})();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>使用闭包和私有变量会导致作用域链变长 作用域链越长 则找到变量所需的时间就越多</p>
</blockquote>
<h1 id="Promise-和异步函数"><a href="#Promise-和异步函数" class="headerlink" title="Promise 和异步函数"></a>Promise 和异步函数</h1><p><code>promise</code>的状态是私有的 不能直接通过 js 检测到 这是为了避免读取到的<code>promise</code>的状态以同步方式处理 同时 <code>promise</code>的状态也不能被外部 js 代码修改 要是为了隔离外部的同步代码</p>
<p><code>Promise.resolved()</code>是幂等状态</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> {});</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>Promise.reject()</code>会将传给他的作为错误信息返回 包括<code>promise.resloved()</code></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>()));</span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: Promise &lt;resolved&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>Finally</code>用于给<code>promise</code>添加<code>onFinally</code>处理程序 可以避免 <code>onResolved</code> 和 <code>onRejected</code> 处理程序中出 现冗余代码 主要用于添加清理代码</p>
<blockquote>
<p>明天再看</p>
</blockquote>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="窗口关系"><a href="#窗口关系" class="headerlink" title="窗口关系"></a>窗口关系</h2><p><code>outerWidth 和 outerHeight</code> 返回浏 览器窗口自身的大小（不管是在最外层 window 上使用，还是在窗格中使用）。<code>innerWidth 和 innerHeight</code> 返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）</p>
<p><code>document.documentElement.clientWidth 和 document.documentElement.clientHeight</code> 返回页面视口的宽度和高度。</p>
<h3 id="视口位置"><a href="#视口位置" class="headerlink" title="视口位置"></a>视口位置</h3><p>度量文档相对于视口滚动距离的属性有两对，返回相等的值<code>：window.pageXoffset/window. scrollX 和 window.pageYoffset/window.scrollY</code></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对于当前视口向下滚动 100 像素</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollBy</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 相对于当前视口向右滚动 40 像素</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollBy</span>(<span class="number">40</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 滚动到页面左上角</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 滚动到距离屏幕左边及顶边各 100 像素的位置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>除了偏移值之外 还能通过<code>behavior</code>属性告诉浏览器是否平滑滚动</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常滚动</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>({</span><br><span class="line">  <span class="attr">left</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">top</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">behavior</span>: <span class="string">"auto"</span>,</span><br><span class="line">  <span class="comment">//behavior: 'smooth'//平滑滚动</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h2><p><code>URL</code>包含当前页面的完整 URL（地址栏中的 URL） <code>domain</code>包含页面的域名 <code>referrer</code>包含连接到当前页面的那个页面的 URL（如果当前页面无来源 则尾空字符串）<strong>只有 domain 的值是可以设置的</strong></p>
<p><code>getElementsByName()</code>方法最常用于单选按钮，因为同 一字段的单选按钮必须具有相同的 <code>name</code> 属性才能确保把正确的值发送给服务器</p>
<h2 id="ScrollIntoView（）"><a href="#ScrollIntoView（）" class="headerlink" title="ScrollIntoView（）"></a>ScrollIntoView（）</h2><p><code>scrollIntoView()</code>方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元 素进入视口</p>
<ul>
<li>alignToTop：boolean default：true<ul>
<li>true：窗口滚动后元素的顶部与视口顶部对齐</li>
<li>false：窗口滚动后元素的底部与视口底部对齐</li>
</ul>
</li>
<li>false：窗口滚动后元素的底部与视口底部对齐<ul>
<li>false：窗口滚动后元素的底部与视口底部对齐</li>
<li>block：定义垂直方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默 认为 “start”。</li>
<li>inline：定义水平方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默 认为 “nearest”。</li>
</ul>
</li>
</ul>
<p>这个方法可以用来在页面上发生某个事件时引起用户关注。把焦点设置到一个元素上也会导致浏览 器将元素滚动到可见位置。</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="DOM-事件对象"><a href="#DOM-事件对象" class="headerlink" title="DOM 事件对象"></a>DOM 事件对象</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bubbles 布尔值 只读 表示事件是否冒泡</span><br><span class="line">cancelable 布尔值 只读 表示是否可以取消事件的默认行为</span><br><span class="line">currentTarget 元素 只读 当前事件处理程序所在的元素</span><br><span class="line">defaultPrevented 布尔值 只读 true 表示已经调用 preventDefault()方法（DOM3</span><br><span class="line">Events 中新增）</span><br><span class="line">detail 整数 只读 事件相关的其他信息</span><br><span class="line">eventPhase 整数 只读 表示调用事件处理程序的阶段：1 代表捕获阶段，2 代表</span><br><span class="line">到达目标，3 代表冒泡阶段</span><br><span class="line">preventDefault() 函数 只读 用于取消事件的默认行为。只有 cancelable 为 true 才</span><br><span class="line">可以调用这个方法</span><br><span class="line">stopImmediatePropagation() 函数 只读 用于取消所有后续事件捕获或事件冒泡，并阻止调用任</span><br><span class="line">何后续事件处理程序（DOM3 Events 中新增）</span><br><span class="line">stopPropagation() 函数 只读 用于取消所有后续事件捕获或事件冒泡。只有 bubbles</span><br><span class="line">为 true 才可以调用这个方法</span><br><span class="line">target 元素 只读 事件目标</span><br><span class="line">trusted 布尔值 只读 true 表示事件是由浏览器生成的。false 表示事件是开</span><br><span class="line">发者通过 JavaScript 创建的（DOM3 Events 中新增）</span><br><span class="line">type 字符串 只读 被触发的事件类型</span><br><span class="line">View AbstractView 只读 与事件相关的抽象视图。等于事件所发生的 window 对象</span><br></pre></td></tr></tbody></table></figure>

<p>在事件处理程序内部 <code>this</code>对象始终等于<code>currentTatget</code>的值 而<code>target</code>只包含事件的实际目标</p>
<p><code>type</code>属性在一个对象处理多个程序的时候很有用</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span> (<span class="params">event</span>) {</span><br><span class="line">  <span class="keyword">switch</span> (event.<span class="property">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Clicked"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">      event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">"red"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">      event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">btn.<span class="property">onclick</span> = handler;</span><br><span class="line">btn.<span class="property">onmouseover</span> = handler;</span><br><span class="line">btn.<span class="property">onmouseout</span> = handler;</span><br></pre></td></tr></tbody></table></figure>

<p><code>preventDefault()</code>方法用于阻止特定事件的默认动作</p>
<p><code>stopPropagation()</code>方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件<code>捕获</code>或<code>冒泡</code></p>
<p><code>eventPhase</code> 属性可用于确定事件流当前所处的阶段</p>
<blockquote>
<p>event 对象只在事件处理程序执行期间存在 一旦执行完毕 就会被销毁</p>
</blockquote>
<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><ul>
<li><p>用户界面事件（<code>UIEvent</code>）：涉及与 BOM 交互的通用浏览器事件</p>
<ul>
<li>resize：在 window 或窗格上当窗口或窗格被缩放时触发（浏览器窗口在最大化或最小化的时候也会触发这个事件）</li>
<li>scroll：当用户滚动包含滚动条上的元素时在元素上触发</li>
<li>abort：在<code>&lt;object&gt;</code>元素上当相应对象加载完成前被用户提前终止下载时触发</li>
</ul>
</li>
<li><p>焦点事件（<code>FocusEvent</code>）：在元素获得和失去焦点时触发</p>
<ul>
<li>blur：失去焦点时触发</li>
<li>focus：用户获得焦点时触发 不冒泡</li>
<li>focusin：当元素获得焦点时触发。这个事件是 focus 的冒泡版</li>
<li>focusout：当元素失去焦点时触发。这个事件是 blur 的通用版</li>
</ul>
</li>
<li><p>鼠标事件（<code>MouseEvent</code>）：使用鼠标在页面上执行某些操作时触发</p>
</li>
<li><p>dblclick：在用户双击鼠标主键（通常是左键）时触发</p>
</li>
<li><p>mousedown：在用户按下任意鼠标键时触发。这个事件不能通过键盘触发</p>
</li>
<li><p>mouseenter：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在 光标经过后代元素时触发</p>
</li>
<li><p>mouseleave：在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在 光标经过后代元素时触发</p>
</li>
<li><p>mousemove：在鼠标光标在元素上移动时反复触发</p>
</li>
<li><p>mouseout：在用户把鼠标光标从一个元素移到另一个元素上时触发</p>
</li>
<li><p>mouseover：在用户把鼠标光标从元素外部移到元素内部时触发</p>
</li>
<li><p>mouseup：在用户释放鼠标键时触发</p>
</li>
</ul>
<p>除了 mouseenter 和 mouseleave，所有鼠标事件都会冒泡， 都可以被取消，而这会影响浏览器的默认行为</p>
<ul>
<li><p>滚轮事件（<code>WheelEvent</code>）：使用鼠标滚轮（或类似设备）时触发</p>
</li>
<li><p>输入事件（<code>InputEvent</code>）：向文档中输入文本时触发</p>
</li>
<li><p>键盘事件（<code>KeyboardEvent</code>）：使用键盘在页面上执行某些操作时触发</p>
<ul>
<li>textInput：输入事件 当 会在文本被插入到文本框之前触发(只在可编辑区域触发 只有新字符被插入时才会触发)</li>
<li>keydown 和 keypress 会在文本框变化前触发（按住不放则重复触发） keyUp 会在发生后触发</li>
<li>key 属性用于替代 keyCode，且包含字符串。在按下字符键时，key 的值等于文本字符（如 “k”或“M”）；在按下非字符键时，key 的值是键名（如“Shift”或“ArrowDown”）。char 属性在按 下字符键时与 key 类似，在按下非字符键时为 null</li>
</ul>
</li>
<li><p>合成事件（<code>CompositionEvent</code>）：在使用某种 IME（Input Method Editor，输入法编辑器）输入 字符时触发。</p>
</li>
</ul>
<h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托利用事件冒泡 可以只使用一个事件处理程序来处理一种类型事件</p>
<p><strong>所有使用按钮的事件（大多数鼠标事件和键盘事件）都适用于这个解决方案</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"myLinks"</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"goSomewhere"</span>&gt;</span>Go somewhere<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"sayHi"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;;</span><br><span class="line"><span class="comment">//如果对三个li都像这样指定3个事件处理程序</span></span><br><span class="line"><span class="keyword">let</span> item1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"goSomewhere"</span>);</span><br><span class="line"><span class="keyword">let</span> item2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"doSomething"</span>);</span><br><span class="line"><span class="keyword">let</span> item3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"sayHi"</span>);</span><br><span class="line">item1.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  location.<span class="property">href</span> = <span class="string">"http:// www.wrox.com"</span>;</span><br><span class="line">});</span><br><span class="line">item2.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">"I changed the document's title"</span>;</span><br><span class="line">});</span><br><span class="line">item3.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"hi"</span>);</span><br><span class="line">});</span><br><span class="line"><span class="comment">//使用事件委托 只要给所有元素沟通的祖先节点添加一个事件处理程序 可以解决问题</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myLinks"</span>);</span><br><span class="line">list.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> target = event.<span class="property">target</span>;</span><br><span class="line">  <span class="keyword">switch</span> (target.<span class="property">id</span>) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"doSomething"</span>:</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">"I changed the document's title"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"goSomewhere"</span>:</span><br><span class="line">      location.<span class="property">href</span> = <span class="string">"http:// www.wrox.com"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"sayHi"</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"hi"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>事件委托的好处</p>
<ul>
<li><code>document</code> 对象随时可用，任何时候都可以给它添加事件处理程序（不用等待 DOMContentLoaded 或 load 事件）。这意味着只要页面渲染出可点击的元素，就可以无延迟地起作用。</li>
<li>节省花在设置页面事件处理程序上的时间。只指定一个事件处理程序既可以节省 DOM 引用，也 可以节省时间</li>
<li>减少整个页面所需的内存，提升整体性能</li>
</ul>
<p>最适合使用事件委托的事件包括：<code>click、mousedown、mouseup、keydown 和 keypress</code></p>
<h1 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h1><h2 id="跨上下文消息"><a href="#跨上下文消息" class="headerlink" title="跨上下文消息"></a>跨上下文消息</h2><p>跨文档消息（XDM）是一种在不同执行上下文（如不同工作线程或不同源的页面能力）间传递消息的能力</p>
<blockquote>
<p>跨上下文消息用于窗口之间通信或工作线程之间通信</p>
</blockquote>
<p><code>postMessage()</code>方法接收三个参数：消息、表示目标接收源的字符串和可选的可传输对象的数组（只与工作线程相关）第二个参数对于安全非常重要 可以限制浏览器交付数据的目标</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iframeWindow = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myframe"</span>).<span class="property">contentWIndow</span>;</span><br><span class="line">iframeWindow.<span class="title function_">postMessage</span>(<span class="string">"a message"</span>, <span class="string">"http://www.wrox.com"</span>);</span><br><span class="line"><span class="comment">//如果源匹配 就将消息交付到内嵌彪哥 否则啥都不错 可以保护信息不会因地址改变而泄漏</span></span><br></pre></td></tr></tbody></table></figure>

<p>接收到 XDM 消息后 window 对象上会触发<code>message</code>事件（<code>异步</code>触发 从发出到接收消息可能会有延迟）传给<code>message</code>的<code>event</code>对象包含以下三方面重要信息</p>
<ul>
<li><code>data</code>：作为第一个参数传递给<code>postMessage（）</code>的字符串数据</li>
<li><code>origin</code>：发送消息的文档源</li>
<li><code>source</code>：发送消息的文档中<code>window</code>对象的代理 这个代理对象主要用于发送上一条消息的窗口中执行<code>postMessage()</code>方法 如果发送窗口有相同的源 那么对象就是 window 对象</li>
</ul>
<p><code>onmessage</code> 事件处理程序中检查发送窗口的源可以保证数据来自正确的 地方</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">"message"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 确保来自预期发送者</span></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">origin</span> == <span class="string">"http://www.wrox.com"</span>) {</span><br><span class="line">    <span class="comment">// 对数据进行一些处理</span></span><br><span class="line">    <span class="title function_">processMessage</span>(event.<span class="property">data</span>);</span><br><span class="line">    <span class="comment">// 可选：向来源窗口发送一条消息</span></span><br><span class="line">    event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">"Received!"</span>, <span class="string">"http://p2p.wrox.com"</span>);</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>大多数情况下，<code>event.source</code> 是某个 <code>window</code> 对象的代理，而非实际的 window 对象。因此不能 通过它访问所有窗口下的信息。最好只使用 <code>postMessage()</code>，这个方法永远存在而且可以调用</p>
<p><strong>tips：</strong>最好就是只 通 过 <code>postMessage()</code> 发送字符串。如果需要传递结构化数据，那么最好先对该数据调用 <code>JSON.stringify()，</code>通过 postMessage()传过去之后，再在 <code>onmessage</code> 事件处理程序中调用 <code>JSON.parse()</code></p>
<p>在通过内嵌窗格加载不同域时，使用 XDM 是非常方便的。这种方法在混搭（mashup）和<code>社交应用</code> 中非常常用。通过使用 XDM 与内嵌窗格中的网页通信，可以保证包含页面的安全。XDM 也可以用于 <code>同源页面</code>之间通信</p>
<h2 id="Encoding-API"><a href="#Encoding-API" class="headerlink" title="Encoding API"></a>Encoding API</h2><p>用于实现字符串和定型数组之间的转换 <code>TextEncoder、TextEncoderStream、TextDecoder 和 TextDecoderStream。</code></p>
<h3 id="批量编码"><a href="#批量编码" class="headerlink" title="批量编码"></a>批量编码</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextEncoder、TextEncoderStream、TextDecoder 和 TextDecoderStream。</span></span><br><span class="line"><span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>();</span><br><span class="line"><span class="keyword">const</span> decodedText = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">const</span> encodedTRext = textEncoder.<span class="title function_">encode</span>(docodedText);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encodedText); <span class="comment">// Uint8Array(3) [102, 111, 111]</span></span><br><span class="line"><span class="comment">//编码器是用于处理字符的，有些字符（如表情符号）在最终返回的数组中可能会占多个索引</span></span><br><span class="line"><span class="comment">//encodeInto()方法，该方法接收一个字符串和目标 Unit8Array，返回一个</span></span><br><span class="line">字典，该字典包含 read 和 written 属性，分别表示成功从源字符串读取了多少字符和向目标数组写</span><br><span class="line">入了多少字符。如果定型数组的空间不够，编码就会提前终止，</span><br><span class="line"><span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>();</span><br><span class="line"><span class="keyword">const</span> fooArr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> barArr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> fooResult = textEncoder.<span class="title function_">encodeInto</span>(<span class="string">'foo'</span>, fooArr);</span><br><span class="line"><span class="keyword">const</span> barResult = textEncoder.<span class="title function_">encodeInto</span>(<span class="string">'bar'</span>, barArr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooArr); <span class="comment">// Uint8Array(3) [102, 111, 111]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooResult); <span class="comment">// { read: 3, written: 3 }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(barArr); <span class="comment">// Uint8Array(2) [98, 97]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(barResult); <span class="comment">// { read: 2, written: 2 }</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>文本编码会始终使用 UTF-8 格式，而且必须写入 Unit8Array 实例。使用其他类 型数组会导致 encodeInto()抛出错误</p>
</blockquote>
<h2 id="File-API-与-Blob-API"><a href="#File-API-与-Blob-API" class="headerlink" title="File API 与 Blob API"></a>File API 与 Blob API</h2><h3 id="File-类型"><a href="#File-类型" class="headerlink" title="File 类型"></a>File 类型</h3><p>每个 File 对象都有一些只读属性</p>
<ul>
<li>name：本地系统中的文件名</li>
<li>size：以字节计的文件大小</li>
<li>type：包含文件 MIME 类型的字符串</li>
<li>lastModifiedDate：表示文件最后修改的时间的字符串 只有 chome 实现了</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">通过监听 change 事件然后遍历 files 集合可以取得每个选中文件的信息</span><br><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"files-list"</span>);</span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">"change"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"> <span class="keyword">let</span> files = event.<span class="property">target</span>.<span class="property">files</span>,</span><br><span class="line"> i = <span class="number">0</span>,</span><br><span class="line"> len = files.<span class="property">length</span>;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; len) {</span><br><span class="line"> <span class="keyword">const</span> f = files[i];</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">${f.name}</span> (<span class="subst">${f.type}</span>, <span class="subst">${f.size}</span> bytes)`</span>);</span><br><span class="line"> i++;</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="FileReader-类型"><a href="#FileReader-类型" class="headerlink" title="FileReader 类型"></a>FileReader 类型</h3><p><code>FileReader</code>类型表示一种<code>异步</code>文件读取机制</p>
<ul>
<li><code>readAsText(file, encoding)</code>：从文件中读取纯文本内容并保存在 result 属性中。第二个 参数表示编码，是可选的</li>
<li><code>readAsDataURL(file)</code>：读取文件并将内容的数据 URI 保存在 result 属性中</li>
<li><code>readAsBinaryString(file)</code>：读取文件并将每个字符的二进制数据保存在 result 属性中</li>
<li><code>readAsArrayBuffer(file)</code>：读取文件并将文件内容以 <code>ArrayBuffer</code> 形式保存在 result 属性</li>
</ul>
<p>因为这些读取方法是异步的，所以每个 FileReader 会发布几个事件，其中 3 个最有用的事件是 <code>progress、error 和 load</code>，分别表示还有更多数据、发生了错误和读取完成</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从表单字段读取一个文件并将其内容显示在网页上</span></span><br><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"files-list"</span>);</span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">"change"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> info = <span class="string">""</span>,</span><br><span class="line">    output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"output"</span>);</span><br><span class="line">  (progress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"progress"</span>)),</span><br><span class="line">    (files = event.<span class="property">target</span>.<span class="property">files</span>),</span><br><span class="line">    (type = <span class="string">"default"</span>),</span><br><span class="line">    (reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>());</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/image/</span>.<span class="title function_">test</span>(files[<span class="number">0</span>].<span class="property">type</span>)) {</span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(files[<span class="number">0</span>]);</span><br><span class="line">    type = <span class="string">"image"</span>; <span class="comment">//如果是图片 则将其读取后保存为URL</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    reader.<span class="title function_">readAsText</span>(files[<span class="number">0</span>]); <span class="comment">//如果是文字则保存为文字</span></span><br><span class="line">    type = <span class="string">"text"</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//用于监控错误</span></span><br><span class="line">  reader.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    output.<span class="property">innerHTML</span> =</span><br><span class="line">      <span class="string">"Could not read file, error code is "</span> + reader.<span class="property">error</span>.<span class="property">code</span>;</span><br><span class="line">  };</span><br><span class="line">  <span class="comment">//用于跟踪和显示读取文件的进度</span></span><br><span class="line">  reader.<span class="property">onprogress</span> = <span class="keyword">function</span> (<span class="params">event</span>) {</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) {</span><br><span class="line">      progress.<span class="property">innerHTML</span> = <span class="string">`<span class="subst">${event.loaded}</span>/<span class="subst">${event.total}</span>`</span>; <span class="comment">//读取文件的进度</span></span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">  <span class="comment">//读取成功后</span></span><br><span class="line">  reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">let</span> html = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) {</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"image"</span>:</span><br><span class="line">        html = <span class="string">`&lt;img src="<span class="subst">${reader.result}</span>"&gt;`</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"text"</span>:</span><br><span class="line">        html = reader.<span class="property">result</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    output.<span class="property">innerHTML</span> = html;</span><br><span class="line">  };</span><br><span class="line">});</span><br><span class="line"><span class="comment">//如果想提前结束文件的读取 可以在过程中调用abort()方法 在load error和 abort事件触发后 还会触发loadend事件 loadend事件表示上述三种情况下所有读取操作都已经结束</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="FileReaderSync-类型"><a href="#FileReaderSync-类型" class="headerlink" title="FileReaderSync 类型"></a>FileReaderSync 类型</h3><p><code>FileReader</code>的同步版本 只有整个文件都加载到内存之后才能继续进行 只在工作线程中可用 因为如果读取整个文件的耗时过长则会影响全局</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line">self.<span class="property">omessage</span> = <span class="function">(<span class="params">messageEvent</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> syncReader = <span class="keyword">new</span> <span class="title class_">FileReaderSync</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(syncReader); <span class="comment">// FileReaderSync {}</span></span><br><span class="line">  <span class="comment">// 读取文件时阻塞工作线程</span></span><br><span class="line">  <span class="keyword">const</span> result = syncReader.<span class="title function_">readAsDataUrl</span>(messageEvent.<span class="property">data</span>);</span><br><span class="line">  <span class="comment">// PDF 文件的示例响应</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// data:application/pdf;base64,JVBERi0xLjQK...</span></span><br><span class="line">  <span class="comment">// 把 URL 发回去</span></span><br><span class="line">  self.<span class="title function_">postMessage</span>(result);</span><br><span class="line">};</span><br><span class="line"><span class="comment">//假设通过 postMessage()向工作线程发送了一个 File 对象。以下代码会让工作线程同步将文件</span></span><br><span class="line"><span class="comment">//读取到内存中，然后将文件的数据 URL 发回来</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Blob-与部分读取"><a href="#Blob-与部分读取" class="headerlink" title="Blob 与部分读取"></a>Blob 与部分读取</h3><p><code>File</code>对象提供了一个名为<code>slice()</code>的方法 （接收两个参数 其实字节和读取的字节数 返回一个 Blob 实例 ）Blob 实际上是 File 的<strong>超类</strong></p>
<p>Blob 对象有一个 <code>size</code> 属性和一个 <code>type</code> 属性，还有一个 <code>slice()</code>方法用于进一步切分数据。另 外也可以使用 <code>FileReader</code> 从 Blob 中读取数据</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文件的前32字节</span></span><br><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'files-list'</span>);</span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">"change"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">	<span class="keyword">let</span> info = <span class="string">""</span>,</span><br><span class="line">	output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'output'</span>);</span><br><span class="line">	progress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'progress'</span>),</span><br><span class="line">	files = event.<span class="property">target</span>.<span class="property">files</span>,</span><br><span class="line">	reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(),</span><br><span class="line">	blob = <span class="title function_">blobSlice</span>(files[<span class="number">0</span>], <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">	<span class="keyword">if</span>(blob) [</span><br><span class="line">	reader.<span class="title function_">readAsText</span>(blob);</span><br><span class="line">	reader.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">		output.<span class="property">innerHTML</span> = <span class="string">"Could not read file, error code is"</span> +</span><br><span class="line">			reader.<span class="property">error</span>.<span class="property">code</span>;</span><br><span class="line">	};</span><br><span class="line">	reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">		output.<span class="property">innerHTML</span> = reader.<span class="property">result</span>;</span><br><span class="line">	}</span><br><span class="line">	]<span class="keyword">else</span> {</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'error'</span>)</span><br><span class="line">	}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>只读取部分文件可以节约时间 特别是在只需要特定部分比如文件头的时候</p>
</blockquote>
<h3 id="对象-URL-与-Blob"><a href="#对象-URL-与-Blob" class="headerlink" title="对象 URL 与 Blob"></a>对象 URL 与 Blob</h3><p>引用储存在<code>File</code>或<code>Blob</code>中数据的<code>URL</code></p>
<p>**优点:**不用把文件内容读取到 JavaScript 也可以使用文件 只要在适当的位置提供对象 URL 即可</p>
<p>使用 <code>window.URL.createObjectURL()</code>方法并传入 <code>File</code> 或 <code>Blob</code> 对象 返回一个指向内存中<strong>地址</strong>的字符串 在<code>DOM</code>中可以直接使用</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用对象URL在页面中显示一张图片</span></span><br><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"files-list"</span>);</span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">'change'</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">	<span class="keyword">let</span> info = <span class="string">''</span>,</span><br><span class="line">	output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"output"</span>),</span><br><span class="line"> 	progress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"progress"</span>),</span><br><span class="line">	 files = event.<span class="property">target</span>.<span class="property">files</span>,</span><br><span class="line"> 	reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(),</span><br><span class="line">	 url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(files[<span class="number">0</span>]);</span><br><span class="line">	 <span class="keyword">if</span>(url) {</span><br><span class="line">	 	<span class="keyword">if</span>(<span class="regexp">/image/</span>.<span class="title function_">test</span>(files[<span class="number">0</span>].<span class="property">type</span>)) {</span><br><span class="line">	 	output.<span class="property">innerHTML</span> = <span class="string">`&lt;img src="<span class="subst">${url}</span>"&gt;`</span>;</span><br><span class="line"></span><br><span class="line">	 	}esle {</span><br><span class="line"> output.<span class="property">innerHTML</span> = <span class="string">"Not an image."</span>;</span><br><span class="line"> }</span><br><span class="line">	 }<span class="keyword">else</span> {</span><br><span class="line">	  output.<span class="property">innerHTML</span> = <span class="string">"Your browser doesn't support object URLs."</span>;</span><br><span class="line">	 }</span><br><span class="line">})</span><br><span class="line"><span class="comment">//如果把对象 URL 直接放到&lt;img&gt;标签，就不需要把数据先读到 JavaScript 中了。&lt;img&gt;标签可以直</span></span><br><span class="line"><span class="comment">//接从相应的内存位置把数据读取到页面上。</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用完数据之后，最好能释放与之关联的内存。只要对象 URL 在使用中，就不能释放内存。如果 想表明不再使用某个对象 URL，则可以把它传给 window.URL.revokeObjectURL()。页面卸载时， 所有对象 URL 占用的内存都会被释放。不过，最好在不使用时就立即释放内存，以便尽可能保持页面 占用最少资源</p>
<h3 id="读取拖放文件"><a href="#读取拖放文件" class="headerlink" title="读取拖放文件"></a>读取拖放文件</h3><p>拖放文件可以像拖放图片或连接一样触发<code>drop</code>事件 被放置的文件可以通过事件的<code>event.dataTransfer.files</code>属性读到 这个属性保存着一组 File 对象 就像文本输入字段一样</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> droptarget = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"droptarget"</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleEvent</span>(<span class="params">event</span>) {</span><br><span class="line">  <span class="keyword">let</span> info = <span class="string">""</span>,</span><br><span class="line">    output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"output"</span>),</span><br><span class="line">    files,</span><br><span class="line">    i,</span><br><span class="line">    len;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">type</span> == <span class="string">"drop"</span>) {</span><br><span class="line">    files = event.<span class="property">dataTransfer</span>.<span class="property">files</span>;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    len = files.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) {</span><br><span class="line">      info += <span class="string">`<span class="subst">${files[i].name}</span> (<span class="subst">${files[i].type}</span>, <span class="subst">${files[i].size}</span> bytes)&lt;br&gt;`</span>;</span><br><span class="line">      i++;</span><br><span class="line">    }</span><br><span class="line">    output.<span class="property">innerHTML</span> = info;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">"dragenter"</span>, handleEvent);</span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">"dragover"</span>, handleEvent);</span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">"drop"</span>, handleEvent);</span><br><span class="line"><span class="comment">//必须取消dragenter、dragover和drop的默认行为 在drop事件处理程序中 可以通过event.dataTransfer.files 读到文件，此时可以获取文件的相关信息</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/24/595504b72117d4fb.png"></p>
<p><img src="https://i.bmp.ovh/imgs/2022/04/24/539327ac86e98fdd.png"></p>
<p><img src="https://i.bmp.ovh/imgs/2022/04/24/afd2eed69d58a3dd.png"></p>
<h3 id="检测编解码器"><a href="#检测编解码器" class="headerlink" title="检测编解码器"></a>检测编解码器</h3><p>有一个<code>canPlayType()</code>的方法 接收一个格式/编解码器字符串 返回一个”probably”、”maybe”或””</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (audio.<span class="title function_">canPlayType</span>(<span class="string">"audio/mpeg"</span>)) {</span><br><span class="line"> <span class="comment">// 执行某些操作</span></span><br><span class="line">}</span><br><span class="line"><span class="string">"probably"</span>和<span class="string">"maybe"</span>都是真值，在 <span class="keyword">if</span> 语句的上下文中可以转型为 <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Notifications-API"><a href="#Notifications-API" class="headerlink" title="Notifications API"></a>Notifications API</h2><p>用于向用户显示通知</p>
<ul>
<li>通知只能运行再安全上下文的代码中被触发</li>
<li>通知必须按照每个源的原则明确得到用户允许</li>
</ul>
<p>浏览器会记住用户的选择 如果被拒绝则无法重来</p>
<h3 id="通知授权"><a href="#通知授权" class="headerlink" title="通知授权"></a>通知授权</h3><p>页面可以使用全局对象<code>Notification</code> 向用户请求通知权限 这个对象会有一个<code>requestPermission()</code> 返回一个<code>promise</code>对象 用户在授权对话框上执行操作后这个<code>promise</code>会被解决</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Notification</span>.<span class="title function_">requestPermission</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">permission</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"User responded to permission request:"</span>, permission);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p><code>"granted"</code>值意味着用户明确授权了显示通知的权限。除此之外的其他值意味着显示通知会静默失 败。如果用户拒绝授权，这个值就是<code>"denied"</code>。一旦拒绝，就无法通过编程方式挽回，因为不可能再 触发授权提示。</p>
<h3 id="显示和隐藏通知"><a href="#显示和隐藏通知" class="headerlink" title="显示和隐藏通知"></a>显示和隐藏通知</h3><p>Notification 构造函数用于创建和显示通知</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">"Title text!"</span>, {</span><br><span class="line">  <span class="attr">body</span>: <span class="string">"Body text!"</span>,</span><br><span class="line">  <span class="attr">image</span>: <span class="string">"path/to/image.png"</span>,</span><br><span class="line">  <span class="attr">vibrate</span>: <span class="literal">true</span>,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> n = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">"I will close in 1000ms"</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> n.<span class="title function_">close</span>(), <span class="number">1000</span>); <span class="comment">//调用close关闭通知</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="通知生命周期"><a href="#通知生命周期" class="headerlink" title="通知生命周期"></a>通知生命周期</h3><ul>
<li><code>onshow</code> 在通知显示时触发</li>
<li><code>onshow</code> 在通知显示时触发</li>
<li><code>onclose</code> 在通知消失或通过 close()关闭时触发</li>
<li><code>onclose</code> 在通知消失或通过 close()关闭时触发</li>
</ul>
<h2 id="Page-Visibility-API"><a href="#Page-Visibility-API" class="headerlink" title="Page Visibility API"></a>Page Visibility API</h2><p>为开发者提供页面对用户是否可见的信息</p>
<ul>
<li><code>document.visibilityState</code> 值，表示下面 4 种状态之一<ul>
<li>页面在后台标签页或浏览器中最小化了。</li>
<li>页面在前台标签页中</li>
<li>实际页面隐藏了，但对页面的预览是可见的（例如在 Windows 7 上，用户鼠标移到任务栏图标 上会显示网页预览）。</li>
<li>页面在屏外预渲染</li>
</ul>
</li>
<li><code>visibilitychange</code> 事件，该事件会在文档从隐藏变可见（或反之）时触发</li>
<li><code>document.hidden</code> 布尔值，表示页面是否隐藏。这可能意味着页面在后台标签页或浏览器中被最小 化了。这个值是为了向后兼容才继续被浏览器支持的，应该优先使用 <code>document.visibilityState</code> 检测页面可见性</li>
</ul>
<h2 id="计时-API"><a href="#计时-API" class="headerlink" title="计时 API"></a>计时 API</h2><h3 id="High-Resolution-Time-API"><a href="#High-Resolution-Time-API" class="headerlink" title="High Resolution Time API"></a>High Resolution Time API</h3><p><code>Date.now()</code>不精确</p>
<p><code>performance.now()</code>:相对度量 计时器在执行上下文创建时从 0 开始</p>
<p><code>performance.timeOrigin</code> 属性返回计时器初始化时全局系统时钟的值</p>
<p><code>performance.getEntries()</code>：性能时间线（performance timeline）。每个 PerformanceEntry 对象 都有 name、entryType、startTime 和 duration 属性</p>
<h1 id="错误处理和调试"><a href="#错误处理和调试" class="headerlink" title="错误处理和调试"></a>错误处理和调试</h1><p>为了保证浏览器兼容 最好只使用<code>message</code></p>
<blockquote>
<p>只要代码中包含了<code>finally</code>子块 <code>try</code> 块或 <code>catch</code> 块中的 <code>return</code> 语句就会被忽 略</p>
</blockquote>
<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ul>
<li>Error</li>
<li>InternalError ：底层 JavaScript 引擎发出异常时由浏览器抛出 如递归过多导致栈移除 发生这种错误一般是出了问题</li>
<li><code>EvalError</code> ：使用<code>eval()</code>函数发生异常时抛出</li>
<li><code>RangeError</code> ：数值越界</li>
<li><code>ReferenceError</code> ：找不到对象时发生或者变量</li>
<li><code>SyntaxErro</code>：r 经常在给 <code>eval()</code>传入的字符串包含 JavaScript 语法错误时发生</li>
<li><code>TypeError</code> 主要发生在变量不是预期类型，或者访问不存在的方法时</li>
<li>``URIError<code>使用 </code>encodeURI()<code>或 </code>decodeURI()`但传入了格式错误的 URI 时发</li>
</ul>
<p>可以在 try/vatch 中使用 instance of 操作符确定错误的类型</p>
<h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>使用 <code>throw</code> 操作符时，代码立即停止执行，除非 <code>try/catch</code> 语句捕获了抛出的值。</p>
<p>可以通过继承 ERROR 来创建自定义的类型错误 创建自定义类型错误需要提供<code>name</code>以及<code>message</code>属性</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message</span>) {</span><br><span class="line">    <span class="variable language_">super</span>(message);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">"CustomError"</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">message</span> = message;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomError</span>(<span class="string">"My message"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>使用自定义错误有助于捕获错误时更准确地区分错误</strong></p>
<h3 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h3><p>任何没有被<code>try/catch</code>处理的错误都会在<code>window</code>对象上触发<code>error</code>事件</p>
<h3 id="错误处理策略"><a href="#错误处理策略" class="headerlink" title="错误处理策略"></a>错误处理策略</h3><p>最好使用(===)来避免比较时发生类型转换</p>
<p>在流控制语句中使用非布尔值作为条件时很常见的错误来源 为避免这种错误 需要始终坚持使用布尔值作为条件</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不好的写法</span></span><br><span class="line"> <span class="keyword">if</span> (str3) { <span class="comment">// 不要！</span></span><br><span class="line"> <span class="comment">//好的写法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str3 === <span class="string">"string"</span>) { <span class="comment">// 恰当的比</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果知道预期的确切类型 最好使用<code>instanceof</code>来确定值的正确类型</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (values) { // 不要</span><br><span class="line">if (values) { // 不要</span><br><span class="line"> if (typeof values.sort === "function") { // 不要</span><br><span class="line">  if (values instanceof Array) { // 修复</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>一般来说 原始类型的值应该使用 typeof 检测 而对象值应该使用 instanceof 检测</p>
</blockquote>
<h4 id="抛出错误-1"><a href="#抛出错误-1" class="headerlink" title="抛出错误"></a>抛出错误</h4><p>在大型应用程序中，自定义错误通常使用 <code>assert()</code>函数抛出错误。这个函数接收一个应该为 <code>true</code> 的条件，并在条件为 false 时抛出错误</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">condition, message</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!condition) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//这个 assert()函数可用于代替多个 if 语句，同时也是记录错误的好地方</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">num1, num2</span>) {</span><br><span class="line">  <span class="title function_">assert</span>(</span><br><span class="line">    <span class="keyword">typeof</span> num1 == <span class="string">"number"</span> &amp;&amp; <span class="keyword">typeof</span> num2 == <span class="string">"number"</span>,</span><br><span class="line">    <span class="string">"divide(): Both arguments must be numbers."</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> num1 / num2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="网络请求与远程资源"><a href="#网络请求与远程资源" class="headerlink" title="网络请求与远程资源"></a>网络请求与远程资源</h1><h2 id="跨源资源共享"><a href="#跨源资源共享" class="headerlink" title="跨源资源共享"></a>跨源资源共享</h2><p><code>CORS:</code>定义了浏览器和服务器如何实现跨源通信（背后的基本思路就是使用自定义的 HTTP 头部允许浏览器服务器相互了解 以确定请求或响应应该成功还是失败）</p>
<p>对于简单的请求（<code>get/post</code>）没有自定义头部 而且请求体是<code>text/plain</code>类型 这样的请求在发送时会有一个额外的头部教<code>Origin</code> <code>Origin</code>头部包含发送请求的页面的源（协议、域名和端口）以便服务器确定是否为其提供响应</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://www.nczonline.net</span><br><span class="line">如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源；</span><br><span class="line">或者如果资源是公开的，那么就包含"*"。</span><br><span class="line">如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个</span><br><span class="line">请求。注意，无论请求还是响应都不会包含 cookie 信息</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>因为无论同域还是跨域请求都使用同一个接口 所以最好在访问本地资源时使用相对 URL 在访问远程资源时使用绝对 URL 这样可以更明确区分使用场景 同时避免出现访问本地资源时出现头部或 cookie 信息访问受限的问题</p>
</blockquote>
<h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p><code>CORS</code>通过一种教预检请求的服务器验证机制 允许自定义头部、除<code>GET和POST</code>之外的方法 以及不同请求体内容类型 预检请求使用<code>OPTIONS</code>发送包含以下头部</p>
<ul>
<li><code>origin</code>：与简单请求相同</li>
<li><code>Access-Control-Request-Method</code>：请求希望使用的方法。</li>
<li><code>Access-Control-Request-Headers</code>：（可选）要使用的逗号分隔的自定义头部列表</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">下面假设一个post请求 包含自定义的NCZ头部：</span><br><span class="line">Origin: http://www.nczonline.net</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: NCZ</span><br><span class="line">在这个请求发送后 服务器可以确定是否允许这种类型的请求 服务器会通过响应中发送以下头部与浏览器沟通这些信息</span><br><span class="line">Access-Control-Allow-Origin：与简单请求相同</span><br><span class="line">Access-Control-Allow-Methods：允许的方法（逗号分隔的列表</span><br><span class="line">Access-Control-Allow-Headers：服务器允许的头部（逗号分隔的列表）</span><br><span class="line">Access-Control-Max-Age：缓存预检请求的秒数</span><br><span class="line">例如：</span><br><span class="line">Access-Control-Allow-Origin: http://www.nczonline.net</span><br><span class="line">Access-Control-Allow-Methods: POST, GET</span><br><span class="line">Access-Control-Allow-Headers: NCZ</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></tbody></table></figure>

<p><strong>预检请求返回后 结果会按响应指定的时间缓存一段时间 换句话说 只有第一次发送这种类型的请求时才会多发送一次额外的 http 请求</strong></p>
<h3 id="凭据请求"><a href="#凭据请求" class="headerlink" title="凭据请求"></a>凭据请求</h3><p>默认情况下 跨源请求不提供凭据（cookie、HTTP 认证和客户端 SSL 证书） 可以通过将<code>withCredentials</code>属性设置为 true 来表明请求会发送凭据 如果服务器允许携带凭据的话 可以包含<code>Access-Control-Allow-Credentials: true</code></p>
<h3 id="Headers-对象"><a href="#Headers-对象" class="headerlink" title="Headers 对象"></a>Headers 对象</h3><p><strong>Headers 对象是所有外发请求和入站响应头部的容器</strong></p>
<h1 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h1><h3 id="cookie：服务器在响应-http-请求时-通过发送-Set-CookieHTTP-头部会话信息"><a href="#cookie：服务器在响应-http-请求时-通过发送-Set-CookieHTTP-头部会话信息" class="headerlink" title="cookie：服务器在响应 http 请求时 通过发送 Set-CookieHTTP 头部会话信息"></a>cookie：服务器在响应 http 请求时 通过发送 Set-CookieHTTP 头部会话信息</h3><p>cookie 是与特定域绑定的 设置 cookie 后 他会与请求一起发送到创建它的域 这个限制能保证 cookie 中存储的信息只对被认可的接收者开放 不被其他域访问</p>
<p>cookie 的构成</p>
<ul>
<li>名称：唯一表示 cookie 的名称 不区分大小写 必须经过 URL 编码</li>
<li>值：存储在 cookie 中的字符串 这个值必须经过 URL 编码</li>
<li>域：cookie 有效的域 发送到这个域的所有请求都会包含到对应的 cookie</li>
<li>路径：请求 URL 中包含这个路径才会把 cookie 发送到服务器</li>
<li>过期时间：合适删除 cookie 的时间戳（什么时间之后就不发送到服务器了）</li>
<li>安全标志：设置之后 只有在使用 SSL 安全连接的情况下才会把 cookie 发送到服务器</li>
</ul>
<h4 id="JavaScript-中的-cookie"><a href="#JavaScript-中的-cookie" class="headerlink" title="JavaScript 中的 cookie"></a>JavaScript 中的 cookie</h4><p><code>document.cookie</code>返回包含页面中所有有效 cookie 的字符串（根据域、路径、过期时间和安全设置）</p>
<p>根据域、路径、过期时间和安全设置</p>
<p>所有名和值都是 URL 编码 因此必须通过<code>decodeURIComponent()</code>解码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(decodeURIComponent(document.cookie));</span><br><span class="line">//_octo=GH1.1.1592692317.1629286532; tz=Asia/Shanghai</span><br></pre></td></tr></tbody></table></figure>

<p>在设置值是 可以通过<code>document.cookie</code>设置新的 cookie 字符串 这个字符串在被解析之后会添加到原有的<code>cookie</code>中 设置<code>document.cookie</code>不会覆盖之前任何的<code>cookie</code> 除非设置了已有的 cookie</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = "name=Nicholas";</span><br></pre></td></tr></tbody></table></figure>

<p><code>CookieUtil.get()</code>方法用于取得给定名称的 cookie 值</p>
<p><code>CookieUtil.set()</code>方法用于设置页面上的 cookie</p>
<h4 id="子-cookie：为了绕过浏览器对每个域-cookie-数的限制"><a href="#子-cookie：为了绕过浏览器对每个域-cookie-数的限制" class="headerlink" title="子 cookie：为了绕过浏览器对每个域 cookie 数的限制"></a>子 cookie：为了绕过浏览器对每个域 cookie 数的限制</h4><p>在单个 cookie 存储的小块数据 本质上是使用 cookie 的值在单个 cookie 中存储多个名/值对 如</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5</span><br></pre></td></tr></tbody></table></figure>

<p>子 cookie 的格式类似于查询字符串 这些值可以储存单个 cookie 而不用单独存储为自己的名/值对 结果就是网站或者 Web 应用程序能够在单域 cookie 数限制下存储更多的结构化数据</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//要取得某个子cookie 必须先取得cookie 然后在解码值之前需要先像下面这样找到子cookie</span><br><span class="line">class SubCookieUtil {</span><br><span class="line"> static get(name, subName) {</span><br><span class="line"> let subCookies = SubCookieUtil.getAll(name); //getAll用于取得所有子cookie的值 get用于取得一个子cookie</span><br><span class="line"> return subCookies ? subCookies[subName] : null;</span><br><span class="line"> }</span><br><span class="line"> static getAll(name) {</span><br><span class="line"> let cookieName = encodeURIComponent(name) + "=",</span><br><span class="line"> cookieStart = document.cookie.indexOf(cookieName),</span><br><span class="line"> cookieValue = null,</span><br><span class="line"> cookieEnd,</span><br><span class="line"> subCookies,</span><br><span class="line"> parts,</span><br><span class="line"> result = {};</span><br><span class="line"> if (cookieStart &gt; -1) {</span><br><span class="line"> cookieEnd = document.cookie.indexOf(";", cookieStart);</span><br><span class="line"> if (cookieEnd == -1) {</span><br><span class="line"> cookieEnd = document.cookie.length;</span><br><span class="line"> }</span><br><span class="line"> cookieValue = document.cookie.substring(cookieStart +</span><br><span class="line"> cookieName.length, cookieEnd);</span><br><span class="line"> if (cookieValue.length &gt; 0) {</span><br><span class="line"> subCookies = cookieValue.split("&amp;");</span><br><span class="line"> for (let i = 0, len = subCookies.length; i &lt; len; i++) {</span><br><span class="line"> parts = subCookies[i].split("=");</span><br><span class="line"> result[decodeURIComponent(parts[0])] =</span><br><span class="line"> decodeURIComponent(parts[1]);</span><br><span class="line"> }</span><br><span class="line"> return result;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> return null;</span><br><span class="line"> }</span><br><span class="line"> // 省略其他代码</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="使用-cookie-的注意事项"><a href="#使用-cookie-的注意事项" class="headerlink" title="使用 cookie 的注意事项"></a>使用 cookie 的注意事项</h4><p><code>HTTP-only</code>可在浏览器设置 也可以在服务器设置 但是只能在服务器上读取 这是因为 JavaScript 无法取得这种 cookie 的值</p>
<p><code>**http-only</code>的作用**</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果cookie中设置了http-only属性 那么通过js脚本无法读取cookie信息 这样能有效防止XSS攻击 窃取cookie内容 这样增加了cookie1的安全性</span><br><span class="line">XSS攻击：跨站脚本攻击 属于被动式且客户端的攻击方式 原理是攻击者向有XSS漏洞的网站中输入恶意HTML代码 当其他用户浏览该网站时 这段HTML代码会自动执行 从而达到攻击的目的 通常用来盗取用户Cookie 破坏页面结构 重定向到其他网站等</span><br></pre></td></tr></tbody></table></figure>

<p>因为所有 cookie 都会作为请求头部由浏览器发送给服务器，所以在 cookie 中保存大量信息可能会影 响特定域浏览器请求的性能。保存的 cookie 越大，请求完成的时间就越长。即使浏览器对 cookie 大小有 限制，最好还是尽可能只通过 cookie 保存必要信息，以避免性能问题。 对 cookie 的限制及其特性决定了 cookie 并不是存储大量数据的理想方式。因此，其他客户端存储技 术出现</p>
<blockquote>
<p>不要在 cookie 中存储重要或敏感的信息。cookie 数据不是保存在安全的环境中，因 此任何人都可能获得。应该避免把信用卡号或个人地址等信息保存在 cookie 中</p>
</blockquote>
<h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p>解决通过客户端储存不需要频繁发送回服务器的数据时使用 cookie 的问题</p>
<ul>
<li>提供在 cookie 之外的储存会话数据的途径</li>
<li>提供跨会话持久化储存大量数据的机制</li>
</ul>
<p><code>localStorage</code> 是 永久存储机制，<code>sessionStorage</code> 是跨会话的存储机制</p>
<h4 id="Storage-类型"><a href="#Storage-类型" class="headerlink" title="Storage 类型"></a>Storage 类型</h4><p>用于保存名/值对数据</p>
<ul>
<li><code>clear（）</code>：删除所有值</li>
<li><code>getItem(name)</code>:取得给定 name 的值</li>
<li><code>key(index):</code>取得给定数值位置名称</li>
<li><code>removeItem(name):</code>删除给定的 name 的名/值对</li>
<li><code>setItem(name, value)</code>:设置给定 name 的值</li>
</ul>
<h4 id="sessionStorage-对象"><a href="#sessionStorage-对象" class="headerlink" title="sessionStorage 对象"></a>sessionStorage 对象</h4><p><code>sessionStorage</code> 对象只存储会话数据，这意味着数据只会存储到浏览器关闭</p>
<p>因为 <code>sessionStorag</code>e 对象与服务器会话紧密相关，所以在运行本地文件时不能使用。存储在 <code>sessionStorage</code> 对象中的数据只能由最初存储数据的页面使用，在多页应用程序中的用处有限</p>
<p><strong>浏览器在实现存储的时候使用同步阻塞方式 因此数据会立即被提交到储存</strong></p>
<p><strong>通过 webStorage 写入的任何数据都能被立即读取</strong></p>
<p>可以使用 for-in 循环迭代<code>sessionStorage</code>的值</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> sessionStorage) {</span><br><span class="line">  <span class="comment">//每次循环 key都会被赋予sessionStorage中的一个名称 这里不会返回内置方法或length属性</span></span><br><span class="line">  <span class="keyword">let</span> value = sessionStorage.<span class="title function_">getItem</span>(key);</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">${key}</span>=<span class="subst">${value}</span>`</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以使用<code>delete</code>或<code>removeItem</code>删除<code>sessionStorage</code>的数据</p>
<h4 id="localStorage-对象"><a href="#localStorage-对象" class="headerlink" title="localStorage 对象"></a>localStorage 对象</h4><p><strong>要想访问同一个 localStorage 对象 页面必须来自同一个域（子域不可以</strong>） <strong>在相同的端口上使用相同的协议</strong></p>
<p>两种存储方法的区别在于，存储在 localStorage 中的数据会保留到通过 JavaScript 删除或者用户 清除浏览器缓存。localStorage 数据不受页面刷新影响，也不会因关闭窗口、标签页或重新启动浏览 器而丢失。</p>
<h4 id="储存事件"><a href="#储存事件" class="headerlink" title="储存事件"></a>储存事件</h4><p>每当 Storage 对象发生变化时 都会在文档上触发 storage 事件</p>
<ul>
<li><code>domain</code>：存储变化对应的域。</li>
<li><code>key：</code>被设置或删除的键。。</li>
<li><code>newValue</code>：键被设置的新值，若键被删除则为 null。</li>
<li><code>oldValue</code>：键变化之前的值。</li>
</ul>
<p>对于 <code>sessionStorage</code> 和 <code>localStorage</code> 上的任何更改都会触发 storage 事件，但 storage 事 件不会区分这两者</p>
<h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><p><code>indexedDB</code>的请求几乎都是<strong>异步</strong>的 添加<code>onerror</code>和<code>onsuccess</code> 事件处理程序来确定输出</p>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>使用对象储存</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db,</span><br><span class="line">  request,</span><br><span class="line">  version = <span class="number">1</span>;</span><br><span class="line">request = indexedDB.<span class="title function_">open</span>(<span class="string">"admin"</span>, version); <span class="comment">//如果存在数据库就打开 否则发送创建并打开这个数据库的请求</span></span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  event <span class="comment">//失败事件</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">`Failed to open: <span class="subst">${event.target.errorCode}</span>`</span>);</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">//成功事件</span></span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>简历好数据库连接后就是使用对象储存了</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设插入一条user记录</span></span><br><span class="line"><span class="keyword">let</span> user = {</span><br><span class="line">  <span class="attr">username</span>: <span class="string">"007"</span>,</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">"James"</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">"Bond"</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">"foo"</span>,</span><br><span class="line">}; <span class="comment">//用户名必须全局唯一 因为创建储存时必须指定一个键</span></span><br><span class="line"><span class="comment">//open操作触发了upgradeneeded事件 因此可以在事件处理程序中更新数据库模式</span></span><br><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="comment">// 如果存在则删除当前 objectStore。测试的时候可以这样做</span></span><br><span class="line">  <span class="comment">// 但这样会在每次执行事件处理程序时删除已有数据</span></span><br><span class="line">  <span class="keyword">if</span> (db.<span class="property">objectStoreNames</span>.<span class="title function_">contains</span>(<span class="string">"users"</span>)) {</span><br><span class="line">    db.<span class="title function_">deleteObjectStore</span>(<span class="string">"users"</span>);</span><br><span class="line">  }</span><br><span class="line">  db.<span class="title function_">createObjectStore</span>(<span class="string">"users"</span>, { <span class="attr">keyPath</span>: <span class="string">"username"</span> }); <span class="comment">//这里第二个参数的 keyPath 属性表示应该用作键的存储对象的属性名。</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务通过调用数据库对象的<code>transaction</code>方法创建</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> transaction = db.<span class="property">transaction</span>; <span class="comment">//如果不指定参数 则对数据库中所有对象储存有只读权限</span></span><br><span class="line"><span class="comment">//可以指定一个或多个要访问的对象存储的名称（传入名称数组）</span></span><br><span class="line"><span class="keyword">let</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">"users"</span>, <span class="string">"readwrite"</span>); <span class="comment">//"readonly"、"readwrite"或"versionchange"权限问题</span></span><br></pre></td></tr></tbody></table></figure>

<p>有了事务的引用，就可以使用 <code>objectStore()</code>方法并传入对象存储的名称以访问特定的对象存储。 然后，可以使用 <code>add()</code>和 <code>put()</code>方法添加和更新对象，使用 <code>get()</code>取得对象，使用 <code>delete(</code>)删除对象， 使用 <code>clear()</code>删除所有对象</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">"users"</span>),</span><br><span class="line">  store = transaction.<span class="title function_">objectStore</span>(<span class="string">"users"</span>),</span><br><span class="line">  request = store.<span class="title function_">get</span>(<span class="string">"007"</span>);</span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">"Did not get the object!"</span>);</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">result</span>.<span class="property">firstName</span>);</span><br><span class="line">transaction.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 整个事务被取消</span></span><br><span class="line">};</span><br><span class="line">transaction.<span class="property">oncomplete</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 整个事务成功完成</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>不能通过<code>oncomplete</code>事件处理程序的<code>event</code>对象访问<code>get（）</code>请求返回的任何数据 因此 仍然需要通过请求的<code>onsuccess</code>事件处理程序来获取数据</p>
<h4 id="插入对象"><a href="#插入对象" class="headerlink" title="插入对象"></a>插入对象</h4><p>使用<code>add()</code>或<code>put()</code>写入数据 <code>add（）</code>是插入新值 而<code>put</code>是更新值</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users 是一个用户数据的数组</span></span><br><span class="line"><span class="keyword">let</span> request,</span><br><span class="line">  requests = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> users) {</span><br><span class="line">  request = store.<span class="title function_">add</span>(user); <span class="comment">//将请求对象保存到一个变量 然后为它添加onerror和onSuccess事件</span></span><br><span class="line">  request.<span class="property">onerror</span> = <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  };</span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// 处理成功</span></span><br><span class="line">  };</span><br><span class="line">  requests.<span class="title function_">push</span>(request);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="通过游标查询"><a href="#通过游标查询" class="headerlink" title="通过游标查询"></a>通过游标查询</h4><p>如果想要取得多条数据 则需要在事务中创建一个游标（指向结果集的指针）使用<code>openCursor()</code>创建</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onst transaction = db.<span class="title function_">transaction</span>(<span class="string">"users"</span>),</span><br><span class="line"> store = transaction.<span class="title function_">objectStore</span>(<span class="string">"users"</span>),</span><br><span class="line"> request = store.<span class="title function_">openCursor</span>();</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"> <span class="comment">// 处理成功</span></span><br><span class="line">    <span class="comment">//可以通过event.target.result访问对象储存中的下一条记录 包含着IDBCursor实例</span></span><br><span class="line">    <span class="comment">//包括属性：direction、 key、 value：实际的对象（需要用JSON编码） primaryKey：游标使用的键</span></span><br><span class="line">};</span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"> <span class="comment">// 处理错误</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>游标可用于更新个别记录 <code>update（）</code>方法指定使用的对象更新当前游标对应的值</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"> <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"> <span class="keyword">let</span> value,</span><br><span class="line"> updateRequest;</span><br><span class="line"> <span class="keyword">if</span> (cursor) { <span class="comment">// 永远要检查</span></span><br><span class="line"> <span class="keyword">if</span> (cursor.<span class="property">key</span> == <span class="string">"foo"</span>) {</span><br><span class="line"> value = cursor.<span class="property">value</span>; <span class="comment">// 取得当前对象</span></span><br><span class="line"> value.<span class="property">password</span> = <span class="string">"magic!"</span>; <span class="comment">// 更新密码</span></span><br><span class="line"> updateRequest = cursor.<span class="title function_">update</span>(value); <span class="comment">// 请求保存更新后的对象</span></span><br><span class="line"> updateRequest.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> {</span><br><span class="line"> <span class="comment">// 处理成功</span></span><br><span class="line"> };</span><br><span class="line"> updateRequest.<span class="property">onerror</span> = <span class="function">() =&gt;</span> {</span><br><span class="line"> <span class="comment">// 处理错误</span></span><br><span class="line"> };</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> <span class="comment">//也可以调用delete（）删除游标位置的记录</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果事务没有修改对象储存的权限 <code>uodate（）和delete（）</code>都会抛出错误</p>
<p>默认情况下 每个游标只会创建一个请求 如果想要创建另一个请求 必须调用以下方法</p>
<ul>
<li><code>continue（key）</code>：移动到结果集中的下一条记录 如果没有指定 key 则移动到下一条 否则移动到指定的</li>
<li><code>advance（count）</code>：向前移动指定 count 条记录</li>
</ul>
<p>这两个方法都会让游标重用相同的请求 因此也会重用<code>onsuccess和onerror</code>处理程序 知道不需要</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">if</span> (cursor) {</span><br><span class="line">    <span class="comment">// 永远要检查</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Key: <span class="subst">${cursor.key}</span>, Value: <span class="subst">${<span class="built_in">JSON</span>.stringify(cursor.value)}</span>`</span>);</span><br><span class="line">    cursor.<span class="title function_">continue</span>(); <span class="comment">// 移动到下一条记录</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Done!"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="comment">//调用cursor.continue()会触发另一个请求并再次调用onsuccess事件处理程序 在没有更多记录时 onsuccess最后一次被调用 此时event.target.result = null</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="键范围"><a href="#键范围" class="headerlink" title="键范围"></a>键范围</h4><p>使用键范围可以让游标更容易管理 键范围对应 IDBKeyRange 的实例</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onlyRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">only</span>(<span class="string">"007"</span>);</span><br><span class="line">这个范围保证只获取键为<span class="string">"007"</span>的值。使用这个范围创建的游标类似于直接访问对象存储并调用</span><br><span class="line"><span class="title function_">get</span>(<span class="string">"007"</span>)。</span><br><span class="line">第二种键范围可以定义结果集的下限。下限表示游标开始的位置。例如，下面的键范围保证游标从</span><br><span class="line"><span class="string">"007"</span>这个键开始，直到最后：</span><br><span class="line"><span class="comment">// 从"007"记录开始，直到最后</span></span><br><span class="line"><span class="keyword">const</span> lowerRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">lowerBound</span>(<span class="string">"007"</span>); <span class="comment">//如果想要从后面的记录开始 则传入true</span></span><br><span class="line">第二种键范围可以定义结果集的下限。下限表示游标开始的位置。例如，下面的键范围保证游标从</span><br><span class="line"><span class="string">"007"</span>这个键开始，直到最后：</span><br><span class="line"><span class="comment">// 从"007"记录开始，直到最后</span></span><br><span class="line"><span class="keyword">const</span> lowerRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">lowerBound</span>(<span class="string">"007"</span>);<span class="comment">//不想包含指定的键 则传入true</span></span><br><span class="line">要同时指定下限和上限，可以使用 <span class="title function_">bound</span>()方法。这个方法接收四个参数：下限的键、上限的键、</span><br><span class="line">可选的布尔值表示是否跳过下限和可选的布尔值表示是否跳过上限</span><br><span class="line">要同时指定下限和上限，可以使用 <span class="title function_">bound</span>()方法。这个方法接收四个参数：下限的键、上限的键、</span><br><span class="line">可选的布尔值表示是否跳过下限和可选的布尔值表示是否跳过上限</span><br><span class="line">定义了范围之后，把它传给 <span class="title function_">openCursor</span>()方法，就可以得到位于该范围内的游标：</span><br><span class="line"><span class="keyword">const</span> store = db.<span class="title function_">transaction</span>(<span class="string">"users"</span>).<span class="title function_">objectStore</span>(<span class="string">"users"</span>),</span><br><span class="line"> range = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">"007"</span>, <span class="string">"ace"</span>);</span><br><span class="line"> request = store.<span class="title function_">openCursor</span>(range);</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params">event</span>){</span><br><span class="line"> <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"> <span class="keyword">if</span> (cursor) { <span class="comment">// 永远要检查</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Key: <span class="subst">${cursor.key}</span>, Value: <span class="subst">${<span class="built_in">JSON</span>.stringify(cursor.value)}</span>`</span>);</span><br><span class="line"> cursor.<span class="title function_">continue</span>(); <span class="comment">// 移动到下一条记录</span></span><br><span class="line"> } <span class="keyword">else</span> {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Done!"</span>);</span><br><span class="line"> }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p>如果两个不同的浏览器标签同时打开了同一个网页 可能出现一个网页尝试升级数据库而另一个网页尚未就绪的情形</p>
<p>应该在每次成功打开数据库后都指定 onversionchange 事件处理程序。记住，onversionchange 有可能会被其他标签页触发。</p>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>无论一个模块在 require（）中被引用多少次 模块永远时单例（无论请求多少次 module 只会被加载一次）</p>
<p>模块第一次被加载后会被缓存 后续加载会取得缓存的模块 模块加载顺序由依赖图决定</p>
<p>在 CommonJS 中 模块加载是模块系统的同步操作</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"moduleA"</span>);</span><br><span class="line"><span class="keyword">if</span> (loadCondition) {</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">"./moduleA"</span>); <span class="comment">//moduleA会在loadCondition为true是才会加载 这个加载是同步的 因此if之前的任何代码都会在加载moduleA之前执行 而if之后的任何代码都会在module执行之后执行 如果moduleA已经在前面某个地方加载过 这个条件的require意味着只暴露moduleA这个命名空间而已</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="异步模块定义（AMD）"><a href="#异步模块定义（AMD）" class="headerlink" title="异步模块定义（AMD）"></a>异步模块定义（AMD）</h3><p><code>COmmonJS</code>以服务器为目标环境 能够一次性将所有的模块都加载到内存中 而异步模块定义（<code>AMD</code>）的模块定义系统则以浏览器为目标执行环境 这需要考虑网络延迟的问题。</p>
<p><code>AMD</code>的一般策略是让模块<strong>声明</strong>自己的依赖 而运行在浏览器中的模块系统会<strong>按需获取依赖</strong> 并在依赖<strong>加载完成后</strong>立即执行依赖他们的模块</p>
<p><code>AMD</code>模块实现的核心是用<strong>函数包装</strong>模块定义 这样可以防止声明<strong>全局变量</strong> 并允许加载器控制何时加载模块</p>
<p><code>AMD</code>模块可以使用字符串标识符指定自己的依赖 而<code>AMD加载器</code>会在所有依赖模块加载完毕后立即调用模块工厂函数</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ID 为'moduleA'的模块定义。moduleA 依赖 moduleB，</span></span><br><span class="line"><span class="comment">// moduleB 会异步加载</span></span><br><span class="line"><span class="title function_">define</span>(<span class="string">'moduleA'</span>, [<span class="string">'moduleB'</span>], <span class="keyword">function</span>(<span class="params">moduleB</span>) {</span><br><span class="line"> <span class="keyword">return</span> {</span><br><span class="line"> <span class="attr">stuff</span>: moduleB.<span class="title function_">doStuff</span>();</span><br><span class="line"> };</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>AMD 也支持<code>require和exports</code>对象 通过他们可以在 AMD 模块工厂函数内部定义 CommonJS 风格的模块</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="string">'moduleA'</span>, [<span class="string">'require'</span>, <span class="string">'exports'</span>], <span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span></span>) {</span><br><span class="line"> <span class="keyword">var</span> moduleB = <span class="built_in">require</span>(<span class="string">'moduleB'</span>);</span><br><span class="line"> <span class="built_in">exports</span>.<span class="property">stuff</span> = moduleB.<span class="title function_">doStuff</span>();</span><br><span class="line">});</span><br><span class="line">动态依赖也是通过这种方式支持的：</span><br><span class="line"><span class="title function_">define</span>(<span class="string">'moduleA'</span>, [<span class="string">'require'</span>], <span class="keyword">function</span>(<span class="params"><span class="built_in">require</span></span>) {</span><br><span class="line"> <span class="keyword">if</span> (condition) {</span><br><span class="line"> <span class="keyword">var</span> moduleB = <span class="built_in">require</span>(<span class="string">'moduleB'</span>);</span><br><span class="line"> }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h4 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h4><p><code>UMD</code>用于创建两个系统都可以使用的模块代码 本质上 UMD 定义的模块会在启动时检测到要使用那个模块系统 然后进行适当配置 并把所有逻辑包装在一个立即调用的函数表达式中</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) {</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.<span class="property">amd</span>) {</span><br><span class="line">    <span class="comment">// AMD。注册为匿名模块</span></span><br><span class="line">    <span class="title function_">define</span>([<span class="string">"moduleB"</span>], factory);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="variable language_">module</span>.<span class="property">exports</span>) {</span><br><span class="line">    <span class="comment">// Node。不支持严格 CommonJS</span></span><br><span class="line">    <span class="comment">// 但可以在 Node 这样支持 module.exports 的</span></span><br><span class="line">    <span class="comment">// 类 CommonJS 环境下使用</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">" moduleB "</span>));</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 浏览器全局上下文（root 是 window）</span></span><br><span class="line">    root.<span class="property">returnExports</span> = <span class="title function_">factory</span>(root.<span class="property">moduleB</span>);</span><br><span class="line">  }</span><br><span class="line">})(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">moduleB</span>) {</span><br><span class="line">  <span class="comment">// 以某种方式使用 moduleB</span></span><br><span class="line">  <span class="comment">// 将返回值作为模块的导出</span></span><br><span class="line">  <span class="comment">// 这个例子返回了一个对象</span></span><br><span class="line">  <span class="comment">// 但是模块也可以返回函数作为导出值</span></span><br><span class="line">  <span class="keyword">return</span> {};</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h1 id="工作者线程"><a href="#工作者线程" class="headerlink" title="工作者线程"></a>工作者线程</h1><p>使用工作者线程 浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境 这个子环境不能与依赖单线程交互的 API 互操作 但可以与父环境并行执行代码</p>
<h3 id="工作者线程和线程"><a href="#工作者线程和线程" class="headerlink" title="工作者线程和线程"></a>工作者线程和线程</h3><ul>
<li>工作者线程是以实际线程实现的</li>
<li>工作者线程并行执行 虽然页面和工作者线程都是单线程 JavaScript 环境 每个环境中的指令可以并行执行</li>
<li>工作者线程可以共享某些内存 使用<code>SharedArrayBuffer</code> 在多个环境间共享 内容 JavaScript 使用 <code>Atomics</code> 接口实现并发控制</li>
<li>工作者线程不共享全部内存</li>
<li>工作者线程不一定再同一个进程里</li>
<li>创建工作者线程的开销更大 工作者线程有自己独立的<strong>事件循环</strong> <strong>全局对象</strong> <strong>事件处理程序</strong>和其他 js<strong>环境</strong>必须的特性</li>
</ul>
<p><strong>工作者线程相对比较重 不建议大量使用 工作者线程应该是长期运行的 启动成本比较高 每个实例占用的内存耶比较大</strong></p>
<h3 id="工作者线程的类型"><a href="#工作者线程的类型" class="headerlink" title="工作者线程的类型"></a>工作者线程的类型</h3><p>专用工作者线程、共享工作者线程和服务工作者线程</p>
<h4 id="专用工作者线程"><a href="#专用工作者线程" class="headerlink" title="专用工作者线程"></a>专用工作者线程</h4><p>可以让脚本单独创建一个 js 线程 只能被创建它的页面使用</p>
<h4 id="共享工作者线程"><a href="#共享工作者线程" class="headerlink" title="共享工作者线程"></a>共享工作者线程</h4><p>可以被多个不同的上下文使用 任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送 消息或从中接收消息</p>
<h4 id="服务工作者线程"><a href="#服务工作者线程" class="headerlink" title="服务工作者线程"></a>服务工作者线程</h4><p>主要用于拦截、重定向和修改页面发出的请求 充当网络请求的仲裁者</p>
<h1 id="ES2018-与-ES2019"><a href="#ES2018-与-ES2019" class="headerlink" title="ES2018 与 ES2019"></a>ES2018 与 ES2019</h1><p>剩余运算符再对象间执行前复制 因此只会复制对象的引用而不会克隆整个对象</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = { <span class="attr">name</span>: <span class="string">"Matt"</span>, <span class="attr">age</span>: <span class="number">27</span>, <span class="attr">job</span>: { <span class="attr">title</span>: <span class="string">"Engineer"</span>, <span class="attr">level</span>: <span class="number">10</span> } };</span><br><span class="line"><span class="keyword">const</span> { ...remainingData } = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person === remainingData); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">job</span> === remainingData.<span class="property">job</span>); <span class="comment">// true</span></span><br><span class="line">remainingData.<span class="property">name</span> = <span class="string">"olddog"</span>;</span><br><span class="line">person.<span class="property">name</span> = <span class="string">"wqdq"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(remainingData.<span class="property">name</span>); <span class="comment">//olddog</span></span><br><span class="line">person.<span class="property">name</span>; <span class="comment">//wqdq</span></span><br><span class="line">person.<span class="property">job</span>.<span class="property">title</span> = <span class="string">"123"</span>;</span><br><span class="line">remainingData.<span class="property">job</span>, title; <span class="comment">//123</span></span><br></pre></td></tr></tbody></table></figure>

<p>剩余运算符会复制所有自有可枚举属性 包括括号</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> foo = { <span class="attr">a</span>: <span class="number">1</span>, [s]: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> };</span><br><span class="line"><span class="keyword">const</span> { a, ...remainingData } = foo;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(remainingData);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符会像拼接数组一样合并两个对象 应用到内部对象的扩展运算符会对所有自有可枚举属性执行浅复制到外部对象 包括符号</p>
<ul>
<li>对象跟踪插入顺序 从扩展对象复制的属性按照他们在对象字面量中列出的顺序插入</li>
<li>对象会覆盖重名属性 出现重名属性时会使用后续出现的值</li>
<li>与剩余操作符一样 所有复制都是浅复制</li>
</ul>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p>有了<code>Promise.prototype.finally</code>可以统一共享的处理程序 <code>finally（）</code>不传递任何参数 也不知道自己处理的<code>promise</code>是什么状态</p>
<p>每个<code>finally（）</code>都会创建一个新的<code>promise</code>实例 而这个新<code>promise</code>会被添加到浏览器的微任务队列 只有前面的处理程序执行完成才会解决</p>
<h3 id="数组打平方法"><a href="#数组打平方法" class="headerlink" title="数组打平方法"></a>数组打平方法</h3><blockquote>
<p><code>flat()</code>和 <code>flatMap()</code>只能用于打平嵌套数组。嵌套的可迭代对象如 Map 和 Set 不能打平</p>
</blockquote>
<h4 id="Array-prototype-flatten"><a href="#Array-prototype-flatten" class="headerlink" title="Array.prototype.flatten()"></a>Array.prototype.flatten()</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打平数组的实例实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">sourceArray, flattenedArray = []</span>) {</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> sourceArray) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(element)) {</span><br><span class="line">      <span class="title function_">flatten</span>(element, flattenedArray);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      flattenedArray.<span class="title function_">push</span>(element);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> flattenedArray;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> arr = [[<span class="number">0</span>], <span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]], <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br><span class="line"><span class="comment">//重写邦本 允许指定打平到第几级嵌套</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">sourceArray, depth, flattenedArray = []</span>) {</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> sourceArray) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(element) &amp;&amp; depth &gt; <span class="number">0</span>) {</span><br><span class="line">      <span class="title function_">flatten</span>(element, depth - <span class="number">1</span>, flattenedArray);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      flattenedArray.<span class="title function_">push</span>(element);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> flattenedArray;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> arr = [[<span class="number">0</span>], <span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]], <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, [4, 5], 6]</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>Array.prototype.flat()</code> 接收一个 depth 参数 默认为 1 返回一个打平 Array 实例的浅复制版本</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [[<span class="number">0</span>], <span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> arr1 = arr.<span class="title function_">flat</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">//[0,1,2,3,4,5,6]</span></span><br><span class="line">arr1.<span class="title function_">push</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">//[0,1,2,3,4,5,6,10]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">//[[0], 1, 2, [3, [4, 5]], 6]</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap()"></a>Array.prototype.flatMap()</h4><p><code>Array.prototype.flatMap()</code>方法会在打平数组之前执行一次映射操作。在功能上，<code>arr.flatMap(f)</code> 与 <code>arr.map(f).flat()</code>等价；但 <code>arr.flatMap()</code>更高效，因为浏览器只需要执行<strong>一次遍历</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [[<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">5</span>]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">map</span>(<span class="function">(<span class="params">[x]</span>) =&gt;</span> [x, x + <span class="number">1</span>]));</span><br><span class="line"><span class="comment">// [[1, 2], [3, 4], [5, 6]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">flatMap</span>(<span class="function">(<span class="params">[x]</span>) =&gt;</span> [x, x + <span class="number">1</span>]));</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>flatMap()</code>在非数组对象的方法返回数组时特别有用，例如字符串的 <code>split()</code>方法</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一组输入字符串分割为单词 然后把这些单词拼接成一个单词数组</span></span><br><span class="line"><span class="keyword">const</span> arr =  [<span class="string">'Lorem ipsum dolor sit amet,'</span>, <span class="string">'consectetur adipiscing elit.'</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="title function_">split</span>(<span class="regexp">/[\W+]/</span>)));</span><br><span class="line"><span class="comment">// ["Lorem", "ipsum", "dolor", "sit", "amet", "", "consectetur", "adipiscing",</span></span><br><span class="line"><span class="string">"elit"</span>, <span class="string">""</span>]</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Object-formEntries"><a href="#Object-formEntries" class="headerlink" title="Object.formEntries()"></a>Object.formEntries()</h4><p>用于通过键/值对数组的 集合构建对象。这个方法执行与 <code>Object.entries()</code>方法相反的操作</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="string">"qux"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> objEntries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objEntries);</span><br><span class="line"><span class="comment">// [["foo", "bar"], ["baz", "qux"]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(objEntries));</span><br><span class="line"><span class="comment">// { foo: "bar", baz: "qux" }</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以快速地将<code>Map</code>实例转换为<code>Object</code>实例 因为 Map 迭代器返回的结果与<code>formEntries（）</code>的参数恰好匹配</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">formEntries</span>(map)); <span class="comment">//{foo: "bar"}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="字符串修理方法"><a href="#字符串修理方法" class="headerlink" title="字符串修理方法"></a>字符串修理方法</h3><p><code>trimStart():</code>删除字符串开头的空格</p>
<p><code>trimEnd()</code>;删除末尾的空格</p>
<p>在只有一个空格的情况下 这两个方法相当于执行与<code>padStart()和padEnd()</code>相反的操作</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">" foo "</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">trimStart</span>()); <span class="comment">// "foo "</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">trimEnd</span>()); <span class="comment">// " foo"</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><p>用于取得可选的符号描述 只读的 如果没有描述 默认为<code>undefined</code></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="title class_">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">description</span>); <span class="comment">//foo</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="可选的-catch-绑定"><a href="#可选的-catch-绑定" class="headerlink" title="可选的 catch 绑定"></a>可选的 catch 绑定</h2><p>在<code>try/catch</code>中 可以忽略<code>catch</code>的错误对象不做任何操作</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"foo"</span>;</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">  <span class="comment">// 发生错误了，但你不想使用错误对象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">olddog</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://23olddog.github.io/2022/04/25/chong-xue-js-di-er-tian/">https://23olddog.github.io/2022/04/25/chong-xue-js-di-er-tian/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">olddog</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JS/">
                                    <span class="chip bg-color">JS</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/05/06/chong-xue-es61.0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="重学ES6 1.0">
                        
                        <span class="card-title">重学ES6 1.0</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-05-06
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" class="post-category">
                                    前端基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ES6/">
                        <span class="chip bg-color">ES6</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/04/20/chong-xue-js-di-yi-tian/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="重学JS第一天">
                        
                        <span class="card-title">重学JS第一天</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-04-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JS/" class="post-category">
                                    JS
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JS/">
                        <span class="chip bg-color">JS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: olddog<br />'
            + '文章作者: olddog<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022</span>
            
            <a href="/about" target="_blank">olddog</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">128.8k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/23olddog" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:3056085618@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=3056085618" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 3056085618" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
