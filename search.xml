<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重学ES6第一天</title>
      <link href="/2022/05/06/chong-xue-es61.0/"/>
      <url>/2022/05/06/chong-xue-es61.0/</url>
      
        <content type="html"><![CDATA[<h1 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h1><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a= [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">a [ i] = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">a[6J ();<span class="comment">// 6</span></span><br><span class="line"> <span class="comment">//每轮的i都是重新声明的 因为js引擎内部会记住上一轮循环的值 另外 设置循环变量的那部分是一个父作用域 而循环体内部是一个单独的子作用域</span></span><br></pre></td></tr></tbody></table></figure><p>暂时性死区的本质就是只要进入当前作用域 所要使用的变量就已经存在 但是不可获取 只有等到声明变量的那一行代码出现 才可以获取和使用变量。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>ES6 允许块级作用域声明函数</p><ul><li>函数声明类似于<code>var</code> 即会提升到全局作用域或者函数作用域的头部</li><li>函数声明还会提升到所在块级作用域的头部</li></ul><h3 id="do-表达式"><a href="#do-表达式" class="headerlink" title="do 表达式"></a>do 表达式</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> {</span><br><span class="line">  <span class="keyword">let</span> t = <span class="title function_">f</span>();</span><br><span class="line">  t * t + <span class="number">1</span>;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//变量x会得到块级作用域的返回值</span></span><br></pre></td></tr></tbody></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p><code>const</code>实际上保证的并不是变量的值不得改动 而是变量指向的那个<strong>内存地址</strong>不得改动（对于一个复合类型的数据 变量指向的内存地址保存的只是一个指针 const 只能保证这个指针是固定的 不能保证它指向的数据结构是不可变的）</p><h1 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h1><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><blockquote><p>ES6 内部使用严格相等运算符判断一个位置是否有值 所以 如果一个数组成员不严格等于<code>undefined</code> 默认值是不会生效的</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x=<span class="number">1</span>] = [<span class="literal">undefined</span>]; <span class="comment">// x = 1</span></span><br><span class="line"><span class="keyword">let</span> [x=<span class="number">1</span>] = [<span class="literal">null</span>];<span class="comment">// x = null</span></span><br><span class="line"><span class="comment">//如果默认值是一个表达式 那么这个表达式是惰性求值的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) {....};</span><br><span class="line"><span class="keyword">let</span> [x = <span class="title function_">f</span>()] = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">//默认值可以引用解构赋值的其他变量 但是该变量必须已经声明</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];<span class="comment">//ReferenceError</span></span><br></pre></td></tr></tbody></table></figure><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><blockquote><p>数组的元素是按次序排列的 变量的取值是由他的位置决定的 而对象的属性没有次序 变量必须与属性同名才能取到正确的值 0</p></blockquote><p>默认值生效的条件是对象的属性值严格等于<code>undefined</code> 如果解构失败 那么变量的值等于<code>undefined</code></p><p>如果解构的是嵌套的对象 而且子对象所在的父属性不存在 那么就会报错</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> {</span><br><span class="line">  <span class="attr">foo</span>: { bar },</span><br><span class="line">} = { <span class="attr">baz</span>: <span class="string">"baz"</span> }; <span class="comment">//foo = undefined 所以取其子元素就会报错</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> { <span class="number">0</span>: first, [arr.<span class="property">length</span> - <span class="number">1</span>]: last } = arr; <span class="comment">//first: 1, last: 3</span></span><br></pre></td></tr></tbody></table></figure><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p><strong>解构赋值时 只要等号右边的值不是对象或数组 就会将其转为对象 由于<code>undefined</code>和<code>null</code>无法转为对象 所以对他们进行解构赋值时都会报错</strong></p><h2 id="解构的用途"><a href="#解构的用途" class="headerlink" title="解构的用途"></a>解构的用途</h2><ul><li>交换变量的值</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></tbody></table></figure><ul><li>从函数返回多个值</li><li>函数参数的命名</li><li>提取<code>JSON</code>数据</li><li>函数参数的默认值</li><li>遍历<code>Map</code>结构</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) {</span><br><span class="line">....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>输入模块的指定方法</li></ul><h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h2 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes() startsWith() endsWith()"></a><code>includes() startsWith() endsWith()</code></h2><ul><li><code>includes()</code>: 返回布尔值 表示是否找到了字符串</li><li><code>startsWith()</code>: 返回布尔值 表示参数字符串是否在源字符串的头部</li><li><code>endsWith():</code> 返回布尔值 表示参数字符串是否在源字符串的头部</li></ul><h2 id="repeat（）"><a href="#repeat（）" class="headerlink" title="repeat（）"></a><code>repeat（）</code></h2><p>返回一个新字符串 将原来的字符串重复几次</p><h2 id="padStart-padEnd"><a href="#padStart-padEnd" class="headerlink" title="padStart() padEnd()"></a><code>padStart() padEnd()</code></h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">'ab'</span>)<span class="comment">//'ababx' 最小长度以及补全的字符串</span></span><br><span class="line"><span class="comment">//如果字符串的长度大于或等于指定的最小长度 则返回原字符串 如果省略第二个参数 则用空格来补全</span></span><br><span class="line"><span class="comment">//padStart常用来胃数值补全指定位</span></span><br><span class="line">’ <span class="number">1</span> ’ . <span class="title function_">padStart</span>(l <span class="number">0</span>,’<span class="number">0</span> ’ ) <span class="comment">// ” 0 00000000 1 ”</span></span><br><span class="line"><span class="comment">//也可以用来提示字符串格式</span></span><br><span class="line"><span class="string">'12'</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>)<span class="comment">//'YYYY-MM-12'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串默认会将其他字符串转移 导致无法嵌入其他语言</p><h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h2><p>充当模板字符串的处理函数（返回一个连反斜线都被转转义的字符串）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property">raw</span><span class="string">`Hi\n<span class="subst">${<span class="number">5</span>+<span class="number">3</span>}</span>`</span>;<span class="comment">///  Hi \\nS !</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property">raw</span> <span class="title class_">Hi</span>\\n ;<span class="comment">// ” Hi \\n” 如果原字符串中的反斜线已经转移 则不会处理</span></span><br></pre></td></tr></tbody></table></figure><h1 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h1><h2 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h2><p><img src="https://s2.loli.net/2022/05/04/KwiHW6oR3PxnXGh.png" alt="image.png"></p><h1 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h1><h3 id="Number-isFinite-判断一个数是不是有限的"><a href="#Number-isFinite-判断一个数是不是有限的" class="headerlink" title="Number.isFinite():判断一个数是不是有限的"></a>Number.isFinite():判断一个数是不是有限的</h3><h4 id="Number-isNaN-判断一个数是不是-NaN"><a href="#Number-isNaN-判断一个数是不是-NaN" class="headerlink" title="Number.isNaN():判断一个数是不是 NaN"></a>Number.isNaN():判断一个数是不是 NaN</h4><p>只对数值有效 对非数值一律返回 f<code>alse</code></p><h2 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h2><p>极小的常量 实质是一个可以接受的误差范围</p><p>可用于为浮点数设置一个误差范围</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withinErrorMargin</span>(<span class="params">left, right</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(left - right) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span>;</span><br><span class="line">}</span><br><span class="line"><span class="title function_">withinErrorMargin</span>(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">withinErrorMargin</span>(<span class="number">0.2</span> + <span class="number">0.2</span>, <span class="number">0.3</span>); <span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Math-对象的新增"><a href="#Math-对象的新增" class="headerlink" title="Math 对象的新增"></a>Math 对象的新增</h2><h3 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h3><p>用于取出一个数的小数部分 返回整数部分（先内部使用 Number 再转为数值 对于空值或者无法截取整数的值 返回 NaN）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">trunc</span> = <span class="title class_">Math</span>.<span class="property">trunc</span> || <span class="function">(<span class="params">x</span>) =&gt;</span> x &lt; <span class="number">0</span>? <span class="title class_">Math</span>.<span class="title function_">ceil</span>(x): <span class="title class_">Math</span>.<span class="title function_">floor</span>(x)</span><br></pre></td></tr></tbody></table></figure><h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h3><p>判断一个数到底是正数负数还是零 先转为数值</p><h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>参数默认值不是传值的 而是每次都重新计算默认表达式的值 也就是默认表达式其实是惰性求值的</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params">p = x + <span class="number">1</span></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">//100</span></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">//101</span></span><br></pre></td></tr></tbody></table></figure><p>函数的<code>length</code>返回没有设置<strong>默认值</strong>的参数个数</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了默认值 函数进行声明式初始化 参会会形成一个单独的作用域 等到初始化结束 这个作用域就会消失 这和不设置参数的默认行为不一样</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params">y = x</span>) =&gt; {</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">};</span><br><span class="line"><span class="title function_">f</span>();<span class="comment">//1 参数y = x形成一个单独的作用域 在这个作用域里面 x还未定义 所以指向外层的全局变量x 函数体内部的局部变量x影响不到默认值变量x 如果全局x不存在 就会报错</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> =(<span class="params">x = x</span>) =&gt; {...};</span><br><span class="line"><span class="title function_">foo</span>();<span class="comment">//ReferenceError : x is not defined x = x会形成一个单独的作用域 实际上就是let x = x 由于暂时性死区 执行这行代码会产生定义错误</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() {x = <span class="number">2</span>}</span>) {<span class="comment">//定义了x</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="title function_">y</span>();<span class="comment">//改变的是参数定义的x</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">//输出var定义的x</span></span><br><span class="line">}</span><br><span class="line"><span class="title function_">foo</span>();<span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);<span class="comment">//1</span></span><br><span class="line">---------------------------</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (x , y = <span class="keyword">function</span> (<span class="params"></span>) { x = <span class="number">2</span> ; } ) {</span><br><span class="line">x = <span class="number">3</span>; <span class="comment">//改变参数的x</span></span><br><span class="line"><span class="title function_">y</span>(); <span class="comment">//改变定义的x</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">}</span><br><span class="line">foo () <span class="comment">// 2</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ol><li>函数体内的<code>this</code>就是定义时所在的对象 而不是使用时所在的对象<ol><li><code>this</code>指向的固定化并不是因为箭头函数内部由绑定 this 的机制 而是因为箭头函数根本没有自己的<code>this</code> 导致内部的<code>this</code>就是外层代码块的<code>this</code></li></ol></li><li>不可以当作构造函数<ol><li>因为它没有<code>this</code> 所以不能用作构造函数</li></ol></li><li>不可以使用<code>arguments</code>对象 可以用<code>rest</code>参数代替</li><li>不可以使用<code>yield</code>命令 因此箭头函数不能也能做<code>Generator</code>函数</li></ol><h3 id="绑定-this"><a href="#绑定-this" class="headerlink" title="绑定 this"></a>绑定 this</h3><p>使用<code>（::）</code>会自动将左边的对象作为上下文环境（即<code>this</code>对象）绑定到右边的函数上</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">foo</span>::bar; <span class="comment">// bar.bind(foo);</span></span><br></pre></td></tr></tbody></table></figure><p><strong>可以链式调用</strong></p><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>函数调用会在内部形成一个<strong>调用记录</strong>（<strong>调用帧</strong>）保存调用位置和内部变量等信息 所有调用帧就形成一个调用栈 尾调用由于是函数的最后一步操作 所以不需要保留外层函数的调用栈 因为调用位置 内部变量等信息都不会再用到 所以直接用内层函数的调用帧取代外层函数的即可。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">g</span>(m + n); <span class="comment">//需要保存m n 和g的调用位置</span></span><br><span class="line">}</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">g</span>(<span class="number">3</span>); <span class="comment">//只保留g3的调用帧</span></span><br><span class="line">}</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="comment">//等同于</span></span><br></pre></td></tr></tbody></table></figure><p>尾调用优化即指保留内层函数的调用帧 如果函数都是尾调用 那么可以做到每次执行时调用帧只有一项 可以大大节省内存</p><blockquote><p>只有不再用到外层函数的内部变量 内层函数的调用帧才可以取代外层函数的调用帧 否则无法进行尾调用优化</p></blockquote><h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span> (n) {</span><br><span class="line"><span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> n * <span class="title function_">factorial</span>(n - <span class="number">1</span>) ;</span><br><span class="line"><span class="title function_">factorial</span>(S) <span class="comment">// 120 容易栈溢出 复杂度On</span></span><br><span class="line"><span class="comment">//用尾调用优化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span> (n , total) {</span><br><span class="line"><span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total ;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span> , n *total);</span><br><span class="line"><span class="title function_">factorial</span>(S, <span class="number">1</span>) <span class="comment">// 120 复杂的O1</span></span><br><span class="line">----------------</span><br><span class="line"><span class="keyword">function</span> <span class="title class_">Fibonacc</span> 工（ {</span><br><span class="line"><span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) {<span class="keyword">return</span> <span class="number">1</span>};</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>) + <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>) ;</span><br><span class="line"><span class="title class_">Fibonacci</span> (lO) <span class="comment">// 89</span></span><br><span class="line"><span class="title class_">Fibonacci</span>(lOO) ／／ 堆裁溢出</span><br><span class="line"><span class="comment">//尾调用优化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fibonacci2</span> (n , acl = <span class="number">1</span> , ac2 = <span class="number">1</span>) {</span><br><span class="line"><span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) {<span class="keyword">return</span> ac2} ;</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Fibonacci2</span> (n - <span class="number">1</span> , ac2, acl + ac2);</span><br><span class="line"><span class="title class_">Fibonacc</span> i2 (<span class="number">100</span>) <span class="comment">// 573147844013817200000</span></span><br><span class="line"><span class="title class_">Fibonacci2</span> (<span class="number">1</span> <span class="number">000</span>) <span class="comment">// 7. 0330367711422765e+208</span></span><br><span class="line"><span class="title class_">Fibonacci2</span>(<span class="number">10000</span>) <span class="comment">//Infinit</span></span><br></pre></td></tr></tbody></table></figure><h3 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h3><ul><li>在尾递归函数之外再提供一个正常形式的函数</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tailFactorial</span>(<span class="params">n, total</span>) {</span><br><span class="line">......</span><br><span class="line">}</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">tailFactorial</span>(n, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 ES6 的函数默认值</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) {</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">}</span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>); <span class="comment">//120</span></span><br></pre></td></tr></tbody></table></figure><p><strong>一旦使用递归 则最好使用尾递归</strong></p><p>ES2017 提议可以在最后一个参数后面加逗号 减少后期更改时的提交信息的冗余</p><h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = []; <span class="comment">//first:undefined ; rest: []</span></span><br></pre></td></tr></tbody></table></figure><p><strong>如果将扩展运算符用于数组赋值 则只能将其作为参数的最后一位</strong></p><p>任何<code>Iterator</code>接口的对象 都可以使用扩展运算符来转为真正的数组</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">var</span> array = [...nodeList];</span><br></pre></td></tr></tbody></table></figure><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>将两类对象转为真正的数组：类似数组的对象（<code>array-like object</code>）和可遍历(<code>iterable</code>)对象</p><p><code>Array.from</code>的第二个参数类似于<code>map</code>方法 将每个元素处理后放入返回的数组</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr)); <span class="comment">//数组去重</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(string).<span class="property">length</span>; <span class="comment">//将字符串转换为数组并返回字符串的长度 避免特殊字符算作两个字符的bug</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>将一组值转换为数组</p><h2 id="copyWithin（）"><a href="#copyWithin（）" class="headerlink" title="copyWithin（）"></a>copyWithin（）</h2><p>在当前数组内部将指定位置的成员复制到其他位置（会覆盖原有裁员） 然后返回数组 即这个方法会修改当前数组</p><p><code>Array.prototype.copyWithin(target, start = 0, end = this.length)</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将3号位复制到0号位</span></span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span>, <span class="number">5</span>) . copyWi thin ( <span class="number">0</span> , <span class="number">3</span> , <span class="number">4</span>) <span class="comment">//[4,2,3,4,5]</span></span><br></pre></td></tr></tbody></table></figure><h2 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find()和 findIndex()"></a>find()和 findIndex()</h2><p>找到符合条件值以及对应的索引</p><h2 id="fill（）"><a href="#fill（）" class="headerlink" title="fill（）"></a>fill（）</h2><p>使用一个定制填充一个数组</p><h2 id="entries（）、keys（）、values（）"><a href="#entries（）、keys（）、values（）" class="headerlink" title="entries（）、keys（）、values（）"></a>entries（）、keys（）、values（）</h2><h2 id="includes（）"><a href="#includes（）" class="headerlink" title="includes（）"></a>includes（）</h2><ul><li><code>Map</code>结构的<code>has</code>方法是用来查找键名的</li><li><code>Set</code>结构的<code>has</code>方法是用来查找值的</li></ul><h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><blockquote><p>空位不是 undefined 一个位置的值等于 undefined 依然是有值的 空位是没有任何值的 in 运算符可以说明这点</p></blockquote><p>ES6 规定将空位转为<code>undefined</code></p><h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>与全等运算符差不多 但是<code>NaN</code>等于<code>NaN +0 ！= -0</code></p><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>将源对象的所有可枚举属性复制到目标对象</p><blockquote><p>如果目标对象和源对象有同名属性或者多个源有同名属性 则后面的属性会覆盖前面的属性</p></blockquote><p>如果只有一个参数 则<code>Object.assign</code>直接返回参数 如果该参数不是对象 则先转成<strong>对象</strong>再返回 如果是<code>null</code>或者 undefined 则报错</p><p>源对象（非首参数）位置的参数会先转成对象 不能则跳过 粗了字符串会以数组的形式复制到目标对象 其他值不会产生效果</p><p><strong><code>Object.assign</code>复制的属性是有限的 只复制源对象的自身属性（不复制继承属性） 也不复制不可枚举的属性</strong></p><p><strong><code>Object.assign</code>是浅复制 不是深复制</strong></p><p>对于嵌套的对象 一旦遇到同名属性 <code>Object.assign</code>的处理方法是<strong>替换</strong>而不是添加</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = { <span class="attr">a</span>: { <span class="attr">b</span>: <span class="string">"c"</span>, <span class="attr">d</span>: <span class="string">"e"</span> } };</span><br><span class="line"><span class="keyword">var</span> source = { <span class="attr">a</span>: { <span class="attr">b</span>: <span class="string">"hello"</span> } };</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source); <span class="comment">//{a: {b: 'hello'}}</span></span><br></pre></td></tr></tbody></table></figure><p>Object.assign 可以用来处理数组 但是会把数组当作对象来处理</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>为对象添加属性</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">x, y</span>) {</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, {x, y) );</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>为对象添加方法</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span> . assign (<span class="title class_">SomeClass</span> . prototype , {</span><br><span class="line">someMethod (argl , arg2) {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>克隆对象</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>({} , origin);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将原始对象赋值到一个新的对象 只能克隆自身的值 不能克隆继承的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) {</span><br><span class="line"><span class="keyword">let</span> originProto = <span class="title class_">Object</span> . getPrototypeOf（ ori gin );</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Object</span> . <span class="title function_">create</span>(originProto) , origin );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>合并多个对象</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> = (<span class="params">target, ...source</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...source)</span><br><span class="line"><span class="comment">//如果希望合并后返回一个新对象 可以对一个空对象合并</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> = (<span class="params">...source</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>({}, ...source);</span><br><span class="line"><span class="keyword">const</span> data1 = {<span class="attr">name</span>: <span class="string">'james'</span>};</span><br><span class="line"><span class="keyword">const</span> data2 = <span class="title function_">merge</span>(data1);</span><br><span class="line">data2.<span class="property">name</span> = <span class="string">'curry'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data1.<span class="property">name</span>):<span class="comment">//'james';//深复制</span></span><br></pre></td></tr></tbody></table></figure><ul><li>为属性指定默认值</li></ul><blockquote><p>由于存在深复制的问题 DEFAULTS 对象和 options 对象的所有属性都只能是简单类型 而不能指向另一个对象 否则将导致 DEFAULTS 对象该属性不起作用</p></blockquote><h2 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h2><ul><li><p><code>for...in</code></p><ul><li>遍历对象自身和继承的可枚举属性（不含<code>Symbol</code>属性）</li></ul></li><li><p><code>Object.keys(obj)</code></p><ul><li>返回一个包含自身（不包含<code>Symbo</code>l 以及继承）的可枚举属性</li></ul></li><li><p><code>Object.getOwnPropertyNames(obj)</code></p><ul><li>包含自身（不包含<code>Symbol</code>但是包含不可枚举属性）的数组</li></ul></li><li><p><code>Object.getOwnPropertySymbols(obj)</code></p><ul><li>包含自身的所有<code>Symbol</code>属性</li></ul></li><li><p><code>Reflect.ownKeys(obj)</code></p><ul><li>包含自身的所有属性</li></ul></li></ul><p>遍历规则</p><ul><li>首先遍历所有属性名为数值的属性 按照数字排序</li><li>其次遍历所有属性名为字符串的属性 按照生成时间遍历</li><li>最后遍历所有属性名为<code>Symbo</code>l 的属性 按照生成时间排序</li></ul><h2 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h2><p>设置一个对象的<code>prototype</code>对象 返回参数本身</p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p>读取一个对象的<code>prototype</code>对象</p><p>如果参数不是对象 则自动转换为对象 如果是<code>undefined</code>或<code>null</code> 则直接报错</p><h2 id="Objecr-keys-Object-values-Object-entries"><a href="#Objecr-keys-Object-values-Object-entries" class="headerlink" title="Objecr.keys() Object.values() Object.entries()"></a>Objecr.keys() Object.values() Object.entries()</h2><ul><li><p>O<code>bject.keys()</code>:包含自身（不包含继承）的所有可遍历属性</p></li><li><p><code>Object.values()</code>:如果参数不是对象 则会先将其转为对象 对于数值或者布尔值则返回空数组</p></li><li><p><code>Object.entries()</code>:输出非<code>Symbol</code>值的属性</p><ul><li>‘可以将对象转为真正的<code>Map</code>结构</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = { <span class="attr">foo</span>: <span class="string">"bar"</span>, <span class="attr">baz</span>: <span class="number">40</span> };</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br><span class="line">map; <span class="comment">//{foo: 'bar', baz: 40}</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h2><blockquote><p>解构赋值的复制是浅复制 即如果一个键的值是复合类型的值（数组、对象、函数） 那么解构赋值复制的是这个值的引用 而不是这个值的副本</p></blockquote><p>解构赋值不会复制继承自原型对象的属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//克隆完整对象</span></span><br><span class="line"><span class="keyword">const</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj)), obj);</span><br><span class="line"><span class="comment">//修改现有对象</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>Object.assign</code>总是复制一个属性的值 而不会复制它背后的赋值方法或取值方法</p></blockquote><p><code>Object.getOwnPropertyDescriptions</code>配合<code>Object.defineProperties</code>可以实现正确复制</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = {</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">value</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> target2 = {};</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(target2, <span class="title class_">Objecxt</span>.<span class="title function_">getOwnPropertyDescriptions</span>(source));</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptiontor</span>(target2, <span class="string">"fpp"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="Null-传到运算符（？"><a href="#Null-传到运算符（？" class="headerlink" title="Null 传到运算符（？.)"></a>Null 传到运算符（<code>？.</code>)</h2><p>相当于判空操作</p><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><blockquote><p><code>Symbol</code>函数不能使用 new 命令 否则会报错 因为<code>Symbol</code>是一个原始类型的值 不是对象 所以不能添加属性 是一种类似于字符串的数据类型</p><p><code>Symbol</code>函数的参数只表示对当前<code>Symbol</code>值的描述 因此相同参数的<code>Symbol</code>函数的返回值是不相等的</p></blockquote><p><code>Symbol</code>值不能与其他值进行比较 否则会报错 <code>Symbol</code>值可以转为字符串或者布尔值 但是不能转为数值</p><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><p><code>Symbol</code>值可以作为标识符用于对象的属性名 复制某一个键不小心被重写或者覆盖</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> data = {</span><br><span class="line">  [mySymbol]: <span class="string">"james"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="comment">//Symbol作为对象属性名时不能使用点运算符 因为点运算符后面总是字符串 所以不会读取mySymbol作为标识名所指代的值 导致a的属性名实际上时一个字符串 而不是一个Symbol值</span></span><br><span class="line">data.<span class="property">mySymbol</span>; <span class="comment">//undefined</span></span><br><span class="line">data[mySymbol]; <span class="comment">//james</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>Symbol</code>值作为属性名时 该属性还是<strong>公开</strong>属性 不是<strong>私有</strong>属性</p></blockquote><p>常量使用 Symbol 值的最大好处就是其他任何值不可能有相同的值了 因此可以保证 switch 语句按设计的方式工作</p><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><h3 id="消除魔法字符串"><a href="#消除魔法字符串" class="headerlink" title="消除魔法字符串"></a>消除魔法字符串</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = {</span><br><span class="line">  <span class="attr">triangle</span>: <span class="title class_">Symbol</span>(),</span><br><span class="line">};</span><br><span class="line"><span class="comment">//将多次出现的和代码耦合度高的字符串设置成Symbol降低耦合度</span></span><br></pre></td></tr></tbody></table></figure><h3 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h3><p><code>Symbol</code>作为属性名 不会被<code>for...in for...of</code> 以及<code>Object.keys() Object.getOwnPropertyNames()</code>返回 但是<strong>不是私有属性</strong> 可以使用<code>Object.getOwnPropertySymbols</code>获取对象的所有<code>Symbol</code>属性名</p><p><code>Reflect.owbKeys()</code>可以返回所有的类型的键名 包括常规键名和 Symbol 键名</p><blockquote><p>以<code>Symbol</code>值作为名称的属性不会被常规方法遍历得到 可以用这个特性为对象定义一些非私有但又希望只用于内部的方法</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> size = <span class="title class_">Symbol</span>(<span class="string">"size"</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">this</span>[size] = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">item</span>) {</span><br><span class="line">    <span class="variable language_">this</span>[<span class="variable language_">this</span>[size]] = item;</span><br><span class="line">    <span class="variable language_">this</span>[size]++;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sizeOf</span>(<span class="params">instance</span>) {</span><br><span class="line">    <span class="keyword">return</span> instance[size];</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Collection</span>();</span><br><span class="line"><span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x); <span class="comment">//0</span></span><br><span class="line">x.<span class="title function_">add</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x); <span class="comment">//1</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(x); <span class="comment">//['0']</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(x); <span class="comment">//['0']</span></span><br><span class="line"><span class="comment">//size属性是一个Symbol值 所以Objct.keys(x)都无法获取它 这就造成了一种非私有的内部方法的效果</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Symbol-for-Symbol-keyFor"><a href="#Symbol-for-Symbol-keyFor" class="headerlink" title="Symbol.for() Symbol.keyFor()"></a>Symbol.for() Symbol.keyFor()</h2><p>接收一个字符串作为参数 然后搜索有没有以该参数作为名称的<code>Symbol</code> 有就返回这个<code>Symbol</code>值 没有就新建一个以该字符串为名称的<code>Symbol</code>值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">"foo"</span>);</span><br><span class="line">s1 === s2; <span class="comment">//true</span></span><br><span class="line"><span class="comment">//Symbol.for()与Symbol（）这两种方法都会生成新的Symbol 前者会被登记在全局环境中供搜索 后者不会</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s1); <span class="comment">//foo</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="title class_">Symobl</span>.<span class="title function_">keyFor</span>(s2); <span class="comment">//undefined</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>Symbol.for</code>为<code>Symbol</code>值登记的名字是全局环境的 可以在不同的<code>iframe</code>或<code>service worker</code>中取到同一个值</p></blockquote><h3 id="模块的-Singleton-模式"><a href="#模块的-Singleton-模式" class="headerlink" title="模块的 Singleton 模式"></a>模块的 Singleton 模式</h3><p>Singleton 模式指的是 调用一个类并且在任何时候都返回同一个实例</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mod.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FOO_KEY</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">"hello"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>]) {</span><br><span class="line">  <span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>] = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">}</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>];</span><br><span class="line"><span class="comment">//可以保证globl[FOO_KEY]不会被无意间覆盖 但是还可以被改写</span></span><br></pre></td></tr></tbody></table></figure><h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><ul><li><code>Symbol.hasInstance</code></li></ul><p>使用<code>instanceof</code>运算符时会调用这个方法 判断该对象是否为某个构造函数的实例</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo <span class="keyword">instanceof</span> <span class="title class_">Foo</span> 实际上调用了<span class="title class_">Foo</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](foo)</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Symbol.isConcatSpreadable</code></li><li><code>Symbol.species</code></li><li><code>Symbol.match</code></li><li><code>Symbol.replace</code></li><li><code>Symbol.search</code></li><li><code>Symbol.split</code></li><li><code>Symbol.iterator</code></li><li><code>Symbol.toPrimitive</code></li><li><code>Symbol.toStringTag</code></li><li><code>Symbol.unscopables</code></li></ul><h1 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>Set</code>：一组不会重复的数组</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]; <span class="comment">//数组去重</span></span><br></pre></td></tr></tbody></table></figure><p>向<code>Set</code>加入值时不会发生类型转换 <code>Set</code>内部判断两个值是否相等时使用的算法类似于精确运算符 但是<code>NaN</code>等于自身 （<strong>两个对象总是不相等的</strong>）</p><blockquote><p><code>Set</code>的<strong>遍历顺序就是插入顺序</strong> 这个特性非常有用 比如使用<code>Set</code>保存一个回调函数列表 调用时能保证按照添加顺序调用</p></blockquote><h3 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h3><p>扩展运算符<code>(...)</code>内部使用<code>for...of</code>循环 也可以使用<code>Set</code>结构</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">"red"</span>, <span class="string">"blue"</span>]);</span><br><span class="line"><span class="keyword">let</span> arr = [...set];</span><br><span class="line"><span class="comment">//扩展运算符和Set结构相结合就能去除数组的重复裁员</span></span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"><span class="comment">//数组的map和fillter方法也可以用于Set</span></span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">fillter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line"><span class="comment">//所以set很用以实现并集、焦急和差集</span></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">fillter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="keyword">let</span> defference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">fillter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> !b.<span class="title function_">has</span>(x)));</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无法直接在遍历操作中同步改变Set结构 一种是利用原Set映射出一个新的结构 然后赋值给原来的Set结构 另一种是利用Array.from方法</span></span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(set, <span class="function">(<span class="params">val</span>) =&gt;</span> val * <span class="number">2</span>));</span><br></pre></td></tr></tbody></table></figure><h3 id="WaekSet"><a href="#WaekSet" class="headerlink" title="WaekSet"></a>WaekSet</h3><ul><li><code>WeakSet</code>的成员只能是对象 而不能是其他类型的值</li><li><code>WeakSet</code>中的对象都是弱引用 即垃圾回收机制不考虑<code>WeakSet</code>对该对象的引用（如果其他对象不再引用该对象 那么垃圾回收机制就会自动回收该对象所占用的内存 不考虑是否还存在于<code>WeakSet</code>中）</li><li><code>WeakSet</code>不能<strong>遍历</strong> 因为成员都是弱引用 随时可能消失 遍历机制无法保证成员存在 很可能刚刚遍历结束 成员就获取不到了</li></ul><blockquote><p><code>WeakSet</code>的一个用处是储存 DOM 节点 而不用担心这些节点从文档移除时会语法内存泄漏</p></blockquote><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><code>Map</code>的键可以是任何数据类型</li><li><code>Map</code>的键实际上适合内存绑定的 只要内存不一样 就视为两个键 这就解决了同名属性的问题 我们扩展别人的库是 如果使用对象作为键名 不 i 用担心自己的属性和原作者的属性同名</li></ul><blockquote><p>只有对<strong>同一对象的引用</strong> <code>Map</code>结构才将其视为同一个键</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>([<span class="string">"a"</span>], <span class="number">555</span>);</span><br><span class="line">map.<span class="title function_">get</span>([<span class="string">"a"</span>]); <span class="comment">//undefined</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果Map的键是一个简单类型的值（数字、字符串、布尔值） 只要两个值严格相等 Map就将其视为一个键 将NaN视为一个键</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="title class_">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="title class_">NaN</span>); <span class="comment">//123</span></span><br></pre></td></tr></tbody></table></figure><p><strong><code>Map</code>的遍历顺序就是插入顺序</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map转为JSON</span></span><br><span class="line"><span class="comment">//键名都是字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToJson</span>(<span class="params">strMap</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">strMapToJson</span>(strMap));</span><br><span class="line">}</span><br><span class="line"><span class="comment">//Map键名有非字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapToArrayJson</span>(<span class="params">map</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...map]);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//JSON转为Map</span></span><br><span class="line"><span class="comment">//正常情况下 所有键名都是字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToStrMap</span>(<span class="params">jsonStr</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">objToStrMap</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">}</span><br><span class="line"><span class="comment">//JSON就是一个数组 且每个成员本身又是一个具有两个成员的数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToMap</span>(<span class="params">jsonStr</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>如果想要往对象中添加数据又不想干扰垃圾回收机制 便可以使用<code>WeakMap</code> 比如在网页的<code>DOM</code>元素上添加数据时就可以用<code>WeakMap</code>结构 当该<code>DOM</code>元素被清除时 其对应的<code>WeakMap</code>记录就会自动清除</p><blockquote><p><code>WeakMap</code>弱引用的只是键名而不是键值 键值依然是正常引用的</p></blockquote><p>将监听函数反正该<code>WeakMap</code>里面 一旦<code>DOM</code>对象消失 与它绑定的函数也会自动消失</p><p><code>WeakMap</code>也可以用来部署私有属性</p><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><blockquote><p>要使<code>Proxy</code>起作用 必须针对<code>Proxy</code>实例进行操作 而不是针对目标对象进行操作</p></blockquote><p><code>Proxy</code>实例也可以作为其他对象的原型对象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">  {},</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, property</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line">);</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line">obj.<span class="property">time</span>; <span class="comment">//35</span></span><br><span class="line"><span class="comment">//proxy对象是obj对象的原型 obj对象本身没有time属性 所以根据原型链会在proxy对象上读取该属性 导致被拦截</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>get(target, propKey, receiver):</code>拦截对象属性的读取</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get方法可以继承</span></span><br><span class="line"><span class="keyword">let</span> proto = <span class="keyword">new</span> <span class="title class_">Proxy</span> ( { } , {</span><br><span class="line"><span class="title function_">get</span>(<span class="params">target, propertyKey , receiver</span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span> ( ’ <span class="variable constant_">GET</span> ’+propertyKey);</span><br><span class="line"><span class="keyword">return</span> target[propertyKey] ;</span><br><span class="line">.</span><br><span class="line">, } )</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto) ;</span><br><span class="line">obj.<span class="property">xxx</span> <span class="variable constant_">II</span> ” <span class="variable constant_">GET</span> xxx ”</span><br><span class="line"><span class="comment">//拦截操作定义在Propertype对象上 所以如果读取obj对象继承的属性 拦截会生效</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>set(target, propKey, value, receiver</code>):拦截的对象属性的设置</li></ul><p>如果一个属性不可配置或不可写 则该属性不能被代理 通过<code>Proxy</code>对象访问该属性将会报错</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有时候 我们会在对象上设置内部属性 属性名的第一个字符使用下划线开头 表示这些属性不应该被外部使用 结合get和set方法可以防止这些内部属性被外部读/写</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">invariant</span> = (<span class="params">key, action</span>) =&gt; {</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">"_"</span>) {</span><br><span class="line">    <span class="comment">//读取属性的第一个字符判断是否为内部属性</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">${action}</span>的属性<span class="subst">${key}</span>是内部的`</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) {</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">"get"</span>);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) {</span><br><span class="line">    <span class="title function_">invariant</span>(prop, <span class="string">"set"</span>);</span><br><span class="line">    target[prop] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果目标对象自身的某个属性不可写也不可配置 那么 set 不得改变这个属性的值 只能返回同样的值 否则报错</p></blockquote><ul><li><code>has(target, propKey):</code>拦截<code>propKey in proxy</code>的操作</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用has方法隐藏了某些属性 使其不被in运算符发现</span></span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"><span class="title function_">has</span>(<span class="params">target, key</span>) {</span><br><span class="line"><span class="keyword">if</span>(key[<span class="number">0</span>] === <span class="string">'_'</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> key <span class="keyword">in</span> target</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> target = { prop : ’ foo ’, prop :’foo ’ };</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target , handler);</span><br><span class="line">’ _prop ’ <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p>如果原对象不可配置或禁止扩展 那么<code>has</code>拦截会报错</p><blockquote><p><code>has</code> 方法拦截的是 <code>Has Property</code> 操作，而不是 <code>HasOwnProperty</code> 操作，即 <code>has</code> 方法 不判断一个属性是对象自身的属性还是继承的属性 对<code>for...in</code>不生效</p></blockquote><ul><li><code>deleteProperty(target, propKey)</code>:拦截<code>delete proxy[propKey</code>]的操作</li><li><code>ownKeys(target)</code>:拦截<code>Object.getOwnPropertyNames(proxy) Object.getOwnPropertySymbols(proxy) Object.keys(proxy)</code> 返回一个数组 该方法返回目标对象自身属性的属性名 而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性</li><li><code>getOwnPropertyDescriptor(target, propKey)</code>:拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code></li><li><code>defineProperty(target, propKey, propDesc):</code>拦截 <code>Object defineProperty(proxy propKey,</code> <code>propDesc 〕、 Object define Properties(proxy, propDescs)</code></li><li><code>preventExtensions(target):</code>拦截 <code>Object preventExtensions proxy</code></li><li><code>getPrototypeOf(target)</code></li><li><code>isExtensible(target)</code></li><li><code>setPrototypeOf(target, proto)</code> :拦截 <code>Object setPrototypeOf proxy proto ）</code>， 返回一个布尔值。 果目标对象是 函数 那么还有两 操作可以拦截。</li><li><code>apply(target, object, args)</code></li></ul><p><code>apply</code>方法拦截函数的调用<code>/call/apply</code>操作(直接调用<code>Reflect.apply</code>方法也会被拦截)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个参数 目标对象 目标对象的上下文对象 目标对象的参数数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">target</span> = (<span class="params"></span>) =&gt; {</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"i am the target"</span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"i am the proxy"</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="title function_">p</span>(); <span class="comment">// i am the proxy</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>construct( target, args)</code>:拦截 <code>Proxy</code> 实例作为构造函数调用的操作 ，比 <code>ηew proxy ( . . . arg)</code></li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target：目标对象 args：构建函数的参数对象</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params"></span>) {}, {</span><br><span class="line">    <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'call'</span> + args.<span class="title function_">join</span>(<span class="string">','</span>));</span><br><span class="line">        <span class="keyword">return</span> {<span class="attr">value</span>: args[<span class="number">0</span>]*<span class="number">10</span>}</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line">(<span class="keyword">new</span> <span class="title function_">p</span>(<span class="number">1</span>)).<span class="property">value</span>;<span class="comment">//10</span></span><br><span class="line"><span class="comment">//construct方法返回的必须是一个对象 否则会报错</span></span><br></pre></td></tr></tbody></table></figure><h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>在<code>Proxy</code>代理的情况下 目标对象内部的<code>this</code>关键字会指向<code>Proxy</code>代理</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === proxy);</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">target.<span class="title function_">m</span>(); <span class="comment">//false</span></span><br><span class="line">proxy.<span class="title function_">m</span>(); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//target内部的this也指向proxy 而不是target</span></span><br></pre></td></tr></tbody></table></figure><p>有些元素对象的内部属性只有通过正确的<code>this</code>才能获取 所以<code>Proxy</code>也无法代理这些原生对象的属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="title function_">getDate</span>();<span class="comment">//TypeError: this is not a Data object</span></span><br><span class="line"><span class="comment">//这个时候绑定bind就能解决问题</span></span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span> (’ <span class="number">2015</span>-<span class="number">01</span>-<span class="number">0</span> <span class="number">1</span> ’) ;</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"><span class="title function_">get</span>(<span class="params">target, prop</span>) {</span><br><span class="line"><span class="keyword">if</span> (p rop === ’ get <span class="title class_">Date</span> ’) {</span><br><span class="line"><span class="keyword">return</span> target . getDate .<span class="title function_">bind</span>(target) ;</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Reflect</span> . <span class="title function_">get</span>(target, prop);</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="title function_">getDate</span>()<span class="comment">//1</span></span><br></pre></td></tr></tbody></table></figure><h3 id="实例：web-服务的客户端"><a href="#实例：web-服务的客户端" class="headerlink" title="实例：web 服务的客户端"></a>实例：web 服务的客户端</h3><p><code>Proxy</code>对象可以拦截目标对象的任意属性 所以它很适合编写 Web 服务的客户端</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> service = createWebSer rice (’ <span class="attr">http</span>:<span class="comment">//example . com/data ’);</span></span><br><span class="line">service . <span class="title function_">employees</span>() . <span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> {</span><br><span class="line"><span class="keyword">const</span> employees= <span class="title class_">JSON</span> . <span class="title function_">parse</span>(json) ;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">}) ;</span><br><span class="line"><span class="comment">//proxy可以拦截这个对象的任意属性 所以不用为每一种数据写一个适配方法 只要写一个proxy拦截即可</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWebService</span>(<span class="params">baseurl</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>({}, {</span><br><span class="line"><span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">httpGet</span>(baseUrl + <span class="string">'/'</span> + propKey)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Proxy</code>还可以用来实现数据库的<strong>ORM</strong>层</p><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><ul><li>将<code>Object</code>对象的一些明显属于语言内部的方法（<code>Object.defineProperty</code>）放到<code>Reflect</code>对象上</li><li>修改某些<code>Object</code>方法的返回结果 让其变得合理</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧写法</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, property, attributes);</span><br><span class="line">} <span class="keyword">catch</span> (e) {</span><br><span class="line">  <span class="comment">//failure</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, property, attributes)) {</span><br><span class="line">  <span class="comment">//success</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">//failure</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>让<code>object</code>操作编程函数行为</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧写法</span></span><br><span class="line"><span class="string">"assign"</span> <span class="keyword">in</span> <span class="title class_">Object</span>; <span class="comment">//true</span></span><br><span class="line"><span class="comment">//新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(<span class="title class_">Object</span>, <span class="string">"assign"</span>); <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就 能在 <code>Reflect</code> 对象上找到对应的方法。这就使 <code>Proxy</code> 对象可以方便地调用对应的 <code>Reflect</code> 方法来完成默认行为，作为修改行为的基础。也就是说，无论 <code>Proxy</code> 怎么修改默认行为，我们 总可以在 <code>Reflect</code> 上获取默认行为。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Proxy</span>(target, {</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, name, value, receiver</span>) {</span><br><span class="line">    <span class="keyword">const</span> success = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, name, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (success) {</span><br><span class="line">      <span class="comment">//;;;;;;;</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="comment">//Proxy拦截了target对象的属性赋值方法 他采用Reflect.set方法将之际赋给对象的属性 保证原有的行为 然后再部署额外的功能</span></span><br><span class="line"><span class="keyword">var</span> loggedobj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, name</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"get"</span>, target, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, name);</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, name</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"delete"</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, name);</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, name</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"has"</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, name);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="comment">//每个proxy对象的拦截操作都内部调用了Reflect对应的方法 保证原生行为能够正常运行 添加的工作就是将每一个操作输出一行日志</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.lxtlovely.top/XUXI/image-20220505222048711.png" alt="image-20220505222048711"></p><h2 id="使用-Proxy-实现观察者模式"><a href="#使用-Proxy-实现观察者模式" class="headerlink" title="使用 Proxy 实现观察者模式"></a>使用 Proxy 实现观察者模式</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="title class_">Set</span>(); <span class="comment">//观察者函数容器</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">set</span> = (<span class="params">target, key, value, receiver</span>) =&gt; {</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver); <span class="comment">//执行正常set操作</span></span><br><span class="line">  queuedObservers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> <span class="title function_">observer</span>()); <span class="comment">//执行观察者容器里所有观察者</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observe</span> = (<span class="params">fn</span>) =&gt; queuedObservers.<span class="title function_">add</span>(fn); <span class="comment">//加入观察者容器</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observable</span> = (<span class="params">obj</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, { set }); <span class="comment">//设置拦截器</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="title function_">observable</span>({</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">print</span> = (<span class="params"></span>) =&gt; {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"dsqdqdqdsqd"</span>);</span><br><span class="line">};</span><br><span class="line"><span class="title function_">observe</span>(print);</span><br><span class="line">person.<span class="property">name</span> = <span class="string">"curry"</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul><li>对象的状态不受外界影响</li><li>一旦状态改变就不会再变 任何时候都可以得到这个结果</li><li>无法取消<code>Promise</code> 一旦新建就会立即执行 无法中途取消</li><li>如果不设置回调函数 <code>Promise</code>内部抛出的错误不会反映到外部</li><li>处于<code>Pendding</code>状态时 无法得知目前进展到哪一阶段</li><li>如果某些事件不断重复发生 使用<code>Stream</code>模式更好</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise新建后会立即执行</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Promise"</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">});</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Resolved"</span>);</span><br><span class="line">});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"HI"</span>); <span class="comment">//Promise HI Resolved</span></span><br><span class="line"><span class="comment">//Promise新建后立即执行 然后then指定的回调函数会在当前脚本所有同步任务执行完成后才执行 所以resolved最后输出</span></span><br></pre></td></tr></tbody></table></figure><p>调用<code>resolve</code>或<code>reject</code>并不会终结<code>Promise</code>的参数函数的执行</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">}).<span class="title function_">then</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(r)); <span class="comment">//2 --&gt; 1</span></span><br><span class="line"><span class="comment">//立即resolved的Promise是在本轮事件循环的末尾执行 总是晚于本轮循环的同步任务 一般应该再resolve和reject前面加上return 防止后续还有操作</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve , reject</span>) {</span><br><span class="line">resolve (’ ok ’) ;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span> ( ’ test ’);</span><br><span class="line">.</span><br><span class="line">, } )</span><br><span class="line">promise</span><br><span class="line">.<span class="property">then</span> (<span class="keyword">function</span>(<span class="params">value</span>) { <span class="variable language_">console</span>.<span class="title function_">log</span>(value) })</span><br><span class="line">. <span class="keyword">catch</span> (<span class="keyword">function</span> (<span class="params">error</span>) { <span class="variable language_">console</span> . log (error) } ) ;</span><br><span class="line"><span class="number">11</span> ok</span><br><span class="line"><span class="comment">//Promise再resolve语句后面再抛出错误 并不会被捕获 等于没有抛出 因为Promise的状态一旦改变 就会永久保持该状态 不会再改变了</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>Promise</code>对象的错误具有<strong>冒泡</strong>性质 会一直向后传递知道被捕获为止 即错误总会被下一个<code>catch</code>捕获</p><p>不要再 then 中定义<code>reject</code>状态的回调函数 而应该总是使用<code>catch</code>方法</p><p><strong>如果没有指定 catch 方法指定错误处理的回调函数 Promise 对象抛出的错误不会被传递到外层代码 即不会有任何反应</strong></p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学JS2.0</title>
      <link href="/2022/04/25/chong-xue-js-di-er-tian/"/>
      <url>/2022/04/25/chong-xue-js-di-er-tian/</url>
      
        <content type="html"><![CDATA[<h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p><code>Object.assign()</code>接收一个目标对象和一个或多个元对象作为参数 然后将每个原对象中可枚举（<code>Object.propertyIsEnumerable()</code>返回 true）和自有（<code>Object.hasOwnProperty()</code>返回 true）属性复制到目标对象以字符串和符号为键的属性 会被复制。对每个符合条件的属性，这个方法会使用源对象上的<code>[[Get]]</code>取得属性的值，然后使用目标 对象上的<code>[[Set]]</code>设置属性的值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = { <span class="attr">id</span>: <span class="string">"src"</span> };</span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// Object.assign 修改目标对象</span></span><br><span class="line"><span class="comment">// 也会返回修改后的目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest === result); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest !== src); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// { id: src }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { id: src }</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dest = {</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">val</span>) {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Invoked dest setter with param <span class="subst">${val}</span>`</span>);</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">src = {</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">a</span>() {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Invoked src getter'</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 调用 src 的获取方法</span></span><br><span class="line"><span class="comment">// 调用 dest 的设置方法并传入参数"foo"</span></span><br><span class="line"><span class="comment">// 因为这里的设置函数不执行赋值操作</span></span><br><span class="line"><span class="comment">// 所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// Invoked src getter"</span></span><br><span class="line"><span class="string">"Invoked dest setter with param foo"</span> {}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = { <span class="attr">a</span>: {} };</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { a :{} }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest.<span class="property">a</span> === src.<span class="property">a</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest == src)<span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>assign()</code>是浅复制 意味着只会复制对象的引用</p></blockquote><p>如果赋值期间出错 操作会中止并退出 同时抛出错误 因此可能只完成部分复制</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = {</span><br><span class="line">  <span class="attr">a</span>: <span class="string">"foo"</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">b</span>() {</span><br><span class="line">    <span class="comment">// Object.assign()在调用这个获取函数时会抛出错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">c</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line">} <span class="keyword">catch</span> (e) {}</span><br><span class="line"><span class="comment">// Object.assign()没办法回滚已经完成的修改</span></span><br><span class="line"><span class="comment">// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { a: foo }</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>可计算属性表达式中抛出任何错误都会中断对象创建 如果计算属性的表达式有副作用就要小心 因为如果表达式抛出错误 那么之前完成的计算是不能回滚的</p></blockquote><p>解构并不要求变量必须在解构表达式中说明 不过 如果是事先声明的变量 则赋值表达式必须包含在一对括号中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personName, personAge;</span><br><span class="line"><span class="keyword">let</span> person = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"Matt"</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line">};</span><br><span class="line">({ <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge } = person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName, personAge); <span class="comment">// Matt, 27</span></span><br><span class="line"><span class="comment">//vue的写法</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>({</span><br><span class="line">  <span class="attr">name</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">0</span>,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> response = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"olddog"</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">}(({ <span class="attr">name</span>: data.<span class="property">name</span>, <span class="attr">age</span>: data.<span class="property">age</span> } = response)); <span class="comment">//data:{name: 'olddog', age: 23}</span></span><br></pre></td></tr></tbody></table></figure><h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><p>可以通过解构来复制对象属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = {</span><br><span class="line"> <span class="attr">name</span>: <span class="string">'Matt'</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line"> <span class="attr">job</span>: {</span><br><span class="line"> <span class="attr">title</span>: <span class="string">'Software engineer'</span></span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> personCopy = {};</span><br><span class="line">({</span><br><span class="line"> <span class="attr">name</span>: personCopy.<span class="property">name</span>,</span><br><span class="line"> <span class="attr">age</span>: personCopy.<span class="property">age</span>,</span><br><span class="line"> <span class="attr">job</span>: personCopy.<span class="property">job</span></span><br><span class="line">} = person);</span><br><span class="line"><span class="comment">// 因为一个对象的引用被赋值给 personCopy，所以修改</span></span><br><span class="line"><span class="comment">// person.job 对象的属性也会影响 personCopy</span></span><br><span class="line">person.<span class="property">job</span>.<span class="property">title</span> = <span class="string">'Hacker'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line"><span class="comment">// { name: 'Matt', age: 27, job: { title: 'Hacker' } }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personCopy);</span><br><span class="line"><span class="comment">// { name: 'Matt', age: 27, job: { title: 'Hacker' } }</span></span><br><span class="line">--------------------------------</span><br><span class="line">vue的写法</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>({</span><br><span class="line"><span class="attr">name</span>: <span class="string">''</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">address</span>:{</span><br><span class="line">  <span class="attr">home</span>:<span class="string">""</span></span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"><span class="keyword">const</span> response = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'olddogewqeeqwweq'</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="attr">address</span>:{</span><br><span class="line">    <span class="attr">home</span>: <span class="string">'huilaieqw1341343'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  ({<span class="attr">name</span>: data.<span class="property">name</span>, <span class="attr">age</span>: data.<span class="property">age</span>, <span class="attr">address</span>:{<span class="attr">home</span>: data.<span class="property">address</span>.<span class="property">home</span>}} = response)<span class="comment">//data:{name: 'olddog', age: 23}</span></span><br><span class="line">  response.<span class="property">name</span> = <span class="string">"wdqdw"</span></span><br><span class="line">  response.<span class="property">address</span>.<span class="property">home</span> = <span class="string">'2132'</span></span><br><span class="line">  data.<span class="property">address</span>.<span class="property">home</span> = <span class="string">'qdewqdeqsw'</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="comment">//改变response不会影响data</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><blockquote><p>涉及到多个属性的解构赋值是一个无关输出的顺序化操作 如果一个解构表达式涉及多个赋值 如果开始的赋值成功而后面的赋值出错 则整个赋值表达式只会完成一部分</p></blockquote><p><strong>Object.setPrototypeof()可能会严重影响代码性能</strong></p><p><code>hasOwnProprtty()</code>用于确定某个属性是实例上还是原型对象上（实例上返回<code>true</code>）</p><h5 id="原型和-in-操作符"><a href="#原型和-in-操作符" class="headerlink" title="原型和 in 操作符"></a>原型和 in 操作符</h5><p>单独使用<code>in</code>只要可以访问到对象指定属性时返回<code>true</code> 无论是在实例上还是在原型上</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以同时使用hasOwnProperty()和in()操作符来确定某个属性是否存在于原型上</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasPrototypePrototy</span>(<span class="params">object, name</span>) {</span><br><span class="line">  <span class="keyword">return</span> !object.<span class="title function_">hasOwnProprtty</span>(name) &amp;&amp; name <span class="keyword">in</span> object;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) {}</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">"Software Engineer"</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(person, <span class="string">"name"</span>)); <span class="comment">// true --对象在原型上</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">"Greg"</span>; <span class="comment">//重写name属性后 实例上也有这个属性了 即使原型上还有name属性 但是会被实例上的属性遮蔽 所以不会被用到</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(person, <span class="string">"name"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p><code>for-in</code>只要能通过对象访问到并且可以被枚举的属性都会返回 包括实例属性和原型属性（遮蔽原型中不可枚举的实例属性也会被返回 因为默认情况下开发者定义的属性都是可枚举的）</p><p>如果要获得对象上的所有可枚举实例属性 可以使用<code>Object.keys()</code> (返回包含该对象所有可枚举属性名称的字符串数组)</p><blockquote><p><code>Object.keys()</code> 和 <code>Object.getOwnPropertyNames()</code> 在适当的时候都可以用来代替<code>for- in</code> 循环</p></blockquote><h5 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h5><p><code>for-in、Object.keys()</code>的枚举顺序是不确定的 <code>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign()</code> 的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中 定义的键以它们逗号分隔的顺序插入。</p><h4 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h4><p><code>Object.values()</code>返回对象值的数组 <code>Object.entries()</code>返回键值对的数组</p><blockquote><p>这两个方法执行对象浅复制</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"james"</span>,</span><br><span class="line">  <span class="attr">address</span>: {</span><br><span class="line">    <span class="attr">home</span>: <span class="string">"sga"</span>,</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> per1 = <span class="title class_">Object</span>.<span class="title function_">values</span>(data)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> per2 = <span class="title class_">Object</span>.<span class="title function_">values</span>(data)[<span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1); <span class="comment">//james</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per2);</span><br><span class="line">{</span><br><span class="line">  <span class="attr">home</span>: <span class="string">"sga"</span>;</span><br><span class="line">}</span><br><span class="line">data.<span class="property">name</span> = <span class="string">"curry"</span>;</span><br><span class="line">data.<span class="property">address</span>.<span class="property">home</span> = <span class="string">"school"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1); <span class="comment">//james</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per2); <span class="comment">//school</span></span><br></pre></td></tr></tbody></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>使用<code>new</code>调用类的构造函数会执行以下操作</p><ol><li>在内存中创建一个新对象</li><li>在这个新对象内部的<code>[[Prototype]]</code>指针被复制为构造函数的<code>prototype</code>属性</li><li>构造函数内部的 this 被赋值为这个新对象（即<code>this</code>指向新对象）</li><li>执行构造函数内部的代码（给新对象添加属性）</li><li>如果构造函数返回非空对象 则返回该对象 否则 返回刚创建的新对象</li></ol><h1 id="代理和反射"><a href="#代理和反射" class="headerlink" title="代理和反射"></a>代理和反射</h1><p>在代理对象上执行的任何操作实际上都会应用到目标对象 唯一可以感知的不同就是代码中操作的是代理对象那个</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line"><span class="attr">id</span>: <span class="string">'target'</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> handler = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span> == proxy.<span class="property">id</span>)<span class="comment">//true; id属性会访问同一个值</span></span><br><span class="line">target.<span class="property">id</span> = <span class="string">'foo'</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span> == proxy.<span class="property">id</span>);<span class="comment">//true 给目标属性赋值会反映在两个对象上 因为两个对象访问的是同一个值</span></span><br><span class="line">proxy.<span class="property">id</span> = <span class="string">'bar'</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( target.<span class="property">id</span> == proxy.<span class="property">id</span>);<span class="comment">//true 给代理属性赋值会反映到两个对象上 因为这个赋值会转移到目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>);<span class="comment">//TypeError: Function has non-object prototype</span></span><br><span class="line"><span class="string">'undefined'</span> <span class="keyword">in</span> <span class="keyword">instanceof</span> check <span class="title class_">Proxy</span>.<span class="property"><span class="keyword">prototype</span></span>是<span class="literal">undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target == proxy)<span class="comment">//false 严格相等可以用来区分代理和目标</span></span><br></pre></td></tr></tbody></table></figure><h3 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h3><p>使用代理的主要目的是可以定义捕获器(trap)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个get捕获器 在调用get（）时触发</span></span><br><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="comment">//捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"handler override"</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></tbody></table></figure><h5 id="捕获器参数和反射-API"><a href="#捕获器参数和反射-API" class="headerlink" title="捕获器参数和反射 API"></a>捕获器参数和反射 API</h5><p>所有捕获器都可以访问相应的参数 基于这些参数可以重建被捕获方法的原始行为</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) {</span><br><span class="line">    <span class="keyword">return</span> trapTarget[property];</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></tbody></table></figure><p>可以调用全局<code>Reflect</code>对象上（封装了原始行为）的同名方法来轻松重建</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">'bar'</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"> <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"> }</span><br><span class="line"> <span class="comment">//简洁写法</span></span><br><span class="line"> <span class="attr">get</span>: <span class="title class_">Reflect</span>.<span class="property">get</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="comment">//反射API为开发者准备好了样板代码 在此基础上可以用最少的代码修改捕获的方法</span></span><br><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">'bar'</span>,</span><br><span class="line"> <span class="attr">baz</span>: <span class="string">'qux'</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"> <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) {</span><br><span class="line"> <span class="keyword">let</span> decoration = <span class="string">''</span>;</span><br><span class="line"> <span class="keyword">if</span> (property === <span class="string">'foo'</span>) {</span><br><span class="line"> decoration = <span class="string">'!!!'</span>;</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>) + decoration;</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar!!!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">baz</span>); <span class="comment">// qux</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">baz</span>); <span class="comment">// qux</span></span><br></pre></td></tr></tbody></table></figure><h4 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h4><p>捕获器应该遵守某些规范而不是出现过于反常的行为</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的</span><br><span class="line">值时，会抛出 <span class="title class_">TypeError</span>：</span><br><span class="line"><span class="keyword">const</span> target = {};</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">'foo'</span>, {</span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">value</span>: <span class="string">'bar'</span></span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"> <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line"> <span class="keyword">return</span> <span class="string">'qux'</span>;</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">//TypeError</span></span><br></pre></td></tr></tbody></table></figure><h5 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h5><p>使用<code>new Proxy()</code>创建的普通代理的联系在代理的生命周期内会一直持续纯在 可以使用<code>revocable()</code>来撤销代理对象和目标对象的联系 撤销时不可逆和幂等的（调用多少次都一样） 撤销后再调用代理就会抛出<code>TypeError</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//撤销函数和代理对象是在实例化时同时生成的</span></span><br><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"intercepted"</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> { proxy, revoke } = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// intercepted</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// TypeError</span></span><br></pre></td></tr></tbody></table></figure><h4 id="使用反射-API"><a href="#使用反射-API" class="headerlink" title="使用反射 API"></a>使用反射 API</h4><p>优先使用反射 API 的情况</p><p>Object 上的方法适用于通用程序 而反射方法适用于细粒度的对象控制与操作</p><h5 id="状态标记"><a href="#状态标记" class="headerlink" title="状态标记"></a>状态标记</h5><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始代码</span></span><br><span class="line"><span class="keyword">const</span> o = {};</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"success"</span>);</span><br><span class="line">} <span class="keyword">catch</span> (e) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"failure"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用反射方法重构</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(o, <span class="string">"foo"</span>, { <span class="attr">value</span>: <span class="string">"bar"</span> })) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"success"</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"failure"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以下反射方法都会提供状态标记：</p><ul><li><code>Reflect.defineProperty()</code></li><li><code>Reflect.preventExtensions()</code></li><li><code>Reflect.setPrototypeOf()</code></li><li><code>Reflect.set()</code></li><li><code>Reflect.deleteProperty(</code></li></ul><p>以下反射方法提供只有通过操作符才能完成的操作。</p><ul><li><code>Reflect.get()：</code>可以替代对象属性访问操作符</li><li><code>Reflect.set()</code>：可以替代=赋值操作符</li><li><code>Reflect.has()</code>：可以替代 in 操作符或 with()</li><li><code>Reflect.deleteProperty()</code>：可以替代 delete 操作符</li><li><code>Reflect.construct()</code>：可以替代 new 操作符</li></ul><p><strong>可以创建一个代理去代理另一个代理 这样就能在一个目标对象上构建多层拦截网</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> firstProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"first proxy"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> secondProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(firstProxy, {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"second proxy"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondProxy.<span class="property">foo</span>); <span class="comment">//second first bar</span></span><br></pre></td></tr></tbody></table></figure><h3 id="代理的问题与不足"><a href="#代理的问题与不足" class="headerlink" title="代理的问题与不足"></a>代理的问题与不足</h3><h5 id="代理中的-this"><a href="#代理中的-this" class="headerlink" title="代理中的 this"></a>代理中的 this</h5><p>如果目标对象依赖于对象标识 那么就可能出现问题</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入有一个weakMap</span></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">userId</span>) {</span><br><span class="line"> wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, userId);</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">id</span>(<span class="params">userId</span>) {</span><br><span class="line"> wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, userId);</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">id</span>() {</span><br><span class="line"> <span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">id</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">const</span> userInstanceProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, {});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInstanceProxy.<span class="property">id</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">//这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实</span></span><br><span class="line">例。要解决这个问题，就需要重新配置代理，把代理 <span class="title class_">User</span> 实例改为代理 <span class="title class_">User</span> 类本身。之后再创建代</span><br><span class="line">理的实例就会以代理实例作为 <span class="title class_">WeakMap</span> 的键了：</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserClassProxy</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, {});</span><br><span class="line"><span class="keyword">const</span> proxyUser = <span class="keyword">new</span> <span class="title class_">UserClassProxy</span>(<span class="number">456</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyUser.<span class="property">id</span>);</span><br></pre></td></tr></tbody></table></figure><h5 id="代理与内部槽位"><a href="#代理与内部槽位" class="headerlink" title="代理与内部槽位"></a>代理与内部槽位</h5><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//，Date 类型方法的执行依赖 this 值上的</span></span><br><span class="line">内部槽位[[<span class="title class_">NumberDate</span>]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通</span><br><span class="line">的 <span class="title function_">get</span>()和 <span class="title function_">set</span>()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 <span class="title class_">TypeError</span></span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, {});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy <span class="keyword">instanceof</span> <span class="title class_">Date</span>); <span class="comment">// true</span></span><br><span class="line">proxy.<span class="title function_">getDate</span>(); <span class="comment">// TypeError: 'this' is not a Date object</span></span><br></pre></td></tr></tbody></table></figure><h2 id="代理捕获器和反射方法"><a href="#代理捕获器和反射方法" class="headerlink" title="代理捕获器和反射方法"></a>代理捕获器和反射方法</h2><blockquote><p>对于代理对象上执行的任何一种操作 只会有一个捕获程序会被调用 不存在重复捕获的情况</p></blockquote><h3 id="get（）方法"><a href="#get（）方法" class="headerlink" title="get（）方法"></a>get（）方法</h3><p><code>get()</code>捕获器会在获取属性值的操作中被调用 对应的反射 API 为<code>Reflect.get()</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, {</span><br><span class="line"> <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'get()'</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line">proxy.<span class="property">foo</span>;</span><br><span class="line"><span class="comment">//拦截的操作</span></span><br><span class="line">proxy.<span class="property">property</span></span><br><span class="line">proxy[property]</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(proxy)[property]</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(proxy, property, receiver)</span><br><span class="line"><span class="comment">//捕获不变式</span></span><br><span class="line">如果target.<span class="property">property</span>不可写且不可配置 则处理程序返回的值必须与target.<span class="property">property</span>匹配</span><br><span class="line">如果target.<span class="property">property</span>不可配置且[[<span class="title class_">Get</span>]]特性为<span class="literal">undefined</span> 处理程序的返回值也必须是<span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><h3 id="set（）"><a href="#set（）" class="headerlink" title="set（）"></a>set（）</h3><p><code>set()</code>捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 <code>Reflect.set()。</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, {</span><br><span class="line"> <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'set()'</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">'bar'</span>;</span><br><span class="line"><span class="comment">// set()</span></span><br><span class="line"><span class="comment">//返回值：true 表示成功 false 表示失败</span></span><br><span class="line"><span class="comment">//拦截的操作</span></span><br><span class="line">proxy.<span class="property">property</span> = value;</span><br><span class="line">proxy[peoperty] = value;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(proxy)[property] = value</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(proxy, property, value, receiver)</span><br><span class="line"><span class="comment">//捕获器处理程序参数</span></span><br><span class="line"><span class="attr">target</span>: 目标对象</span><br><span class="line"><span class="attr">property</span>: 引用的目标对象上的字符串键属性</span><br><span class="line">value：要赋给属性的值</span><br><span class="line">receiver：接收最初赋值的对象</span><br><span class="line"><span class="comment">//捕获器不变式</span></span><br><span class="line">如果target.<span class="property">property</span>不可写且不可配置 则不修改目标属性的值</span><br><span class="line">如果target.<span class="property">property</span>不可配置且[[<span class="title class_">Set</span>]]特性为<span class="literal">undefined</span> 则不能修改目标属性的值</span><br><span class="line">在严格模式下 处理程序中返回<span class="literal">false</span>会抛出<span class="title class_">TypeError</span></span><br></pre></td></tr></tbody></table></figure><h3 id="has（）"><a href="#has（）" class="headerlink" title="has（）"></a>has（）</h3><p><code>has()</code>捕获器会在 in 操作符中被调用。对应的反射 API 方法为 <code>Reflect.has()。</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, {</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, property</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"has()"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="string">"foo"</span> <span class="keyword">in</span> proxy;</span><br><span class="line"><span class="comment">//返回值 必须返回布尔值 表示属性是否存在 返回非布尔值会被转型为布尔值</span></span><br><span class="line"><span class="comment">//捕获不变式：</span></span><br><span class="line"><span class="comment">//如果 target.property 存在且不可配置，则处理程序必须返回 true。</span></span><br><span class="line"><span class="comment">//如果 target.property 存在且目标对象不可扩展，则处理程序必须返回 true。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>apply()捕获器会在调用函数时被调用 对应的反射 api 方法为 Reflect.apply()</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myTarget</span> = (<span class="params"></span>) =&gt; {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, {</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">target, thisArg, ...argumentsList</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"apply()"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// apply()</span></span><br></pre></td></tr></tbody></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h4 id="跟踪属性访问（很重要）"><a href="#跟踪属性访问（很重要）" class="headerlink" title="跟踪属性访问（很重要）"></a><strong>跟踪属性访问</strong>（很重要）</h4><p>通过捕获<code>get set 和has</code>等操作 可以知道对象属性说明时候被使用 查询的那个 把实现相应捕获器的某个对象代理放到应用中 就可以检测这个对象何时在何处被访问过</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'Jack'</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, {</span><br><span class="line"><span class="title function_">get</span>(<span class="params">target, property, receiver</span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Getting ${property}'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">}</span><br><span class="line"><span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Setting ${property} = ${value}'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// Getting name</span></span><br><span class="line">proxy.<span class="property">age</span> = <span class="number">27</span>; <span class="comment">// Setting age=27</span></span><br></pre></td></tr></tbody></table></figure><h4 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h4><p>代理的内部实现对外部代码是不可见的 因此可以用来隐藏目标对象上的属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">"foo"</span>, <span class="string">"bar"</span>];</span><br><span class="line"><span class="keyword">const</span> targetObject = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="number">3</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targetObject, {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property</span>) {</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, property</span>) {</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="comment">// get()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">bar</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">baz</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// has()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"foo"</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"bar"</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"baz"</span> <span class="keyword">in</span> proxy); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h4 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h4><p>因为所有的赋值操作都会触发<code>set（）</code>捕获器 所以可以根据所赋的值决定是允许还是拒绝赋值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">onlyNumbersGoHere</span>: <span class="number">0</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, {</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value</span>) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">"number"</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="string">"2"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><h4 id="函数与构造函数参数验证"><a href="#函数与构造函数参数验证" class="headerlink" title="函数与构造函数参数验证"></a>函数与构造函数参数验证</h4><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种 类型的值：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">median</span>(<span class="params">...nums</span>) {</span><br><span class="line"> <span class="keyword">return</span> nums.<span class="title function_">sort</span>()[<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>)];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(median, {</span><br><span class="line"> <span class="title function_">apply</span>(<span class="params">target, thisArg, argumentsList</span>) {</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> arg <span class="keyword">of</span> argumentsList) {</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'number'</span>) {</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">'Non-number argument provided'</span>;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">4</span>, <span class="string">'7'</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// Error: Non-number argument provided</span></span><br><span class="line">类似地，可以要求实例化时必须给构造函数传参：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">id</span>) {</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">id_</span> = id;</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, {</span><br><span class="line"> <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) {</span><br><span class="line"> <span class="keyword">if</span> (argumentsList[<span class="number">0</span>] === <span class="literal">undefined</span>) {</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">'User cannot be instantiated without id'</span>;</span><br><span class="line"> } <span class="keyword">else</span> {</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// Error: User cannot be instantiated without id</span></span><br></pre></td></tr></tbody></table></figure><h4 id="数据绑定和可观察对象"><a href="#数据绑定和可观察对象" class="headerlink" title="数据绑定和可观察对象"></a>数据绑定和可观察对象</h4><p>通过代理把运行中原本不相关的部分联系在一起 可以实现各种模式 从而让不同的代码互操作 比如 可以将代理的类绑定到一个全局实例集合 让所有创建的实例都被添加到这个集合中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name_</span> = name;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, {</span><br><span class="line">  <span class="title function_">construct</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> newUser = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    userList.<span class="title function_">push</span>(nreUser);</span><br><span class="line">    <span class="keyword">return</span> newUser;</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="string">"John"</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="string">"Jacob"</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="string">"Jingqdqdk"</span>);</span><br></pre></td></tr></tbody></table></figure><p>另外 还可以将集合绑定到一个事件分派程序 每次插入新实例都会发送消息</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">emit</span>(<span class="params">newValue</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(userList, {</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) {</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">      <span class="title function_">emit</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="string">"John"</span>);</span><br><span class="line"><span class="comment">// John</span></span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="string">"Jacob"</span>);</span><br><span class="line"><span class="comment">// Jacob</span></span><br></pre></td></tr></tbody></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote><p>ECMAScript 中的所有参数都按值传递 不可能按引用传递 如果把对象作为参数重载 那么传递的值就是这个对象的引用</p></blockquote><p>JavaScript 引擎在任何代码执行之前 会先读取函数声明 并在执行上下文中生成函数定义 而函数表达式必须等到代码执行到它的那一行 才会在执行上下文中生成函数定义。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) {</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//函数声明提升：函数声明会在任何代码执行之前被读取并添加到上下文中</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span> (<span class="params">num1, num2</span>) {</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//提升的是sum变量 而不是函数</span></span><br></pre></td></tr></tbody></table></figure><p><strong>从一个函数内部返回另一个函数也是可以的 而且非常重要</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">object1, object2</span>) {</span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) {</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">"Zachary"</span>, <span class="attr">age</span>: <span class="number">28</span> },</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">age</span>: <span class="number">29</span> },</span><br><span class="line">];</span><br><span class="line"><span class="comment">//可以根据不同的属性来进行不同的比较规则</span></span><br><span class="line">data.<span class="title function_">sort</span>(<span class="title function_">createComparisonFunction</span>(<span class="string">"name"</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="number">0</span>].<span class="property">name</span>); <span class="comment">// Nicholas</span></span><br><span class="line">data.<span class="title function_">sort</span>(<span class="title function_">createComparisonFunction</span>(<span class="string">"age"</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="number">0</span>].<span class="property">name</span>); <span class="comment">// Zachary</span></span><br></pre></td></tr></tbody></table></figure><p><strong>箭头函数中的<code>this</code>引用的是定义箭头函数的上下文</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">let</span> o = {</span><br><span class="line">  <span class="attr">color</span>: <span class="string">"blue"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sayColor</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">//red</span></span><br><span class="line">o.<span class="property">sayColor</span> = sayColor;</span><br><span class="line">o.<span class="title function_">sayColor</span>(); <span class="comment">//red</span></span><br><span class="line"><span class="comment">//因为this是在window上下文中定义的 所以引用的都是window对象</span></span><br><span class="line"><span class="comment">//函数名只是保存指针的变量 因此全局定义的sayColor和o.sayColor是同一个函数 只不过执行的上下文不同</span></span><br></pre></td></tr></tbody></table></figure><p>ES6 新增：<code>new.target</code>如果是使用<code>new</code>关键字调用的 则 n<code>ew.target</code>将引用被调用的构造函数 否则值是<code>undefined</code> 可以用来规定某个函数只能通过<code>new</code>来构建</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">King</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'King must be instantiated using "new"'</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'King instantiated using "new"'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">King</span>(); <span class="comment">// King instantiated using "new"</span></span><br><span class="line"><span class="title class_">King</span>(); <span class="comment">// Error: King must be instantiated using "new"</span></span><br></pre></td></tr></tbody></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>可以使用命名表达式来完成递归</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num) {</span><br><span class="line"> if (num &lt;= 1) {</span><br><span class="line"> return 1;</span><br><span class="line"> } else {</span><br><span class="line"> return num * factorial(num - 1);</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">let anotherFactorial = factorial; //将函数保存在anthorPactorial中</span><br><span class="line">factorial = null;</span><br><span class="line">console.log(anotherFactorial(4)); // 报错 递归调用factorial 但是factoprial已经不是函数了</span><br><span class="line">//可以使用命名函数来解决</span><br><span class="line">const factorial = (function f(num) {</span><br><span class="line"> if (num &lt;= 1) {</span><br><span class="line"> return 1;</span><br><span class="line"> } else {</span><br><span class="line"> return num * f(num - 1);</span><br><span class="line"> }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>ES6 新增了一想内存管理优化机制 让 js 引擎在满足条件时可以重用栈帧 非常适合尾调用（外部函数的返回值时一个内部函数的返回值）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">innerFunction</span>();<span class="comment">//尾调用</span></span><br><span class="line">}</span><br><span class="line"><span class="title class_">ES6</span>优化之前：</span><br><span class="line">(<span class="number">1</span>) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。</span><br><span class="line">(<span class="number">2</span>) 执行 outerFunction 函数体，到 <span class="keyword">return</span> 语句。计算返回值必须先计算 innerFunction。</span><br><span class="line">(<span class="number">3</span>) 执行到 innerFunction 函数体，第二个栈帧被推到栈上。</span><br><span class="line">(<span class="number">4</span>) 执行 innerFunction 函数体，计算其返回值。</span><br><span class="line">(<span class="number">5</span>) 将返回值传回 outerFunction，然后 outerFunction 再返回值。</span><br><span class="line">(<span class="number">6</span>) 将栈帧弹出栈外。</span><br><span class="line">在 <span class="title class_">ES6</span> 优化之后，执行这个例子会在内存中发生如下操作。</span><br><span class="line">(<span class="number">1</span>) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。</span><br><span class="line">(<span class="number">2</span>) 执行 outerFunction 函数体，到达 <span class="keyword">return</span> 语句。为求值返回语句，必须先求值 innerFunction。</span><br><span class="line">(<span class="number">3</span>) 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction</span><br><span class="line">的返回值。</span><br><span class="line">(<span class="number">4</span>) 弹出 outerFunction 的栈帧。</span><br><span class="line">(<span class="number">5</span>) 执行到 innerFunction 函数体，栈帧被推到栈上。</span><br><span class="line">(<span class="number">6</span>) 执行 innerFunction 函数体，计算其返回值。</span><br><span class="line">(<span class="number">7</span>) 将 innerFunction 的栈帧弹出栈外</span><br><span class="line">很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多</span><br><span class="line">少次嵌套函数，都只有一个栈帧。这就是 <span class="title class_">ES6</span> 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其</span><br><span class="line">销毁，则引擎就会那么做。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个常见的递归尾调用优化的例子</span></span><br><span class="line"><span class="comment">// 基础框架</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fibImpl</span>(<span class="number">0</span>, <span class="number">1</span>, n);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 执行递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibImpl</span>(<span class="params">a, b, n</span>) {</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fibImpl</span>(b, a + b, n - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包指的是那些引用了另一个函数作用域中变量的函数 通常是在嵌套函数中实现的</p><blockquote><p>在调用一个函数的时候 会为这个函数调用创建一个执行上下文 并创建一个作用域链 然后用 arguments 和其他命名参数来初始化这个函数的所有活动对象 外部函数的活动对象是内部函数作用域链上的第二个对象 这个作用域链一直向外串起了所有包含函数的活动对象 知道全局执行上下文才终止</p></blockquote><h2 id="理解调用的函数表达式"><a href="#理解调用的函数表达式" class="headerlink" title="理解调用的函数表达式"></a>理解调用的函数表达式</h2><p>立即调用的匿名函数又称作立即调用的函数表达式（IIFE）ES6 之后没有使用的必要了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IIFE可以模拟块级作用域 即在一个函数表达式内部声明变量然后立即调用这个函数 这样位于函数作用域的变量就相当于在块级作用域中一样</span></span><br><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  }</span><br><span class="line">})();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>使用闭包和私有变量会导致作用域链变长 作用域链越长 则找到变量所需的时间就越多</p></blockquote><h1 id="Promise-和异步函数"><a href="#Promise-和异步函数" class="headerlink" title="Promise 和异步函数"></a>Promise 和异步函数</h1><p><code>promise</code>的状态是私有的 不能直接通过 js 检测到 这是为了避免读取到的<code>promise</code>的状态以同步方式处理 同时 <code>promise</code>的状态也不能被外部 js 代码修改 要是为了隔离外部的同步代码</p><p><code>Promise.resolved()</code>是幂等状态</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> {});</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><code>Promise.reject()</code>会将传给他的作为错误信息返回 包括<code>promise.resloved()</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>()));</span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: Promise &lt;resolved&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><code>Finally</code>用于给<code>promise</code>添加<code>onFinally</code>处理程序 可以避免 <code>onResolved</code> 和 <code>onRejected</code> 处理程序中出 现冗余代码 主要用于添加清理代码</p><blockquote><p>明天再看</p></blockquote><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="窗口关系"><a href="#窗口关系" class="headerlink" title="窗口关系"></a>窗口关系</h2><p><code>outerWidth 和 outerHeight</code> 返回浏 览器窗口自身的大小（不管是在最外层 window 上使用，还是在窗格中使用）。<code>innerWidth 和 innerHeight</code> 返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）</p><p><code>document.documentElement.clientWidth 和 document.documentElement.clientHeight</code> 返回页面视口的宽度和高度。</p><h3 id="视口位置"><a href="#视口位置" class="headerlink" title="视口位置"></a>视口位置</h3><p>度量文档相对于视口滚动距离的属性有两对，返回相等的值<code>：window.pageXoffset/window. scrollX 和 window.pageYoffset/window.scrollY</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对于当前视口向下滚动 100 像素</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollBy</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 相对于当前视口向右滚动 40 像素</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollBy</span>(<span class="number">40</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 滚动到页面左上角</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 滚动到距离屏幕左边及顶边各 100 像素的位置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></tbody></table></figure><p>除了偏移值之外 还能通过<code>behavior</code>属性告诉浏览器是否平滑滚动</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常滚动</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>({</span><br><span class="line">  <span class="attr">left</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">top</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">behavior</span>: <span class="string">"auto"</span>,</span><br><span class="line">  <span class="comment">//behavior: 'smooth'//平滑滚动</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h2><p><code>URL</code>包含当前页面的完整 URL（地址栏中的 URL） <code>domain</code>包含页面的域名 <code>referrer</code>包含连接到当前页面的那个页面的 URL（如果当前页面无来源 则尾空字符串）<strong>只有 domain 的值是可以设置的</strong></p><p><code>getElementsByName()</code>方法最常用于单选按钮，因为同 一字段的单选按钮必须具有相同的 <code>name</code> 属性才能确保把正确的值发送给服务器</p><h2 id="ScrollIntoView（）"><a href="#ScrollIntoView（）" class="headerlink" title="ScrollIntoView（）"></a>ScrollIntoView（）</h2><p><code>scrollIntoView()</code>方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元 素进入视口</p><ul><li>alignToTop：boolean default：true<ul><li>true：窗口滚动后元素的顶部与视口顶部对齐</li><li>false：窗口滚动后元素的底部与视口底部对齐</li></ul></li><li>false：窗口滚动后元素的底部与视口底部对齐<ul><li>false：窗口滚动后元素的底部与视口底部对齐</li><li>block：定义垂直方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默 认为 “start”。</li><li>inline：定义水平方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默 认为 “nearest”。</li></ul></li></ul><p>这个方法可以用来在页面上发生某个事件时引起用户关注。把焦点设置到一个元素上也会导致浏览 器将元素滚动到可见位置。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="DOM-事件对象"><a href="#DOM-事件对象" class="headerlink" title="DOM 事件对象"></a>DOM 事件对象</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bubbles 布尔值 只读 表示事件是否冒泡</span><br><span class="line">cancelable 布尔值 只读 表示是否可以取消事件的默认行为</span><br><span class="line">currentTarget 元素 只读 当前事件处理程序所在的元素</span><br><span class="line">defaultPrevented 布尔值 只读 true 表示已经调用 preventDefault()方法（DOM3</span><br><span class="line">Events 中新增）</span><br><span class="line">detail 整数 只读 事件相关的其他信息</span><br><span class="line">eventPhase 整数 只读 表示调用事件处理程序的阶段：1 代表捕获阶段，2 代表</span><br><span class="line">到达目标，3 代表冒泡阶段</span><br><span class="line">preventDefault() 函数 只读 用于取消事件的默认行为。只有 cancelable 为 true 才</span><br><span class="line">可以调用这个方法</span><br><span class="line">stopImmediatePropagation() 函数 只读 用于取消所有后续事件捕获或事件冒泡，并阻止调用任</span><br><span class="line">何后续事件处理程序（DOM3 Events 中新增）</span><br><span class="line">stopPropagation() 函数 只读 用于取消所有后续事件捕获或事件冒泡。只有 bubbles</span><br><span class="line">为 true 才可以调用这个方法</span><br><span class="line">target 元素 只读 事件目标</span><br><span class="line">trusted 布尔值 只读 true 表示事件是由浏览器生成的。false 表示事件是开</span><br><span class="line">发者通过 JavaScript 创建的（DOM3 Events 中新增）</span><br><span class="line">type 字符串 只读 被触发的事件类型</span><br><span class="line">View AbstractView 只读 与事件相关的抽象视图。等于事件所发生的 window 对象</span><br></pre></td></tr></tbody></table></figure><p>在事件处理程序内部 <code>this</code>对象始终等于<code>currentTatget</code>的值 而<code>target</code>只包含事件的实际目标</p><p><code>type</code>属性在一个对象处理多个程序的时候很有用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span> (<span class="params">event</span>) {</span><br><span class="line">  <span class="keyword">switch</span> (event.<span class="property">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Clicked"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">      event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">"red"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">      event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">btn.<span class="property">onclick</span> = handler;</span><br><span class="line">btn.<span class="property">onmouseover</span> = handler;</span><br><span class="line">btn.<span class="property">onmouseout</span> = handler;</span><br></pre></td></tr></tbody></table></figure><p><code>preventDefault()</code>方法用于阻止特定事件的默认动作</p><p><code>stopPropagation()</code>方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件<code>捕获</code>或<code>冒泡</code></p><p><code>eventPhase</code> 属性可用于确定事件流当前所处的阶段</p><blockquote><p>event 对象只在事件处理程序执行期间存在 一旦执行完毕 就会被销毁</p></blockquote><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><ul><li><p>用户界面事件（<code>UIEvent</code>）：涉及与 BOM 交互的通用浏览器事件</p><ul><li>resize：在 window 或窗格上当窗口或窗格被缩放时触发（浏览器窗口在最大化或最小化的时候也会触发这个事件）</li><li>scroll：当用户滚动包含滚动条上的元素时在元素上触发</li><li>abort：在<code>&lt;object&gt;</code>元素上当相应对象加载完成前被用户提前终止下载时触发</li></ul></li><li><p>焦点事件（<code>FocusEvent</code>）：在元素获得和失去焦点时触发</p><ul><li>blur：失去焦点时触发</li><li>focus：用户获得焦点时触发 不冒泡</li><li>focusin：当元素获得焦点时触发。这个事件是 focus 的冒泡版</li><li>focusout：当元素失去焦点时触发。这个事件是 blur 的通用版</li></ul></li><li><p>鼠标事件（<code>MouseEvent</code>）：使用鼠标在页面上执行某些操作时触发</p></li><li><p>dblclick：在用户双击鼠标主键（通常是左键）时触发</p></li><li><p>mousedown：在用户按下任意鼠标键时触发。这个事件不能通过键盘触发</p></li><li><p>mouseenter：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在 光标经过后代元素时触发</p></li><li><p>mouseleave：在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在 光标经过后代元素时触发</p></li><li><p>mousemove：在鼠标光标在元素上移动时反复触发</p></li><li><p>mouseout：在用户把鼠标光标从一个元素移到另一个元素上时触发</p></li><li><p>mouseover：在用户把鼠标光标从元素外部移到元素内部时触发</p></li><li><p>mouseup：在用户释放鼠标键时触发</p></li></ul><p>除了 mouseenter 和 mouseleave，所有鼠标事件都会冒泡， 都可以被取消，而这会影响浏览器的默认行为</p><ul><li><p>滚轮事件（<code>WheelEvent</code>）：使用鼠标滚轮（或类似设备）时触发</p></li><li><p>输入事件（<code>InputEvent</code>）：向文档中输入文本时触发</p></li><li><p>键盘事件（<code>KeyboardEvent</code>）：使用键盘在页面上执行某些操作时触发</p><ul><li>textInput：输入事件 当 会在文本被插入到文本框之前触发(只在可编辑区域触发 只有新字符被插入时才会触发)</li><li>keydown 和 keypress 会在文本框变化前触发（按住不放则重复触发） keyUp 会在发生后触发</li><li>key 属性用于替代 keyCode，且包含字符串。在按下字符键时，key 的值等于文本字符（如 “k”或“M”）；在按下非字符键时，key 的值是键名（如“Shift”或“ArrowDown”）。char 属性在按 下字符键时与 key 类似，在按下非字符键时为 null</li></ul></li><li><p>合成事件（<code>CompositionEvent</code>）：在使用某种 IME（Input Method Editor，输入法编辑器）输入 字符时触发。</p></li></ul><h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托利用事件冒泡 可以只使用一个事件处理程序来处理一种类型事件</p><p><strong>所有使用按钮的事件（大多数鼠标事件和键盘事件）都适用于这个解决方案</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"myLinks"</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"goSomewhere"</span>&gt;</span>Go somewhere<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"sayHi"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;;</span><br><span class="line"><span class="comment">//如果对三个li都像这样指定3个事件处理程序</span></span><br><span class="line"><span class="keyword">let</span> item1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"goSomewhere"</span>);</span><br><span class="line"><span class="keyword">let</span> item2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"doSomething"</span>);</span><br><span class="line"><span class="keyword">let</span> item3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"sayHi"</span>);</span><br><span class="line">item1.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  location.<span class="property">href</span> = <span class="string">"http:// www.wrox.com"</span>;</span><br><span class="line">});</span><br><span class="line">item2.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">"I changed the document's title"</span>;</span><br><span class="line">});</span><br><span class="line">item3.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"hi"</span>);</span><br><span class="line">});</span><br><span class="line"><span class="comment">//使用事件委托 只要给所有元素沟通的祖先节点添加一个事件处理程序 可以解决问题</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myLinks"</span>);</span><br><span class="line">list.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> target = event.<span class="property">target</span>;</span><br><span class="line">  <span class="keyword">switch</span> (target.<span class="property">id</span>) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"doSomething"</span>:</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">"I changed the document's title"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"goSomewhere"</span>:</span><br><span class="line">      location.<span class="property">href</span> = <span class="string">"http:// www.wrox.com"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"sayHi"</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"hi"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>事件委托的好处</p><ul><li><code>document</code> 对象随时可用，任何时候都可以给它添加事件处理程序（不用等待 DOMContentLoaded 或 load 事件）。这意味着只要页面渲染出可点击的元素，就可以无延迟地起作用。</li><li>节省花在设置页面事件处理程序上的时间。只指定一个事件处理程序既可以节省 DOM 引用，也 可以节省时间</li><li>减少整个页面所需的内存，提升整体性能</li></ul><p>最适合使用事件委托的事件包括：<code>click、mousedown、mouseup、keydown 和 keypress</code></p><h1 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h1><h2 id="跨上下文消息"><a href="#跨上下文消息" class="headerlink" title="跨上下文消息"></a>跨上下文消息</h2><p>跨文档消息（XDM）是一种在不同执行上下文（如不同工作线程或不同源的页面能力）间传递消息的能力</p><blockquote><p>跨上下文消息用于窗口之间通信或工作线程之间通信</p></blockquote><p><code>postMessage()</code>方法接收三个参数：消息、表示目标接收源的字符串和可选的可传输对象的数组（只与工作线程相关）第二个参数对于安全非常重要 可以限制浏览器交付数据的目标</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iframeWindow = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myframe"</span>).<span class="property">contentWIndow</span>;</span><br><span class="line">iframeWindow.<span class="title function_">postMessage</span>(<span class="string">"a message"</span>, <span class="string">"http://www.wrox.com"</span>);</span><br><span class="line"><span class="comment">//如果源匹配 就将消息交付到内嵌彪哥 否则啥都不错 可以保护信息不会因地址改变而泄漏</span></span><br></pre></td></tr></tbody></table></figure><p>接收到 XDM 消息后 window 对象上会触发<code>message</code>事件（<code>异步</code>触发 从发出到接收消息可能会有延迟）传给<code>message</code>的<code>event</code>对象包含以下三方面重要信息</p><ul><li><code>data</code>：作为第一个参数传递给<code>postMessage（）</code>的字符串数据</li><li><code>origin</code>：发送消息的文档源</li><li><code>source</code>：发送消息的文档中<code>window</code>对象的代理 这个代理对象主要用于发送上一条消息的窗口中执行<code>postMessage()</code>方法 如果发送窗口有相同的源 那么对象就是 window 对象</li></ul><p><code>onmessage</code> 事件处理程序中检查发送窗口的源可以保证数据来自正确的 地方</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">"message"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 确保来自预期发送者</span></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">origin</span> == <span class="string">"http://www.wrox.com"</span>) {</span><br><span class="line">    <span class="comment">// 对数据进行一些处理</span></span><br><span class="line">    <span class="title function_">processMessage</span>(event.<span class="property">data</span>);</span><br><span class="line">    <span class="comment">// 可选：向来源窗口发送一条消息</span></span><br><span class="line">    event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">"Received!"</span>, <span class="string">"http://p2p.wrox.com"</span>);</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>大多数情况下，<code>event.source</code> 是某个 <code>window</code> 对象的代理，而非实际的 window 对象。因此不能 通过它访问所有窗口下的信息。最好只使用 <code>postMessage()</code>，这个方法永远存在而且可以调用</p><p><strong>tips：</strong>最好就是只 通 过 <code>postMessage()</code> 发送字符串。如果需要传递结构化数据，那么最好先对该数据调用 <code>JSON.stringify()，</code>通过 postMessage()传过去之后，再在 <code>onmessage</code> 事件处理程序中调用 <code>JSON.parse()</code></p><p>在通过内嵌窗格加载不同域时，使用 XDM 是非常方便的。这种方法在混搭（mashup）和<code>社交应用</code> 中非常常用。通过使用 XDM 与内嵌窗格中的网页通信，可以保证包含页面的安全。XDM 也可以用于 <code>同源页面</code>之间通信</p><h2 id="Encoding-API"><a href="#Encoding-API" class="headerlink" title="Encoding API"></a>Encoding API</h2><p>用于实现字符串和定型数组之间的转换 <code>TextEncoder、TextEncoderStream、TextDecoder 和 TextDecoderStream。</code></p><h3 id="批量编码"><a href="#批量编码" class="headerlink" title="批量编码"></a>批量编码</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextEncoder、TextEncoderStream、TextDecoder 和 TextDecoderStream。</span></span><br><span class="line"><span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>();</span><br><span class="line"><span class="keyword">const</span> decodedText = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">const</span> encodedTRext = textEncoder.<span class="title function_">encode</span>(docodedText);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encodedText); <span class="comment">// Uint8Array(3) [102, 111, 111]</span></span><br><span class="line"><span class="comment">//编码器是用于处理字符的，有些字符（如表情符号）在最终返回的数组中可能会占多个索引</span></span><br><span class="line"><span class="comment">//encodeInto()方法，该方法接收一个字符串和目标 Unit8Array，返回一个</span></span><br><span class="line">字典，该字典包含 read 和 written 属性，分别表示成功从源字符串读取了多少字符和向目标数组写</span><br><span class="line">入了多少字符。如果定型数组的空间不够，编码就会提前终止，</span><br><span class="line"><span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>();</span><br><span class="line"><span class="keyword">const</span> fooArr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> barArr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> fooResult = textEncoder.<span class="title function_">encodeInto</span>(<span class="string">'foo'</span>, fooArr);</span><br><span class="line"><span class="keyword">const</span> barResult = textEncoder.<span class="title function_">encodeInto</span>(<span class="string">'bar'</span>, barArr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooArr); <span class="comment">// Uint8Array(3) [102, 111, 111]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooResult); <span class="comment">// { read: 3, written: 3 }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(barArr); <span class="comment">// Uint8Array(2) [98, 97]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(barResult); <span class="comment">// { read: 2, written: 2 }</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>文本编码会始终使用 UTF-8 格式，而且必须写入 Unit8Array 实例。使用其他类 型数组会导致 encodeInto()抛出错误</p></blockquote><h2 id="File-API-与-Blob-API"><a href="#File-API-与-Blob-API" class="headerlink" title="File API 与 Blob API"></a>File API 与 Blob API</h2><h3 id="File-类型"><a href="#File-类型" class="headerlink" title="File 类型"></a>File 类型</h3><p>每个 File 对象都有一些只读属性</p><ul><li>name：本地系统中的文件名</li><li>size：以字节计的文件大小</li><li>type：包含文件 MIME 类型的字符串</li><li>lastModifiedDate：表示文件最后修改的时间的字符串 只有 chome 实现了</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">通过监听 change 事件然后遍历 files 集合可以取得每个选中文件的信息</span><br><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"files-list"</span>);</span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">"change"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"> <span class="keyword">let</span> files = event.<span class="property">target</span>.<span class="property">files</span>,</span><br><span class="line"> i = <span class="number">0</span>,</span><br><span class="line"> len = files.<span class="property">length</span>;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; len) {</span><br><span class="line"> <span class="keyword">const</span> f = files[i];</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">${f.name}</span> (<span class="subst">${f.type}</span>, <span class="subst">${f.size}</span> bytes)`</span>);</span><br><span class="line"> i++;</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="FileReader-类型"><a href="#FileReader-类型" class="headerlink" title="FileReader 类型"></a>FileReader 类型</h3><p><code>FileReader</code>类型表示一种<code>异步</code>文件读取机制</p><ul><li><code>readAsText(file, encoding)</code>：从文件中读取纯文本内容并保存在 result 属性中。第二个 参数表示编码，是可选的</li><li><code>readAsDataURL(file)</code>：读取文件并将内容的数据 URI 保存在 result 属性中</li><li><code>readAsBinaryString(file)</code>：读取文件并将每个字符的二进制数据保存在 result 属性中</li><li><code>readAsArrayBuffer(file)</code>：读取文件并将文件内容以 <code>ArrayBuffer</code> 形式保存在 result 属性</li></ul><p>因为这些读取方法是异步的，所以每个 FileReader 会发布几个事件，其中 3 个最有用的事件是 <code>progress、error 和 load</code>，分别表示还有更多数据、发生了错误和读取完成</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从表单字段读取一个文件并将其内容显示在网页上</span></span><br><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"files-list"</span>);</span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">"change"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> info = <span class="string">""</span>,</span><br><span class="line">    output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"output"</span>);</span><br><span class="line">  (progress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"progress"</span>)),</span><br><span class="line">    (files = event.<span class="property">target</span>.<span class="property">files</span>),</span><br><span class="line">    (type = <span class="string">"default"</span>),</span><br><span class="line">    (reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>());</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/image/</span>.<span class="title function_">test</span>(files[<span class="number">0</span>].<span class="property">type</span>)) {</span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(files[<span class="number">0</span>]);</span><br><span class="line">    type = <span class="string">"image"</span>; <span class="comment">//如果是图片 则将其读取后保存为URL</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    reader.<span class="title function_">readAsText</span>(files[<span class="number">0</span>]); <span class="comment">//如果是文字则保存为文字</span></span><br><span class="line">    type = <span class="string">"text"</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//用于监控错误</span></span><br><span class="line">  reader.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    output.<span class="property">innerHTML</span> =</span><br><span class="line">      <span class="string">"Could not read file, error code is "</span> + reader.<span class="property">error</span>.<span class="property">code</span>;</span><br><span class="line">  };</span><br><span class="line">  <span class="comment">//用于跟踪和显示读取文件的进度</span></span><br><span class="line">  reader.<span class="property">onprogress</span> = <span class="keyword">function</span> (<span class="params">event</span>) {</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) {</span><br><span class="line">      progress.<span class="property">innerHTML</span> = <span class="string">`<span class="subst">${event.loaded}</span>/<span class="subst">${event.total}</span>`</span>; <span class="comment">//读取文件的进度</span></span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">  <span class="comment">//读取成功后</span></span><br><span class="line">  reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">let</span> html = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) {</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"image"</span>:</span><br><span class="line">        html = <span class="string">`&lt;img src="<span class="subst">${reader.result}</span>"&gt;`</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"text"</span>:</span><br><span class="line">        html = reader.<span class="property">result</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    output.<span class="property">innerHTML</span> = html;</span><br><span class="line">  };</span><br><span class="line">});</span><br><span class="line"><span class="comment">//如果想提前结束文件的读取 可以在过程中调用abort()方法 在load error和 abort事件触发后 还会触发loadend事件 loadend事件表示上述三种情况下所有读取操作都已经结束</span></span><br></pre></td></tr></tbody></table></figure><h3 id="FileReaderSync-类型"><a href="#FileReaderSync-类型" class="headerlink" title="FileReaderSync 类型"></a>FileReaderSync 类型</h3><p><code>FileReader</code>的同步版本 只有整个文件都加载到内存之后才能继续进行 只在工作线程中可用 因为如果读取整个文件的耗时过长则会影响全局</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line">self.<span class="property">omessage</span> = <span class="function">(<span class="params">messageEvent</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> syncReader = <span class="keyword">new</span> <span class="title class_">FileReaderSync</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(syncReader); <span class="comment">// FileReaderSync {}</span></span><br><span class="line">  <span class="comment">// 读取文件时阻塞工作线程</span></span><br><span class="line">  <span class="keyword">const</span> result = syncReader.<span class="title function_">readAsDataUrl</span>(messageEvent.<span class="property">data</span>);</span><br><span class="line">  <span class="comment">// PDF 文件的示例响应</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// data:application/pdf;base64,JVBERi0xLjQK...</span></span><br><span class="line">  <span class="comment">// 把 URL 发回去</span></span><br><span class="line">  self.<span class="title function_">postMessage</span>(result);</span><br><span class="line">};</span><br><span class="line"><span class="comment">//假设通过 postMessage()向工作线程发送了一个 File 对象。以下代码会让工作线程同步将文件</span></span><br><span class="line"><span class="comment">//读取到内存中，然后将文件的数据 URL 发回来</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Blob-与部分读取"><a href="#Blob-与部分读取" class="headerlink" title="Blob 与部分读取"></a>Blob 与部分读取</h3><p><code>File</code>对象提供了一个名为<code>slice()</code>的方法 （接收两个参数 其实字节和读取的字节数 返回一个 Blob 实例 ）Blob 实际上是 File 的<strong>超类</strong></p><p>Blob 对象有一个 <code>size</code> 属性和一个 <code>type</code> 属性，还有一个 <code>slice()</code>方法用于进一步切分数据。另 外也可以使用 <code>FileReader</code> 从 Blob 中读取数据</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文件的前32字节</span></span><br><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'files-list'</span>);</span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">"change"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">""</span>,</span><br><span class="line">output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'output'</span>);</span><br><span class="line">progress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'progress'</span>),</span><br><span class="line">files = event.<span class="property">target</span>.<span class="property">files</span>,</span><br><span class="line">reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(),</span><br><span class="line">blob = <span class="title function_">blobSlice</span>(files[<span class="number">0</span>], <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">if</span>(blob) [</span><br><span class="line">reader.<span class="title function_">readAsText</span>(blob);</span><br><span class="line">reader.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">output.<span class="property">innerHTML</span> = <span class="string">"Could not read file, error code is"</span> +</span><br><span class="line">reader.<span class="property">error</span>.<span class="property">code</span>;</span><br><span class="line">};</span><br><span class="line">reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">output.<span class="property">innerHTML</span> = reader.<span class="property">result</span>;</span><br><span class="line">}</span><br><span class="line">]<span class="keyword">else</span> {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'error'</span>)</span><br><span class="line">}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><blockquote><p>只读取部分文件可以节约时间 特别是在只需要特定部分比如文件头的时候</p></blockquote><h3 id="对象-URL-与-Blob"><a href="#对象-URL-与-Blob" class="headerlink" title="对象 URL 与 Blob"></a>对象 URL 与 Blob</h3><p>引用储存在<code>File</code>或<code>Blob</code>中数据的<code>URL</code></p><p>**优点:**不用把文件内容读取到 JavaScript 也可以使用文件 只要在适当的位置提供对象 URL 即可</p><p>使用 <code>window.URL.createObjectURL()</code>方法并传入 <code>File</code> 或 <code>Blob</code> 对象 返回一个指向内存中<strong>地址</strong>的字符串 在<code>DOM</code>中可以直接使用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用对象URL在页面中显示一张图片</span></span><br><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"files-list"</span>);</span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">'change'</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">''</span>,</span><br><span class="line">output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"output"</span>),</span><br><span class="line"> progress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"progress"</span>),</span><br><span class="line"> files = event.<span class="property">target</span>.<span class="property">files</span>,</span><br><span class="line"> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(),</span><br><span class="line"> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(files[<span class="number">0</span>]);</span><br><span class="line"> <span class="keyword">if</span>(url) {</span><br><span class="line"> <span class="keyword">if</span>(<span class="regexp">/image/</span>.<span class="title function_">test</span>(files[<span class="number">0</span>].<span class="property">type</span>)) {</span><br><span class="line"> output.<span class="property">innerHTML</span> = <span class="string">`&lt;img src="<span class="subst">${url}</span>"&gt;`</span>;</span><br><span class="line"></span><br><span class="line"> }esle {</span><br><span class="line"> output.<span class="property">innerHTML</span> = <span class="string">"Not an image."</span>;</span><br><span class="line"> }</span><br><span class="line"> }<span class="keyword">else</span> {</span><br><span class="line">  output.<span class="property">innerHTML</span> = <span class="string">"Your browser doesn't support object URLs."</span>;</span><br><span class="line"> }</span><br><span class="line">})</span><br><span class="line"><span class="comment">//如果把对象 URL 直接放到&lt;img&gt;标签，就不需要把数据先读到 JavaScript 中了。&lt;img&gt;标签可以直</span></span><br><span class="line"><span class="comment">//接从相应的内存位置把数据读取到页面上。</span></span><br></pre></td></tr></tbody></table></figure><p>使用完数据之后，最好能释放与之关联的内存。只要对象 URL 在使用中，就不能释放内存。如果 想表明不再使用某个对象 URL，则可以把它传给 window.URL.revokeObjectURL()。页面卸载时， 所有对象 URL 占用的内存都会被释放。不过，最好在不使用时就立即释放内存，以便尽可能保持页面 占用最少资源</p><h3 id="读取拖放文件"><a href="#读取拖放文件" class="headerlink" title="读取拖放文件"></a>读取拖放文件</h3><p>拖放文件可以像拖放图片或连接一样触发<code>drop</code>事件 被放置的文件可以通过事件的<code>event.dataTransfer.files</code>属性读到 这个属性保存着一组 File 对象 就像文本输入字段一样</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> droptarget = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"droptarget"</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleEvent</span>(<span class="params">event</span>) {</span><br><span class="line">  <span class="keyword">let</span> info = <span class="string">""</span>,</span><br><span class="line">    output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"output"</span>),</span><br><span class="line">    files,</span><br><span class="line">    i,</span><br><span class="line">    len;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">type</span> == <span class="string">"drop"</span>) {</span><br><span class="line">    files = event.<span class="property">dataTransfer</span>.<span class="property">files</span>;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    len = files.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) {</span><br><span class="line">      info += <span class="string">`<span class="subst">${files[i].name}</span> (<span class="subst">${files[i].type}</span>, <span class="subst">${files[i].size}</span> bytes)&lt;br&gt;`</span>;</span><br><span class="line">      i++;</span><br><span class="line">    }</span><br><span class="line">    output.<span class="property">innerHTML</span> = info;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">"dragenter"</span>, handleEvent);</span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">"dragover"</span>, handleEvent);</span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">"drop"</span>, handleEvent);</span><br><span class="line"><span class="comment">//必须取消dragenter、dragover和drop的默认行为 在drop事件处理程序中 可以通过event.dataTransfer.files 读到文件，此时可以获取文件的相关信息</span></span><br></pre></td></tr></tbody></table></figure><h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/24/595504b72117d4fb.png"></p><p><img src="https://i.bmp.ovh/imgs/2022/04/24/539327ac86e98fdd.png"></p><p><img src="https://i.bmp.ovh/imgs/2022/04/24/afd2eed69d58a3dd.png"></p><h3 id="检测编解码器"><a href="#检测编解码器" class="headerlink" title="检测编解码器"></a>检测编解码器</h3><p>有一个<code>canPlayType()</code>的方法 接收一个格式/编解码器字符串 返回一个”probably”、”maybe”或””</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (audio.<span class="title function_">canPlayType</span>(<span class="string">"audio/mpeg"</span>)) {</span><br><span class="line"> <span class="comment">// 执行某些操作</span></span><br><span class="line">}</span><br><span class="line"><span class="string">"probably"</span>和<span class="string">"maybe"</span>都是真值，在 <span class="keyword">if</span> 语句的上下文中可以转型为 <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Notifications-API"><a href="#Notifications-API" class="headerlink" title="Notifications API"></a>Notifications API</h2><p>用于向用户显示通知</p><ul><li>通知只能运行再安全上下文的代码中被触发</li><li>通知必须按照每个源的原则明确得到用户允许</li></ul><p>浏览器会记住用户的选择 如果被拒绝则无法重来</p><h3 id="通知授权"><a href="#通知授权" class="headerlink" title="通知授权"></a>通知授权</h3><p>页面可以使用全局对象<code>Notification</code> 向用户请求通知权限 这个对象会有一个<code>requestPermission()</code> 返回一个<code>promise</code>对象 用户在授权对话框上执行操作后这个<code>promise</code>会被解决</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Notification</span>.<span class="title function_">requestPermission</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">permission</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"User responded to permission request:"</span>, permission);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p><code>"granted"</code>值意味着用户明确授权了显示通知的权限。除此之外的其他值意味着显示通知会静默失 败。如果用户拒绝授权，这个值就是<code>"denied"</code>。一旦拒绝，就无法通过编程方式挽回，因为不可能再 触发授权提示。</p><h3 id="显示和隐藏通知"><a href="#显示和隐藏通知" class="headerlink" title="显示和隐藏通知"></a>显示和隐藏通知</h3><p>Notification 构造函数用于创建和显示通知</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">"Title text!"</span>, {</span><br><span class="line">  <span class="attr">body</span>: <span class="string">"Body text!"</span>,</span><br><span class="line">  <span class="attr">image</span>: <span class="string">"path/to/image.png"</span>,</span><br><span class="line">  <span class="attr">vibrate</span>: <span class="literal">true</span>,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> n = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">"I will close in 1000ms"</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> n.<span class="title function_">close</span>(), <span class="number">1000</span>); <span class="comment">//调用close关闭通知</span></span><br></pre></td></tr></tbody></table></figure><h3 id="通知生命周期"><a href="#通知生命周期" class="headerlink" title="通知生命周期"></a>通知生命周期</h3><ul><li><code>onshow</code> 在通知显示时触发</li><li><code>onshow</code> 在通知显示时触发</li><li><code>onclose</code> 在通知消失或通过 close()关闭时触发</li><li><code>onclose</code> 在通知消失或通过 close()关闭时触发</li></ul><h2 id="Page-Visibility-API"><a href="#Page-Visibility-API" class="headerlink" title="Page Visibility API"></a>Page Visibility API</h2><p>为开发者提供页面对用户是否可见的信息</p><ul><li><code>document.visibilityState</code> 值，表示下面 4 种状态之一<ul><li>页面在后台标签页或浏览器中最小化了。</li><li>页面在前台标签页中</li><li>实际页面隐藏了，但对页面的预览是可见的（例如在 Windows 7 上，用户鼠标移到任务栏图标 上会显示网页预览）。</li><li>页面在屏外预渲染</li></ul></li><li><code>visibilitychange</code> 事件，该事件会在文档从隐藏变可见（或反之）时触发</li><li><code>document.hidden</code> 布尔值，表示页面是否隐藏。这可能意味着页面在后台标签页或浏览器中被最小 化了。这个值是为了向后兼容才继续被浏览器支持的，应该优先使用 <code>document.visibilityState</code> 检测页面可见性</li></ul><h2 id="计时-API"><a href="#计时-API" class="headerlink" title="计时 API"></a>计时 API</h2><h3 id="High-Resolution-Time-API"><a href="#High-Resolution-Time-API" class="headerlink" title="High Resolution Time API"></a>High Resolution Time API</h3><p><code>Date.now()</code>不精确</p><p><code>performance.now()</code>:相对度量 计时器在执行上下文创建时从 0 开始</p><p><code>performance.timeOrigin</code> 属性返回计时器初始化时全局系统时钟的值</p><p><code>performance.getEntries()</code>：性能时间线（performance timeline）。每个 PerformanceEntry 对象 都有 name、entryType、startTime 和 duration 属性</p><h1 id="错误处理和调试"><a href="#错误处理和调试" class="headerlink" title="错误处理和调试"></a>错误处理和调试</h1><p>为了保证浏览器兼容 最好只使用<code>message</code></p><blockquote><p>只要代码中包含了<code>finally</code>子块 <code>try</code> 块或 <code>catch</code> 块中的 <code>return</code> 语句就会被忽 略</p></blockquote><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ul><li>Error</li><li>InternalError ：底层 JavaScript 引擎发出异常时由浏览器抛出 如递归过多导致栈移除 发生这种错误一般是出了问题</li><li><code>EvalError</code> ：使用<code>eval()</code>函数发生异常时抛出</li><li><code>RangeError</code> ：数值越界</li><li><code>ReferenceError</code> ：找不到对象时发生或者变量</li><li><code>SyntaxErro</code>：r 经常在给 <code>eval()</code>传入的字符串包含 JavaScript 语法错误时发生</li><li><code>TypeError</code> 主要发生在变量不是预期类型，或者访问不存在的方法时</li><li>``URIError<code>使用 </code>encodeURI()<code>或 </code>decodeURI()`但传入了格式错误的 URI 时发</li></ul><p>可以在 try/vatch 中使用 instance of 操作符确定错误的类型</p><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>使用 <code>throw</code> 操作符时，代码立即停止执行，除非 <code>try/catch</code> 语句捕获了抛出的值。</p><p>可以通过继承 ERROR 来创建自定义的类型错误 创建自定义类型错误需要提供<code>name</code>以及<code>message</code>属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message</span>) {</span><br><span class="line">    <span class="variable language_">super</span>(message);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">"CustomError"</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">message</span> = message;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomError</span>(<span class="string">"My message"</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>使用自定义错误有助于捕获错误时更准确地区分错误</strong></p><h3 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h3><p>任何没有被<code>try/catch</code>处理的错误都会在<code>window</code>对象上触发<code>error</code>事件</p><h3 id="错误处理策略"><a href="#错误处理策略" class="headerlink" title="错误处理策略"></a>错误处理策略</h3><p>最好使用(===)来避免比较时发生类型转换</p><p>在流控制语句中使用非布尔值作为条件时很常见的错误来源 为避免这种错误 需要始终坚持使用布尔值作为条件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不好的写法</span></span><br><span class="line"> <span class="keyword">if</span> (str3) { <span class="comment">// 不要！</span></span><br><span class="line"> <span class="comment">//好的写法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str3 === <span class="string">"string"</span>) { <span class="comment">// 恰当的比</span></span><br></pre></td></tr></tbody></table></figure><p>如果知道预期的确切类型 最好使用<code>instanceof</code>来确定值的正确类型</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (values) { // 不要</span><br><span class="line">if (values) { // 不要</span><br><span class="line"> if (typeof values.sort === "function") { // 不要</span><br><span class="line">  if (values instanceof Array) { // 修复</span><br></pre></td></tr></tbody></table></figure><blockquote><p>一般来说 原始类型的值应该使用 typeof 检测 而对象值应该使用 instanceof 检测</p></blockquote><h4 id="抛出错误-1"><a href="#抛出错误-1" class="headerlink" title="抛出错误"></a>抛出错误</h4><p>在大型应用程序中，自定义错误通常使用 <code>assert()</code>函数抛出错误。这个函数接收一个应该为 <code>true</code> 的条件，并在条件为 false 时抛出错误</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">condition, message</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!condition) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//这个 assert()函数可用于代替多个 if 语句，同时也是记录错误的好地方</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">num1, num2</span>) {</span><br><span class="line">  <span class="title function_">assert</span>(</span><br><span class="line">    <span class="keyword">typeof</span> num1 == <span class="string">"number"</span> &amp;&amp; <span class="keyword">typeof</span> num2 == <span class="string">"number"</span>,</span><br><span class="line">    <span class="string">"divide(): Both arguments must be numbers."</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> num1 / num2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="网络请求与远程资源"><a href="#网络请求与远程资源" class="headerlink" title="网络请求与远程资源"></a>网络请求与远程资源</h1><h2 id="跨源资源共享"><a href="#跨源资源共享" class="headerlink" title="跨源资源共享"></a>跨源资源共享</h2><p><code>CORS:</code>定义了浏览器和服务器如何实现跨源通信（背后的基本思路就是使用自定义的 HTTP 头部允许浏览器服务器相互了解 以确定请求或响应应该成功还是失败）</p><p>对于简单的请求（<code>get/post</code>）没有自定义头部 而且请求体是<code>text/plain</code>类型 这样的请求在发送时会有一个额外的头部教<code>Origin</code> <code>Origin</code>头部包含发送请求的页面的源（协议、域名和端口）以便服务器确定是否为其提供响应</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://www.nczonline.net</span><br><span class="line">如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源；</span><br><span class="line">或者如果资源是公开的，那么就包含"*"。</span><br><span class="line">如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个</span><br><span class="line">请求。注意，无论请求还是响应都不会包含 cookie 信息</span><br></pre></td></tr></tbody></table></figure><blockquote><p>因为无论同域还是跨域请求都使用同一个接口 所以最好在访问本地资源时使用相对 URL 在访问远程资源时使用绝对 URL 这样可以更明确区分使用场景 同时避免出现访问本地资源时出现头部或 cookie 信息访问受限的问题</p></blockquote><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p><code>CORS</code>通过一种教预检请求的服务器验证机制 允许自定义头部、除<code>GET和POST</code>之外的方法 以及不同请求体内容类型 预检请求使用<code>OPTIONS</code>发送包含以下头部</p><ul><li><code>origin</code>：与简单请求相同</li><li><code>Access-Control-Request-Method</code>：请求希望使用的方法。</li><li><code>Access-Control-Request-Headers</code>：（可选）要使用的逗号分隔的自定义头部列表</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">下面假设一个post请求 包含自定义的NCZ头部：</span><br><span class="line">Origin: http://www.nczonline.net</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: NCZ</span><br><span class="line">在这个请求发送后 服务器可以确定是否允许这种类型的请求 服务器会通过响应中发送以下头部与浏览器沟通这些信息</span><br><span class="line">Access-Control-Allow-Origin：与简单请求相同</span><br><span class="line">Access-Control-Allow-Methods：允许的方法（逗号分隔的列表</span><br><span class="line">Access-Control-Allow-Headers：服务器允许的头部（逗号分隔的列表）</span><br><span class="line">Access-Control-Max-Age：缓存预检请求的秒数</span><br><span class="line">例如：</span><br><span class="line">Access-Control-Allow-Origin: http://www.nczonline.net</span><br><span class="line">Access-Control-Allow-Methods: POST, GET</span><br><span class="line">Access-Control-Allow-Headers: NCZ</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></tbody></table></figure><p><strong>预检请求返回后 结果会按响应指定的时间缓存一段时间 换句话说 只有第一次发送这种类型的请求时才会多发送一次额外的 http 请求</strong></p><h3 id="凭据请求"><a href="#凭据请求" class="headerlink" title="凭据请求"></a>凭据请求</h3><p>默认情况下 跨源请求不提供凭据（cookie、HTTP 认证和客户端 SSL 证书） 可以通过将<code>withCredentials</code>属性设置为 true 来表明请求会发送凭据 如果服务器允许携带凭据的话 可以包含<code>Access-Control-Allow-Credentials: true</code></p><h3 id="Headers-对象"><a href="#Headers-对象" class="headerlink" title="Headers 对象"></a>Headers 对象</h3><p><strong>Headers 对象是所有外发请求和入站响应头部的容器</strong></p><h1 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h1><h3 id="cookie：服务器在响应-http-请求时-通过发送-Set-CookieHTTP-头部会话信息"><a href="#cookie：服务器在响应-http-请求时-通过发送-Set-CookieHTTP-头部会话信息" class="headerlink" title="cookie：服务器在响应 http 请求时 通过发送 Set-CookieHTTP 头部会话信息"></a>cookie：服务器在响应 http 请求时 通过发送 Set-CookieHTTP 头部会话信息</h3><p>cookie 是与特定域绑定的 设置 cookie 后 他会与请求一起发送到创建它的域 这个限制能保证 cookie 中存储的信息只对被认可的接收者开放 不被其他域访问</p><p>cookie 的构成</p><ul><li>名称：唯一表示 cookie 的名称 不区分大小写 必须经过 URL 编码</li><li>值：存储在 cookie 中的字符串 这个值必须经过 URL 编码</li><li>域：cookie 有效的域 发送到这个域的所有请求都会包含到对应的 cookie</li><li>路径：请求 URL 中包含这个路径才会把 cookie 发送到服务器</li><li>过期时间：合适删除 cookie 的时间戳（什么时间之后就不发送到服务器了）</li><li>安全标志：设置之后 只有在使用 SSL 安全连接的情况下才会把 cookie 发送到服务器</li></ul><h4 id="JavaScript-中的-cookie"><a href="#JavaScript-中的-cookie" class="headerlink" title="JavaScript 中的 cookie"></a>JavaScript 中的 cookie</h4><p><code>document.cookie</code>返回包含页面中所有有效 cookie 的字符串（根据域、路径、过期时间和安全设置）</p><p>根据域、路径、过期时间和安全设置</p><p>所有名和值都是 URL 编码 因此必须通过<code>decodeURIComponent()</code>解码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(decodeURIComponent(document.cookie));</span><br><span class="line">//_octo=GH1.1.1592692317.1629286532; tz=Asia/Shanghai</span><br></pre></td></tr></tbody></table></figure><p>在设置值是 可以通过<code>document.cookie</code>设置新的 cookie 字符串 这个字符串在被解析之后会添加到原有的<code>cookie</code>中 设置<code>document.cookie</code>不会覆盖之前任何的<code>cookie</code> 除非设置了已有的 cookie</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = "name=Nicholas";</span><br></pre></td></tr></tbody></table></figure><p><code>CookieUtil.get()</code>方法用于取得给定名称的 cookie 值</p><p><code>CookieUtil.set()</code>方法用于设置页面上的 cookie</p><h4 id="子-cookie：为了绕过浏览器对每个域-cookie-数的限制"><a href="#子-cookie：为了绕过浏览器对每个域-cookie-数的限制" class="headerlink" title="子 cookie：为了绕过浏览器对每个域 cookie 数的限制"></a>子 cookie：为了绕过浏览器对每个域 cookie 数的限制</h4><p>在单个 cookie 存储的小块数据 本质上是使用 cookie 的值在单个 cookie 中存储多个名/值对 如</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5</span><br></pre></td></tr></tbody></table></figure><p>子 cookie 的格式类似于查询字符串 这些值可以储存单个 cookie 而不用单独存储为自己的名/值对 结果就是网站或者 Web 应用程序能够在单域 cookie 数限制下存储更多的结构化数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//要取得某个子cookie 必须先取得cookie 然后在解码值之前需要先像下面这样找到子cookie</span><br><span class="line">class SubCookieUtil {</span><br><span class="line"> static get(name, subName) {</span><br><span class="line"> let subCookies = SubCookieUtil.getAll(name); //getAll用于取得所有子cookie的值 get用于取得一个子cookie</span><br><span class="line"> return subCookies ? subCookies[subName] : null;</span><br><span class="line"> }</span><br><span class="line"> static getAll(name) {</span><br><span class="line"> let cookieName = encodeURIComponent(name) + "=",</span><br><span class="line"> cookieStart = document.cookie.indexOf(cookieName),</span><br><span class="line"> cookieValue = null,</span><br><span class="line"> cookieEnd,</span><br><span class="line"> subCookies,</span><br><span class="line"> parts,</span><br><span class="line"> result = {};</span><br><span class="line"> if (cookieStart &gt; -1) {</span><br><span class="line"> cookieEnd = document.cookie.indexOf(";", cookieStart);</span><br><span class="line"> if (cookieEnd == -1) {</span><br><span class="line"> cookieEnd = document.cookie.length;</span><br><span class="line"> }</span><br><span class="line"> cookieValue = document.cookie.substring(cookieStart +</span><br><span class="line"> cookieName.length, cookieEnd);</span><br><span class="line"> if (cookieValue.length &gt; 0) {</span><br><span class="line"> subCookies = cookieValue.split("&amp;");</span><br><span class="line"> for (let i = 0, len = subCookies.length; i &lt; len; i++) {</span><br><span class="line"> parts = subCookies[i].split("=");</span><br><span class="line"> result[decodeURIComponent(parts[0])] =</span><br><span class="line"> decodeURIComponent(parts[1]);</span><br><span class="line"> }</span><br><span class="line"> return result;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> return null;</span><br><span class="line"> }</span><br><span class="line"> // 省略其他代码</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-cookie-的注意事项"><a href="#使用-cookie-的注意事项" class="headerlink" title="使用 cookie 的注意事项"></a>使用 cookie 的注意事项</h4><p><code>HTTP-only</code>可在浏览器设置 也可以在服务器设置 但是只能在服务器上读取 这是因为 JavaScript 无法取得这种 cookie 的值</p><p><code>**http-only</code>的作用**</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果cookie中设置了http-only属性 那么通过js脚本无法读取cookie信息 这样能有效防止XSS攻击 窃取cookie内容 这样增加了cookie1的安全性</span><br><span class="line">XSS攻击：跨站脚本攻击 属于被动式且客户端的攻击方式 原理是攻击者向有XSS漏洞的网站中输入恶意HTML代码 当其他用户浏览该网站时 这段HTML代码会自动执行 从而达到攻击的目的 通常用来盗取用户Cookie 破坏页面结构 重定向到其他网站等</span><br></pre></td></tr></tbody></table></figure><p>因为所有 cookie 都会作为请求头部由浏览器发送给服务器，所以在 cookie 中保存大量信息可能会影 响特定域浏览器请求的性能。保存的 cookie 越大，请求完成的时间就越长。即使浏览器对 cookie 大小有 限制，最好还是尽可能只通过 cookie 保存必要信息，以避免性能问题。 对 cookie 的限制及其特性决定了 cookie 并不是存储大量数据的理想方式。因此，其他客户端存储技 术出现</p><blockquote><p>不要在 cookie 中存储重要或敏感的信息。cookie 数据不是保存在安全的环境中，因 此任何人都可能获得。应该避免把信用卡号或个人地址等信息保存在 cookie 中</p></blockquote><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p>解决通过客户端储存不需要频繁发送回服务器的数据时使用 cookie 的问题</p><ul><li>提供在 cookie 之外的储存会话数据的途径</li><li>提供跨会话持久化储存大量数据的机制</li></ul><p><code>localStorage</code> 是 永久存储机制，<code>sessionStorage</code> 是跨会话的存储机制</p><h4 id="Storage-类型"><a href="#Storage-类型" class="headerlink" title="Storage 类型"></a>Storage 类型</h4><p>用于保存名/值对数据</p><ul><li><code>clear（）</code>：删除所有值</li><li><code>getItem(name)</code>:取得给定 name 的值</li><li><code>key(index):</code>取得给定数值位置名称</li><li><code>removeItem(name):</code>删除给定的 name 的名/值对</li><li><code>setItem(name, value)</code>:设置给定 name 的值</li></ul><h4 id="sessionStorage-对象"><a href="#sessionStorage-对象" class="headerlink" title="sessionStorage 对象"></a>sessionStorage 对象</h4><p><code>sessionStorage</code> 对象只存储会话数据，这意味着数据只会存储到浏览器关闭</p><p>因为 <code>sessionStorag</code>e 对象与服务器会话紧密相关，所以在运行本地文件时不能使用。存储在 <code>sessionStorage</code> 对象中的数据只能由最初存储数据的页面使用，在多页应用程序中的用处有限</p><p><strong>浏览器在实现存储的时候使用同步阻塞方式 因此数据会立即被提交到储存</strong></p><p><strong>通过 webStorage 写入的任何数据都能被立即读取</strong></p><p>可以使用 for-in 循环迭代<code>sessionStorage</code>的值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> sessionStorage) {</span><br><span class="line">  <span class="comment">//每次循环 key都会被赋予sessionStorage中的一个名称 这里不会返回内置方法或length属性</span></span><br><span class="line">  <span class="keyword">let</span> value = sessionStorage.<span class="title function_">getItem</span>(key);</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">${key}</span>=<span class="subst">${value}</span>`</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以使用<code>delete</code>或<code>removeItem</code>删除<code>sessionStorage</code>的数据</p><h4 id="localStorage-对象"><a href="#localStorage-对象" class="headerlink" title="localStorage 对象"></a>localStorage 对象</h4><p><strong>要想访问同一个 localStorage 对象 页面必须来自同一个域（子域不可以</strong>） <strong>在相同的端口上使用相同的协议</strong></p><p>两种存储方法的区别在于，存储在 localStorage 中的数据会保留到通过 JavaScript 删除或者用户 清除浏览器缓存。localStorage 数据不受页面刷新影响，也不会因关闭窗口、标签页或重新启动浏览 器而丢失。</p><h4 id="储存事件"><a href="#储存事件" class="headerlink" title="储存事件"></a>储存事件</h4><p>每当 Storage 对象发生变化时 都会在文档上触发 storage 事件</p><ul><li><code>domain</code>：存储变化对应的域。</li><li><code>key：</code>被设置或删除的键。。</li><li><code>newValue</code>：键被设置的新值，若键被删除则为 null。</li><li><code>oldValue</code>：键变化之前的值。</li></ul><p>对于 <code>sessionStorage</code> 和 <code>localStorage</code> 上的任何更改都会触发 storage 事件，但 storage 事 件不会区分这两者</p><h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><p><code>indexedDB</code>的请求几乎都是<strong>异步</strong>的 添加<code>onerror</code>和<code>onsuccess</code> 事件处理程序来确定输出</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>使用对象储存</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db,</span><br><span class="line">  request,</span><br><span class="line">  version = <span class="number">1</span>;</span><br><span class="line">request = indexedDB.<span class="title function_">open</span>(<span class="string">"admin"</span>, version); <span class="comment">//如果存在数据库就打开 否则发送创建并打开这个数据库的请求</span></span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  event <span class="comment">//失败事件</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">`Failed to open: <span class="subst">${event.target.errorCode}</span>`</span>);</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">//成功事件</span></span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>简历好数据库连接后就是使用对象储存了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设插入一条user记录</span></span><br><span class="line"><span class="keyword">let</span> user = {</span><br><span class="line">  <span class="attr">username</span>: <span class="string">"007"</span>,</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">"James"</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">"Bond"</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">"foo"</span>,</span><br><span class="line">}; <span class="comment">//用户名必须全局唯一 因为创建储存时必须指定一个键</span></span><br><span class="line"><span class="comment">//open操作触发了upgradeneeded事件 因此可以在事件处理程序中更新数据库模式</span></span><br><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="comment">// 如果存在则删除当前 objectStore。测试的时候可以这样做</span></span><br><span class="line">  <span class="comment">// 但这样会在每次执行事件处理程序时删除已有数据</span></span><br><span class="line">  <span class="keyword">if</span> (db.<span class="property">objectStoreNames</span>.<span class="title function_">contains</span>(<span class="string">"users"</span>)) {</span><br><span class="line">    db.<span class="title function_">deleteObjectStore</span>(<span class="string">"users"</span>);</span><br><span class="line">  }</span><br><span class="line">  db.<span class="title function_">createObjectStore</span>(<span class="string">"users"</span>, { <span class="attr">keyPath</span>: <span class="string">"username"</span> }); <span class="comment">//这里第二个参数的 keyPath 属性表示应该用作键的存储对象的属性名。</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务通过调用数据库对象的<code>transaction</code>方法创建</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> transaction = db.<span class="property">transaction</span>; <span class="comment">//如果不指定参数 则对数据库中所有对象储存有只读权限</span></span><br><span class="line"><span class="comment">//可以指定一个或多个要访问的对象存储的名称（传入名称数组）</span></span><br><span class="line"><span class="keyword">let</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">"users"</span>, <span class="string">"readwrite"</span>); <span class="comment">//"readonly"、"readwrite"或"versionchange"权限问题</span></span><br></pre></td></tr></tbody></table></figure><p>有了事务的引用，就可以使用 <code>objectStore()</code>方法并传入对象存储的名称以访问特定的对象存储。 然后，可以使用 <code>add()</code>和 <code>put()</code>方法添加和更新对象，使用 <code>get()</code>取得对象，使用 <code>delete(</code>)删除对象， 使用 <code>clear()</code>删除所有对象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">"users"</span>),</span><br><span class="line">  store = transaction.<span class="title function_">objectStore</span>(<span class="string">"users"</span>),</span><br><span class="line">  request = store.<span class="title function_">get</span>(<span class="string">"007"</span>);</span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">"Did not get the object!"</span>);</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">result</span>.<span class="property">firstName</span>);</span><br><span class="line">transaction.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 整个事务被取消</span></span><br><span class="line">};</span><br><span class="line">transaction.<span class="property">oncomplete</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 整个事务成功完成</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>不能通过<code>oncomplete</code>事件处理程序的<code>event</code>对象访问<code>get（）</code>请求返回的任何数据 因此 仍然需要通过请求的<code>onsuccess</code>事件处理程序来获取数据</p><h4 id="插入对象"><a href="#插入对象" class="headerlink" title="插入对象"></a>插入对象</h4><p>使用<code>add()</code>或<code>put()</code>写入数据 <code>add（）</code>是插入新值 而<code>put</code>是更新值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users 是一个用户数据的数组</span></span><br><span class="line"><span class="keyword">let</span> request,</span><br><span class="line">  requests = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> users) {</span><br><span class="line">  request = store.<span class="title function_">add</span>(user); <span class="comment">//将请求对象保存到一个变量 然后为它添加onerror和onSuccess事件</span></span><br><span class="line">  request.<span class="property">onerror</span> = <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  };</span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// 处理成功</span></span><br><span class="line">  };</span><br><span class="line">  requests.<span class="title function_">push</span>(request);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="通过游标查询"><a href="#通过游标查询" class="headerlink" title="通过游标查询"></a>通过游标查询</h4><p>如果想要取得多条数据 则需要在事务中创建一个游标（指向结果集的指针）使用<code>openCursor()</code>创建</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onst transaction = db.<span class="title function_">transaction</span>(<span class="string">"users"</span>),</span><br><span class="line"> store = transaction.<span class="title function_">objectStore</span>(<span class="string">"users"</span>),</span><br><span class="line"> request = store.<span class="title function_">openCursor</span>();</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"> <span class="comment">// 处理成功</span></span><br><span class="line">    <span class="comment">//可以通过event.target.result访问对象储存中的下一条记录 包含着IDBCursor实例</span></span><br><span class="line">    <span class="comment">//包括属性：direction、 key、 value：实际的对象（需要用JSON编码） primaryKey：游标使用的键</span></span><br><span class="line">};</span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"> <span class="comment">// 处理错误</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>游标可用于更新个别记录 <code>update（）</code>方法指定使用的对象更新当前游标对应的值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"> <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"> <span class="keyword">let</span> value,</span><br><span class="line"> updateRequest;</span><br><span class="line"> <span class="keyword">if</span> (cursor) { <span class="comment">// 永远要检查</span></span><br><span class="line"> <span class="keyword">if</span> (cursor.<span class="property">key</span> == <span class="string">"foo"</span>) {</span><br><span class="line"> value = cursor.<span class="property">value</span>; <span class="comment">// 取得当前对象</span></span><br><span class="line"> value.<span class="property">password</span> = <span class="string">"magic!"</span>; <span class="comment">// 更新密码</span></span><br><span class="line"> updateRequest = cursor.<span class="title function_">update</span>(value); <span class="comment">// 请求保存更新后的对象</span></span><br><span class="line"> updateRequest.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> {</span><br><span class="line"> <span class="comment">// 处理成功</span></span><br><span class="line"> };</span><br><span class="line"> updateRequest.<span class="property">onerror</span> = <span class="function">() =&gt;</span> {</span><br><span class="line"> <span class="comment">// 处理错误</span></span><br><span class="line"> };</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> <span class="comment">//也可以调用delete（）删除游标位置的记录</span></span><br></pre></td></tr></tbody></table></figure><p>如果事务没有修改对象储存的权限 <code>uodate（）和delete（）</code>都会抛出错误</p><p>默认情况下 每个游标只会创建一个请求 如果想要创建另一个请求 必须调用以下方法</p><ul><li><code>continue（key）</code>：移动到结果集中的下一条记录 如果没有指定 key 则移动到下一条 否则移动到指定的</li><li><code>advance（count）</code>：向前移动指定 count 条记录</li></ul><p>这两个方法都会让游标重用相同的请求 因此也会重用<code>onsuccess和onerror</code>处理程序 知道不需要</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">if</span> (cursor) {</span><br><span class="line">    <span class="comment">// 永远要检查</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Key: <span class="subst">${cursor.key}</span>, Value: <span class="subst">${<span class="built_in">JSON</span>.stringify(cursor.value)}</span>`</span>);</span><br><span class="line">    cursor.<span class="title function_">continue</span>(); <span class="comment">// 移动到下一条记录</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Done!"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="comment">//调用cursor.continue()会触发另一个请求并再次调用onsuccess事件处理程序 在没有更多记录时 onsuccess最后一次被调用 此时event.target.result = null</span></span><br></pre></td></tr></tbody></table></figure><h4 id="键范围"><a href="#键范围" class="headerlink" title="键范围"></a>键范围</h4><p>使用键范围可以让游标更容易管理 键范围对应 IDBKeyRange 的实例</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onlyRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">only</span>(<span class="string">"007"</span>);</span><br><span class="line">这个范围保证只获取键为<span class="string">"007"</span>的值。使用这个范围创建的游标类似于直接访问对象存储并调用</span><br><span class="line"><span class="title function_">get</span>(<span class="string">"007"</span>)。</span><br><span class="line">第二种键范围可以定义结果集的下限。下限表示游标开始的位置。例如，下面的键范围保证游标从</span><br><span class="line"><span class="string">"007"</span>这个键开始，直到最后：</span><br><span class="line"><span class="comment">// 从"007"记录开始，直到最后</span></span><br><span class="line"><span class="keyword">const</span> lowerRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">lowerBound</span>(<span class="string">"007"</span>); <span class="comment">//如果想要从后面的记录开始 则传入true</span></span><br><span class="line">第二种键范围可以定义结果集的下限。下限表示游标开始的位置。例如，下面的键范围保证游标从</span><br><span class="line"><span class="string">"007"</span>这个键开始，直到最后：</span><br><span class="line"><span class="comment">// 从"007"记录开始，直到最后</span></span><br><span class="line"><span class="keyword">const</span> lowerRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">lowerBound</span>(<span class="string">"007"</span>);<span class="comment">//不想包含指定的键 则传入true</span></span><br><span class="line">要同时指定下限和上限，可以使用 <span class="title function_">bound</span>()方法。这个方法接收四个参数：下限的键、上限的键、</span><br><span class="line">可选的布尔值表示是否跳过下限和可选的布尔值表示是否跳过上限</span><br><span class="line">要同时指定下限和上限，可以使用 <span class="title function_">bound</span>()方法。这个方法接收四个参数：下限的键、上限的键、</span><br><span class="line">可选的布尔值表示是否跳过下限和可选的布尔值表示是否跳过上限</span><br><span class="line">定义了范围之后，把它传给 <span class="title function_">openCursor</span>()方法，就可以得到位于该范围内的游标：</span><br><span class="line"><span class="keyword">const</span> store = db.<span class="title function_">transaction</span>(<span class="string">"users"</span>).<span class="title function_">objectStore</span>(<span class="string">"users"</span>),</span><br><span class="line"> range = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">"007"</span>, <span class="string">"ace"</span>);</span><br><span class="line"> request = store.<span class="title function_">openCursor</span>(range);</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params">event</span>){</span><br><span class="line"> <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"> <span class="keyword">if</span> (cursor) { <span class="comment">// 永远要检查</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Key: <span class="subst">${cursor.key}</span>, Value: <span class="subst">${<span class="built_in">JSON</span>.stringify(cursor.value)}</span>`</span>);</span><br><span class="line"> cursor.<span class="title function_">continue</span>(); <span class="comment">// 移动到下一条记录</span></span><br><span class="line"> } <span class="keyword">else</span> {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Done!"</span>);</span><br><span class="line"> }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p>如果两个不同的浏览器标签同时打开了同一个网页 可能出现一个网页尝试升级数据库而另一个网页尚未就绪的情形</p><p>应该在每次成功打开数据库后都指定 onversionchange 事件处理程序。记住，onversionchange 有可能会被其他标签页触发。</p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>无论一个模块在 require（）中被引用多少次 模块永远时单例（无论请求多少次 module 只会被加载一次）</p><p>模块第一次被加载后会被缓存 后续加载会取得缓存的模块 模块加载顺序由依赖图决定</p><p>在 CommonJS 中 模块加载是模块系统的同步操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"moduleA"</span>);</span><br><span class="line"><span class="keyword">if</span> (loadCondition) {</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">"./moduleA"</span>); <span class="comment">//moduleA会在loadCondition为true是才会加载 这个加载是同步的 因此if之前的任何代码都会在加载moduleA之前执行 而if之后的任何代码都会在module执行之后执行 如果moduleA已经在前面某个地方加载过 这个条件的require意味着只暴露moduleA这个命名空间而已</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="异步模块定义（AMD）"><a href="#异步模块定义（AMD）" class="headerlink" title="异步模块定义（AMD）"></a>异步模块定义（AMD）</h3><p><code>COmmonJS</code>以服务器为目标环境 能够一次性将所有的模块都加载到内存中 而异步模块定义（<code>AMD</code>）的模块定义系统则以浏览器为目标执行环境 这需要考虑网络延迟的问题。</p><p><code>AMD</code>的一般策略是让模块<strong>声明</strong>自己的依赖 而运行在浏览器中的模块系统会<strong>按需获取依赖</strong> 并在依赖<strong>加载完成后</strong>立即执行依赖他们的模块</p><p><code>AMD</code>模块实现的核心是用<strong>函数包装</strong>模块定义 这样可以防止声明<strong>全局变量</strong> 并允许加载器控制何时加载模块</p><p><code>AMD</code>模块可以使用字符串标识符指定自己的依赖 而<code>AMD加载器</code>会在所有依赖模块加载完毕后立即调用模块工厂函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ID 为'moduleA'的模块定义。moduleA 依赖 moduleB，</span></span><br><span class="line"><span class="comment">// moduleB 会异步加载</span></span><br><span class="line"><span class="title function_">define</span>(<span class="string">'moduleA'</span>, [<span class="string">'moduleB'</span>], <span class="keyword">function</span>(<span class="params">moduleB</span>) {</span><br><span class="line"> <span class="keyword">return</span> {</span><br><span class="line"> <span class="attr">stuff</span>: moduleB.<span class="title function_">doStuff</span>();</span><br><span class="line"> };</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>AMD 也支持<code>require和exports</code>对象 通过他们可以在 AMD 模块工厂函数内部定义 CommonJS 风格的模块</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="string">'moduleA'</span>, [<span class="string">'require'</span>, <span class="string">'exports'</span>], <span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span></span>) {</span><br><span class="line"> <span class="keyword">var</span> moduleB = <span class="built_in">require</span>(<span class="string">'moduleB'</span>);</span><br><span class="line"> <span class="built_in">exports</span>.<span class="property">stuff</span> = moduleB.<span class="title function_">doStuff</span>();</span><br><span class="line">});</span><br><span class="line">动态依赖也是通过这种方式支持的：</span><br><span class="line"><span class="title function_">define</span>(<span class="string">'moduleA'</span>, [<span class="string">'require'</span>], <span class="keyword">function</span>(<span class="params"><span class="built_in">require</span></span>) {</span><br><span class="line"> <span class="keyword">if</span> (condition) {</span><br><span class="line"> <span class="keyword">var</span> moduleB = <span class="built_in">require</span>(<span class="string">'moduleB'</span>);</span><br><span class="line"> }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h4><p><code>UMD</code>用于创建两个系统都可以使用的模块代码 本质上 UMD 定义的模块会在启动时检测到要使用那个模块系统 然后进行适当配置 并把所有逻辑包装在一个立即调用的函数表达式中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) {</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.<span class="property">amd</span>) {</span><br><span class="line">    <span class="comment">// AMD。注册为匿名模块</span></span><br><span class="line">    <span class="title function_">define</span>([<span class="string">"moduleB"</span>], factory);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="variable language_">module</span>.<span class="property">exports</span>) {</span><br><span class="line">    <span class="comment">// Node。不支持严格 CommonJS</span></span><br><span class="line">    <span class="comment">// 但可以在 Node 这样支持 module.exports 的</span></span><br><span class="line">    <span class="comment">// 类 CommonJS 环境下使用</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">" moduleB "</span>));</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 浏览器全局上下文（root 是 window）</span></span><br><span class="line">    root.<span class="property">returnExports</span> = <span class="title function_">factory</span>(root.<span class="property">moduleB</span>);</span><br><span class="line">  }</span><br><span class="line">})(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">moduleB</span>) {</span><br><span class="line">  <span class="comment">// 以某种方式使用 moduleB</span></span><br><span class="line">  <span class="comment">// 将返回值作为模块的导出</span></span><br><span class="line">  <span class="comment">// 这个例子返回了一个对象</span></span><br><span class="line">  <span class="comment">// 但是模块也可以返回函数作为导出值</span></span><br><span class="line">  <span class="keyword">return</span> {};</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h1 id="工作者线程"><a href="#工作者线程" class="headerlink" title="工作者线程"></a>工作者线程</h1><p>使用工作者线程 浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境 这个子环境不能与依赖单线程交互的 API 互操作 但可以与父环境并行执行代码</p><h3 id="工作者线程和线程"><a href="#工作者线程和线程" class="headerlink" title="工作者线程和线程"></a>工作者线程和线程</h3><ul><li>工作者线程是以实际线程实现的</li><li>工作者线程并行执行 虽然页面和工作者线程都是单线程 JavaScript 环境 每个环境中的指令可以并行执行</li><li>工作者线程可以共享某些内存 使用<code>SharedArrayBuffer</code> 在多个环境间共享 内容 JavaScript 使用 <code>Atomics</code> 接口实现并发控制</li><li>工作者线程不共享全部内存</li><li>工作者线程不一定再同一个进程里</li><li>创建工作者线程的开销更大 工作者线程有自己独立的<strong>事件循环</strong> <strong>全局对象</strong> <strong>事件处理程序</strong>和其他 js<strong>环境</strong>必须的特性</li></ul><p><strong>工作者线程相对比较重 不建议大量使用 工作者线程应该是长期运行的 启动成本比较高 每个实例占用的内存耶比较大</strong></p><h3 id="工作者线程的类型"><a href="#工作者线程的类型" class="headerlink" title="工作者线程的类型"></a>工作者线程的类型</h3><p>专用工作者线程、共享工作者线程和服务工作者线程</p><h4 id="专用工作者线程"><a href="#专用工作者线程" class="headerlink" title="专用工作者线程"></a>专用工作者线程</h4><p>可以让脚本单独创建一个 js 线程 只能被创建它的页面使用</p><h4 id="共享工作者线程"><a href="#共享工作者线程" class="headerlink" title="共享工作者线程"></a>共享工作者线程</h4><p>可以被多个不同的上下文使用 任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送 消息或从中接收消息</p><h4 id="服务工作者线程"><a href="#服务工作者线程" class="headerlink" title="服务工作者线程"></a>服务工作者线程</h4><p>主要用于拦截、重定向和修改页面发出的请求 充当网络请求的仲裁者</p><h1 id="ES2018-与-ES2019"><a href="#ES2018-与-ES2019" class="headerlink" title="ES2018 与 ES2019"></a>ES2018 与 ES2019</h1><p>剩余运算符再对象间执行前复制 因此只会复制对象的引用而不会克隆整个对象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = { <span class="attr">name</span>: <span class="string">"Matt"</span>, <span class="attr">age</span>: <span class="number">27</span>, <span class="attr">job</span>: { <span class="attr">title</span>: <span class="string">"Engineer"</span>, <span class="attr">level</span>: <span class="number">10</span> } };</span><br><span class="line"><span class="keyword">const</span> { ...remainingData } = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person === remainingData); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">job</span> === remainingData.<span class="property">job</span>); <span class="comment">// true</span></span><br><span class="line">remainingData.<span class="property">name</span> = <span class="string">"olddog"</span>;</span><br><span class="line">person.<span class="property">name</span> = <span class="string">"wqdq"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(remainingData.<span class="property">name</span>); <span class="comment">//olddog</span></span><br><span class="line">person.<span class="property">name</span>; <span class="comment">//wqdq</span></span><br><span class="line">person.<span class="property">job</span>.<span class="property">title</span> = <span class="string">"123"</span>;</span><br><span class="line">remainingData.<span class="property">job</span>, title; <span class="comment">//123</span></span><br></pre></td></tr></tbody></table></figure><p>剩余运算符会复制所有自有可枚举属性 包括括号</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> foo = { <span class="attr">a</span>: <span class="number">1</span>, [s]: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> };</span><br><span class="line"><span class="keyword">const</span> { a, ...remainingData } = foo;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(remainingData);</span><br></pre></td></tr></tbody></table></figure><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符会像拼接数组一样合并两个对象 应用到内部对象的扩展运算符会对所有自有可枚举属性执行浅复制到外部对象 包括符号</p><ul><li>对象跟踪插入顺序 从扩展对象复制的属性按照他们在对象字面量中列出的顺序插入</li><li>对象会覆盖重名属性 出现重名属性时会使用后续出现的值</li><li>与剩余操作符一样 所有复制都是浅复制</li></ul><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p>有了<code>Promise.prototype.finally</code>可以统一共享的处理程序 <code>finally（）</code>不传递任何参数 也不知道自己处理的<code>promise</code>是什么状态</p><p>每个<code>finally（）</code>都会创建一个新的<code>promise</code>实例 而这个新<code>promise</code>会被添加到浏览器的微任务队列 只有前面的处理程序执行完成才会解决</p><h3 id="数组打平方法"><a href="#数组打平方法" class="headerlink" title="数组打平方法"></a>数组打平方法</h3><blockquote><p><code>flat()</code>和 <code>flatMap()</code>只能用于打平嵌套数组。嵌套的可迭代对象如 Map 和 Set 不能打平</p></blockquote><h4 id="Array-prototype-flatten"><a href="#Array-prototype-flatten" class="headerlink" title="Array.prototype.flatten()"></a>Array.prototype.flatten()</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打平数组的实例实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">sourceArray, flattenedArray = []</span>) {</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> sourceArray) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(element)) {</span><br><span class="line">      <span class="title function_">flatten</span>(element, flattenedArray);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      flattenedArray.<span class="title function_">push</span>(element);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> flattenedArray;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> arr = [[<span class="number">0</span>], <span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]], <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br><span class="line"><span class="comment">//重写邦本 允许指定打平到第几级嵌套</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">sourceArray, depth, flattenedArray = []</span>) {</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> sourceArray) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(element) &amp;&amp; depth &gt; <span class="number">0</span>) {</span><br><span class="line">      <span class="title function_">flatten</span>(element, depth - <span class="number">1</span>, flattenedArray);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      flattenedArray.<span class="title function_">push</span>(element);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> flattenedArray;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> arr = [[<span class="number">0</span>], <span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]], <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, [4, 5], 6]</span></span><br></pre></td></tr></tbody></table></figure><p><code>Array.prototype.flat()</code> 接收一个 depth 参数 默认为 1 返回一个打平 Array 实例的浅复制版本</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [[<span class="number">0</span>], <span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> arr1 = arr.<span class="title function_">flat</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">//[0,1,2,3,4,5,6]</span></span><br><span class="line">arr1.<span class="title function_">push</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">//[0,1,2,3,4,5,6,10]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">//[[0], 1, 2, [3, [4, 5]], 6]</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap()"></a>Array.prototype.flatMap()</h4><p><code>Array.prototype.flatMap()</code>方法会在打平数组之前执行一次映射操作。在功能上，<code>arr.flatMap(f)</code> 与 <code>arr.map(f).flat()</code>等价；但 <code>arr.flatMap()</code>更高效，因为浏览器只需要执行<strong>一次遍历</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [[<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">5</span>]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">map</span>(<span class="function">(<span class="params">[x]</span>) =&gt;</span> [x, x + <span class="number">1</span>]));</span><br><span class="line"><span class="comment">// [[1, 2], [3, 4], [5, 6]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">flatMap</span>(<span class="function">(<span class="params">[x]</span>) =&gt;</span> [x, x + <span class="number">1</span>]));</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure><p><code>flatMap()</code>在非数组对象的方法返回数组时特别有用，例如字符串的 <code>split()</code>方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一组输入字符串分割为单词 然后把这些单词拼接成一个单词数组</span></span><br><span class="line"><span class="keyword">const</span> arr =  [<span class="string">'Lorem ipsum dolor sit amet,'</span>, <span class="string">'consectetur adipiscing elit.'</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="title function_">split</span>(<span class="regexp">/[\W+]/</span>)));</span><br><span class="line"><span class="comment">// ["Lorem", "ipsum", "dolor", "sit", "amet", "", "consectetur", "adipiscing",</span></span><br><span class="line"><span class="string">"elit"</span>, <span class="string">""</span>]</span><br></pre></td></tr></tbody></table></figure><h4 id="Object-formEntries"><a href="#Object-formEntries" class="headerlink" title="Object.formEntries()"></a>Object.formEntries()</h4><p>用于通过键/值对数组的 集合构建对象。这个方法执行与 <code>Object.entries()</code>方法相反的操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="string">"qux"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> objEntries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objEntries);</span><br><span class="line"><span class="comment">// [["foo", "bar"], ["baz", "qux"]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(objEntries));</span><br><span class="line"><span class="comment">// { foo: "bar", baz: "qux" }</span></span><br></pre></td></tr></tbody></table></figure><p>可以快速地将<code>Map</code>实例转换为<code>Object</code>实例 因为 Map 迭代器返回的结果与<code>formEntries（）</code>的参数恰好匹配</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">formEntries</span>(map)); <span class="comment">//{foo: "bar"}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="字符串修理方法"><a href="#字符串修理方法" class="headerlink" title="字符串修理方法"></a>字符串修理方法</h3><p><code>trimStart():</code>删除字符串开头的空格</p><p><code>trimEnd()</code>;删除末尾的空格</p><p>在只有一个空格的情况下 这两个方法相当于执行与<code>padStart()和padEnd()</code>相反的操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">" foo "</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">trimStart</span>()); <span class="comment">// "foo "</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">trimEnd</span>()); <span class="comment">// " foo"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><p>用于取得可选的符号描述 只读的 如果没有描述 默认为<code>undefined</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="title class_">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">description</span>); <span class="comment">//foo</span></span><br></pre></td></tr></tbody></table></figure><h2 id="可选的-catch-绑定"><a href="#可选的-catch-绑定" class="headerlink" title="可选的 catch 绑定"></a>可选的 catch 绑定</h2><p>在<code>try/catch</code>中 可以忽略<code>catch</code>的错误对象不做任何操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"foo"</span>;</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">  <span class="comment">// 发生错误了，但你不想使用错误对象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学JS第一天</title>
      <link href="/2022/04/20/chong-xue-js-di-yi-tian/"/>
      <url>/2022/04/20/chong-xue-js-di-yi-tian/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-中的-JavaScript"><a href="#HTML-中的-JavaScript" class="headerlink" title="HTML 中的 JavaScript"></a>HTML 中的 JavaScript</h1><h2 id="1-script-元素"><a href="#1-script-元素" class="headerlink" title="1.script 元素"></a>1.script 元素</h2><ul><li>crossorigin：可选。配置相关请求的 CORS（跨源资源共享）设置。默认不使用 CORS。crossorigin= “anonymous”配置文件请求不必设置凭据标志。crossorigin=”use-credentials”设置凭据 标志，意味着出站请求会包含凭据</li><li>defer：可选 表示脚本可以延迟到文档完全被解析和显示之后再执行 只对外部脚本文件有效</li><li>integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性 果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错， 脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提 供恶意内容</li></ul><p>使用了 src 属性的<code>&lt;script&gt;</code>元素不应该再在<code>&lt;script&gt;</code>标签之间再包含其他 js 代码 如果两者都提供的话 浏览器只会下载并执行标本文件 从而忽略行内代码</p><p><strong>浏览器会根据特定的设置缓存所有外部连接的 JavaScript 文件 这意味着如果两个页面都用到同个文件 则该文件只需要下载一次 这最终意味着页面加载更快</strong></p><h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h4 id="const优先-let次之"><a href="#const优先-let次之" class="headerlink" title="const优先 let次之"></a><code>const</code>优先 <code>let</code>次之</h4><p>使用<code>const</code>声明可以让浏览器运行时强制保持变量不变 也可以让静态代码分析工具提前法相不合法的赋值操作。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><p><code>typeof null == object</code> null 被认为是一个对空对象的引用</p><blockquote><p>tips：我们建议在声明变量的同时进行初始化 这样当 <code>typeof</code>返回<code>undefined</code>时我们知道是因为给定的变量尚未声明而不是声明了但没有初始化</p><p>tips：当我们定义一个未来将会赋值对象的变量时 应该初始化为 null（可以保持 null 是空对象指针的语义 并与 undefined 区分开</p><p>.）</p></blockquote><blockquote><p><code>isNaN()</code> 可以用来测试对象 此时会先调用对象的<code>valueOf（）</code>方法 然后再确定返回的值是否可以转换为数值 如果不能 再调用<code>toString()</code>方法 再测试其返回值 这通常是 ES 内置函数和操作符的工作方式</p></blockquote><h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>（）</span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span> || <span class="literal">null</span> - <span class="number">0</span> || <span class="literal">undefined</span> - <span class="title class_">NaN</span> || <span class="title class_">Object</span> 先用valueof 如果是<span class="title class_">NaN</span> 则用toString（）</span><br></pre></td></tr></tbody></table></figure><p><strong>字符串是不可变的 要修改某个变量中的字符串的值 必须先销毁原始的字符串 然后将包括新值的另一个字符串保存到该变量中</strong></p><p>用加号操作符给一个值加上一个<code>“”</code>也可以将其转换为字符串</p><h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><p>符号是原始值 且符号实例唯一 不可变 用于确保对象属性使用唯一标识符 不会发生属性冲突的危险 可以用来创建唯一记号 进而用作非字符串形式的对象属性</p><p>符号没有字面量语法 即只要创建<code>Symbol（）</code>实例并将其用作对象的新属性 就可以保证它不会覆盖以有的对象属性 无论是符号属性还是字符串属性</p><p><code>Symbol（）</code>函数不能与 new 关键字一起作为构造函数使用 这样做是为了避免创建符号包装对象 如果想使用符号包装对象 可以使用<code>Object()</code>函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> myWarpSymbol = <span class="title class_">Object</span>(mySymbol);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> myWarpSymbol); <span class="comment">//object</span></span><br></pre></td></tr></tbody></table></figure><h4 id="使用全局符号注册表"><a href="#使用全局符号注册表" class="headerlink" title="使用全局符号注册表"></a>使用全局符号注册表</h4><p>如果运行时的不同部分需要共享和重用符号实例 可以使用一个字符串作为键 再全局符号注册表中创建并重用符号 需要使用<code>Symbol.for()</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooGolbalSymbol);<span class="comment">//symbol</span></span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">for</span>()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运</span><br><span class="line">行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同</span><br><span class="line">字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例</span><br><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">'foo'</span>); <span class="comment">// 创建新符号</span></span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">'foo'</span>); <span class="comment">// 重用已有符号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooGlobalSymbol === otherFooGlobalSymbol); <span class="comment">// true</span></span><br><span class="line">即使采用相同的符号描述 在全局注册表中定义的符号跟使用<span class="title class_">Symbol</span>（）定义的符号也并不相同</span><br><span class="line"><span class="keyword">let</span> localSymbol = <span class="title class_">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localSymbol === globalSymbol); <span class="comment">// false</span></span><br><span class="line">还可以使用 <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字</span><br><span class="line">符串键。如果查询的不是全局符号，则返回 <span class="literal">undefined</span>。</span><br><span class="line"><span class="comment">// 创建全局符号</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s)); <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 创建普通符号</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2)); <span class="comment">// undefined</span></span><br><span class="line">如果传给 <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>()的不是符号，则该方法抛出 <span class="title class_">TypeError</span>：</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(<span class="number">123</span>); <span class="comment">// TypeError: 123 is not a symbol</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><ul><li>hasOwnProperty（propertyName）：判断当前对象实例（不是原型）上是否存在特定的属性</li><li>isPrototypeOf（object）：判断当前对象是否为另一个对象的原型</li><li>peopertyIsEnumerable（propertyName）：用于判断给定的属性是否可以使用 for-in 循环</li></ul><blockquote><p>由于相等和不相等操作符存在类型转换问题 因此推荐使用全等和不全等操作符 这样有助于在代码中保持数据类型的完整性</p></blockquote><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>为了确保局部变量不被修改 推荐使用 const for-in 不能保证返回对象属性的顺序 如果迭代的变量是 null 或者 undefined 则不执行循环体</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> <span class="variable language_">window</span>) {</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">write</span>(propName);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>for-of</p><p>for-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素。</p><blockquote><p>for-await-of 循环 支持生成 promise 的异步可迭代对象</p></blockquote><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><blockquote><p>switch 语句在比较每个条件的值时会使用全等操作符 因此不会强制转换数据类型</p></blockquote><h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><p>原始值：按值访问</p><p>引用值：对该对象的引用而不是实际的对象本身</p><h4 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h4><ul><li>1.原始值</li></ul><p>在通过变量把原始值赋值给另一个变量时 原始值会被复制到新变量的位置 这两个位置是完全独立的 互不干扰</p><ul><li>2.引用值</li></ul><p>在把引用值从一个变量赋给另一个变量时 储存在变量中的值也会被复制到新变量所在的位置 区别在于这里复制的值实际上时一个指针 它指向储存在堆内存中的对象那个 操作完成后 两个变量实际上指向同一个对象 因此一个对象上面的变化也会从另一个对象上反映出来</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></tbody></table></figure><h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p><strong>ECMAScript 中所有函数的参数都是值传递（ECMAScipt 不可能引用传递）</strong> 这就意味着函数外的值会被复制到函数内部的参数中 就像一个变量复制到另一个变量一样 （如果是原始值 就和原始值变量的复制一样 如果是引用值 就和引用值的复制一样）</p><blockquote><p>按值传递参数时 值会被复制到一个局部变量（一个命名参数 即 arguments 对象中的一个槽位）</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">num</span>) {</span><br><span class="line">  <span class="comment">//这里的num其实是一个局部变量</span></span><br><span class="line">  num += <span class="number">10</span>; <span class="comment">//不会影响到外部的count</span></span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">addTen</span>(count); <span class="comment">//30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">//20</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) { <span class="comment">//obj指向的对象保存在全局作用域的堆内存上 所以也会使外部的对象放映这个变化</span></span><br><span class="line"> obj.<span class="property">name</span> = <span class="string">"Nicholas"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// "Nicholas"</span></span><br><span class="line">----------------------------------<span class="comment">//证明为啥不是引用传递</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) {</span><br><span class="line"> obj.<span class="property">name</span> = <span class="string">"Nicholas"</span>; <span class="comment">//影响到了外部的变量</span></span><br><span class="line"> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//被重写 变成了一个指向本地的指针 函数执行结束后就被销毁了 本来也不会影响到外部的对象</span></span><br><span class="line"> obj.<span class="property">name</span> = <span class="string">"Greg"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// "Nicholas"</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>函数中的参数就是局部变量</p></blockquote><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><p>使用 typeof 判断原始值 使用 instance of 判断引用类型（由原型链决定）</p><blockquote><p>如果想让整个对象都不能被更改 可以使用 freeze（）</p></blockquote><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h4 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h4><p>当变量进入上下文的时候 将变量加上存在于上下文中的标记 当变量离开上下文时 加上离开上下文的标记</p><p>来及回收程序运行的时候 会标记内存中存储的所有变量 然后将所有上下文中的变量以及被在上下文中引用的变量的标记去掉 再次之后再被加上标记的变量就是待删除的 原因是任何在上下文中的变量都访问不到它们了，随后垃圾回收程序做一次内存清理</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>对每个值都记录它被引用的次数 当一个值的引用数为 0 时 就说明没法再访问这个值了 可以安全地回收其内存</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>优化内存占用的最佳手段就是保证再执行代码时只保存必要的数据 如果数据不再必要 就设置为 null 从而释放 这个叫做解除引用（适合全局变量和全局变量的属性 局部变量在超出作用域之后会被自动解除引用）</p><blockquote><p>解除对一个值的引用并不会自动导致相关内存被回收 解除引用的关键在于确保相关的值已经不在上下文中了 因此下一次垃圾回收的时候会被回收</p></blockquote><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>闭包很容易造成内存泄漏</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"Jake"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  };</span><br><span class="line">};</span><br><span class="line"><span class="comment">//调用outer()会导致分配给name的内存被泄漏 因为以上代码执行后创建了一个内部闭包 只要返回的参数存在就不能清理name 因为闭包一直引用着它</span></span><br></pre></td></tr></tbody></table></figure><h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用类型和原始值包装类型（<code>String、Number、Boolean</code>）的主要区别在于对象的生命周期 在通过<code>new</code> 实例化引用类型后 得到的实例会在离开作用域时被销毁 而自动创建的原始值包装对象则指存在于访问它的那行代码执行期间 这意味着不能再运行时给原始值添加属性和方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable constant_">S1</span> - <span class="string">"some text"</span>;</span><br><span class="line">s1.<span class="property">color</span> = <span class="string">'read'</span>;<span class="comment">//临时创建一个String对象 第二行运行后就销毁了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">color</span>)<span class="comment">//undefined//创建了自己的String对象 但是这个对象没有color属性</span></span><br></pre></td></tr></tbody></table></figure><p>在原始值包装类类型的实例上调用 typeof 会返回 object 所有原始值包装对象都会转换为 true</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">"some text"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">String</span>); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>使用<code>new</code>调用原始值包含在那个类型的构造函数和调用同名的转型函数不一样</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">let</span> number = <span class="title class_">Number</span>(value); <span class="comment">// 转型函数 保存的时一个值为25的原始数智</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> number); <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Number</span>(value); <span class="comment">// 构造函数 保存的是一个Number的实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj); <span class="comment">// "object"</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>toFixed()</code>可以表示有 0-20 个小数的数值</p></blockquote><h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><ul><li><p><code>concat()</code>: 将一个或多 i 个字符串拼接成一个新字符串</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello "</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">"world"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// "hello world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// "hello"</span></span><br><span class="line"><span class="comment">//concat()方法可以接收任意多个参数，因此可以一次性拼接多个字符串，</span></span><br></pre></td></tr></tbody></table></figure><p>与 <code>concat()</code>方法一样<code>，slice()、substr() 和 substring()</code>也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>)); <span class="comment">// "lo world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>)); <span class="comment">// "lo world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>)); <span class="comment">// "lo world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// "lo w"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// "lo w"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// "lo worl"</span></span><br><span class="line"><span class="comment">//slice将负值参数当成字符串长度加上负参数值 substr将第一个负参数当成字符串长度加上该值 substring将所有负参数值都当作0</span></span><br><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(-<span class="number">3</span>)); <span class="comment">// "rld"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(-<span class="number">3</span>)); <span class="comment">// "hello world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(-<span class="number">3</span>)); <span class="comment">// "rld"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// "lo w"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// "hel"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// "" (empty string)</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">"o"</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">lastIndexOf</span>(<span class="string">"o"</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">"o"</span>, <span class="number">6</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">lastIndexOf</span>(<span class="string">"o"</span>, <span class="number">6</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></tbody></table></figure><p>判断是否包含另一个字符串的方法：startsWith() endsWith() inclueds()startsWith()检查开始于索引 0 的匹配项，endsWith()检查开始于索 引(string.length - substring.length)的匹配项，而 includes()检查整个字符串</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"foobarbaz"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">"foo"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">"bar"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">"baz"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">"bar"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">"bar"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">"qux"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p><code>trim()</code>:创建字符串的一个副本 删除亲啊后的所有空格符再返回结果 原字符串不受影响 <code>trimLeft()</code>和<code>trimRight（）</code>分别从开始和末尾清理空格</p><p><code>repeat()</code>接收一个参数 表示将字符串复制多少次后返回拼接所有副本后的结果</p><p><code>padStart()</code>和 <code>padEnd()</code>方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至 满足长度条件。</p></li></ul><p>字符串大小写转换：<code>toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()</code></p><h2 id="单例内置对象"><a href="#单例内置对象" class="headerlink" title="单例内置对象"></a>单例内置对象</h2><h3 id="URL-编码方式"><a href="#URL-编码方式" class="headerlink" title="URL 编码方式"></a>URL 编码方式</h3><p><code>encodeURI()</code>和 <code>encodeURIComponent()</code>方法用于编码统一资源标识符（URI），以便传给浏览器</p><blockquote><p>使用 encodeURIComponent()应该比使用 encodeURI()的频率更高， 这是因为编码查询字符串参数比编码基准 URI 的次数更多。</p></blockquote><p><code>encodeURI()</code>和 <code>encodeURIComponent()</code>相对的是 <code>decodeURI()</code>和 <code>decodeURIComponent()</code>。</p><h4 id="eval（）"><a href="#eval（）" class="headerlink" title="eval（）"></a>eval（）</h4><p>解释器 接收一个参数 即耀执行的 js 字符串</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"console.log('h1')"</span>);</span><br><span class="line"><span class="comment">//等价于 console.log("h1")</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>使用 eval 的时候必须慎重 因为这个方法会对 CSS 利用暴露出很大的攻击面 用户可能插入导致你网站或引用奔溃的代码</p></blockquote><h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><blockquote><p>在使用对象字面量表示定义对象时 并不会按实际调用 Object 构造函数</p></blockquote><p><code>from()</code>可用于将类数组结构转换为数组实例 <code>of()</code>用于将一组参数转换为数组实例</p><p><code>Array.from()</code>对数组进行浅复刻</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">form</span>(a1);</span><br><span class="line"><span class="title function_">alert</span>(a1 === a1) <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p><code>Array.from()</code>还可以接收第二个可选的参数 表示直接增强新数组的值 而无需像调用<code>Array.from().map()</code>那样先创建一个中间数组</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1, <span class="function">(<span class="params">x</span>) =&gt;</span> x ** <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(</span><br><span class="line">  a1,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">x</span>) {</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="variable language_">this</span>.<span class="property">exponent</span>;</span><br><span class="line">  },</span><br><span class="line">  { <span class="attr">exponent</span>: <span class="number">2</span> }</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [1, 4, 9, 16]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a3); <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></tbody></table></figure><p><code>Array.of()</code>可以把一组参数转换为数组</p><h4 id="数组的迭代器方法"><a href="#数组的迭代器方法" class="headerlink" title="数组的迭代器方法"></a>数组的迭代器方法</h4><p><code>keys()</code>返回数组索引的迭代器 <code>values()</code>返回数组元素的迭代器 <code>entries()</code>返回索引/值对的迭代器</p><p>使用结构可以非常容易地在循环中拆分键值对</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>, <span class="string">"qux"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [idx, element] <span class="keyword">of</span> a.<span class="title function_">entries</span>()) {</span><br><span class="line">  <span class="title function_">alert</span>(idx);</span><br><span class="line">  <span class="title function_">alert</span>(element);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>fill()</code>静默忽略超出数组边界、零长度以及方向相反的索引范围</p><p><code>copyWithin()</code>会按照指定范围浅复制数组中的部分内容，然后将它们插入到指 定索引开始的位置。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">5</span>); <span class="comment">//从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置</span></span><br><span class="line"><span class="comment">// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始到索引 3 结束的内容</span></span><br><span class="line"><span class="comment">// 插入到索引 4 开始的位置</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// JavaScript 引擎在插值前会完整复制范围内的值</span></span><br><span class="line"><span class="comment">// 因此复制期间不存在重写的风险</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果数组中某一项是 null 或 undefined，则在 join()、toLocaleString()、 toString()和 valueOf()返回的结果中会以空字符串表示</p></blockquote><p><strong>reverse()和 sort()都会返回调用它们的数组的引用</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...arr].<span class="title function_">sort</span>()); <span class="comment">//[1,2,3,4,5,6]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">//[1,3,2,5,4,6]</span></span><br><span class="line"><span class="comment">//使用时需要根据是否可以改变原数组判断创建副本保存</span></span><br></pre></td></tr></tbody></table></figure><p><code>concat()</code>方法可以在现有数组全部元素基础上 创建一个新数组。默认打平 可以使用<code>Symbol.isConcatSpreadable</code>阻止打平</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> newColors = [<span class="string">"black"</span>, <span class="string">"brown"</span>];</span><br><span class="line">newColors[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 强制不打平数组</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">"yellow"</span>, newColors); <span class="comment">// ["red", "green", "blue", "yellow", ["black", "brown"]]</span></span><br></pre></td></tr></tbody></table></figure><p><code>slice()</code>用于创建一个包含原有数组中一个或多个元素的新数组。</p><p><code>splice()</code>的主要目的是 在数组中间插入元素</p><p><code>splice()</code>方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返 回空数组）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,blue</span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// red，只有一个元素的数组</span></span><br><span class="line">removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>, <span class="string">"orange"</span>); <span class="comment">// 在位置 1 插入两个元素</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,yellow,orange,blue</span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// 空数组</span></span><br><span class="line">removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"red"</span>, <span class="string">"purple"</span>); <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,red,purple,orange,blue</span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// yellow，只有一个元素的数组</span></span><br></pre></td></tr></tbody></table></figure><h4 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h4><p>ECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。</p><h5 id="1-严格相等"><a href="#1-严格相等" class="headerlink" title="1.严格相等"></a>1.严格相等</h5><p><code>indexOf()、lastIndexOf()和 includes()。</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">lastIndexOf</span>(<span class="number">4</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">includes</span>(<span class="number">4</span>)); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h5 id="2-断言函数"><a href="#2-断言函数" class="headerlink" title="2.断言函数"></a>2.断言函数</h5><p><code>find()</code>返回 第一个匹配的元素，<code>findIndex()</code>返回第一个匹配元素的索引 找到第一个匹配后就不再进行</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">name</span>: <span class="string">"Matt"</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">name</span>: <span class="string">"Nicholas"</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  },</span><br><span class="line">];</span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>));</span><br><span class="line"><span class="comment">// {name: "Matt", age: 27}</span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>)); <span class="comment">//0</span></span><br></pre></td></tr></tbody></table></figure><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><ul><li><code>every()</code>：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。</li><li><code>filter()</code>：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。</li><li><code>forEach()</code>：对数组每一项都运行传入的函数，没有返回值。</li><li><code>map()</code>：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。</li><li><code>some()</code>：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。 这些方法都不改变调用它们的数组</li></ul><h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><p><code>reduce()</code>和 <code>reduceRight()</code>都会迭代数 组的所有项，并在此基础上构建一个最终返回值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur);</span><br><span class="line"><span class="title function_">alert</span>(sum); <span class="comment">// 15</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>与<code>Object</code>类型的一个主要差异是<code>Map</code>实例会维护键值对的插入顺序 因此可以根据插入顺序执行迭代操作</p><p>映射实例可以提供一个迭代器 能以插入顺序生成[key, value]形式的数组 可以通过 entries（）方法取得迭代器</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">"key1"</span>, <span class="string">"val1"</span>],</span><br><span class="line">  [<span class="string">"key2"</span>, <span class="string">"val2"</span>],</span><br><span class="line">  [<span class="string">"key3"</span>, <span class="string">"val3"</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]]</span></span><br><span class="line"><span class="comment">//keys()和 values()分别返回以插入顺序生成键和值的迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">keys</span>()) {</span><br><span class="line">  <span class="title function_">alert</span>(key); <span class="comment">//key1 key2 key3</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">values</span>()) {</span><br><span class="line">  <span class="title function_">alert</span>(key); <span class="comment">//value1 value2 value3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为 键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">"key1"</span>, <span class="string">"val1"</span>]]);</span><br><span class="line"><span class="comment">// 作为键的字符串原始值是不能修改的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m1.<span class="title function_">keys</span>()) {</span><br><span class="line">  key = <span class="string">"newKey"</span>;</span><br><span class="line">  <span class="title function_">alert</span>(key); <span class="comment">// newKey</span></span><br><span class="line">  <span class="title function_">alert</span>(m1.<span class="title function_">get</span>(<span class="string">"key1"</span>)); <span class="comment">// val1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>选择 Object 还是 Map</p><ul><li>占用内存：储存当个键值对所占用的内存挥着键的数量线性增加 <code>Map</code>大约可以比<code>Object</code>多储存 50%的键值对</li><li>插入性能：涉及到大量插入操作 <code>Map</code>更佳</li><li>查找速度：设计大量查找操作 <code>Object</code>更佳</li><li>删除性能：设计大量删除操作 选择<code>Map</code></li></ul><h2 id="weak-Map"><a href="#weak-Map" class="headerlink" title="weak Map"></a>weak Map</h2><p>键只能是<code>Objec</code>t 或者继承自<code>Object</code>的类型 使用非对象设置键会抛出 TypeError 值没有限制类型</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = { <span class="attr">id</span>: <span class="number">1</span> },</span><br><span class="line">  key2 = { <span class="attr">id</span>: <span class="number">2</span> },</span><br><span class="line">  key3 = { <span class="attr">id</span>: <span class="number">3</span> };</span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个键无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([</span><br><span class="line">  [key1, <span class="string">"val1"</span>],</span><br><span class="line">  [<span class="string">"BADKEY"</span>, <span class="string">"val2"</span>],</span><br><span class="line">  [key3, <span class="string">"val3"</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as WeakMap key</span></span><br><span class="line"><span class="keyword">typeof</span> wm2;</span><br><span class="line"><span class="comment">// ReferenceError: wm2 is not defined</span></span><br></pre></td></tr></tbody></table></figure><p><code>WeakMap</code>的键不属于正式的引用 不会组织垃圾回收 但是只要键存在 键值对就会存在于映射中 并被当作对值的引用 因此不会被垃圾回收</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">wm.<span class="title function_">set</span>({}, <span class="string">"val"</span>);</span><br><span class="line"><span class="comment">//et()方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，</span></span><br><span class="line"><span class="comment">//所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失</span></span><br><span class="line"><span class="comment">//了，使其成为一个空映射。在这个例子中，因为值也没有被引用，所以这对键/值被破坏以后，值本身</span></span><br><span class="line"><span class="comment">//也会成为垃圾回收的目标。</span></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> container = {</span><br><span class="line">  <span class="attr">key</span>: {},</span><br><span class="line">};</span><br><span class="line">wm.<span class="title function_">set</span>(container.<span class="property">key</span>, <span class="string">"val"</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeReference</span>(<span class="params"></span>) {</span><br><span class="line">  container.<span class="property">key</span> = <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//const wm = new WeakMap();</span></span><br><span class="line"><span class="keyword">const</span> container = {</span><br><span class="line">  <span class="attr">key</span>: {},</span><br><span class="line">};</span><br><span class="line">wm.<span class="title function_">set</span>(container.<span class="property">key</span>, <span class="string">"val"</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeReference</span>(<span class="params"></span>) {</span><br><span class="line">  container.<span class="property">key</span> = <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//这一次，container 对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目</span></span><br><span class="line"><span class="comment">//标。不过，如果调用了 removeReference()，就会摧毁键对象的最后一个引用，垃圾回收程序就可以</span></span><br><span class="line"><span class="comment">//把这个键/值对清理掉。</span></span><br></pre></td></tr></tbody></table></figure><p><code>**WeakMap</code> 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值**</p><h4 id="WeakMap-的用处"><a href="#WeakMap-的用处" class="headerlink" title="WeakMap 的用处"></a>WeakMap 的用处</h4><h5 id="1-私有变量"><a href="#1-私有变量" class="headerlink" title="1.私有变量"></a>1.私有变量</h5><h5 id="2-DOM-节点数据"><a href="#2-DOM-节点数据" class="headerlink" title="2.DOM 节点数据"></a>2.DOM 节点数据</h5><p>因为<code>WeakMap</code>实例不会妨碍垃圾回收 所以非常适合保存关联元数据</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">'#login'</span>);</span><br><span class="line"><span class="comment">//给这个节点关联一些元数据</span></span><br><span class="line">m.<span class="title function_">set</span>(loginButton, {<span class="attr">disabled</span>: <span class="literal">true</span>});</span><br><span class="line"><span class="comment">//假设登录按钮被从DOM树删除了 但是由于映射中还保存着对按钮的引用 所以对应的DOM节点仍然会逗留在内存中 除非明确将其从映射中删除或者等到映射本身被销毁</span></span><br><span class="line"><span class="comment">//如果使用WeakMap 当节点从DOM树被删除后 垃圾回收程序就会立即释放其内存（假设其他地方没引用的话</span></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">'#login'</span>);</span><br><span class="line"><span class="comment">// 给这个节点关联一些元数据</span></span><br><span class="line">wm.<span class="title function_">set</span>(loginButton, {<span class="attr">disabled</span>: <span class="literal">true</span>});</span><br></pre></td></tr></tbody></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>Set</code>会维护值插入时的顺序 因此支持按顺序迭代</p><p>修改集合中的值的属性不会影响到其作为集合值的身份</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">"vall"</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s1.<span class="title function_">values</span>()) {</span><br><span class="line">  value = <span class="string">"newVal"</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//newVal</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="title function_">has</span>(<span class="string">"val"</span>)); <span class="comment">//true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>WeakSet</code>可用于给对象打标签</p><h2 id="迭代和扩展操作"><a href="#迭代和扩展操作" class="headerlink" title="迭代和扩展操作"></a>迭代和扩展操作</h2><p>扩展运算符在对可迭代对象执行浅复刻时特别有用 只需要简单的语法就可以复制整个对象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1 === arr2); <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p>浅复制意味着只会复制对象的引用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [{}];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line">arr1[<span class="number">0</span>].<span class="property">foo</span> = <span class="string">"bar"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2[<span class="number">0</span>]); <span class="comment">// { foo: 'bar' }</span></span><br></pre></td></tr></tbody></table></figure><h1 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h1><p>每个迭代器都表示对可迭代对象的一次性有序遍历 不同的迭代器实例直接拿没有联系 只会独立地遍历可迭代对象</p><p>迭代器并不与可迭代对象某个时刻的快照绑定 而仅仅是使用游标来记录遍历可迭代的对象的历程 如果可迭代对象在迭代期间被修改了 那么迭代器也会发生相应的变化</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"foo"</span>, <span class="string">"baz"</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// { done: false, value: 'foo' }</span></span><br><span class="line"><span class="comment">// 在数组中间插入值</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"bar"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// { done: false, value: 'bar' }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// { done: false, value: 'baz' }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// { done: true, value: undefined }</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>迭代器维护着一个指向可迭代对象的引用 因此迭代器会阻止垃圾回收程序回收可迭代对象</p></blockquote><p><strong>自定义一个迭代器（需要将计数器变量放到闭包里 然后通过闭包返回迭代器）</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">limit</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = limit;</span><br><span class="line">  }</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() {</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">      limit = <span class="variable language_">this</span>.<span class="property">limit</span>;</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= limit) {</span><br><span class="line">          <span class="keyword">return</span> { <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ };</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">return</span> { <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> };</span><br><span class="line">        }</span><br><span class="line">      },</span><br><span class="line">    };</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">} <span class="comment">//1 2 3</span></span><br></pre></td></tr></tbody></table></figure><p>如果迭代器没有关闭 则还可以继续从上次离开的地方继续迭代 比如 数组的迭代器就是不能关闭的</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">2</span>) {</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">} <span class="comment">//1 2 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">} <span class="comment">//4 5</span></span><br></pre></td></tr></tbody></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器对象一开始处于暂停执行的状态 具有<code>next()</code>方法 调用这个方法会让生成器开始或恢复执行</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) {}</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn {&lt;suspended&gt;}</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">next</span>); <span class="comment">// f next() { [native code] }</span></span><br></pre></td></tr></tbody></table></figure><p>函数体为 kon 的生成器函数中间不会停留 调用一次<code>next（）</code>就会让生成器达到<code>done:true</code>状态</p><p>生成器函数只会在初次调用<code>next()</code>方法后开始执行</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"foobar"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 初次调用生成器函数并不会打印日志</span></span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>();</span><br><span class="line">generatorObject.<span class="title function_">next</span>(); <span class="comment">// foobar</span></span><br></pre></td></tr></tbody></table></figure><p>yield 可以让生成器停止和开始执行 遇到关键字后 执行停止 作用域的状态会被保留</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"foo"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"bar"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"baz"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// { done: false, value: 'foo' }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// { done: false, value: 'bar' }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// { done: true, value: 'baz' }</span></span><br></pre></td></tr></tbody></table></figure><p>生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用 <code>next()</code> 不会影响其他生成器</p><h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p><code>Object.assign()</code>接收一个目标对象和一个或多个元对象作为参数 然后将每个原对象中可枚举（<code>Object.propertyIsEnumerable()</code>返回 true）和自有（<code>Object.hasOwnProperty()</code>返回 true）属性复制到目标对象以字符串和符号为键的属性 会被复制。对每个符合条件的属性，这个方法会使用源对象上的<code>[[Get]]</code>取得属性的值，然后使用目标 对象上的<code>[[Set]]</code>设置属性的值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = { <span class="attr">id</span>: <span class="string">"src"</span> };</span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// Object.assign 修改目标对象</span></span><br><span class="line"><span class="comment">// 也会返回修改后的目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest === result); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest !== src); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// { id: src }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { id: src }</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dest = {</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">val</span>) {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Invoked dest setter with param <span class="subst">${val}</span>`</span>);</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">src = {</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">a</span>() {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Invoked src getter'</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 调用 src 的获取方法</span></span><br><span class="line"><span class="comment">// 调用 dest 的设置方法并传入参数"foo"</span></span><br><span class="line"><span class="comment">// 因为这里的设置函数不执行赋值操作</span></span><br><span class="line"><span class="comment">// 所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// Invoked src getter"</span></span><br><span class="line"><span class="string">"Invoked dest setter with param foo"</span> {}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = { <span class="attr">a</span>: {} };</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { a :{} }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest.<span class="property">a</span> === src.<span class="property">a</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest == src)<span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>assign()</code>是浅复制 意味着只会复制对象的引用</p></blockquote><p>如果赋值期间出错 操作会中止并退出 同时抛出错误 因此可能只完成部分复制</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = {</span><br><span class="line">  <span class="attr">a</span>: <span class="string">"foo"</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">b</span>() {</span><br><span class="line">    <span class="comment">// Object.assign()在调用这个获取函数时会抛出错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">c</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line">} <span class="keyword">catch</span> (e) {}</span><br><span class="line"><span class="comment">// Object.assign()没办法回滚已经完成的修改</span></span><br><span class="line"><span class="comment">// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { a: foo }</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>可计算属性表达式中抛出任何错误都会中断对象创建 如果计算属性的表达式有副作用就要小心 因为如果表达式抛出错误 那么之前完成的计算是不能回滚的</p></blockquote><p>解构并不要求变量必须在解构表达式中说明 不过 如果是事先声明的变量 则赋值表达式必须包含在一对括号中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personName, personAge;</span><br><span class="line"><span class="keyword">let</span> person = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"Matt"</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line">};</span><br><span class="line">({ <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge } = person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName, personAge); <span class="comment">// Matt, 27</span></span><br><span class="line"><span class="comment">//vue的写法</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>({</span><br><span class="line">  <span class="attr">name</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">0</span>,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> response = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"olddog"</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">}(({ <span class="attr">name</span>: data.<span class="property">name</span>, <span class="attr">age</span>: data.<span class="property">age</span> } = response)); <span class="comment">//data:{name: 'olddog', age: 23}</span></span><br></pre></td></tr></tbody></table></figure><h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><p>可以通过解构来复制对象属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = {</span><br><span class="line"> <span class="attr">name</span>: <span class="string">'Matt'</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line"> <span class="attr">job</span>: {</span><br><span class="line"> <span class="attr">title</span>: <span class="string">'Software engineer'</span></span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> personCopy = {};</span><br><span class="line">({</span><br><span class="line"> <span class="attr">name</span>: personCopy.<span class="property">name</span>,</span><br><span class="line"> <span class="attr">age</span>: personCopy.<span class="property">age</span>,</span><br><span class="line"> <span class="attr">job</span>: personCopy.<span class="property">job</span></span><br><span class="line">} = person);</span><br><span class="line"><span class="comment">// 因为一个对象的引用被赋值给 personCopy，所以修改</span></span><br><span class="line"><span class="comment">// person.job 对象的属性也会影响 personCopy</span></span><br><span class="line">person.<span class="property">job</span>.<span class="property">title</span> = <span class="string">'Hacker'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line"><span class="comment">// { name: 'Matt', age: 27, job: { title: 'Hacker' } }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personCopy);</span><br><span class="line"><span class="comment">// { name: 'Matt', age: 27, job: { title: 'Hacker' } }</span></span><br><span class="line">--------------------------------</span><br><span class="line">vue的写法</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>({</span><br><span class="line"><span class="attr">name</span>: <span class="string">''</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">address</span>:{</span><br><span class="line">  <span class="attr">home</span>:<span class="string">""</span></span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"><span class="keyword">const</span> response = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'olddogewqeeqwweq'</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="attr">address</span>:{</span><br><span class="line">    <span class="attr">home</span>: <span class="string">'huilaieqw1341343'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  ({<span class="attr">name</span>: data.<span class="property">name</span>, <span class="attr">age</span>: data.<span class="property">age</span>, <span class="attr">address</span>:{<span class="attr">home</span>: data.<span class="property">address</span>.<span class="property">home</span>}} = response)<span class="comment">//data:{name: 'olddog', age: 23}</span></span><br><span class="line">  response.<span class="property">name</span> = <span class="string">"wdqdw"</span></span><br><span class="line">  response.<span class="property">address</span>.<span class="property">home</span> = <span class="string">'2132'</span></span><br><span class="line">  data.<span class="property">address</span>.<span class="property">home</span> = <span class="string">'qdewqdeqsw'</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="comment">//改变response不会影响data</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><blockquote><p>涉及到多个属性的解构赋值是一个无关输出的顺序化操作 如果一个解构表达式涉及多个赋值 如果开始的赋值成功而后面的赋值出错 则整个赋值表达式只会完成一部分</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学CSS第一天</title>
      <link href="/2022/04/18/chong-xue-css1.0/"/>
      <url>/2022/04/18/chong-xue-css1.0/</url>
      
        <content type="html"><![CDATA[<h2 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h2><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><ul><li>在 font-size 中使用是相对于<strong>父元素</strong>的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px；</li><li>在其他属性中使用是相对于自身的字体大小，如 width/height/padding/margin 等；</li></ul><p>em 在计算的时候是会层层计算的，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">div { font-size: 2em; }</span><br><span class="line">p { font-size: 2em; }</span><br><span class="line">//对于如上一个结构的 HTML，由于根元素 html 的字体大小是 16px，所以 p 标签最终计算出来后的字体大小会是 16 * 2 * 2 = 64px</span><br></pre></td></tr></tbody></table></figure><h4 id="wm、vh"><a href="#wm、vh" class="headerlink" title="wm、vh"></a>wm、vh</h4><ul><li>1vw = 视口宽度均分成 100 份中 1 份的长度；100vw = window.innerWidth</li><li>1vh = 视口高度均分成 100 份中 1 份的长度；100vh = window.innerHeight</li></ul><h4 id="vmin、vmax"><a href="#vmin、vmax" class="headerlink" title="vmin、vmax"></a>vmin、vmax</h4><ul><li>vmin：取 vw 和 vh 中值较小的；</li><li>vmax：取 vw 和 vh 中值较大的；</li></ul><h2 id="颜色体系"><a href="#颜色体系" class="headerlink" title="颜色体系"></a>颜色体系</h2><h4 id="transparent-关键字"><a href="#transparent-关键字" class="headerlink" title="transparent 关键字"></a>transparent 关键字</h4><p>transparent 关键字表示一个完全透明的颜色，即该颜色看上去将是背景色。从技术上说，它是带有 alpha 通道为最小值的黑色，是 rgba(0,0,0,0) 的简写。</p><h5 id="实现三角形"><a href="#实现三角形" class="headerlink" title="实现三角形"></a>实现三角形</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div {</span><br><span class="line">    border-top-color: #ffc107;</span><br><span class="line">    border-right-color: #00bcd4;</span><br><span class="line">    border-bottom-color: #e26b6b;</span><br><span class="line">    border-left-color: #cc7cda;</span><br><span class="line">    border-width: 50px;</span><br><span class="line">    border-style: solid;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="增大点击区域"><a href="#增大点击区域" class="headerlink" title="增大点击区域"></a>增大点击区域</h5><p>常常在移动端的时候点击的按钮的区域特别小，但是由于现实效果又不太好把它做大，所以常用的一个手段就是通过透明的边框来增大按钮的点击区域</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.btn {</span><br><span class="line">    border: 5px solid transparent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><h4 id="BFC-清除浮动"><a href="#BFC-清除浮动" class="headerlink" title="BFC 清除浮动"></a>BFC 清除浮动</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">    overflow: hidden;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="通过-clear-清除浮动"><a href="#通过-clear-清除浮动" class="headerlink" title="通过 clear 清除浮动"></a>通过 clear 清除浮动</h4><img src="https://s3.bmp.ovh/imgs/2022/04/18/42ab48bfd850f525.png" style="zoom:67%;"><h2 id="长文本处理"><a href="#长文本处理" class="headerlink" title="长文本处理"></a>长文本处理</h2><h4 id="超出部分换行"><a href="#超出部分换行" class="headerlink" title="超出部分换行"></a>超出部分换行</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overflow-wrap:break-word;</span><br></pre></td></tr></tbody></table></figure><h4 id="字符超出位置使用连字符"><a href="#字符超出位置使用连字符" class="headerlink" title="字符超出位置使用连字符"></a>字符超出位置使用连字符</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hyphens: auto</span><br></pre></td></tr></tbody></table></figure><h4 id="单行文本超出省略"><a href="#单行文本超出省略" class="headerlink" title="单行文本超出省略"></a>单行文本超出省略</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">white-space: nowrap;</span><br><span class="line">overflow:hidden;</span><br><span class="line">text-overflow: ellipsis</span><br></pre></td></tr></tbody></table></figure><h4 id="多行文本超出省略"><a href="#多行文本超出省略" class="headerlink" title="多行文本超出省略"></a>多行文本超出省略</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">overflow:hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">display:-webkit-box;</span><br><span class="line">-webkit-line-clamp:2;</span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></tbody></table></figure><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h4 id="单行的文本、inline-或-inline-block-元素"><a href="#单行的文本、inline-或-inline-block-元素" class="headerlink" title="单行的文本、inline 或 inline-block 元素"></a>单行的文本、inline 或 inline-block 元素</h4><h5 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-align: center</span><br></pre></td></tr></tbody></table></figure><h5 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h5><ul><li>通过设置上下内边距一致达到垂直居中的效果</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">padding-top: 10px;</span><br><span class="line">padding-bottom: 10px;</span><br></pre></td></tr></tbody></table></figure><ul><li>通过设置<code>height</code>和<code>line-height</code>一致达到垂直居中</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height: 100px;</span><br><span class="line">line-height: 100px;</span><br></pre></td></tr></tbody></table></figure><h4 id="固定宽高的块级盒子"><a href="#固定宽高的块级盒子" class="headerlink" title="固定宽高的块级盒子"></a>固定宽高的块级盒子</h4><ul><li>absolute + 负 margin</li><li>absolute + margin auto</li><li>absolute + calc</li></ul><h4 id="不固定宽高的块级盒子"><a href="#不固定宽高的块级盒子" class="headerlink" title="不固定宽高的块级盒子"></a>不固定宽高的块级盒子</h4><ul><li><p>absolute + transform</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">position:relative;</span><br><span class="line">}</span><br><span class="line">.child {</span><br><span class="line">position: absolute;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">transform: translate(-50%, -50%);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>line-height + vertical-align</p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.parent{</span><br><span class="line">line-height: 150px;</span><br><span class="line">line-height: 150px;</span><br><span class="line">text-align: center;</span><br><span class="line">}</span><br><span class="line">.child {</span><br><span class="line">display: inline-block;</span><br><span class="line">line-height: initial;</span><br><span class="line">vertical-align: middle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>writing-mode</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent{</span><br><span class="line">writing-mode: vertical-lr;</span><br><span class="line">text-align: center;</span><br><span class="line">}</span><br><span class="line">.middle {</span><br><span class="line">display: inlne-block;</span><br><span class="line">writing-mode: horizontal-tb;</span><br><span class="line">text-align: center;</span><br><span class="line">width: 100%</span><br><span class="line">}</span><br><span class="line">.child{</span><br><span class="line"> display: inline-block</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>table-cell</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">display: table-cell;</span><br><span class="line">vertical-align: middle;</span><br><span class="line">text-align: center;</span><br><span class="line">}</span><br><span class="line">.child {</span><br><span class="line">display: inline-block</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>flex</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>grid</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">display: grid</span><br><span class="line">}</span><br><span class="line">.child {</span><br><span class="line">justify-self: center;</span><br><span class="line">align-self: center</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="常用布局"><a href="#常用布局" class="headerlink" title="常用布局"></a>常用布局</h2><h4 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h4><ul><li>float + overflow(BFC 原理)</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aside {</span><br><span class="line">float: left;</span><br><span class="line">width: 200px;</span><br><span class="line">}</span><br><span class="line">main {</span><br><span class="line">overflow: hidden;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>float + margin</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aside {</span><br><span class="line">float: left;</span><br><span class="line">width: 200px;</span><br><span class="line">}</span><br><span class="line">main {</span><br><span class="line">margin-left: 200px;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>flex</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.layout {</span><br><span class="line">display: flex;</span><br><span class="line">}</span><br><span class="line">aside {</span><br><span class="line">width: 200px;</span><br><span class="line">}</span><br><span class="line">main {</span><br><span class="line">flex: 1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>grid</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.layout {</span><br><span class="line">display: grid;</span><br><span class="line">grid-template-columns: 200px auto;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="三栏布局（两侧栏定宽主栏自适应）"><a href="#三栏布局（两侧栏定宽主栏自适应）" class="headerlink" title="三栏布局（两侧栏定宽主栏自适应）"></a>三栏布局（两侧栏定宽主栏自适应）</h4><ul><li>flex</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;layout&gt;</span><br><span class="line">&lt;aside&gt;</span><br><span class="line">&lt;main&gt;</span><br><span class="line">&lt;aside&gt;</span><br><span class="line">&lt;/layout&gt;</span><br><span class="line">.layout{</span><br><span class="line">display: flex;</span><br><span class="line">}</span><br><span class="line">aside{</span><br><span class="line">width: 200px;</span><br><span class="line">}</span><br><span class="line">main{</span><br><span class="line">flex: 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>grid</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.layout{</span><br><span class="line">display: grid;</span><br><span class="line">grid-template-columns: 200px auto 200px;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="三行布局"><a href="#三行布局" class="headerlink" title="三行布局"></a>三行布局</h4><ul><li>flex</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/dd8b4abc814a8935.png"></p><ul><li>grid</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/a3e63f56c012019b.png"></p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><h3 id="父容器"><a href="#父容器" class="headerlink" title="父容器"></a>父容器</h3><h4 id="justify-content-定义如何沿着主轴方向排列子容器"><a href="#justify-content-定义如何沿着主轴方向排列子容器" class="headerlink" title="justify-content:定义如何沿着主轴方向排列子容器"></a>justify-content:定义如何沿着主轴方向排列子容器</h4><blockquote><p>flex-start: 起始端对齐</p><p>flex-end： 末尾端对齐</p><p>center： 居中对齐</p><p>space-around：子容器沿主轴均匀分布 位于首尾末端的子容器到父容器的距离是子容器间距的一半</p><p>space-between：子容器沿主轴均匀分布 位于首位两端的子容器与父容器相切</p></blockquote><h4 id="align-items：设置子元素如何沿交叉轴排列"><a href="#align-items：设置子元素如何沿交叉轴排列" class="headerlink" title="align-items：设置子元素如何沿交叉轴排列"></a>align-items：设置子元素如何沿交叉轴排列</h4><blockquote><p>flex-satrt：起始端对齐</p><p>flex-end：末尾段对齐</p><p>center：居中对齐</p><p>baseline：基线对齐 这里的<code>baseline</code>默认是值首行文字 即<code>first baseline</code> 所有子容器向基线对齐 交 叉轴起点到元素基线距离最大的子容器会将交叉轴起始端相切以确定基线</p><p>stretch：子容器沿交叉方向的尺寸拉伸至与父容器一致</p></blockquote><h3 id="子容器"><a href="#子容器" class="headerlink" title="子容器"></a>子容器</h3><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/cb3978bf844f693d.png"></p><p>每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器 <code>align-items</code> 属性完全一致，如果两者同时设置则以子容器的 <code>align-self</code> 属性为准。</p><blockquote><p>flex-start：起始端对齐</p><p>flex-end：末尾段对齐</p><p>center：居中对齐</p><p>baseline：基线对齐</p><p>stretch：拉伸对齐</p></blockquote><h4 id="轴"><a href="#轴" class="headerlink" title="轴"></a>轴</h4><p><code>jusitify-content</code>决定子容器沿主轴排列方式 align-items 决定子容器沿交叉轴的排列方向 <code>flex-dirextion</code>决定主轴的方向</p><p><strong>主轴的起始端由<code>flex-start</code>表示 末尾以<code>flex-end</code>表示</strong></p><blockquote><p>向右：flex-direction： row</p><p>向下：flex-direction： column</p><p>向左：flex-direction： row-reverse</p><p>向上：flex-direction： column-reverse</p></blockquote><h3 id="flex-进阶概念"><a href="#flex-进阶概念" class="headerlink" title="flex 进阶概念"></a>flex 进阶概念</h3><ul><li>设置换行方式： flex-wrap</li></ul><blockquote><p>nowrap：不换行</p><p>wrap：换行</p><p>wrap-reverse：逆序换行</p></blockquote><ul><li>轴向与换行组合设置：flex-flow</li><li>多行沿交叉轴对齐：<code>align-content</code></li></ul><blockquote><p>flex-start：起始端对齐</p><p>flex-end：末尾端对齐</p><p>center：居中对齐</p><p>space-around：等边距均匀分布</p><p>space-between：等间距均匀分布</p><p>strench：拉伸对齐</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/e524c68a7305f540.png"></p><h2 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h2><h4 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h4><p>通过声明<code>display:grid</code>该容器是一个块级元素 <code>display: inline-grid</code> 则容器元素为行内元素</p><h4 id="grid-template-columns-属性和-grid-template-rows-属性"><a href="#grid-template-columns-属性和-grid-template-rows-属性" class="headerlink" title="grid-template-columns 属性和 grid-template-rows 属性"></a>grid-template-columns 属性和 grid-template-rows 属性</h4><p><code>grid-template-columns</code> 属性设置列宽，<code>grid-template-rows</code> 属性设置行高</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.wrapper {</span><br><span class="line">  display: grid;</span><br><span class="line">  /*  声明了三列，宽度分别为 200px 100px 200px */</span><br><span class="line">  grid-template-columns: 200px 100px 200px;</span><br><span class="line">  grid-gap: 5px;</span><br><span class="line">  /*  声明了两行，行高分别为 50px 50px  */</span><br><span class="line">  grid-template-rows: 50px 50px;</span><br><span class="line">}</span><br><span class="line">repeat函数：可以简化重复的值 第一个参数是重复的次数 第二个对象是重复的值</span><br><span class="line">grid-template-rows: repeat(2, 50px);</span><br></pre></td></tr></tbody></table></figure><h5 id="auto-fill-关键字：表示自动填充-让一行或者一列中尽可能地容纳更多的单元格"><a href="#auto-fill-关键字：表示自动填充-让一行或者一列中尽可能地容纳更多的单元格" class="headerlink" title="auto-fill 关键字：表示自动填充 让一行或者一列中尽可能地容纳更多的单元格"></a>auto-fill 关键字：表示自动填充 让一行或者一列中尽可能地容纳更多的单元格</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: repeat(auto-fill, 200px);</span><br></pre></td></tr></tbody></table></figure><h5 id="fr-关键字：-fr单位代表网格容器中可用空间的一等份"><a href="#fr-关键字：-fr单位代表网格容器中可用空间的一等份" class="headerlink" title="fr 关键字： fr单位代表网格容器中可用空间的一等份"></a>fr 关键字： <code>fr</code>单位代表网格容器中可用空间的一等份</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: 200px 1fr 2fr;//表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3。</span><br></pre></td></tr></tbody></table></figure><h5 id="minmax-函数：产生一个范围-表示长度在这个范围之中都可以应用到网格项目中-接收两个参数表示最大值和最小值"><a href="#minmax-函数：产生一个范围-表示长度在这个范围之中都可以应用到网格项目中-接收两个参数表示最大值和最小值" class="headerlink" title="minmax()函数：产生一个范围 表示长度在这个范围之中都可以应用到网格项目中 接收两个参数表示最大值和最小值"></a>minmax()函数：产生一个范围 表示长度在这个范围之中都可以应用到网格项目中 接收两个参数表示最大值和最小值</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: 1fr 1fr minmax(300px, 2fr);//，第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍</span><br></pre></td></tr></tbody></table></figure><h5 id="auto-关键字：由浏览器决定长度"><a href="#auto-关键字：由浏览器决定长度" class="headerlink" title="auto 关键字：由浏览器决定长度"></a>auto 关键字：由浏览器决定长度</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: 100px auto 100px;//第一列和第三列为100px 中间由浏览器长度决定</span><br></pre></td></tr></tbody></table></figure><h4 id="grid-row-gap-属性、grid-column-gap-属性以及-grid-gap-属性"><a href="#grid-row-gap-属性、grid-column-gap-属性以及-grid-gap-属性" class="headerlink" title="grid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性"></a>grid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性</h4><p><code>grid-row-gap</code> 属性、<code>grid-column-gap</code> 属性分别设置行间距和列间距。<code>grid-gap</code> 属性是两者的简写形式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-row-gap: 10px;//行间距是10px</span><br><span class="line">grid-cloumn-gap：20px;//列间距是20px；</span><br><span class="line">grid-gap: 10px 20px;//行间距10px 列间距20px</span><br></pre></td></tr></tbody></table></figure><h4 id="grid-template-areas-属性"><a href="#grid-template-areas-属性" class="headerlink" title="grid-template-areas 属性"></a>grid-template-areas 属性</h4><p><code>rid-template-areas</code> 属性用于定义区域，一个区域由一个或者多个单元格组成</p><p>一般这个属性跟网格元素的 <code>grid-area</code> 一起使用 <code>grid-area</code> 属性指定项目放在哪一个区域</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.wrapper {</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-gap: 10px;</span><br><span class="line">  grid-template-columns: 120px  120px  120px;</span><br><span class="line">  grid-template-areas://划出六个单元格 .符号代表空的单元格 即没有用到该单元格</span><br><span class="line">    ". header  header"</span><br><span class="line">    "sidebar content content";</span><br><span class="line">  background-color: #fff;</span><br><span class="line">  color: #444;</span><br><span class="line">}</span><br><span class="line">.sidebar {</span><br><span class="line">  grid-area: sidebar;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.content {</span><br><span class="line">  grid-area: content;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.header {</span><br><span class="line">  grid-area: header;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="grid-auto-flow-属性"><a href="#grid-auto-flow-属性" class="headerlink" title="grid-auto-flow 属性"></a>grid-auto-flow 属性</h3><p><code>grid-auto-flow</code> 属性控制着自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-auto-flow: row;</span><br><span class="line">grid-auto-flow: row dense;//表示尽可能填满表格</span><br><span class="line">grid-auto-flow: column;//表示先列后行</span><br></pre></td></tr></tbody></table></figure><h3 id="justify-items-属性、align-items-属性以及-place-items-属性"><a href="#justify-items-属性、align-items-属性以及-place-items-属性" class="headerlink" title="justify-items 属性、align-items 属性以及 place-items 属性"></a>justify-items 属性、align-items 属性以及 place-items 属性</h3><p><code>justify-items</code> 属性设置单元格内容的水平位置（左中右），<code>align-items</code> 属性设置单元格的垂直位置（上中下）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container {</span><br><span class="line">  justify-items: start | end | center | stretch;</span><br><span class="line">  align-items: start | end | center | stretch;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="justify-content-属性、align-content-属性以及-place-content-属性"><a href="#justify-content-属性、align-content-属性以及-place-content-属性" class="headerlink" title="justify-content 属性、align-content 属性以及 place-content 属性"></a>justify-content 属性、align-content 属性以及 place-content 属性</h3><p><code>justify-content</code> 属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code> 属性是整个内容区域的垂直位置（上中下）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container {</span><br><span class="line">  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">  align-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍</p><p>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔</p><p>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</p><p>stretch - 项目大小没有指定时，拉伸占据整个网格容器</p><h2 id="各种简写形式"><a href="#各种简写形式" class="headerlink" title="各种简写形式"></a>各种简写形式</h2><h4 id="Border-radius"><a href="#Border-radius" class="headerlink" title="Border-radius"></a><code>Border-radius</code></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 1em 2em 3em 4em;//top-left、 top-right、 bottom-right 、bottom-left</span><br></pre></td></tr></tbody></table></figure><h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a><code>Background</code></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: #000 url(images/bg.gif) no-repeat top right;//color-image-repeat-position</span><br></pre></td></tr></tbody></table></figure><h4 id="Font"><a href="#Font" class="headerlink" title="Font"></a><code>Font</code></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: italic bold .8em/1.2 Arial, sans-serif;//style-weight-size-height-family</span><br></pre></td></tr></tbody></table></figure><h4 id="Border"><a href="#Border" class="headerlink" title="Border"></a><code>Border</code></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid #000;//wdth-style-color</span><br></pre></td></tr></tbody></table></figure><h4 id="Margin和Padding"><a href="#Margin和Padding" class="headerlink" title="Margin和Padding"></a><code>Margin</code>和<code>Padding</code></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">margin: 10px 5px 10px 5px;</span><br><span class="line">padding: 10px 5px 10px 5px;</span><br><span class="line">//四个值-上下边距和左右边距-上边距和左右边距和下边距-顺时针</span><br></pre></td></tr></tbody></table></figure><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initial 该关键字代表该元素或其父元素的所有属性至初始值</span><br><span class="line">inherit 元素获取其父元素的计算值 通常只在覆盖原有的值的时候使用 继承始终来自文档树中的父元素 即使父元素不是包含块</span><br><span class="line">unset 表示如果有父元素继承 则继承父元素 否则使用默认 即不是inherit就是initial</span><br></pre></td></tr></tbody></table></figure><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/595fa6efc529bdfd.png"></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学Git第一天</title>
      <link href="/2022/04/15/chu-xue-git-di-yi-tian/"/>
      <url>/2022/04/15/chu-xue-git-di-yi-tian/</url>
      
        <content type="html"><![CDATA[<h2 id="运行-Git-前的配置"><a href="#运行-Git-前的配置" class="headerlink" title="运行 Git 前的配置"></a>运行 Git 前的配置</h2><h3 id="查看所有的配置及它们所在的文件"><a href="#查看所有的配置及它们所在的文件" class="headerlink" title="查看所有的配置及它们所在的文件"></a>查看所有的配置及它们所在的文件</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list --show-origin</span><br></pre></td></tr></tbody></table></figure><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name "John Doe"</span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></tbody></table></figure><p>使用了–global 代表全局配置 如果想根据不同项目使用不同的用户名和邮件地址 可以在该项目目录下运行不带–global</p><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --list //查看所有配置</span><br><span class="line">git config &lt;key&gt;//查看某一项配置 eg: git config user.name</span><br><span class="line">git config --show-origin rerere.autoUpdate //查看原始配置</span><br></pre></td></tr></tbody></table></figure><h2 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br><span class="line">//以上三种命令都是等价的</span><br><span class="line">//eg: 想要获取git config的命令手册 执行 git help config</span><br><span class="line">//如果只需要可用选项的快速参考 可以使用-h来获取更简明的</span><br><span class="line">eg: git add -h</span><br></pre></td></tr></tbody></table></figure><h1 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h1><h2 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h2><h3 id="获取-Git-仓库-1"><a href="#获取-Git-仓库-1" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><ul><li>将未进行版本控制的本地目录转换为 Git 仓库</li><li>从其它服务器 <strong>克隆</strong> 一个已存在的 Git 仓库。</li></ul><h4 id="1-从已存在的目录初始化仓库"><a href="#1-从已存在的目录初始化仓库" class="headerlink" title="1.从已存在的目录初始化仓库"></a>1.从已存在的目录初始化仓库</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. cd project // cd /c/user/my_project</span><br><span class="line">2. git init //初始化 将创建一个.git文件 包含Git仓库的所有文件 此时只是初始化 还未被追踪</span><br><span class="line">3 git add // eg: git add *c 追踪指定的文件</span><br><span class="line">4 git commit -m "..."//初始提交 这样我们就已经得到一个被追踪文件与初始提交的Git仓库</span><br></pre></td></tr></tbody></table></figure><h4 id="2-克隆现有的仓库"><a href="#2-克隆现有的仓库" class="headerlink" title="2.克隆现有的仓库"></a>2.克隆现有的仓库</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. git clone "url" //git clone https://github.com/libgit2/libgit2 会在当前目录初始化.git 并将所有拉取的所有数据都存到.git文件夹 当你想自定义拉下来的仓库名 git clone url yourName</span><br></pre></td></tr></tbody></table></figure><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>每一个文件都是两种状态之一：<strong>已跟踪</strong>或<strong>未跟踪</strong></p><p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/15/fd2225fd7d24e098.png"></p><h4 id="检查当前的状态"><a href="#检查当前的状态" class="headerlink" title="检查当前的状态"></a>检查当前的状态</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></tbody></table></figure><h4 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add fileName // eg: git add README.md</span><br><span class="line">git status // 只要出现changes to be committed 就说明已经是暂存状态 如果此时提交 那么该文件在你运行git add时的版本将被留存在后续的历史记录中</span><br></pre></td></tr></tbody></table></figure><p><code>git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p><h4 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h4><p>要暂存这次更新，需要运行 <code>git add</code> 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</p><p>提交时提交的版本是最后一次 git add 的版本而不是运行 git commit 时的版本</p><h4 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status -s</span><br></pre></td></tr></tbody></table></figure><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。 来看一个实际的 <code>.gitignore</code> 例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></tbody></table></figure><p><code>gitignore</code>的格式规范如下</p><ul><li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>**</code>）表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 忽略所有的 .a 文件</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># 忽略任何目录下名为 build 的文件夹</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></tbody></table></figure><h4 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h4><p>查看未暂存部分更新了哪些部分 不加参数直接输入 git diff</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></tbody></table></figure><p>若要查看已暂存的将要添加到下次提交的内容 可以使用<code>git diff --staged</code> 将对比已暂存文件与最后一次提交的文件差异</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged</span><br></pre></td></tr></tbody></table></figure><p><strong>请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</strong></p><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p><code>git commit</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></tbody></table></figure><p>可以在<code>commit</code>命令后面添加<code>-m</code> 将提交信息与命令行放在同一行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "Story 182: Fix benchmarks for speed"</span><br></pre></td></tr></tbody></table></figure><p>请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p><h4 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h4><p>只要在<code>git commit</code>加上<code>-a</code>选项 Git 就会自动把之前所有已经跟踪的文件暂存起来一并提交 从而跳过<code>git add</code>步骤：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m 'added new benchmarks'</span><br></pre></td></tr></tbody></table></figure><p><strong>需要小心使用 有时这个选项会将不需要的文件添加到提交中</strong></p><h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>要从 Git 中移除某文件 需要先从已跟踪的文件清单（暂存区域）移除 然后提交 可以使用<code>git rm</code> 并连带从工作目录中删除指定的文件 以后不会出现在未跟踪的清单中</p><p>如果只是从工作目录中删除文件 运行<code>git status</code>时就会在“Changes not staged for commit” 部分（也就是 _未暂存清单_）看到：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ rm PROJECTS.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with 'origin/master'.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add/rm &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    PROJECTS.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></tbody></table></figure><p>然后再运行<code>git rm</code>记录此次移除文件的操作</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rm PROJECTS.md</span><br><span class="line">rm 'PROJECTS.md'</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with 'origin/master'.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><br><span class="line"></span><br><span class="line">    deleted:    PROJECTS.md</span><br></pre></td></tr></tbody></table></figure><p>如果要删除之前修改过或已经放到暂存区的文件 则必须强制使用<code>-f</code> 用于防止误删尚未添加到快照的数据 这样的数据不能被 Git 恢复</p><p>如果想要将文件从 Git 仓库删除但是又想保留在当前工作目录中（文件留在磁盘但是不再追踪 Git）例如你忘记添加<code>.gitignore</code>文件 但是一不小心将日志文件或<code>.a</code>这样的编译文件添加到暂存区 这一方法很有用</p><p>使用<code>--cached</code>选项</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached README</span><br></pre></td></tr></tbody></table></figure><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm log/\*.log</span><br></pre></td></tr></tbody></table></figure><h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>要在 Git 中对文件改名</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv file_from file_to</span><br></pre></td></tr></tbody></table></figure><p>可以使用<code>git status</code>查看状态信息以及重命名操作的说明</p><p><code>git mv</code>相当于以下的命令</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></tbody></table></figure><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><h4 id="查看提交历史-1"><a href="#查看提交历史-1" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p><code>git log</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></tbody></table></figure><ul><li><p><code>-p</code> 或 <code>-patch</code> 显式每次提交所引入的差异（按补丁的形式输出） 也可以限制显式的日志条目数量</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p -2</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>--stat</code> 查看每次提交的简略统计信息</p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></tbody></table></figure><ul><li><code>--pretty</code>使用不同的默认格式的方式展示提交信息</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br><span class="line">git log --pretty=format:"%h - %an, %ar : %s";//定制记录的显式格式 对后期提取分析格外有用</span><br></pre></td></tr></tbody></table></figure><ul><li><code>git log --pretty=format</code> 常用的选项</li></ul><table><thead><tr><th><code>%H</code></th><th>提交的完整哈希值</th></tr></thead><tbody><tr><td><code>%h</code></td><td>提交的简写哈希值</td></tr><tr><td><code>%T</code></td><td>树的完整哈希值</td></tr><tr><td><code>%t</code></td><td>树的简写哈希值</td></tr><tr><td><code>%P</code></td><td>父提交的完整哈希值</td></tr><tr><td><code>%p</code></td><td>父提交的简写哈希值</td></tr><tr><td><code>%an</code></td><td>作者名字</td></tr><tr><td><code>%ae</code></td><td>作者的电子邮件地址</td></tr><tr><td><code>%ad</code></td><td>作者修订日期（可以用 –date=选项 来定制格式）</td></tr><tr><td><code>%ar</code></td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td><code>%cn</code></td><td>提交者的名字</td></tr><tr><td><code>%ce</code></td><td>提交者的电子邮件地址</td></tr><tr><td><code>%cd</code></td><td>提交日期</td></tr><tr><td><code>%cr</code></td><td>提交日期（距今多长时间）</td></tr><tr><td><code>%s</code></td><td>提交说明</td></tr></tbody></table><ul><li><code>git log</code> 的常用选项</li></ul><table><thead><tr><th><code>-p</code></th><th>按补丁格式显示每个提交引入的差异。</th></tr></thead><tbody><tr><td><code>--stat</code></td><td>显示每次提交的文件修改统计信息。</td></tr><tr><td><code>--shortstat</code></td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td><code>--name-only</code></td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td><code>--name-status</code></td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td><code>--abbrev-commit</code></td><td>仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。</td></tr><tr><td><code>--relative-date</code></td><td>使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）。</td></tr><tr><td><code>--graph</code></td><td>在日志旁以 ASCII 图形显示分支与合并历史。</td></tr><tr><td><code>--pretty</code></td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format（用来定义自己的格式）。</td></tr><tr><td><code>--oneline</code></td><td><code>--pretty=oneline --abbrev-commit</code> 合用的简写。</td></tr></tbody></table><h4 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h4><p><code>--since</code> 和 <code>--until</code> 这种按照时间作限制的选项很有用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --since=2.weeks //列出最近两周的所有提交</span><br></pre></td></tr></tbody></table></figure><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><h4 id="撤销操作-1"><a href="#撤销操作-1" class="headerlink" title="撤销操作"></a>撤销操作</h4><p>有时候我们漏提交了东西或者提交信息写错了 可以使用<code>--amend</code>选项来重新提交</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></tbody></table></figure><p>这个命令会将暂存区的文件提交 如果自从上次提交以来未做任何操修改（上次提交后立马执行次命令）那么快照会保存不变 所修改的只是提交信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m 'initial commit'</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></tbody></table></figure><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p><p>从效果上来说，就像是旧有的提交从未存在过一样，它并不会出现在仓库的历史中。</p><p>修补提交最明显的价值是可以稍微改进你最后的提交，而不会让“啊，忘了添加一个文件”或者 “小修补，修正笔误”这种提交信息弄乱你的仓库历史。</p><h4 id="取消暂存的操作"><a href="#取消暂存的操作" class="headerlink" title="取消暂存的操作"></a>取消暂存的操作</h4><p>如果已经修改了两个文件并且想要将它们作为两次独立的修改提交 但是却意外地输入了 <code>git add .</code> 如果想取消暂存中的一个 使用 git reset HEAD <file>… 来取消暂存</file></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h4><p>使用 git checkout –<file></file></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- CONTRIBUTING.md</span><br></pre></td></tr></tbody></table></figure><p><strong>请务必记得 <code>git checkout -- &lt;file&gt;</code> 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</strong></p><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><h4 id="远程仓库的使用-1"><a href="#远程仓库的使用-1" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h4><p>查看已经配置好的远程仓库服务器 <code>git remote</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/schacon/ticgit</span><br><span class="line">git remote</span><br></pre></td></tr></tbody></table></figure><p>如果指定<code>-v</code> 会显示需要读写远程仓库使用的 Git 保存的简写与之对应的 URL 如果远程仓库不止一个 还会将协作者一起列出来</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br></pre></td></tr></tbody></table></figure><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库 同时指定一个方便使用的简写</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit</span><br><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></tbody></table></figure><p>如果想要拉取仓库的代码 使用 git fetch pb</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch pb</span><br></pre></td></tr></tbody></table></figure><h4 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h4><p>从远程仓库中获取代码 可以执行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></tbody></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你的当前分支设置了跟踪远程分支 那么可以用 <code>git pull</code> 命令来自动抓取后合并该远程分支到当前分支。</p><p>默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 <code>master</code> 分支（或其它名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p><code>git push &lt;remote&gt; &lt;branch&gt;</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master//将master分支推送到origin分支</span><br></pre></td></tr></tbody></table></figure><h4 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h4><p><code>git remote show &lt;remote&gt;</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                               tracked</span><br><span class="line">    dev-branch                           tracked</span><br><span class="line">  Local branch configured for 'git pull':</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for 'git push':</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></tbody></table></figure><h4 id="远程仓库的重命名与移除"><a href="#远程仓库的重命名与移除" class="headerlink" title="远程仓库的重命名与移除"></a>远程仓库的重命名与移除</h4><p><code>git remote rename</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul //将pb重命名未paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></tbody></table></figure><p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p><p>移除一个远程仓库</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote remove paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></tbody></table></figure><p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git 管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学VueAPI</title>
      <link href="/2022/04/14/vueapi/"/>
      <url>/2022/04/14/vueapi/</url>
      
        <content type="html"><![CDATA[<h1 id="全局-API"><a href="#全局-API" class="headerlink" title="全局 API"></a>全局 API</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="createApp"><a href="#createApp" class="headerlink" title="createApp()"></a>createApp()</h3><ul><li>类型</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function createApp(rootComponent: Component, rootProps?: object): App</span><br></pre></td></tr></tbody></table></figure><ul><li><p>细节</p><p>第一个参数是根组件 第二个是传递给跟组件的 props</p></li><li><p>例子</p><p>使用内联根组件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createApp } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>({</span><br><span class="line">  <span class="comment">/* root component options */</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>使用引用组件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createApp } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">"./App.vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="app-mount"><a href="#app-mount" class="headerlink" title="app.mount()"></a>app.mount()</h3><ul><li><p>类型</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  <span class="title function_">mount</span>(<span class="attr">rootContainer</span>: <span class="title class_">Element</span> | <span class="built_in">string</span>): <span class="title class_">ComponentPublicInstance</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>细节</p><p>参数可以是实际的 DOM 元素或 CSS 选择器 返回根组件实例</p><p>如果组件定义了模板或渲染函数 他将替代容器内现有的 DOM 节点 否则 将在运行时使用容器的 innerHTML 作为模板</p><p>对于每个实例 <code>mount()</code>只能调用一次</p></li></ul><p>app.unmount()</p><p>卸载已挂载的应用程序实例 触发应用程序组件树中所有组件的卸载生命周期</p><ul><li>类型</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  <span class="title function_">unmount</span>(): <span class="built_in">void</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="app-provide"><a href="#app-provide" class="headerlink" title="app.provide"></a>app.provide</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  provide&lt;T&gt;(<span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;T&gt; | <span class="built_in">symbol</span> | <span class="built_in">string</span>, <span class="attr">value</span>: T): <span class="variable language_">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>期望注入值作为第一个参数 提供的值作为第二个参数 返回应用程序实例本身</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { provide } from "vue";</span><br><span class="line"></span><br><span class="line">provide(/* key */ "message", /* value */ "hello!");</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import { inject } from "vue";</span><br><span class="line"></span><br><span class="line">const message = inject("message");</span><br><span class="line">const value = inject("message", "default value"); //注入默认值</span><br><span class="line">const value = inject("key", () =&gt; new ExpensiveClass()); //避免在不适用可选值的情况下产生不必要的计算或副作用 可以使用工厂函数来创建默认值</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="app-component"><a href="#app-component" class="headerlink" title="app.component()"></a>app.component()</h3><ul><li>类型</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  <span class="title function_">component</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Component</span> | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">component</span>(<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">component</span>: <span class="title class_">Component</span>): <span class="variable language_">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>例子</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import { createApp } from 'vue' const app = createApp({}) // register an options</span><br><span class="line">object app.component('my-component', { /* ... */ }) // retrieve a registered</span><br><span class="line">component const MyComponent = app.component('my-component')</span><br></pre></td></tr></tbody></table></figure><h3 id="app-directive"><a href="#app-directive" class="headerlink" title="app.directive()"></a>app.directive()</h3><p>如果定义字符串名称 则同时输入指令和指令 则只要检索已注册的指令</p><ul><li>类型</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  <span class="title function_">directive</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Directive</span> | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">directive</span>(<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">directive</span>: <span class="title class_">Directive</span>): <span class="variable language_">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>例子</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import { createApp } from 'vue' const app = createApp({ /* ... */ }) // register</span><br><span class="line">(object directive) app.directive('my-directive', { /* custom directive hooks */</span><br><span class="line">}) // register (function directive shorthand) app.directive('my-directive', ()</span><br><span class="line">=&gt; { /* ... */ }) // retrieve a registered directive const myDirective =</span><br><span class="line">app.directive('my-directive')</span><br></pre></td></tr></tbody></table></figure><h3 id="app-use"><a href="#app-use" class="headerlink" title="app.use()"></a>app.use()</h3><p>安装一个插件</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  <span class="title function_">use</span>(<span class="attr">plugin</span>: <span class="title class_">Plugin</span>, ...<span class="attr">options</span>: <span class="built_in">any</span>[]): <span class="variable language_">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>期望插件作为第一个参数 可选选项作为第二个参数</p><p>插件可以是带有<code>install()</code>方法的对象 也可以是直接的函数</p><p>当<code>app.use()</code>在同一个插件上多次调用时 插件只会安装一次</p><ul><li>例子</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import { createApp } from 'vue' import MyPlugin from './plugins/MyPlugin' const</span><br><span class="line">app = createApp({ /* ... */ }) app.use(MyPlugin)</span><br></pre></td></tr></tbody></table></figure><h3 id="app-version"><a href="#app-version" class="headerlink" title="app.version"></a>app.version</h3><p>提供创建应用程序时使用的 vue 版本 这在插件中很有用 因为可能需要基于不同的 Vue 版本的条件逻辑</p><ul><li>类型</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>例子</li></ul><p>在插件中执行版本检查</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="title function_">install</span>(<span class="params">app</span>) {</span><br><span class="line">    <span class="keyword">const</span> version = <span class="title class_">Number</span>(app.<span class="property">version</span>.<span class="title function_">split</span>(<span class="string">"."</span>)[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (version &lt; <span class="number">3</span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">"This plugin requires Vue 3"</span>);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="app-config"><a href="#app-config" class="headerlink" title="app.config"></a>app.config</h3><h3 id="app-config-errorHandler"><a href="#app-config-errorHandler" class="headerlink" title="app.config.errorHandler"></a>app.config.errorHandler</h3><p>从未应用程序未内部部署的一个内部处理程序</p><ul><li>类型</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">  errorHandler?: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    err: <span class="built_in">unknown</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    instance: ComponentPublicInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// `info` is a Vue-specific error info,</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// e.g. which lifecycle hook the error was thrown in</span></span></span></span><br><span class="line"><span class="params"><span class="function">    info: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>错误处理程序接收三个参数：错误、触发错误的组件实例和指定源类型的信息字符串</p><p>可以捕获到以下错误类型：</p><ul><li>渲染组件</li><li>事件处理程序</li><li>生命周期钩子</li><li>setup()功能</li><li>观察者</li><li>自定义指令钩子</li><li>过度挂载</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.config.errorHandler = (err, instance, info) =&gt; { // handle error, e.g.</span><br><span class="line">report to a service }</span><br></pre></td></tr></tbody></table></figure><h3 id="app-config-warnHandler"><a href="#app-config-warnHandler" class="headerlink" title="app.config.warnHandler"></a>app.config.warnHandler</h3><p>为来自 Vue 的运行时警告分配一个自定义处理程序</p><ul><li>类型</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">  warnHandler?: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    msg: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    instance: ComponentPublicInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    trace: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//第一个参数时接收警告信息 第二个参数是源组件实例 第三个参数是组件跟踪字符串</span></span><br></pre></td></tr></tbody></table></figure><p>用于过滤特定的警告以减少控制台的冗长 所有 Vue 警告都应该在开发期间解决 因此建议在调试会话期间关注许多特定警告并在调试完成后将其删除</p><p><strong>仅在开发期间有效 因此在生成模式下会忽略此配置</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.config.warnHandler = (msg, instance, trace) =&gt; { // `trace` is the component</span><br><span class="line">hierarchy trace }</span><br></pre></td></tr></tbody></table></figure><h3 id="app-config-performance"><a href="#app-config-performance" class="headerlink" title="app.config.performance"></a>app.config.performance</h3><p>设置为 true 在浏览器开发工具性能/事件线面板中启用组件初始化、编译、渲染和修补性能跟踪 仅用于开发模式和支持<a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark">performance.mark</a> API 的浏览器。</p><h3 id="app-compilerOptions-isCustomElement"><a href="#app-compilerOptions-isCustomElement" class="headerlink" title="app.compilerOptions.isCustomElement"></a>app.compilerOptions.isCustomElement</h3><p>指定一个检查方法来识别本机自定义元素</p><ul><li>类型：（tag: string） =&gt; boolean</li><li>细节</li></ul><p>如果标签被视为本机自定义元素 则应返回 对于匹配的标签 Vue 将其呈现为原生元素 而不是尝试将其解析为 Vue 组件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// treat all tags starting with 'ion-' as custom elements</span><br><span class="line">app.config.compilerOptions.isCustomElement = (tag) =&gt; { return</span><br><span class="line">tag.startsWith('ion-') }</span><br></pre></td></tr></tbody></table></figure><h3 id="app-compilerOptions-whitespace"><a href="#app-compilerOptions-whitespace" class="headerlink" title="app.compilerOptions.whitespace"></a>app.compilerOptions.whitespace</h3><p>调整模板空白处理行为</p><ul><li>类型：<code>‘condense' | 'preserve'</code></li><li>默认： <code>'condense'</code></li><li>细节</li></ul><p>Vue 删除/压缩模板中的空白字符以产生更有效的编译输出 默认策略是“浓缩”</p><ul><li>元素内的前导/结束空白字符被压缩成一个字符</li><li>包含换行符的元素之间的空白字符被删除</li><li>文本节点中连续的空白字符被压缩成一个空格</li></ul><p>将吃选项设置为<code>'preserve'</code>将禁用(2) 和 (3)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config.compilerOptions.whitespace = 'preserve'</span><br></pre></td></tr></tbody></table></figure><h3 id="app-compilerOptions-delimiters"><a href="#app-compilerOptions-delimiters" class="headerlink" title="app.compilerOptions.delimiters"></a>app.compilerOptions.delimiters</h3><p>调整用于模板内文本插值的分隔符</p><ul><li>类型： <code>[string, string]</code></li><li>默认： <code>['{{', '}}']</code></li><li>细节</li></ul><p>通常用于避免与使用 mustache 语法的服务器框架发生冲突</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Delimiters changed to ES6 template string style</span><br><span class="line">app.config.compilerOptions.delimiters = ['${', '}']</span><br></pre></td></tr></tbody></table></figure><h3 id="app-compilerOptions-comments"><a href="#app-compilerOptions-comments" class="headerlink" title="app.compilerOptions.comments"></a>app.compilerOptions.comments</h3><p>调整模板中 HTML 注释的处理方法</p><ul><li>boolean</li><li>默认： false</li><li>细节</li></ul><p>默认情况下 Vue 会删除生产环境中的注释 将此选项设置为 true 将强制 vue 即使在生产中也保留注释 在开发过程中始终保留注释</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config.compilerOptions.comments = true</span><br></pre></td></tr></tbody></table></figure><h2 id="app-config-globalProperties"><a href="#app-config-globalProperties" class="headerlink" title="app.config.globalProperties"></a>app.config.globalProperties</h2><p>可用于注册全局属性的对象 可在应用程序内的任何组件实例上访问这些属性</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">  <span class="attr">globalProperties</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>细节</p></li><li><p>与任何全局的东西一样 应该谨慎使用它</p></li><li><p>如果全局属性与自己的属性充裕 组件自己的属性将拥有更高的优先级</p></li><li><p>```vue<br>app.config.globalProperties.msg = ‘hello’ export default { mounted() {<br>console.log(this.msg) // ‘hello’ } }</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### nextTick（）</span><br><span class="line"></span><br><span class="line">等待下一次 DOM 更新刷新的应用程序</span><br><span class="line"></span><br><span class="line">```typescript</span><br><span class="line">function nextTick(callback?: () =&gt; void): Promise&lt;void&gt;;</span><br></pre></td></tr></tbody></table></figure></li><li><p>细节</p></li></ul><p>当你在 Vue 改变响应状态时 生成的 DOM 更新不会同步应用 Vue 会缓存它们直到下一个 nextTick（）以确保无论您进行了多少次状态更改每个组件都只更新一次</p><p>nextTick()可以在状态更改后立即使用以等待 DOM 更新完成 可以将回调作为参数传递 也可以等待返回的 Promise</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { ref, nextTick } from "vue";</span><br><span class="line"></span><br><span class="line">const count = ref(0);</span><br><span class="line"></span><br><span class="line">async function increment() {</span><br><span class="line">  count.value++;</span><br><span class="line"></span><br><span class="line">  // DOM not yet updated</span><br><span class="line">  console.log(document.getElementById("counter").textContent); // 0</span><br><span class="line"></span><br><span class="line">  await nextTick();</span><br><span class="line">  // DOM is now updated</span><br><span class="line">  console.log(document.getElementById("counter").textContent); // 1</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button id="counter" @click="increment"&gt;{{ count }}&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="defineComponent"><a href="#defineComponent" class="headerlink" title="defineComponent()"></a>defineComponent()</h2><p>用于定义具有类型推断的 Vue 组件的类型助手</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  component: ComponentOptions | ComponentOptions[<span class="string">"setup"</span>]</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">ComponentConstructor</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="defineAsyncComponent"><a href="#defineAsyncComponent" class="headerlink" title="defineAsyncComponent()"></a>defineAsyncComponent()</h2><p>定义一个仅在渲染时才延迟加载的异步组件 参数可以是加载器函数 也可以是用于更高级控制加载行为的选项对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineAsyncComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  source: AsyncComponentLoader | AsyncComponentOptions</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AsyncComponentLoader</span> = <span class="function">() =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="title class_">Component</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AsyncComponentOptions</span> {</span><br><span class="line">  <span class="attr">loader</span>: <span class="title class_">AsyncComponentLoader</span>;</span><br><span class="line">  loadingComponent?: <span class="title class_">Component</span>;</span><br><span class="line">  errorComponent?: <span class="title class_">Component</span>;</span><br><span class="line">  delay?: <span class="built_in">number</span>;</span><br><span class="line">  timeout?: <span class="built_in">number</span>;</span><br><span class="line">  suspensible?: <span class="built_in">boolean</span>;</span><br><span class="line">  onError?: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    error: <span class="built_in">Error</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    retry: () =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    fail: () =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    attempts: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Composition-api"><a href="#Composition-api" class="headerlink" title="Composition api"></a>Composition api</h1><h2 id="setup（）"><a href="#setup（）" class="headerlink" title="setup（）"></a>setup（）</h2><p>如果对 props 对象解构 那么将失去响应性</p><p>可以使用 toRefs()或 toRef()程序执行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import { toRefs, toRef } from 'vue' export default { setup(props) { // turn</span><br><span class="line">`props` into an object of refs, then destructure const { title } = toRefs(props)</span><br><span class="line">// `title` is a ref that tracks `props.title` console.log(title.value) // OR,</span><br><span class="line">turn a single property on `props` into a ref const title = toRef(props, 'title')</span><br><span class="line">} }</span><br></pre></td></tr></tbody></table></figure><h3 id="Setup-Context"><a href="#Setup-Context" class="headerlink" title="Setup Context"></a>Setup Context</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default { setup(props, context) { // Attributes (Non-reactive object,</span><br><span class="line">equivalent to $attrs) console.log(context.attrs) // Slots (Non-reactive object,</span><br><span class="line">equivalent to $slots) console.log(context.slots) // Emit events (Function,</span><br><span class="line">equivalent to $emit) console.log(context.emit) // Expose public properties</span><br><span class="line">(Function) console.log(context.expose) } }</span><br></pre></td></tr></tbody></table></figure><p>context 不是响应式的 可以安全地解构</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default { setup(props, { attrs, slots, emit, expose }) { ... } }</span><br></pre></td></tr></tbody></table></figure><p>如果打算对更改执行副作用 应该在生命周期钩子中执行此操作<code>attrsslotsattrsslotsonBeforeUpdate</code></p><p><code>expose</code>是一个函数 可以显式限制父组件通过模板 refs 访问组件实例时暴露的属性：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, { expose }</span>) {</span><br><span class="line">    <span class="comment">// make the instance "closed" -</span></span><br><span class="line">    <span class="comment">// i.e. do not expose anything to the parent</span></span><br><span class="line">    <span class="title function_">expose</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> publicCount = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> privateCount = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// selectively expose local state</span></span><br><span class="line">    <span class="title function_">expose</span>({ <span class="attr">count</span>: publicCount });</span><br><span class="line">  },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="与渲染函数一起使用"><a href="#与渲染函数一起使用" class="headerlink" title="与渲染函数一起使用"></a>与渲染函数一起使用</h3><p><code>setup</code>还可以返回一个渲染函数 该函数可以直接使用同一范围内声明的反应状态</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { h, ref } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">"div"</span>, count.<span class="property">value</span>);</span><br><span class="line">  },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>返回一个渲染函数可以的防止我们返回其他任何东西 可以使用<code>expose()</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { h, ref } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, { expose }</span>) {</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; ++count.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expose</span>({</span><br><span class="line">      increment,</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">"div"</span>, count.<span class="property">value</span>);</span><br><span class="line">  },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>然后 该<code>increment</code>方法将通过模板引用在父组件中可用</p><h2 id="反应性核心"><a href="#反应性核心" class="headerlink" title="反应性核心"></a>反应性核心</h2><h3 id="ref（）"><a href="#ref（）" class="headerlink" title="ref（）"></a>ref（）</h3><p>接收一个内部值并返回一个反应性和响应的 ref 对象 他还有一个<code>.value</code>指向内部值的属性</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> ref&lt;T&gt;(<span class="attr">value</span>: T): <span class="title class_">Ref</span>&lt;<span class="title class_">UnwrapRef</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Ref</span>&lt;T&gt; {</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>如果一个对象被分配为一个 ref 的值 那么该对象将与<code>reactive()</code>进行深度响应 这也意味着如果对象包含嵌套的 ref 它们将被深度展开</p><p>为了避免深度转换 请使用<code>shallowRef()</code></p><h3 id="computed"><a href="#computed" class="headerlink" title="computed()"></a>computed()</h3><p>接收一个函数并未 getter 的返回值返回一个实时的<code>ref</code>对象 可以使用具有<code>get</code>和<code>set</code>函数的对象来创建 ref 对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read-only</span></span><br><span class="line"><span class="keyword">function</span> computed&lt;T&gt;(</span><br><span class="line">  <span class="attr">getter</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  <span class="comment">// see "Computed Debugging" link below</span></span><br><span class="line">  debuggerOptions?: <span class="title class_">DebuggerOptions</span></span><br><span class="line">): <span class="title class_">Readonly</span>&lt;<span class="title class_">Ref</span>&lt;<span class="title class_">Readonly</span>&lt;T&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// writable</span></span><br><span class="line"><span class="keyword">function</span> computed&lt;T&gt;(</span><br><span class="line">  <span class="attr">options</span>: {</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> T;</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">value: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  },</span><br><span class="line">  debuggerOptions?: <span class="title class_">DebuggerOptions</span></span><br><span class="line">): <span class="title class_">Ref</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a>reactive()</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> reactive&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">target</span>: T): <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><p>当使用数组的元素或者集合类型如(<code>Map</code>) 为避免深度转换并仅在根级别保留响应性 可以改用<code>shallowReactive()</code></p><p>返回的对象及其嵌套对象被 ES Proxy 包裹 不等于原始对象 建议只使用响应式代理并避免依赖原始对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>({ count });</span><br><span class="line"></span><br><span class="line"><span class="comment">// ref will be unwrapped</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span> === count.<span class="property">value</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// it will update `obj.count`</span></span><br><span class="line">count.<span class="property">value</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// it will also update `count` ref</span></span><br><span class="line">obj.<span class="property">count</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>); <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><p>当作为数组或集合元素访问时 refs 不会被解构</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = <span class="title function_">reactive</span>([<span class="title function_">ref</span>(<span class="string">"Vue 3 Guide"</span>)]);</span><br><span class="line"><span class="comment">// need .value here</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(books[<span class="number">0</span>].<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="title function_">reactive</span>(<span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">"count"</span>, <span class="title function_">ref</span>(<span class="number">0</span>)]]));</span><br><span class="line"><span class="comment">// need .value here</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">"count"</span>).<span class="property">value</span>);</span><br></pre></td></tr></tbody></table></figure><p>将 ref 分配给 reactive 属性时 该 ref 将自动展开</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>({});</span><br><span class="line"></span><br><span class="line">obj.<span class="property">count</span> = count;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span> === count.<span class="property">value</span>); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly()"></a>readonly()</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">readonly</span>&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">DeepReadonly</span>&lt;<span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;&gt;;</span><br></pre></td></tr></tbody></table></figure><p>它展示的任何属性都将是潜在的<code>reactive()</code></p><p>避免深度转换 请使用<code>shallowReadonly()</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>({ <span class="attr">count</span>: <span class="number">0</span> });</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="title function_">readonly</span>(original);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="comment">// works for reactivity tracking</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(copy.<span class="property">count</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating original will trigger watchers relying on the copy</span></span><br><span class="line">original.<span class="property">count</span>++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating the copy will fail and result in a warning</span></span><br><span class="line">copy.<span class="property">count</span>++; <span class="comment">// warning!</span></span><br></pre></td></tr></tbody></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect()"></a>watchEffect()</h3><p>立即运行一个函数，同时跟随变化时重新关注它的依赖关系，并在依赖关系发生时重新运行它。</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  effect: (onCleanup: OnCleanup) =&gt; <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">  options?: WatchEffectOptions</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">StopHandle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OnCleanup</span> = <span class="function">(<span class="params">cleanupFn: () =&gt; <span class="built_in">void</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">WatchEffectOptions</span> {</span><br><span class="line">  flush?: <span class="string">"pre"</span> | <span class="string">"post"</span> | <span class="string">"sync"</span>; <span class="comment">// default: 'pre'</span></span><br><span class="line">  onTrack?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onTrigger?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StopHandle</span> = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>第一个参数是要运行的效果函数 效果函数接收可用于注册清理回调的函数 清理回调将在下一次重新运行效果之前调用 可用于清理无效的副作用 例如挂起的异步请求</p><p>第二个参数是可选的选项对象 用于调整效果的刷新时间或调试效果的依赖关系</p><p>返回值是一个 handdle 函数可以用来组织效果再次运行</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>));</span><br><span class="line"><span class="comment">// -&gt; logs 0</span></span><br><span class="line"></span><br><span class="line">count.<span class="property">value</span>++;</span><br><span class="line"><span class="comment">// -&gt; logs 1</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>));</span><br><span class="line"><span class="comment">// -&gt; logs 0</span></span><br><span class="line"></span><br><span class="line">count.<span class="property">value</span>++;</span><br></pre></td></tr></tbody></table></figure><p>副作用清理</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">async</span> (onCleanup) =&gt; {</span><br><span class="line">  <span class="keyword">const</span> { response, cancel } = <span class="title function_">doAsyncWork</span>(id.<span class="property">value</span>);</span><br><span class="line">  <span class="comment">// `cancel` will be called if `id` changes</span></span><br><span class="line">  <span class="comment">// so that previous pending request will be cancelled</span></span><br><span class="line">  <span class="comment">// if not yet completed</span></span><br><span class="line">  <span class="title function_">onCleanup</span>(cancel);</span><br><span class="line">  data.<span class="property">value</span> = <span class="keyword">await</span> response;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>停止观察者</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> {});</span><br><span class="line"></span><br><span class="line"><span class="comment">// when the watcher is no longer needed:</span></span><br><span class="line"><span class="title function_">stop</span>();</span><br></pre></td></tr></tbody></table></figure><p>Options:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> {}, {</span><br><span class="line">  <span class="attr">flush</span>: <span class="string">"post"</span>,</span><br><span class="line">  <span class="title function_">onTrack</span>(<span class="params">e</span>) {</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">onTrigger</span>(<span class="params">e</span>) {</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">  },</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch()"></a>watch()</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watching single source</span></span><br><span class="line"><span class="keyword">function</span> watch&lt;T&gt;(</span><br><span class="line">  <span class="attr">source</span>: <span class="title class_">WatchSource</span>&lt;T&gt;,</span><br><span class="line">  <span class="attr">callback</span>: <span class="title class_">WatchCallback</span>&lt;T&gt;,</span><br><span class="line">  options?: <span class="title class_">WatchOptions</span></span><br><span class="line">): <span class="title class_">StopHandle</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// watching multiple sources</span></span><br><span class="line"><span class="keyword">function</span> watch&lt;T&gt;(</span><br><span class="line">  <span class="attr">sources</span>: <span class="title class_">WatchSource</span>&lt;T&gt;[],</span><br><span class="line">  <span class="attr">callback</span>: <span class="title class_">WatchCallback</span>&lt;T[]&gt;,</span><br><span class="line">  options?: <span class="title class_">WatchOptions</span></span><br><span class="line">): <span class="title class_">StopHandle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">WatchCallback</span>&lt;T&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: T,</span></span></span><br><span class="line"><span class="params"><span class="function">  oldValue: T,</span></span></span><br><span class="line"><span class="params"><span class="function">  onCleanup: (cleanupFn: () =&gt; <span class="built_in">void</span>) =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">WatchSource</span>&lt;T&gt; =</span><br><span class="line">  | <span class="title class_">Ref</span>&lt;T&gt; <span class="comment">// ref</span></span><br><span class="line">  | (<span class="function">() =&gt;</span> T) <span class="comment">// getter</span></span><br><span class="line">  | T <span class="keyword">extends</span> <span class="built_in">object</span></span><br><span class="line">  ? T</span><br><span class="line">  : <span class="built_in">never</span>; <span class="comment">// reactive object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">WatchOptions</span> <span class="keyword">extends</span> <span class="title class_">WatchEffectOptions</span> {</span><br><span class="line">  immediate?: <span class="built_in">boolean</span>; <span class="comment">// default: false</span></span><br><span class="line">  deep?: <span class="built_in">boolean</span>; <span class="comment">// default: false</span></span><br><span class="line">  flush?: <span class="string">"pre"</span> | <span class="string">"post"</span> | <span class="string">"sync"</span>; <span class="comment">// default: 'pre'</span></span><br><span class="line">  onTrack?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onTrigger?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p><code>watch</code>默认是惰性的 即当监视的源发生更改时才调用回调</p><p>第三个参数时一个<code>options</code></p><ul><li>**<code>immediate</code>**：在观察者创建时立即触发回调。旧值将<code>undefined</code>在第一次调用时出现。</li><li>**<code>deep</code>**：如果源是对象，则强制深度遍历源，以便回调触发深度突变。</li><li>**<code>flush</code>**：调整回调的刷新时间。</li><li><strong><code>onTrack / onTrigger</code></strong>: 调试观察者的依赖</li></ul><p>相比<a href="https://vuejs.org/api/reactivity-core.html#watcheffect"><code>watchEffect()</code></a>，<code>watch()</code>允许我们：</p><ul><li>懒惰地执行副作用；</li><li>更具体地说明应该触发观察者重新运行的状态；</li><li>访问监视状态的先前值和当前值。</li></ul><p>当观察多个源时 回调函数将接收包含与源数组对应的新/旧值的数组</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>([fooRef, barRef], <span class="function">(<span class="params">[foo, bar], [prevFoo, prevBar]</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>如果希望回调即使在深度突变时也能触发 那么需要使用显式强制观察者进入深度模式{deep: <code>true</code>} <strong>在深度模式下 如果回调是由深度突变触发的 那么新值和旧值将是同一个对象</strong></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>({ <span class="attr">count</span>: <span class="number">0</span> });</span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> state,</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// newValue === oldValue</span></span><br><span class="line">  },</span><br><span class="line">  { <span class="attr">deep</span>: <span class="literal">true</span> }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p><strong>如果直接观察响应式对象 观察者处于深度模式</strong></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>({ <span class="attr">count</span>: <span class="number">0</span> });</span><br><span class="line"><span class="title function_">watch</span>(state, <span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="comment">/* triggers on deep mutation to state */</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h2 id="Reactivity-Utilities"><a href="#Reactivity-Utilities" class="headerlink" title="Reactivity: Utilities"></a>Reactivity: Utilities</h2><h3 id="isRef"><a href="#isRef" class="headerlink" title="isRef()"></a>isRef()</h3><p>检查一个值是否是一个 ref 对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> isRef&lt;T&gt;(<span class="attr">r</span>: <span class="title class_">Ref</span>&lt;T&gt; | <span class="built_in">unknown</span>): r is <span class="title class_">Ref</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><p>返回类型是一个类型谓词 可以作为类型保护</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">unknown</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isRef</span>(foo)) {</span><br><span class="line">  <span class="comment">// foo's type is narrowed to Ref&lt;unknown&gt;</span></span><br><span class="line">  foo.<span class="property">value</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="unref"><a href="#unref" class="headerlink" title="unref()"></a>unref()</h3><p>如果参数是 ref 则返回内部值 否则返回参数本身</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = <span class="title function_">isRef</span>(val) ? val.<span class="property">value</span> : val;</span><br></pre></td></tr></tbody></table></figure><h3 id="toRef（）"><a href="#toRef（）" class="headerlink" title="toRef（）"></a>toRef（）</h3><p>用于为源响应对象上的属性创建 ref 创建的 ref 与其源属性同步 改变原属性将更新 ref</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> toRef&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, K <span class="keyword">extends</span> keyof T&gt;(</span><br><span class="line">  <span class="attr">object</span>: T,</span><br><span class="line">  <span class="attr">key</span>: K,</span><br><span class="line">  defaultValue?: T[K]</span><br><span class="line">): <span class="title class_">ToRef</span>&lt;T[K]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToRef</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">Ref</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>({</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooRef = <span class="title function_">toRef</span>(state, <span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating the ref updates the original</span></span><br><span class="line">fooRef.<span class="property">value</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">foo</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating the original also updates the ref</span></span><br><span class="line">state.<span class="property">foo</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooRef.<span class="property">value</span>); <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><p>当你想将 prop 的 ref 传递给可组合函数时很有用</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> {toRef} <span class="keyword">from</span> <span class="string">'vue'</span> <span class="keyword">const</span> props = <span class="title function_">defineProps</span>(<span class="comment">/* ... */</span>) <span class="comment">// convert</span></span><br><span class="line">  <span class="string">`props.foo`</span> into a ref, then pass into <span class="comment">// a composable</span></span><br><span class="line">  <span class="title function_">useSomeFeature</span>(<span class="title function_">toRef</span>(props, <span class="string">'foo'</span>))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>但是如果尝试为 ref 分配新值时相当直接修改 prop 这是不允许的 这种情况下 可以考虑使用 computed 来替代</p><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs()"></a>toRefs()</h3><p>将响应式对象转换为普通对象 其中结果对象的每个属性都是指向原始对象相应属性的 ref 每个单独的 ref 都是使用 toRef()```创建的</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> toRefs&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(</span><br><span class="line">  <span class="attr">object</span>: T</span><br><span class="line">): {</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: <span class="title class_">ToRef</span>&lt;T[K]&gt;;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToRef</span> = T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">Ref</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>({</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stateAsRefs = <span class="title function_">toRefs</span>(state);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Type of stateAsRefs: {</span></span><br><span class="line"><span class="comment">  foo: Ref&lt;number&gt;,</span></span><br><span class="line"><span class="comment">  bar: Ref&lt;number&gt;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The ref and the original property is "linked"</span></span><br><span class="line">state.<span class="property">foo</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stateAsRefs.<span class="property">foo</span>.<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">stateAsRefs.<span class="property">foo</span>.<span class="property">value</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">foo</span>); <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><p>toRefs 在从可组合函数返回响应式对象时很有用 以便使用组件可以构建/扩展返回的对象而不会失去响应性</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useFeatureX</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">const</span> state = <span class="title function_">reactive</span>({</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...logic operating on state</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// convert to refs when returning</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// can destructure without losing reactivity</span></span><br><span class="line"><span class="keyword">const</span> { foo, bar } = <span class="title function_">useFeatureX</span>();</span><br></pre></td></tr></tbody></table></figure><p><code>toRefs</code>只会在调用时为源对象上可枚举的属性生成引用。要为可能尚不存在的属性创建 ref，请<a href="https://vuejs.org/api/reactivity-utilities.html#toref"><code>toRef</code></a>改用。</p><h3 id="isProxy"><a href="#isProxy" class="headerlink" title="isProxy()"></a>isProxy()</h3><p>Checks if an object is a proxy created by <a href="https://vuejs.org/api/reactivity-core.html#reactive"><code>reactive()</code></a>, <a href="https://vuejs.org/api/reactivity-core.html#readonly"><code>readonly()</code></a>, <a href="https://vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> or <a href="https://vuejs.org/api/reactivity-advanced.html#shallowreadonly"><code>shallowReadonly()</code></a>.</p><h3 id="isReactive"><a href="#isReactive" class="headerlink" title="isReactive()"></a>isReactive()</h3><p>Checks if an object is a proxy created by <a href="https://vuejs.org/api/reactivity-core.html#reactive"><code>reactive()</code></a> or <a href="https://vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a>.</p><h3 id="isReadonly"><a href="#isReadonly" class="headerlink" title="isReadonly()"></a>isReadonly()</h3><p>Checks if an object is a proxy created by <a href="https://vuejs.org/api/reactivity-core.html#readonly"><code>readonly()</code></a> or <a href="https://vuejs.org/api/reactivity-advanced.html#shallowreadonly"><code>shallowReadonly()</code></a>.</p><h2 id="响应式：高级"><a href="#响应式：高级" class="headerlink" title="响应式：高级"></a>响应式：高级</h2><h3 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a>shallowRef</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> shallowRef&lt;T&gt;(<span class="attr">value</span>: T): <span class="title class_">ShallowRef</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ShallowRef</span>&lt;T&gt; {</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与<code>ref()</code>不同 <code>shallowdRef</code>的内部值按原样储存和公开 不会被深度响应 只有.<code>value</code>是响应性的</p><p>通常用于大型数据结构的性能优化 或外部状态管理系统的集成</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">shallowRef</span>({ <span class="attr">count</span>: <span class="number">1</span> });</span><br><span class="line"></span><br><span class="line"><span class="comment">// does NOT trigger change</span></span><br><span class="line">state.<span class="property">value</span>.<span class="property">count</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// does trigger change</span></span><br><span class="line">state.<span class="property">value</span> = { <span class="attr">count</span>: <span class="number">2</span> };</span><br></pre></td></tr></tbody></table></figure><h3 id="triggerRef"><a href="#triggerRef" class="headerlink" title="triggerRef()"></a>triggerRef()</h3><p>强制触发效果取决于<code>shallowRef</code> 这通常在浅反应的内部值进行深度突变后使用</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">triggerRef</span>(<span class="params">ref: ShallowRef</span>): <span class="built_in">void</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallow = <span class="title function_">shallowRef</span>({</span><br><span class="line">  <span class="attr">greet</span>: <span class="string">"Hello, world"</span>,</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs "Hello, world" once for the first run-through</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(shallow.<span class="property">value</span>.<span class="property">greet</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// This won't trigger the effect because the ref is shallow</span></span><br><span class="line">shallow.<span class="property">value</span>.<span class="property">greet</span> = <span class="string">"Hello, universe"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs "Hello, universe"</span></span><br><span class="line"><span class="title function_">triggerRef</span>(shallow);</span><br></pre></td></tr></tbody></table></figure><h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef()"></a>customRef()</h3><p>创建一个自定义的 ref 显式控制其依赖跟踪和更新触发</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> customRef&lt;T&gt;(<span class="attr">factory</span>: <span class="title class_">CustomRefFactory</span>&lt;T&gt;): <span class="title class_">Ref</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CustomRefFactory</span>&lt;T&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  track: () =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  trigger: () =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> {</span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> T;</span><br><span class="line">  <span class="attr">set</span>: <span class="function">(<span class="params">value: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p><code>customRef()</code>需要一个工厂函数 它接收<code>track</code>和<code>trigger</code>函数作为参数 并返回一个带有<code>get</code>和<code>set</code>方法的对象</p><p><code>track</code>应该叫<code>get（）</code> trigger 应该叫<code>set</code> 但是 我们可以控制合适调用以及是否调用它们</p><ul><li>例子</li></ul><p>创建一个 debounced ref 它只在最近一次 set 调用某个超时后的更新值：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { customRef } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useDebouncedRef</span>(<span class="params">value, delay = <span class="number">200</span></span>) {</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">customRef</span>(<span class="function">(<span class="params">track, trigger</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="title function_">track</span>()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      },</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) {</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">          value = newValue</span><br><span class="line">          <span class="title function_">trigger</span>()</span><br><span class="line">        }, delay)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"><span class="comment">//在组件中的用法</span></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> { useDebouncedRef } <span class="keyword">from</span> <span class="string">'./debouncedRef'</span></span><br><span class="line"><span class="keyword">const</span> text = <span class="title function_">useDebouncedRef</span>(<span class="string">'hello'</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"text"</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="comment">//可用于搜索等功能的防抖节流 可以避免频繁的请求 用watch监听</span></span><br></pre></td></tr></tbody></table></figure><h3 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive()"></a>shallowReactive()</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> shallowReactive&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">target</span>: T): T;</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>没有深度响应 只有根级属性是响应性的 属性值按原样储存和公开 这也意味着具有 ref 值的属性不会自动展开</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">shallowReactive</span>({</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">nested</span>: {</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating state's own properties is reactive</span></span><br><span class="line">state.<span class="property">foo</span>++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...but does not convert nested objects</span></span><br><span class="line"><span class="title function_">isReactive</span>(state.<span class="property">nested</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NOT reactive</span></span><br><span class="line">state.<span class="property">nested</span>.<span class="property">bar</span>++;</span><br></pre></td></tr></tbody></table></figure><h3 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly()"></a>shallowReadonly()</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> shallowReadonly&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">target</span>: T): <span class="title class_">Readonly</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><p>与 不同<code>readonly()</code>的是，没有深度转换：只有根级属性是只读的。属性值按原样存储和公开 - 这也意味着具有 ref 值的属性<strong>不会</strong>自动展开。</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">shallowReadonly</span>({</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">nested</span>: {</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating state's own properties will fail</span></span><br><span class="line">state.<span class="property">foo</span>++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...but works on nested objects</span></span><br><span class="line"><span class="title function_">isReadonly</span>(state.<span class="property">nested</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// works</span></span><br><span class="line">state.<span class="property">nested</span>.<span class="property">bar</span>++;</span><br></pre></td></tr></tbody></table></figure><h3 id="toRaw（）"><a href="#toRaw（）" class="headerlink" title="toRaw（）"></a>toRaw（）</h3><p>返回 Vue 创建的代理的原始对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> toRaw&lt;T&gt;(<span class="attr">proxy</span>: T): T;</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p><code>toRaw()</code> can return the original object from proxies created by <a href="https://vuejs.org/api/reactivity-core.html#reactive"><code>reactive()</code></a>, <a href="https://vuejs.org/api/reactivity-core.html#readonly"><code>readonly()</code></a>, <a href="https://vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> or <a href="https://vuejs.org/api/reactivity-advanced.html#shallowreadonly"><code>shallowReadonly()</code></a>.</p><p>可用于临时读取而不会产生代理访问/跟踪开销或写入而部触发更改 不建议持有对原始对象的持久引用 谨慎使用</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = {};</span><br><span class="line"><span class="keyword">const</span> reactiveFoo = <span class="title function_">reactive</span>(foo);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">toRaw</span>(reactiveFoo) === foo); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="effectScope"><a href="#effectScope" class="headerlink" title="effectScope()"></a>effectScope()</h3><p>可以在其中创建一个对象 api 观察对象的范围（computed and watchers）以便观察这些对象的详细使用情况</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">effectScope</span>(<span class="params">detached?: <span class="built_in">boolean</span></span>): <span class="title class_">EffectScope</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">EffectScope</span> {</span><br><span class="line">  run&lt;T&gt;(<span class="attr">fn</span>: <span class="function">() =&gt;</span> T): T | <span class="literal">undefined</span>; <span class="comment">// undefined if scope is inactive</span></span><br><span class="line">  <span class="title function_">stop</span>(): <span class="built_in">void</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scope = <span class="title function_">effectScope</span>();</span><br><span class="line"></span><br><span class="line">scope.<span class="title function_">run</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> doubled = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> counter.<span class="property">value</span> * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">watch</span>(doubled, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(doubled.<span class="property">value</span>));</span><br><span class="line"></span><br><span class="line">  <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Count: "</span>, doubled.<span class="property">value</span>));</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// to dispose all effects in the scope</span></span><br><span class="line">scope.<span class="title function_">stop</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><h3 id="onMounted"><a href="#onMounted" class="headerlink" title="onMounted"></a>onMounted</h3><p>组件在以下情况视为已挂载完成</p><ul><li>他的所有同步子组件都已挂载（不包括异步组件或<code>&lt;Suspense&gt;</code>树内的组件）</li><li>它自己的 DOM 树已创建并插入到父容器中 如果应用程序的根容器也在文档内 它只保证组件的 DOM 树在文档内</li></ul><p>通常用于执行需要访问组件渲染的 DOM 的副作用</p><p><strong>在服务端渲染期间不会调用此钩子</strong></p><h3 id="onUpdated"><a href="#onUpdated" class="headerlink" title="onUpdated()"></a>onUpdated()</h3><p>注册一个回调 以便在组件由于响应式状态改变而更新其 DOM 树后调用</p><ul><li>细节</li></ul><p>父组件的更新钩子在其子组件之后被调用</p><p><strong>在组件的任何 DOM 更新后都会调用此钩子 这可能是由不同的状态更改引起的 如果需要在特定的状态更改后访问更新的 DOM 改用 nextTick()</strong></p><p>服务器渲染期间不会调用此钩子</p><blockquote><p>不要在此钩子中改变组件状态 这可能会导致无限更新循环</p></blockquote><h3 id="onUnmounted"><a href="#onUnmounted" class="headerlink" title="onUnmounted()"></a>onUnmounted()</h3><p>注册一个在组件被卸载后调用的回调</p><ul><li><p>以下情况组件已被卸载</p><ul><li>他的所有子组件都已卸载</li><li>预期相关的响应状态（渲染效果以及期间创建的计算属性及观察者）都已停止</li></ul><p><strong>使用此钩子清除手动创建的副作用 例如计时器 DOM 时间侦听器或服务器连接</strong></p><p>在服务器渲染期间不会调用此钩子</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { onMounted, onUnmounted } from "vue";</span><br><span class="line"></span><br><span class="line">let intervalId;</span><br><span class="line">onMounted(() =&gt; {</span><br><span class="line">  intervalId = setInterval(() =&gt; {</span><br><span class="line">    // ...</span><br><span class="line">  });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">onUnmounted(() =&gt; clearInterval(intervalId));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="onBeforeMount"><a href="#onBeforeMount" class="headerlink" title="onBeforeMount()"></a>onBeforeMount()</h3><p>当这个钩子被调用时 说明组件已经完成了响应状态的设置 但是还没有创建 DOM 节点 它即将第一次执行他的 DOM 渲染效果</p><p><strong>在服务端渲染期间不会被调用</strong></p><h3 id="onBeforeUpdate"><a href="#onBeforeUpdate" class="headerlink" title="onBeforeUpdate()"></a>onBeforeUpdate()</h3><p>由于响应式状态更新 在组件即将更新其 DOM 树之前调用</p><p>可以用于 Vue 更新 DOM 之前访问 DOM 状态 在这个钩子中修改组件的状态也是安全的</p><p><strong>服务端渲染期间不会调用此钩子</strong></p><h3 id="onBeforeUnmount"><a href="#onBeforeUnmount" class="headerlink" title="onBeforeUnmount()"></a>onBeforeUnmount()</h3><p>在组件要卸载之前调用</p><p>调用此钩子时 组件实例仍然可以正常工作</p><p><strong>服务端渲染期间不会调用此钩子</strong></p><h3 id="onErrorCaptured"><a href="#onErrorCaptured" class="headerlink" title="onErrorCaptured()"></a>onErrorCaptured()</h3><p>当捕获到从后代组件传播的错误时 注册要调用的钩子</p><p>可以从以下错误源捕获错误</p><ul><li>组件渲染</li><li>事件处理程序</li><li>生命周期钩子</li><li><code>setup()</code>功能</li><li>观察者</li><li>自定义指令钩子</li><li>过渡挂钩</li></ul><p>钩子接收三个参数：错误、触发错误的组件实例和指定错误类型的信息字符串</p><p>可以修改组件状态以<code>errorCaptured()</code>向用户展示错误状态 但是 重要的错误状态 但是 重要的错误状态不应该呈现导致错误的原始内容 否则组件将抛出无限渲染循环</p><p>钩子可以返回<code>false</code>以阻止错误进一步传播</p><p>错误传播规则</p><ul><li><p>默认情况下 <code>app.config.errorHandler</code>如果已定义 所有错误仍会发送到应用程序级别 因此这些错误仍然可以在一个地方报告给分析服务</p></li><li><p>如果一个组件的继承链或父链上存在多个<code>errorCaptured</code>钩子 它们会在同一个错误时被调用</p></li><li><p>如果<code>errorCaptured</code>钩子本身抛出一个错误 这个错误和原始捕获的错误都会被发送到<code>app.config.errorHandler</code></p></li><li><p><code>errorCaptured</code>钩子可以返回<code>false</code>防止错误进一步传播 这本质上说明这个错误已经被处理 应该被忽略 它将防止任何额外的<code>errorCaptured</code>或<code>app.config,errorHandler</code></p><p>被此错误调用</p></li></ul><h3 id="onRenderTracked"><a href="#onRenderTracked" class="headerlink" title="onRenderTracked()"></a>onRenderTracked()</h3><h3 id="onActivated"><a href="#onActivated" class="headerlink" title="onActivated()"></a>onActivated()</h3><p>为了在组件中插入 DOM 作为缓存的一部分后调用<code>&lt;KeepAlive&gt;</code>专属</p><h3 id="onDeactivated"><a href="#onDeactivated" class="headerlink" title="onDeactivated()"></a>onDeactivated()</h3><p>为了从 DOM 删除后调用 作为缓存的树的部分 <code>&lt;keepAlive&gt;</code></p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="provide（）"><a href="#provide（）" class="headerlink" title="provide（）"></a>provide（）</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> provide&lt;T&gt;(<span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;T&gt; | <span class="built_in">string</span>, <span class="attr">value</span>: T): <span class="built_in">void</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p><code>Symbol</code>可用于在<code>provide()</code>和<code>inject()</code>之间同步值类型</p><p><code>provode</code>必须在组件<code>setup()</code>阶段同步调用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { ref, provide } from "vue";</span><br><span class="line">import { fooSymbol } from "./injectionSymbols";</span><br><span class="line"></span><br><span class="line">// provide static value</span><br><span class="line">provide("foo", "bar");</span><br><span class="line"></span><br><span class="line">// provide reactive value</span><br><span class="line">const count = ref(0);</span><br><span class="line">provide("count", count);</span><br><span class="line"></span><br><span class="line">// provide with Symbol keys</span><br><span class="line">provide(fooSymbol, count);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="inject"><a href="#inject" class="headerlink" title="inject()"></a>inject()</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> inject&lt;T&gt;(<span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;T&gt; | <span class="built_in">string</span>): T | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// with default value</span></span><br><span class="line"><span class="keyword">function</span> inject&lt;T&gt;(<span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;T&gt; | <span class="built_in">string</span>, <span class="attr">defaultValue</span>: T): T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// with factory</span></span><br><span class="line"><span class="keyword">function</span> inject&lt;T&gt;(</span><br><span class="line">  <span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;T&gt; | <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">defaultValue</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  <span class="attr">treatDefaultAsFactory</span>: <span class="literal">true</span></span><br><span class="line">): T;</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>第一个参数是 key Vue 将沿着父链查找具有匹配键的提供值 如果父链中的多个组件提供相同的 key 则使用最接近注入组件的那个 如果没有找到相匹配的键 则返回 undefined 或提供的默认值</p><p>第二个参数是可选的 在没有找到匹配的 key 的适合作为默认值 也可以是应该工厂函数来返回创建成本高的值 如果默认值是一个函数 那么 false 必须作为第三个参数传递 表示该函数作为值而不是工厂</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { inject } from "vue";</span><br><span class="line">import { fooSymbol } from "./injectionSymbols";</span><br><span class="line"></span><br><span class="line">// inject static value with default</span><br><span class="line">const foo = inject("foo");</span><br><span class="line"></span><br><span class="line">// inject reactive value</span><br><span class="line">const count = inject("count");</span><br><span class="line"></span><br><span class="line">// inject with Symbol keys</span><br><span class="line">const foo2 = inject(fooSymbol);</span><br><span class="line"></span><br><span class="line">// inject with default value</span><br><span class="line">const bar = inject("foo", "default value");</span><br><span class="line"></span><br><span class="line">// inject with default value factory</span><br><span class="line">const baz = inject("foo", () =&gt; new Map());</span><br><span class="line"></span><br><span class="line">// inject with function default value, by passing the 3rd argument</span><br><span class="line">const fn = inject("function", () =&gt; {}, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h1 id="内置插件"><a href="#内置插件" class="headerlink" title="内置插件"></a>内置插件</h1><h2 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h2><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><p>更新元素的文本内容</p><p><code>v-text</code>通过设置元素的 textContent 属性来工作 因此它将覆盖元素内所有的现有内容 如果只需要更新部分内容 可以使用 mustache 插值代替</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- same as --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>{{msg}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>v-for 默认行为将尝试在不移动元素的情况下就地修补元素 要强制它重新排序 应该提供一个带有<code>key</code>的特殊属性的排序提示</p><p>v-for 也可以处理包括 Map 和 Set</p><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>修饰符：</p><ul><li><code>.stop</code>- 触发<code>event.stopPropagation()</code>。</li><li><code>.prevent</code>- 触发<code>event.preventDefault()</code>。</li><li><code>.capture</code>- 在捕获模式下添加事件监听器。</li><li><code>.self</code>- 仅在从该元素分派事件时触发处理程序。</li><li><code>.{keyAlias}</code>- 仅在某些键上触发处理程序。</li><li><code>.once</code>- 最多触发一次处理程序。</li><li><code>.left</code>- 仅触发鼠标左键事件的处理程序。</li><li><code>.right</code>- 仅触发鼠标右键事件的处理程序。</li><li><code>.middle</code>- 仅触发中键鼠标事件的处理程序。</li><li><code>.passive</code>- 附加一个 DOM 事件<code>{ passive: true }</code>。</li></ul><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>.<code>lazy</code>监听的是<code>change</code>事件而不是<code>input</code>事件</p><p>.<code>number</code>将有效的输入字符串转换为数字</p><p>..<code>trim</code>修建输入</p><h3 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h3><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><p>跳过此元素及其所有子元素的编译</p><p>最常用的用力是显式原始标签</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-pre</span>&gt;</span>{{ this will not be compiled }}<span class="tag">&lt;/<span class="name">span</span>&gt;</span> //渲染结果：{{ this will not</span><br><span class="line">be compiled }}</span><br></pre></td></tr></tbody></table></figure><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>仅渲染元素和组件一次 并跳过以后的更新</p><p>在随后的重新渲染中 元素/组件及其所有子元素将被视为静态内容并跳过 这可用于优化更新性能</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- single element --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>This will never change: {{msg}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- the element have children --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{msg}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- component --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-once</span> <span class="attr">:comment</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `v-for` directive --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"i in list"</span> <span class="attr">v-once</span>&gt;</span>{{i}}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="v-memo"><a href="#v-memo" class="headerlink" title="v-memo"></a>v-memo</h3><p>记忆模板的子树 可用于元素和组件 该指令需要一个固定长度的依赖值数组来记忆比较 如果数组中的每个值都和上次渲染相同 则跳过整个子树的更新</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-memo</span>=<span class="string">"[valueA, valueB]"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>当组件重新渲染时 如果 valueA 和 valueB 都和之前用于 那么它和它的子树的更新都会直接被跳过 甚至连虚拟 dom 的创建都被跳过</p><p>正确指定记忆数组很重要 负责我们肯会跳过应该更新的更新 v-memo 具有空依赖数组(v-memo=”[]” ) 在功能上等同于 v-once</p><h4 id="与-v-for-结合"><a href="#与-v-for-结合" class="headerlink" title="与 v-for 结合"></a>与 v-for 结合</h4><p>v-<code>memo</code>仅为性能关键场景的微优化而提供 很少需要用到 最常见的情况可能是渲染大型 v-for 列表时 （其中 length&gt; 1000）</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span> <span class="attr">v-memo</span>=<span class="string">"[item.id === selected]"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID: {{ item.id }} - selected: {{ item.id === selected }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>...more child nodes<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>当组件的<code>selected</code>状态发生变化时，即使大部分项目保持不变，也会创建大量的 VNode。这里的<code>v-memo</code>用法本质上是说“仅当它从未选中变为选中时才更新此项目，或者相反”。这允许每个未受影响的项目重用其先前的 VNode 并完全跳过差异。请注意，我们不需要<code>item.id</code>在此处包含在 memo 依赖数组中，因为 Vue 会自动从项目的<code>:key</code>.</p><p><code>v-memo</code>也可以在组件上使用，以在子组件更新检查已被取消优化的某些边缘情况下手动防止不需要的更新。但同样，开发人员有责任指定正确的依赖数组以避免跳过必要的更新。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>为单个元素或组件提供过度效果</p><ul><li><code>@before-enter</code></li><li><code>@before-leave</code></li><li><code>@enter</code></li><li><code>@leave</code></li><li><code>@appear</code></li><li><code>@after-enter</code></li><li><code>@after-leave</code></li><li><code>@after-appear</code></li><li><code>@enter-cancelled</code></li><li><code>@leave-cancelled</code>（<code>v-show</code>仅限）</li><li><code>@appear-cancelled</code></li></ul><p>简单元素</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Transition&gt;</span><br><span class="line">  &lt;div v-if="ok"&gt;toggled content&lt;/div&gt;</span><br><span class="line">&lt;/Transition&gt;</span><br></pre></td></tr></tbody></table></figure><p>动态组件 出现过度模式 + 动画</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Transition name="fade" mode="out-in" appear&gt;</span><br><span class="line">  &lt;component :is="view"&gt;&lt;/component&gt;</span><br><span class="line">&lt;/Transition&gt;</span><br></pre></td></tr></tbody></table></figure><p>监听事件转换</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Transition @after-enter="onTransitionComplete"&gt;</span><br><span class="line">  &lt;div v-show="ok"&gt;toggled content&lt;/div&gt;</span><br><span class="line">&lt;/Transition&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="TransitionGroup"><a href="#TransitionGroup" class="headerlink" title="TransitionGroup"></a>TransitionGroup</h3><p>为列表中的多个元素或组件提供过度效果</p><h1 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h1><h2 id="脚本设置"><a href="#脚本设置" class="headerlink" title="脚本设置"></a>脚本设置</h2><p><code>&lt;script setup&gt;</code>的优点</p><ul><li>更简洁的代码 更少的样板</li><li>能够使用纯 typescript 声明 props 和发出的事件</li><li>更好的运行时性能（模板编译成同范围内的渲染函数 无需中间代理）</li><li>更好的 IDE 类型推断性能（服务器从代码中提取类型的工作量更少）</li></ul><h3 id="命名空间组件"><a href="#命名空间组件" class="headerlink" title="命名空间组件"></a>命名空间组件</h3><p>可以使用带有点的组件标签来引用嵌套在对象属性下的组件 当从单个文件中导入多个组件时很有用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import * as Form from "./form-components";</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Form.Input&gt;</span><br><span class="line">    &lt;Form.Label&gt;label&lt;/Form.Label&gt;</span><br><span class="line">  &lt;/Form.Input&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="使用自定义指令"><a href="#使用自定义指令" class="headerlink" title="使用自定义指令"></a>使用自定义指令</h3><p>全局注册的自定义指令正常工作 本地自定义指令不需要显式注册 但是必须遵守命名方案<code>vNameOfDirective</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const vMyDirective = {</span><br><span class="line">  beforeMount: (el) =&gt; {</span><br><span class="line">    // do something with the element</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 v-my-directive&gt;This is a Heading&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果从其他地方引入 可以将其重命名以使用所需的方案</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { myDirective as vMyDirective } from "./MyDirective.js";</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="defineProps-和-defineEmits"><a href="#defineProps-和-defineEmits" class="headerlink" title="defineProps() 和 defineEmits()"></a>defineProps() 和 defineEmits()</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps({</span><br><span class="line">  foo: String,</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">const emit = defineEmits(["change", "delete"]);</span><br><span class="line">// setup code</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>传递给<code>defineProps</code>并将<code>defineEmits</code>从设置中提升到模块范围的选项。因此，选项不能引用在设置范围内声明的局部变量。这样做会导致编译错误。但是，它<em>可以引用</em>导入的绑定，因为它们也在模块范围内。</p><h2 id="useSlots-amp-useAttrs"><a href="#useSlots-amp-useAttrs" class="headerlink" title="useSlots()&amp;useAttrs()"></a><code>useSlots()</code>&amp;<code>useAttrs()</code></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { useSlots, useAttrs } from "vue";</span><br><span class="line"></span><br><span class="line">const slots = useSlots();</span><br><span class="line">const attrs = useAttrs();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong><script setup=""> 不能与 src 属性一起使用</strong></p><h2 id="CSS-特性"><a href="#CSS-特性" class="headerlink" title="CSS 特性"></a>CSS 特性</h2><h3 id="深度选择器"><a href="#深度选择器" class="headerlink" title="深度选择器"></a>深度选择器</h3><p>如果希望<code>scoped</code>样式中可以影响子组件 可以使用`:deep()``味蕾</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="selector-class">.a</span> :<span class="built_in">deep</span>(.b) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="开槽选择器"><a href="#开槽选择器" class="headerlink" title="开槽选择器"></a>开槽选择器</h3><p>默认情况下 作用域样式不会影响由<code>&lt;slot/&gt;</code>渲染的内容 因为它们被认为是由传递它们的父组件拥有 要显式定位插槽内容 使用<code>:slotted</code>伪类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="selector-pseudo">:slotted</span>(<span class="selector-tag">div</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="全局选择器"><a href="#全局选择器" class="headerlink" title="全局选择器"></a>全局选择器</h3><p>如果想要全局应用一个规则 可以使用:global 伪类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">:<span class="built_in">global</span>(.red) &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="v-bind-在-css-中"><a href="#v-bind-在-css-中" class="headerlink" title="v-bind 在 css 中"></a>v-bind 在 css 中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const theme = &#123;</span><br><span class="line">  color: &quot;red&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;hello&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">p &#123;</span><br><span class="line">  color: v-bind(&quot;theme.color&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>实际值将被编译成散列的 CSS 自定义属性，因此 CSS 仍然是静态的。自定义属性将通过内联样式应用于组件的根元素，并在源值更改时进行响应式更新。</p><h1 id="高级-API"><a href="#高级-API" class="headerlink" title="高级 API"></a>高级 API</h1><h2 id="渲染函数-API"><a href="#渲染函数-API" class="headerlink" title="渲染函数 API"></a>渲染函数 API</h2><h3 id="H（）"><a href="#H（）" class="headerlink" title="H（）"></a>H（）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// full signature</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">h</span>(<span class="params"></span></span><br><span class="line"><span class="params">  type: string | Component,</span></span><br><span class="line"><span class="params">  props?: object | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  children?: Children | Slot | Slots</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">VNode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// omitting props</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">h</span>(<span class="params">type: string | Component, children?: Children | Slot</span>): <span class="title class_">VNode</span></span><br><span class="line"></span><br><span class="line">type <span class="title class_">Children</span> = string | number | boolean | <span class="title class_">VNode</span> | <span class="literal">null</span> | <span class="title class_">Children</span>[]</span><br><span class="line"></span><br><span class="line">type <span class="title class_">Slot</span> = <span class="function">() =&gt;</span> <span class="title class_">Children</span></span><br><span class="line"></span><br><span class="line">type <span class="title class_">Slots</span> = &#123; [<span class="attr">name</span>: string]: <span class="title class_">Slot</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>细节</li></ul><p>第一个参数是字符串（可用于原生元素）或 Vue 组件 第二个参数这是传递的 props 第三个元素是孩子</p><p>创建 vnode 时 子节点必须作为插槽函数传递 如果组件只需要默认槽 则可以传递单个插槽函数 否则 插槽必须作为槽函数的对象传递</p><p>创建原生元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; h &#125; from &#x27;vue&#x27; // all arguments except the type are optional h(&#x27;div&#x27;)</span><br><span class="line">h(&#x27;div&#x27;, &#123; id: &#x27;foo&#x27; &#125;) // both attributes and properties can be used in props</span><br><span class="line">// Vue automatically picks the right way to assign it h(&#x27;div&#x27;, &#123; class: &#x27;bar&#x27;,</span><br><span class="line">innerHTML: &#x27;hello&#x27; &#125;) // class and style have the same object / array // value</span><br><span class="line">support like in templates h(&#x27;div&#x27;, &#123; class: [foo, &#123; bar &#125;], style: &#123; color:</span><br><span class="line">&#x27;red&#x27; &#125; &#125;) // event listeners should be passed as onXxx h(&#x27;div&#x27;, &#123; onClick: ()</span><br><span class="line">=&gt; &#123;&#125; &#125;) // children can be a string h(&#x27;div&#x27;, &#123; id: &#x27;foo&#x27; &#125;, &#x27;hello&#x27;) // props</span><br><span class="line">can be omitted when there are no props h(&#x27;div&#x27;, &#x27;hello&#x27;) h(&#x27;div&#x27;, [h(&#x27;span&#x27;,</span><br><span class="line">&#x27;hello&#x27;)]) // children array can contain mixed vnodes and strings h(&#x27;div&#x27;,</span><br><span class="line">[&#x27;hello&#x27;, h(&#x27;span&#x27;, &#x27;hello&#x27;)])</span><br></pre></td></tr></table></figure><p>创建组件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Foo</span> <span class="keyword">from</span> <span class="string">&quot;./Foo.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// passing props</span></span><br><span class="line"><span class="title function_">h</span>(<span class="title class_">Foo</span>, &#123;</span><br><span class="line">  <span class="comment">// equivalent of some-prop=&quot;hello&quot;</span></span><br><span class="line">  <span class="attr">someProp</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="comment">// equivalent of @update=&quot;() =&gt; &#123;&#125;&quot;</span></span><br><span class="line">  <span class="attr">onUpdate</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// passing single default slot</span></span><br><span class="line"><span class="title function_">h</span>(<span class="title class_">Foo</span>, <span class="function">() =&gt;</span> <span class="string">&quot;default slot&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// passing named slots</span></span><br><span class="line"><span class="comment">// notice the `null` is required to avoid</span></span><br><span class="line"><span class="comment">// slots object being treated as props</span></span><br><span class="line"><span class="title function_">h</span>(<span class="title class_">MyComponent</span>, <span class="literal">null</span>, &#123;</span><br><span class="line">  <span class="attr">default</span>: <span class="function">() =&gt;</span> <span class="string">&quot;default slot&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&quot;div&quot;</span>, <span class="string">&quot;foo&quot;</span>),</span><br><span class="line">  <span class="attr">bar</span>: <span class="function">() =&gt;</span> [<span class="title function_">h</span>(<span class="string">&quot;span&quot;</span>, <span class="string">&quot;one&quot;</span>), <span class="title function_">h</span>(<span class="string">&quot;span&quot;</span>, <span class="string">&quot;two&quot;</span>)],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="mergeProps"><a href="#mergeProps" class="headerlink" title="mergeProps()"></a>mergeProps()</h2><p>合并多个 props 对象 对某些 props 进行特殊处理</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeProps</span>(<span class="params">...args: <span class="built_in">object</span>[]</span>): <span class="built_in">object</span>;</span><br></pre></td></tr></table></figure><p><code>mergeProps()</code>支持合并多个 props 对象 对以下 props 进行特殊处理</p><ul><li><code>class</code></li><li><code>style</code></li><li><code>onXxx</code>事件监听器-多个具有相同名称的监听器将被合并到一个数组中</li></ul><p>如果不需要合并只是想要简单的覆盖 可以使用原生对象的扩展</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mergeProps &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = &#123;</span><br><span class="line">  <span class="attr">class</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="attr">onClick</span>: handlerA,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> two = &#123;</span><br><span class="line">  <span class="attr">class</span>: &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">onClick</span>: handlerB,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merged = <span class="title function_">mergeProps</span>(one, two);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment">   class: &#x27;foo bar&#x27;,</span></span><br><span class="line"><span class="comment">   onClick: [handlerA, handlerB]</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="cloneVNode"><a href="#cloneVNode" class="headerlink" title="cloneVNode()"></a>cloneVNode()</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cloneVNode</span>(<span class="params">vnode: VNode, extraProps?: <span class="built_in">object</span></span>): <span class="title class_">VNode</span>;</span><br></pre></td></tr></table></figure><ul><li>细节</li></ul><p>返回一个克隆的 vnode 可以选择使用额外的 props 与原始节点合并</p><p>Vnodes 一旦被创建就被认定为不可变的 不应该改变现有的 vnode 的 props</p><p>Vnodes 具有特殊的内部属性 因此克隆它们并不像对象传播那么简单 <code>cloneVnode（）</code>处理大部分的内部逻辑</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, cloneVNode &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> original = <span class="title function_">h</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cloned = <span class="title function_">cloneVNode</span>(original, &#123; <span class="attr">id</span>: <span class="string">&quot;foo&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="resolveComponent"><a href="#resolveComponent" class="headerlink" title="resolveComponent"></a>resolveComponent</h3><p>用于按名称手动解析已注册的组件</p><h2 id="withDirectives"><a href="#withDirectives" class="headerlink" title="withDirectives()"></a>withDirectives()</h2><p>用于向 vnode 添加自定义指令</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withDirectives</span>(<span class="params">vnode: VNode, directives: DirectiveArguments</span>): <span class="title class_">VNode</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Directive, value, argument, modifiers]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DirectiveArguments</span> = <span class="title class_">Array</span>&lt;</span><br><span class="line">  | [<span class="title class_">Directive</span>]</span><br><span class="line">  | [<span class="title class_">Directive</span>, <span class="built_in">any</span>]</span><br><span class="line">  | [<span class="title class_">Directive</span>, <span class="built_in">any</span>, <span class="built_in">string</span>]</span><br><span class="line">  | [<span class="title class_">Directive</span>, <span class="built_in">any</span>, <span class="built_in">string</span>, <span class="title class_">DirectiveModifiers</span>]</span><br><span class="line">&gt;;</span><br></pre></td></tr></table></figure><ul><li>细节</li></ul><p>第二个参数时一个自定义指令数组 ``[Directive, value, argument, modifiers]`</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, withDirectives &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a custom directive</span></span><br><span class="line"><span class="keyword">const</span> pin = &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">updated</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;div v-pin:top.animate=&quot;200&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">withDirectives</span>(<span class="title function_">h</span>(<span class="string">&quot;div&quot;</span>), [[pin, <span class="number">200</span>, <span class="string">&quot;top&quot;</span>, &#123; <span class="attr">animate</span>: <span class="literal">true</span> &#125;]]);</span><br></pre></td></tr></table></figure><h2 id="withModifiers"><a href="#withModifiers" class="headerlink" title="withModifiers()"></a>withModifiers()</h2><p>添加事件修饰符</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, withModifiers &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">h</span>(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// equivalent of v-on.stop.prevent</span></span><br><span class="line">  <span class="attr">onClick</span>: <span class="title function_">withModifiers</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;, [<span class="string">&quot;stop&quot;</span>, <span class="string">&quot;prevent&quot;</span>]),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></script></strong></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue TS 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目还能这样优化?</title>
      <link href="/2022/04/11/xiang-mu-you-hua/"/>
      <url>/2022/04/11/xiang-mu-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><h3 id="1-页面加载优化"><a href="#1-页面加载优化" class="headerlink" title="1.页面加载优化"></a>1.页面加载优化</h3><h4 id="1-1Bundle-Size-and-Tree-shaking"><a href="#1-1Bundle-Size-and-Tree-shaking" class="headerlink" title="1.1Bundle Size and Tree-shaking"></a>1.1Bundle Size and Tree-shaking</h4><ul><li>发布使用性能更加全面的 JavaScript 包<ul><li>如果通过现代构建工具捆绑 许多 Vue 的 API 都是 Tree-shaking。例如如果不使用内置的<code>&lt;Transition&gt;</code>组件 他将不会包含在最终的生产包中 Tree-shaking 还可以删除源代码中其他未使用的模块</li><li>使用构建步骤时 模板是预编译的 因此我们不需要将 Vue 编译器发送到浏览器中 这避免了运行时编译成本</li></ul></li><li>引入依赖时要注意大小<ul><li>使用支持 ES 模块格式并且对 Tree-shaking 友好的依赖项 如引入 lodash-es 而不是 lodash</li><li>检查依赖项的大小并评估它是否值得它提供的功能 bundle.js.org 之类的工具可用于快速检查 但使用实际构建设置进行测量始终是最准确的</li></ul></li><li>如果使用 VUE 进行渐进式增强并希望避免构建步骤 可以考虑使用 petite-vue</li></ul><h4 id="1-2-代码拆分"><a href="#1-2-代码拆分" class="headerlink" title="1.2.代码拆分"></a>1.2.代码拆分</h4><p>通过适当的代码拆分 可以立即下载页面加载所需的功能 仅再需要时才延迟加载额外的块 从而提高性能</p><ul><li><p>Rollup（基于 Vite）或 webpack 之类的打包工具可以通过检查 ESM 动态导入元自动创建拆分块</p></li><li><p>```vue<br>function loadLazy() { return import(‘./lazy.js’) }</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 延迟加载最好用于初始页面加载后不需要立即使用的功能。在 Vue 应用程序中 这通常与 vue 的异步组件结合使用 为组件树创建拆分快</span><br><span class="line"></span><br><span class="line">- ```vue</span><br><span class="line">  import { defineAsyncComponent } from 'vue' // a separate chunk is created for</span><br><span class="line">  Foo.vue and its dependencies. // it is only fetched on demand when the async</span><br><span class="line">  component is // rendered on the page. const Foo = defineAsyncComponent(() =&gt;</span><br><span class="line">  import('./Foo.vue'))</span><br></pre></td></tr></tbody></table></figure><p><strong>如果使用 Vue Router</strong>强烈建议使用异步组件作为路由组件</p></li></ul><h4 id="1-3-SSR-SSG"><a href="#1-3-SSR-SSG" class="headerlink" title="1.3.SSR/SSG"></a>1.3.SSR/SSG</h4><p>纯客户端渲染会遇到内容生成时间缓慢的问题。这可以通过服务器端渲染 (SSR) 或静态站点生成 (SSG) 来缓解。</p><h3 id="2-更新优化"><a href="#2-更新优化" class="headerlink" title="2.更新优化"></a>2.更新优化</h3><h4 id="2-1Props-Stability"><a href="#2-1Props-Stability" class="headerlink" title="2.1Props Stability"></a>2.1Props Stability</h4><p>在 Vue 中 子组件仅在接收到至少一个 props 发生改变时才更新</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListItem v-for="item in list" :id="item.id" :active-id="activeId" /&gt;</span><br><span class="line">//在listItem组件内部 它使用的id和activeId来确定它是否是当前活跃的项目</span><br><span class="line">但是这会导致在activeId更改时 列表中的每个listItem都必须更新 //理想状态下</span><br><span class="line">只有活动状态发生变化的项目才必须更新</span><br><span class="line">我们可以通过将活动状态计算移至父级来实现这一点</span><br><span class="line">&lt;ListItem v-for="item in list" :id="item.id" :active="item.id === activeId" /&gt;</span><br><span class="line">//现在 对于大多数组件来说 prop的active在activeId更改时将保持不变</span><br><span class="line">因此它们不再更新</span><br></pre></td></tr></tbody></table></figure><p><strong>思想：保持传递给子组件的 prop 尽量稳定</strong></p><h4 id="2-2-v-once"><a href="#2-2-v-once" class="headerlink" title="2.2 v-once"></a>2.2 v-once</h4><p>依赖于运行时数据但是从不需要高兴的内容 它所使用的整个子树将跳过以进行所有未来的更新</p><h4 id="2-3v-memo"><a href="#2-3v-memo" class="headerlink" title="2.3v-memo"></a>2.3v-memo</h4><p>可用于有条件地跳过大型子树或者 v-for 列表的更新</p><h3 id="3-一般优化：会影响页面加载和更新性能"><a href="#3-一般优化：会影响页面加载和更新性能" class="headerlink" title="3.一般优化：会影响页面加载和更新性能"></a>3.一般优化：会影响页面加载和更新性能</h3><h4 id="3-1-虚拟化大型列表"><a href="#3-1-虚拟化大型列表" class="headerlink" title="3.1 虚拟化大型列表"></a>3.1 虚拟化大型列表</h4><p>我们可以跳过列表虚拟化来极大地提高性能 该技术仅在大列表中呈现当前位于或靠近视口的视图</p><ul><li><a href="https://github.com/Akryum/vue-virtual-scroller">vue-虚拟滚动条</a></li><li><a href="https://github.com/rocwang/vue-virtual-scroll-grid">vue-虚拟滚动网络</a></li></ul><h4 id="3-2-减少大型不可变结构的响应式开销"><a href="#3-2-减少大型不可变结构的响应式开销" class="headerlink" title="3.2 减少大型不可变结构的响应式开销"></a>3.2 减少大型不可变结构的响应式开销</h4><p>vue 的反应系统默认是深度的 可以使用 shallowReactive（）来退出深度响应性</p><p>浅响应性 API 创建仅在根级别具有响应性 并未追踪嵌套对象 这是的嵌套属性访问保持快速 但是我们必须将所有的嵌套对象视为不可变的 并且只能通过替换根状态来触发更新</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowArray = <span class="title function_">shallowRef</span>([</span><br><span class="line">  <span class="comment">/* big list of deep objects */</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// this won't trigger updates...</span></span><br><span class="line">shallowArray.<span class="property">value</span>.<span class="title function_">push</span>(newObject);</span><br><span class="line"><span class="comment">// this does:</span></span><br><span class="line">shallowArray.<span class="property">value</span> = [...shallowArr.<span class="property">value</span>, newObject];</span><br><span class="line"></span><br><span class="line"><span class="comment">// this won't trigger updates...</span></span><br><span class="line">shallowArray.<span class="property">value</span>[<span class="number">0</span>].<span class="property">foo</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// this does:</span></span><br><span class="line">shallowArray.<span class="property">value</span> = [</span><br><span class="line">  {</span><br><span class="line">    ...shallowArray.<span class="property">value</span>[<span class="number">0</span>],</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  },</span><br><span class="line">  ...shallowArray.<span class="property">value</span>.<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">];</span><br></pre></td></tr></tbody></table></figure><p><code>shallowRef()</code>通常用于大型数据结构的性能优化 或者于外部状态管理系统的集成</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">shallowRef</span>({ <span class="attr">count</span>: <span class="number">1</span> });</span><br><span class="line"></span><br><span class="line"><span class="comment">// does NOT trigger change</span></span><br><span class="line">state.<span class="property">value</span>.<span class="property">count</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// does trigger change</span></span><br><span class="line">state.<span class="property">value</span> = { <span class="attr">count</span>: <span class="number">2</span> };</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-避免不必要的组件抽象"><a href="#3-3-避免不必要的组件抽象" class="headerlink" title="3.3 避免不必要的组件抽象"></a>3.3 避免不必要的组件抽象</h4>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学Vue第二天</title>
      <link href="/2022/04/10/chong-xue-vue2.0/"/>
      <url>/2022/04/10/chong-xue-vue2.0/</url>
      
        <content type="html"><![CDATA[<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>当我们需要访问内联处理程序中的原始 DOM 事件 可以用特殊变量将其传递给方法$event 或者使用内联箭头函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click="warn('Form cannot be submitted yet.', $event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- using inline arrow function --&gt;</span><br><span class="line">&lt;button @click="(event) =&gt; warn('Form cannot be submitted yet.', event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="表单上输入绑定"><a href="#表单上输入绑定" class="headerlink" title="表单上输入绑定"></a>表单上输入绑定</h4><ul><li><code>&lt;input&gt;</code>文本类型和<code>&lt;textarea&gt;</code>元素使用<code>value</code>属性和<code>input</code>事件；</li><li><code>&lt;input type="checkbox"&gt;``&lt;input type="radio"&gt;</code>使用<code>checked</code>和事件<code>change</code>；</li><li><code>&lt;select&gt;</code>用作<code>value</code>和<code>change</code>事件。</li></ul><p><strong>v-model<code>将忽略在任何表单元素上找到的初始或属性</code>value<code>。它将始终将当前绑定的 JavaScript 状态视为事实来源。您应该使用反应性 API在 JavaScript 端声明初始值。</code>checked``selected</strong></p><p>如果您的表达式的初始值<code>v-model</code>与任何选项都不匹配，则该<code>&lt;select&gt;</code>元素将呈现为“未选择”状态。在 iOS 上，这将导致用户无法选择第一项，因为在这种情况下 iOS 不会触发更改事件。因此，建议提供一个带空值的禁用选项</p><p>默认情况下 v-model 在每个事件之后将输入与数据同步 可以添加修饰符<code>lazy</code>修改为在事件后同步</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- synced after "change" instead of "input" --&gt;</span><br><span class="line">&lt;input v-model.lazy="msg" /&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果希望用户输入的自动转化为数字 可以添加.number</p><p>如果希望自动修剪用户输入中的空白 可以加入.trim</p><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><img src="https://s3.bmp.ovh/imgs/2022/04/09/87a9e53a6371f344.png" style="zoom: 50%;"><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { ref, watch } from 'vue'</span><br><span class="line"></span><br><span class="line">const question = ref('')</span><br><span class="line">const answer = ref('Questions usually contain a question mark. ;-)')</span><br><span class="line"></span><br><span class="line">// watch works directly on a ref</span><br><span class="line">watch(question, async (newQuestion, oldQuestion) =&gt; {</span><br><span class="line">  if (newQuestion.indexOf('?') &gt; -1) {</span><br><span class="line">    answer.value = 'Thinking...'</span><br><span class="line">    try {</span><br><span class="line">      const res = await fetch('https://yesno.wtf/api')</span><br><span class="line">      answer.value = (await res.json()).answer</span><br><span class="line">    } catch (error) {</span><br><span class="line">      answer.value = 'Error! Could not reach the API. ' + error</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    &lt;input v-model="question" /&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;{{ answer }}&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>当你在 watch()直接调用一个响应式对象时 它会隐式创建一个深度观察者模式-回调将在所有嵌套突变上触发</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const obj = reactive({ count: 0});</span><br><span class="line">watch(obj, (newValue, oldValue) =&gt; {</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line">obj.count ++;</span><br><span class="line">//而使用getter：() =&gt; state.someObject则只会在放回不同的对象时才会触发回调</span><br><span class="line">可以显示使用deep选项来进入深度观察者模式</span><br><span class="line">watch(</span><br><span class="line">() =&gt; state....,</span><br><span class="line">(newValue, oldValue) =&gt; {}</span><br><span class="line">{ deep: true})</span><br></pre></td></tr></tbody></table></figure><p>**tips:**深度监视需要遍历监控对象中的所有嵌套属性 并且在用于大型数据结构时可能会开销昂贵 所以仅在必要时使用它并注意性能影响</p><h4 id="watchEffect（）"><a href="#watchEffect（）" class="headerlink" title="watchEffect（）"></a>watchEffect（）</h4><p>watch 是惰性的 在观察源发生变化之前不会立即调用 但是如果我们想要获取一些初始数据 然后在相关状态发生变化时重新获取数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const url = ref('https://...')</span><br><span class="line">const data = ref(null)</span><br><span class="line"></span><br><span class="line">async function fetchData() {</span><br><span class="line">  const response = await fetch(url.value)</span><br><span class="line">  data.value = await response.json()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// fetch immediately</span><br><span class="line">fetchData()</span><br><span class="line">// ...then watch for url change</span><br><span class="line">watch(url, fetchData)</span><br></pre></td></tr></tbody></table></figure><p><strong>watchEffect 允许我们在自动追踪效果的反应依赖的同时立即执行副作用函数</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(async () =&gt; {</span><br><span class="line">  const response = await fetch(url.value)</span><br><span class="line">  data.value = await response.json()</span><br><span class="line">})</span><br><span class="line">//在这苦 回调函数立即执行 他还会跟踪url.value为依赖项（类似于计算属性） 当url.value发生变化时 回调将再次运行</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const API_URL = `https://api.github.com/repos/vuejs/core/commits?per_page=3&amp;sha=`</span><br><span class="line">const branches = ['main', 'v2-compat']</span><br><span class="line"></span><br><span class="line">const currentBranch = ref(branches[0])</span><br><span class="line">const commits = ref(null)</span><br><span class="line"></span><br><span class="line">watchEffect(async () =&gt; {</span><br><span class="line">  // this effect will run immediately and then</span><br><span class="line">  // re-run whenever currentBranch.value changes</span><br><span class="line">  const url = `${API_URL}${currentBranch.value}`</span><br><span class="line">  commits.value = await (await fetch(url)).json()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>tips：</strong>watch 仅在其同步执行期间跟踪依赖项 当它与异步回调一起使用时 只会跟踪 await 跟踪第一个 tick 之前访问的属性</p><ul><li>watch 仅跟踪明确监视的源 将依赖跟踪与副作用分开</li><li>将依赖跟踪与副作用结合到一个阶段 会自动跟踪在同步执行期间访问的每一个反应属性 会使代码更简洁 但是依赖关系不明确</li></ul><h4 id="回调刷新时间"><a href="#回调刷新时间" class="headerlink" title="回调刷新时间"></a>回调刷新时间</h4><p>vue 默认在组件更新之前调用用户创建的观察者回调 所以如果尝试在观察者回调中访问 dom 则 dom 将处于 Vue 应用任何更新之前的状态 所以如果想要在 vue 更新后在 watcher 回调中访问 dom 需要指定 flush:’post’</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(source, callback, {</span><br><span class="line">  flush: 'post'</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">watchEffect(callback, {</span><br><span class="line">  flush: 'post'</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="停止观察者"><a href="#停止观察者" class="headerlink" title="停止观察者"></a>停止观察者</h4><p>Watchers 在内部同步声明<code>setup()</code>或<code>&lt;script setup&gt;</code>绑定到所有者组件实例，并在所有者组件卸载时自动停止。如果观察者是<strong>异步</strong>创建的 那么不会绑定到所有者组件 必须手动停止以避免<strong>内存泄漏</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const unwatch = watchEffect(() =&gt; {})</span><br><span class="line"></span><br><span class="line">// ...later, when no longer needed</span><br><span class="line">unwatch()</span><br></pre></td></tr></tbody></table></figure><p>应该军垦首选同步创建 如果需要等待一些异步数据 可以使用逻辑控制异步操作</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(() =&gt; {</span><br><span class="line">  if (data.value) {</span><br><span class="line">    // do something when data is loaded</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><p>如果要将对象的所有属性作为 props 传递 则可以使用 v-bind 不带参数使用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost v-bind="post" /&gt;</span><br><span class="line">//相当于使用</span><br><span class="line">&lt;BlogPost :id="post.id" :title="post.title" /&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>prop 用于传入一个初始值：子组件之后希望将其用作本地数据属性 则定义一个使用 prop 作为其初始值的本地数据属性</p></li><li><p>```<br>const props = defineProps([‘initialCounter’])</p><p>// counter only uses props.initialCounter as the initial value;<br>// it is disconnected from future prop updates.<br>const counter = ref(props.initialCounter)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- prop 作为需要转换的原始值传入 最好使用 prop 的值定义计算属性</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  const props = defineProps(['size'])</span><br><span class="line"></span><br><span class="line">  // computed property that auto-updates when the prop changes</span><br><span class="line">  const normalizedSize = computed(() =&gt; props.size.trim().toLowerCase())</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h2><p><strong>tips：</strong>组件的事件不会冒泡 父组件只能接收直接子组件发出的事件</p><p>可以通过 defineEmits 显示声明</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits(['inFocus', 'submit'])</span><br><span class="line">// type-based</span><br><span class="line">const emit = defineEmits&lt;{</span><br><span class="line">  (e: 'change', id: number): void</span><br><span class="line">  (e: 'update', value: string): void</span><br><span class="line">}&gt;()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果在选项中定义了本地事件如 click 则侦听器现在仅侦听组件发出的 click 而不再响应本地的 click 事件</p><p>如果使用对象语法则可以添加验证 为了添加验证 事件被分配了一个函数 改函数将接收传递给调用的参数并返回一个有效的布尔值以只是事件是否</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits({</span><br><span class="line">  // No validation</span><br><span class="line">  click: null,</span><br><span class="line"></span><br><span class="line">  // Validate submit event</span><br><span class="line">  submit: ({ email, password }) =&gt; {</span><br><span class="line">    if (email &amp;&amp; password) {</span><br><span class="line">      return true</span><br><span class="line">    } else {</span><br><span class="line">      console.warn('Invalid submit event payload!')</span><br><span class="line">      return false</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">function submitForm(email, password) {</span><br><span class="line">  emit('submit', { email, password })</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>自定义事件还能和 v-model 相结合</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- CustomInput.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps(['modelValue'])</span><br><span class="line">defineEmits(['update:modelValue'])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    :value="modelValue"</span><br><span class="line">    @input="$emit('update:modelValue', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">使用：</span><br><span class="line">&lt;CustomInput v-model="searchText" /&gt;</span><br></pre></td></tr></tbody></table></figure><p>v-model 还可以使用 computed 属性和 getter 以及 setter 该 get 方法应该返回 modelValue 属性并且该 set 方法应该发出相应的事件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- CustomInput.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import { computed } from 'vue'</span><br><span class="line"></span><br><span class="line">const props = defineProps(['modelValue'])</span><br><span class="line">const emit = defineEmits(['update:modelValue'])</span><br><span class="line"></span><br><span class="line">const value = computed({</span><br><span class="line">  get() {</span><br><span class="line">    return props.modelValue</span><br><span class="line">  },</span><br><span class="line">  set(value) {</span><br><span class="line">    emit('update:modelValue', value)</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input v-model="value" /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>使用多个 v-model</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserName</span><br><span class="line">  v-model:first-name="firstName"</span><br><span class="line">  v-model:last-name="lastName"</span><br><span class="line">/&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps({</span><br><span class="line">  firstName: String,</span><br><span class="line">  lastName: String</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">defineEmits(['update:firstName', 'update:lastName'])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type="text"</span><br><span class="line">    :value="firstName"</span><br><span class="line">    @input="$emit('update:firstName', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type="text"</span><br><span class="line">    :value="lastName"</span><br><span class="line">    @input="$emit('update:lastName', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>处理 v-model 修饰符：<strong>自定义修饰符</strong></p><p>eg：自定义一个将字符串第一个字母大写</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model.capitalize="myText" /&gt;</span><br><span class="line">添加到组件的修饰符v-model将通过modelModifiers prop提供给组件 我们创建了一个组件 其中包含一个modelModifiers默认为空的对象的prop</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps({</span><br><span class="line">  modelValue: String,</span><br><span class="line">  modelModifiers: { default: () =&gt; ({}) }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">defineEmits(['update:modelValue'])</span><br><span class="line"></span><br><span class="line">console.log(props.modelModifiers) // { capitalize: true }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type="text"</span><br><span class="line">    :value="modelValue"</span><br><span class="line">    @input="$emit('update:modelValue', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">------------------我们可以更改成当触发input事件后就会将字符串大写</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps({</span><br><span class="line">  modelValue: String,</span><br><span class="line">  modelModifiers: { default: () =&gt; ({}) }//即传递过来的{ capitalize: true }</span><br><span class="line">})</span><br><span class="line">//设置默认抛出事件</span><br><span class="line">const emit = defineEmits(['update:modelValue'])</span><br><span class="line"></span><br><span class="line">function emitValue(e) {</span><br><span class="line">  let value = e.target.value</span><br><span class="line">  if (props.modelModifiers.capitalize) {</span><br><span class="line">    value = value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">  }</span><br><span class="line">  emit('update:modelValue', value)//触发事件</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//设置input触发事件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type="text" :value="modelValue" @input="emitValue" /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>对于<code>v-model</code>同时具有参数和修饰符 生成的道具名称将为<code>arg + 'Modifiers'</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model:title.capitalize="myText"&gt;</span><br><span class="line">//对应的声明应该为</span><br><span class="line">const props = defineProps(['title', 'titleModifiers'])</span><br><span class="line">defineEmits(['update:title'])</span><br><span class="line">console.log(props.titleModifiers) // { capitalize: true }</span><br></pre></td></tr></tbody></table></figure><h2 id="Fallthrough-属性"><a href="#Fallthrough-属性" class="headerlink" title="Fallthrough 属性"></a>Fallthrough 属性</h2><p><code>v-on</code>传递给组件的属性或事件监听器 但是未在组件的 props 或 emits 中显示声明 如<code>class</code>、<code>style</code>、<code>id</code></p><p>当组件渲染单个根元素时 将自动添加到根元素的属性中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- template of &lt;MyButton&gt; --&gt;</span><br><span class="line">&lt;button&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;MyButton class="large" /&gt;</span><br><span class="line">---最终渲染为</span><br><span class="line">&lt;button class="large"&gt;click me&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果不希望组件自动继承属性 可以在<code>inheriAttrs： false</code>在组件的选项中进行设置</p><p>如果使用<code>&lt;script setup&gt;</code>，您将需要使用单独的普通<code>&lt;script&gt;</code>块声明此选项：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// use normal &lt;script&gt; to declare options</span><br><span class="line">export default {</span><br><span class="line">  inheritAttrs: false</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// ...setup logic</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>常见场景：当属性需要引用于根节点以为的其他元素时 可以将<code>inheritAttrs</code>选项设置为<code>false</code>，您可以完全控制在何处应用 fallthrough 属性</p><p>可以通过<code>$attrs</code>来访问</p><ul><li>与 props 不同，fallthrough 属性在 JavaScript 中保留了它们的原始大小写，因此<code>foo-bar</code>需要将属性 like 访问为<code>$attrs['foo-bar']</code>.</li><li>像这样的<code>v-on</code>事件侦听<code>@click</code>器将作为<code>$attrs.onClick</code>.</li></ul><p>我们希望所有诸如<code>class</code>和<code>v-on</code>监听器之类的贯穿属性都应用于内部<code>&lt;button&gt;</code>，而不是外部<code>&lt;div&gt;</code>。可以使用 inheritAttrs: false 和</p><p><code>v-bind="$attrs"</code>来使用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="btn-wrapper"&gt;</span><br><span class="line">  &lt;button class="btn" v-bind="$attrs"&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>如果 v-bind 没有参数 则将对象的所有属性绑定为目标元素的属性</strong></p><h4 id="多个根节点的继承"><a href="#多个根节点的继承" class="headerlink" title="多个根节点的继承"></a>多个根节点的继承</h4><p>具有多个根节点的组件没有自动属性失效的行为 需要明确绑定$attrs</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomLayout id="custom-layout" @click="changeValue" /&gt;</span><br><span class="line">&lt;header&gt;...&lt;/header&gt;</span><br><span class="line">&lt;main v-bind="$attrs"&gt;...&lt;/main&gt;</span><br><span class="line">&lt;footer&gt;...&lt;/footer&gt;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { useAttrs } from 'vue'</span><br><span class="line"></span><br><span class="line">const attrs = useAttrs()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//尽管attrs始终反应最新的fallthrough属性 但是并不是响应性的 所以无法使用观察者观察变化 如果需要响应性 可以使用prop 或者在onUpdated（）时执行最新的副作用</span><br></pre></td></tr></tbody></table></figure><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><img src="https://s3.bmp.ovh/imgs/2022/04/10/8d00a97ed8cd1522.png" style="zoom: 50%;"><p>插槽的作用</p><ul><li>使用插槽 子组件负责样式的渲染 而内容由父组件提供</li><li>通过使用插槽 我们可以使<code>&lt;FancyButton&gt;</code>更加灵活和重用 我们可以在不同的地方使用它 具有不同的内部内容 但是都具有同样花哨的样式</li></ul><h4 id="渲染范围"><a href="#渲染范围" class="headerlink" title="渲染范围"></a>渲染范围</h4><ul><li>插槽可以访问父组件的数据范围 因为它是在父组件中定义的</li><li>插槽无权访问子组件的数据 因为父模板中的所有内容都在父范围内编译 子模板中的所有内容都在子范围内编译</li></ul><h4 id="命名插槽"><a href="#命名插槽" class="headerlink" title="命名插槽"></a>命名插槽</h4><p>可以通过使用 name 用来为不同的插槽分配一个唯一的 ID 这样可以控制在哪里呈现内容</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="container"&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name="header"&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name="footer"&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">//当我们要传递指定内容时 可以使用v-slot</span><br><span class="line">&lt;BaseLayout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;!-- content for the header slot --&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/BaseLayout&gt;</span><br><span class="line">//可以使用“#”简写</span><br><span class="line">&lt;template #header&gt;。</span><br></pre></td></tr></tbody></table></figure><p>当组件同时接受默认槽和命名槽时，所有顶级非<code>&lt;template&gt;</code>节点都被隐式视为默认槽的内容。</p><h4 id="动态插槽名称"><a href="#动态插槽名称" class="headerlink" title="动态插槽名称"></a>动态插槽名称</h4><p>动态指令参数也适用于 v-slot 允许定义动态插槽的名称</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:[dynamicSlotName]&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- with shorthand --&gt;</span><br><span class="line">  &lt;template #[dynamicSlotName]&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="命名插槽-1"><a href="#命名插槽-1" class="headerlink" title="命名插槽"></a>命名插槽</h4><p><img src="https://i.bmp.ovh/imgs/2022/04/10/06d1487ae8b60eaa.png"></p><p>可以通过命名插槽访问子组件的数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;slot :text="greetingMessage" :count="1"&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;MyComponent v-slot="slotProps"&gt;</span><br><span class="line">  {{ slotProps.text }} {{ slotProps.count }}</span><br><span class="line">&lt;/MyComponent&gt;</span><br><span class="line">//可以通过解构的方式来取值</span><br><span class="line">&lt;MyComponent v-slot="{ text, count }"&gt;</span><br><span class="line">  {{ text }} {{ count }}</span><br><span class="line">&lt;/MyComponent&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="命名范围插槽"><a href="#命名范围插槽" class="headerlink" title="命名范围插槽"></a><strong>命名范围插槽</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;</span><br><span class="line">  &lt;template #header="headerProps"&gt;</span><br><span class="line">    {{ headerProps }}</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #default="defaultProps"&gt;</span><br><span class="line">    {{ defaultProps }}</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #footer="footerProps"&gt;</span><br><span class="line">    {{ footerProps }}</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/MyComponent&gt;</span><br><span class="line">&lt;slot name="header" message="hello"&gt;&lt;/slot&gt;</span><br></pre></td></tr></tbody></table></figure><p>name 不会包含在 prop 中 所以 headerProps 是<code>{ message: 'hello' }</code>.</p><p><strong>作用域插槽的使用场景</strong></p><p>如果需要一个<fancylist>渲染项目列表的组件–它可以封装加载远程数据的逻辑 使用数据显示列表 甚至是分页或无限滚动等高级功能 但是我们希望它能够灵活处理每个项目的外观 并将每个项目的样式留给使用它的父组件</fancylist></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;FancyList :api-url="url" :per-page="10"&gt;</span><br><span class="line">  &lt;template #item="{ body, username, likes }"&gt;</span><br><span class="line">    &lt;div class="item"&gt;</span><br><span class="line">      &lt;p&gt;{{ body }}&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;by {{ username }} | {{ likes }} likes&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/FancyList&gt;</span><br></pre></td></tr></tbody></table></figure><p>在内部，我们可以使用不同的项目数据多次<code>&lt;FancyList&gt;</code>渲染相同的内容（注意我们使用对象作为插槽道具传递）：<code>&lt;slot&gt;``v-bind</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">App.vue</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import FancyList from './FancyList.vue'</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;FancyList :api-url="url" :per-page="10"&gt;</span><br><span class="line">    &lt;template #item="{ body, username, likes }"&gt;</span><br><span class="line">      &lt;div class="item"&gt;</span><br><span class="line">        &lt;p&gt;{{ body }}&lt;/p&gt;</span><br><span class="line">        &lt;p class="meta"&gt;by {{ username }} | {{ likes }} likes&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/FancyList&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.meta {</span><br><span class="line">  font-size: 0.8em;</span><br><span class="line">  color: #42b883;</span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">FancyList.vue</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import { ref } from 'vue'</span><br><span class="line"></span><br><span class="line">const props = defineProps(['api-url', 'per-page'])</span><br><span class="line"></span><br><span class="line">const items = ref([])</span><br><span class="line"></span><br><span class="line">// mock remote data fetching</span><br><span class="line">setTimeout(() =&gt; {</span><br><span class="line">  items.value = [</span><br><span class="line">    { body: 'Scoped Slots Guide', username: 'Evan You', likes: 20 },</span><br><span class="line">  { body: 'Vue Tutorial', username: 'Natalia Tepluhina', likes: 10 }</span><br><span class="line">  ]</span><br><span class="line">}, 1000)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-if="!items.length"&gt;</span><br><span class="line">      Loading...</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li v-for="item in items"&gt;</span><br><span class="line">      &lt;slot name="item" v-bind="item"/&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  ul {</span><br><span class="line">    list-style-type: none;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    background: linear-gradient(315deg, #42d392 25%, #647eff);</span><br><span class="line">  }</span><br><span class="line">  li {</span><br><span class="line">    padding: 5px 20px;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    background: #fff;</span><br><span class="line">  }</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="Provide-Inject"><a href="#Provide-Inject" class="headerlink" title="Provide/Inject"></a>Provide/Inject</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script setup&gt;</span><br><span class="line"><span class="keyword">import</span> { provide } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">provide</span>(<span class="comment">/* key */</span> <span class="string">'message'</span>, <span class="comment">/* value */</span> <span class="string">'hello!'</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>提供响应式值允许使用提供的值的后代组件建立到提供程序组件的响应式连接。</p><p>如果提供的值是 ref 它是按原样注入 不会自动解构 这允许注入器组件保留与提供者组件的反应性连接</p><h4 id="注入默认值"><a href="#注入默认值" class="headerlink" title="注入默认值"></a>注入默认值</h4><p>如果想要让注入的属性和可选提供者一起工作 那么就需要声明一个默认值 类似于 props</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">inject</span>(<span class="string">"message"</span>, <span class="string">"default value"</span>);</span><br></pre></td></tr></tbody></table></figure><p>在某些情况下，可能需要通过调用函数或实例化新类来创建默认值。为了避免在不使用可选值的情况下产生不必要的计算或副作用，我们可以使用<strong>工厂函数来创建默认值：</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">inject</span>(<span class="string">"key"</span>, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">ExpensiveClas</span>());</span><br></pre></td></tr></tbody></table></figure><h4 id="使用响应式数据"><a href="#使用响应式数据" class="headerlink" title="使用响应式数据"></a>使用响应式数据</h4><p>尽可能将任何对响应式状态的突变保留在提供程序内部 这确保了提供的状态以及可能的突变位于同一组件 从而更容易在将来维护</p><p>有时我们可能从租入器组件更新数据 这种情况我们一般提供一个负责改变状态的函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> { provide, ref } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> location = <span class="title function_">ref</span>(<span class="string">'North Pole'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateLocation</span>(<span class="params"></span>) {</span><br><span class="line">  location.<span class="property">value</span> = <span class="string">'South Pole'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">provide</span>(<span class="string">'location'</span>, {</span><br><span class="line">  location,</span><br><span class="line">  updateLocation</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">------------------------</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> { inject } <span class="keyword">from</span> <span class="string">'vue'</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> { location, updateLocation } = <span class="title function_">inject</span>(<span class="string">'location'</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"updateLocation"</span>&gt;</span>{{ location }}<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>最后 我们想确保 provide 的数据不会被改变 可以使用 readonly</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="string">"read-only-count"</span>, <span class="title function_">readonly</span>(count));</span><br></pre></td></tr></tbody></table></figure><p><strong>最好使用符号注入密钥来避免潜在的冲突 可以将符号到处到专有文件中</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keys.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myInjectionKey = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="comment">// in provider component</span></span><br><span class="line"><span class="keyword">import</span> { provide } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> { myInjectionKey } <span class="keyword">from</span> <span class="string">"./keys.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">provide</span>(myInjectionKey, {</span><br><span class="line">  <span class="comment">/* data to provide */</span></span><br><span class="line">});</span><br><span class="line"><span class="comment">// in injector component</span></span><br><span class="line"><span class="keyword">import</span> { inject } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> { myInjectionKey } <span class="keyword">from</span> <span class="string">"./keys.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> injected = <span class="title function_">inject</span>(myInjectionKey);</span><br></pre></td></tr></tbody></table></figure><h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { defineAsyncComponent } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="title function_">import</span>(<span class="string">"./components/MyComponent.vue"</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>结果<code>AsyncComp</code>是一个包装器组件，它仅在实际呈现在页面上时才调用加载器函数。此外，它会将任何 props 传递给内部组件，因此您可以使用异步包装器无缝替换原始组件，同时实现延迟加载。</p><h4 id="加载和错误状态"><a href="#加载和错误状态" class="headerlink" title="加载和错误状态"></a>加载和错误状态</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>({</span><br><span class="line">  <span class="comment">// the loader function</span></span><br><span class="line">  <span class="attr">loader</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">"./Foo.vue"</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A component to use while the async component is loading</span></span><br><span class="line">  <span class="attr">loadingComponent</span>: <span class="title class_">LoadingComponent</span>,</span><br><span class="line">  <span class="comment">// Delay before showing the loading component. Default: 200ms.</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A component to use if the load fails</span></span><br><span class="line">  <span class="attr">errorComponent</span>: <span class="title class_">ErrorComponent</span>,</span><br><span class="line">  <span class="comment">// The error component will be displayed if a timeout is</span></span><br><span class="line">  <span class="comment">// provided and exceeded. Default: Infinity.</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span>,</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>如果提供了加载组件，它将在加载内部组件时首先显示。在显示加载组件之前有一个默认的 200 毫秒延迟 - 这是因为在快速网络上，即时加载状态可能会被替换得太快并最终看起来像闪烁。</p><p>如果提供了错误组件，当 loader 函数返回的 Promise 被拒绝时会显示。您还可以指定超时以在请求时间过长时显示错误组件。</p><h2 id="Composables"><a href="#Composables" class="headerlink" title="Composables"></a>Composables</h2><p>Composables 是一种可以利用 Vue 组合 API 封装和重用有状态逻辑的函数</p><ul><li><p>鼠标跟踪器示例</p></li><li><p>```js<br>// mouse.js<br>import { ref, onMounted, onUnmounted } from ‘vue’</p><p>// by convention, composable function names start with “use”<br>export function useMouse() {<br>  // state encapsulated and managed by the composable<br>  const x = ref(0)<br>  const y = ref(0)</p><p>  // a composable can update its managed state over time.<br>  function update(event) {</p><pre><code>x.value = event.pageXy.value = event.pageY</code></pre><p>  }</p><p>  // a composable can also hook into its owner component’s<br>  // lifecycle to setup and teardown side effects.<br>  onMounted(() =&gt; window.addEventListener(‘mousemove’, update))<br>  onUnmounted(() =&gt; window.removeEventListener(‘mousemove’, update))</p><p>  // expose managed state as return value<br>  return { x, y }<br>}<br>//组件中的使用方式</p><script setup="">import { useMouse } from './mouse.js'const { x, y } = useMouse()</script><p><template>Mouse position is at: , </template></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">COmposables 还可以嵌套使用：一个可组合函数可以调用另一个或多个其他可组合函数 这是的我们能够使用小的、隔离的单元来组合复杂的逻辑 了类似于使用组件来整合整个应用程序的方式</span><br><span class="line"></span><br><span class="line">实例 2：我们可以将添加和清理 DOM 事件监听器的逻辑提取到它自己的可组合中</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">// event.js</span><br><span class="line">import { onMounted, onUnmounted } from "vue";</span><br><span class="line"></span><br><span class="line">export function useEventListener(target, event, callback) {</span><br><span class="line">  // if you want, you can also make this</span><br><span class="line">  // support selector strings as target</span><br><span class="line">  onMounted(() =&gt; target.addEventListener(event, callback));</span><br><span class="line">  onUnmounted(() =&gt; target.removeEventListener(event, callback));</span><br><span class="line">}</span><br><span class="line">//现在我们的useMouse（）可以简化为</span><br><span class="line">// mouse.js</span><br><span class="line">import { ref } from "vue";</span><br><span class="line">import { useEventListener } from "./event";</span><br><span class="line"></span><br><span class="line">export function useMouse() {</span><br><span class="line">  const x = ref(0);</span><br><span class="line">  const y = ref(0);</span><br><span class="line"></span><br><span class="line">  useEventListener(window, "mousemove", (event) =&gt; {</span><br><span class="line">    x.value = event.pageX;</span><br><span class="line">    y.value = event.pageY;</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  return { x, y };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>**tips:**每个组件实例调用<code>useMouse()</code>都将创建自己的副本<code>x</code>和<code>y</code>状态，因此它们不会相互干扰。如果想管理组件之间的共享状态 可以使用 vuex</p><h4 id="异步状态示例"><a href="#异步状态示例" class="headerlink" title="异步状态示例"></a>异步状态示例</h4><p>在进行异步数据获取时 我们经常需要处理不同的状态：加载、成功和错误 我们可以将其提取到可组合中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch.js</span></span><br><span class="line"><span class="keyword">import</span> { ref } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useFetch</span>(<span class="params">url</span>) {</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetch</span>(url)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> (data.<span class="property">value</span> = json))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> (error.<span class="property">value</span> = err));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> { data, error };</span><br><span class="line">}</span><br><span class="line"><span class="comment">//现在在我们的组件中 可以这样做</span></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> {useFetch} <span class="keyword">from</span> <span class="string">'./fetch.js'</span> <span class="keyword">const</span> {(data, error)} = <span class="title function_">useFetch</span>(<span class="string">'...'</span>)</span><br><span class="line">&lt;/script&gt;;</span><br></pre></td></tr></tbody></table></figure><p>如果我们希望在 URL 更改时重新获取数据 可以使用响应式数据作为参数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch.js</span></span><br><span class="line"><span class="keyword">import</span> { ref, isRef, unref, watchEffect } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useFetch</span>(<span class="params">url</span>) {</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doFetch</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// reset state before fetching..</span></span><br><span class="line">    data.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    error.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// unref() unwraps potential refs</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="title function_">unref</span>(url))</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> (data.<span class="property">value</span> = json))</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> (error.<span class="property">value</span> = err));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(url)) {</span><br><span class="line">    <span class="comment">// setup reactive re-fetch if input URL is a ref</span></span><br><span class="line">    <span class="title function_">watchEffect</span>(doFetch);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// otherwise, just fetch once</span></span><br><span class="line">    <span class="comment">// and avoid the overhead of a watcher</span></span><br><span class="line">    <span class="title function_">doFetch</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> { data, error };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>useFetch（）接收静态 URL 以及 URL 字符串的引用 当检测到 URL 是一个动态引用即 isRef（）时 会设置一个响应式效果 WatchEffect()效果将立即运行 并在这个过程中将 URL ref 作为依赖项进行跟踪 每当 URL 更改时 数据将被重置并再次获取</strong></p></li></ul><h4 id="Conventions-and-Best-Practices"><a href="#Conventions-and-Best-Practices" class="headerlink" title="Conventions and Best Practices"></a>Conventions and Best Practices</h4><ul><li><p>以 use 开头 如 useFetch();</p></li><li><p>如果正在编写一个可能被其他开发人员使用的组合 在处理输入参数时 refs 而不是原始值时是一个好主意 可以使用 unref</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { unref } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useFeature</span>(<span class="params">maybeRef</span>) {</span><br><span class="line">  <span class="comment">// if maybeRef is indeed a ref, its .value will be returned</span></span><br><span class="line">  <span class="comment">// otherwise, maybeRef is returned as-is</span></span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">unref</span>(maybeRef);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果在输入是<code>ref</code>是创建响应性 请确保使用<code>watch()</code>来跟踪<code>ref</code>数据 或者使用<code>unref</code>并在内部使用<code>watchEffect()</code></p></li><li><p>我们推荐返回一个 refs 对象 以便在组件中对其进行解构并保持响应性 如果更喜欢返回对象属性 可以使用<code>reactive()</code>以便解构引用</p></li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mouse = <span class="title function_">reactive</span>(<span class="title function_">useMouse</span>());</span><br><span class="line"><span class="comment">// mouse.x is linked to original ref</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mouse.<span class="property">x</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h4><ul><li>如果正在开发服务端渲染（SSR）的原因程序 确保在安装后生命周期执行特定于 DOM 的副作用 如在 onMounted()确保可以访问 DOM</li><li><strong>确保清除 onUnmounted 在设置事件监听器后记得清理</strong></li></ul><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><p>只能在钩子中同步使用 可以在<code>&lt;script setup&gt;setup()onMounted()</code>中调用</p><ul><li>生命周期钩子可以注册到它</li><li>计算属性和观察者可以追踪并在组件卸载时进行处理</li><li>你只能在<code>&lt;script setup&gt;</code>中使用 await 编译器会在执行异步操作后自动恢复活动实例上下文</li></ul><h4 id="为代码组织提取可组合项"><a href="#为代码组织提取可组合项" class="headerlink" title="为代码组织提取可组合项"></a>为代码组织提取可组合项</h4><p>可组合项不仅可以提取用于重用 还可以用于代码组织</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> {useFeatureA} <span class="keyword">from</span> <span class="string">'./featureA.js'</span> <span class="keyword">import</span> {useFeatureB} <span class="keyword">from</span></span><br><span class="line">  <span class="string">'./featureB.js'</span> <span class="keyword">import</span> {useFeatureC} <span class="keyword">from</span> <span class="string">'./featureC.js'</span> <span class="keyword">const</span> {(foo, bar)} =</span><br><span class="line">  <span class="title function_">useFeatureA</span>() <span class="keyword">const</span> {baz} = <span class="title function_">useFeatureB</span>(foo) <span class="keyword">const</span> {qux} = <span class="title function_">useFeatureC</span>(baz)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p><strong>自定义指令主要用于重用涉及对普通元素进行低级 DOM 访问的逻辑</strong></p><p>自定义指令被定义为包含类似于组件的生命周期钩子的对象 钩子接收指令绑定的元素</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="comment">// enables v-focus in templates</span></span><br><span class="line"><span class="keyword">const</span> vFocus = {</span><br><span class="line">  <span class="attr">mounted</span>: <span class="function">(<span class="params">el</span>) =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue TS 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的reactive</title>
      <link href="/2022/04/09/vue-xiang-ying-shi-yuan-li/"/>
      <url>/2022/04/09/vue-xiang-ying-shi-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-源码解析系列-响应式原理（reactive-篇）"><a href="#Vue3-源码解析系列-响应式原理（reactive-篇）" class="headerlink" title="Vue3 源码解析系列 - 响应式原理（reactive 篇）"></a>Vue3 源码解析系列 - 响应式原理（reactive 篇）</h1><h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h2><h3 id="核心入口"><a href="#核心入口" class="headerlink" title="核心入口"></a>核心入口</h3><p>话不多说，我们先来看下核心的 <code>reactive</code> 的源码，先看下有哪些依赖：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工具方法，isObject 是判断是否是对象，toTypeString 获取数据类型</span></span><br><span class="line"><span class="keyword">import</span> { isObject, toTypeString } <span class="keyword">from</span> <span class="string">"@vue/shared"</span>;</span><br><span class="line"><span class="comment">// Proxy 的 handlers</span></span><br><span class="line"><span class="comment">// mutableHandlers：可变数据的 handler</span></span><br><span class="line"><span class="comment">// readonlyHandlers：只读数据的 handler</span></span><br><span class="line"><span class="keyword">import</span> { mutableHandlers, readonlyHandlers } <span class="keyword">from</span> <span class="string">"./baseHandlers"</span>;</span><br><span class="line"><span class="keyword">import</span> {</span><br><span class="line">  mutableCollectionHandlers, <span class="comment">// 可变集合数据的 handler</span></span><br><span class="line">  readonlyCollectionHandlers, <span class="comment">// 只读集合数据的 handler</span></span><br><span class="line">} <span class="keyword">from</span> <span class="string">"./collectionHandlers"</span>;</span><br><span class="line"><span class="comment">// effect 泛型类型</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">ReactiveEffect</span> } <span class="keyword">from</span> <span class="string">"./effect"</span>;</span><br><span class="line"><span class="comment">// ref 泛型类型</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">UnwrapRef</span>, <span class="title class_">Ref</span> } <span class="keyword">from</span> <span class="string">"./ref"</span>;</span><br><span class="line"><span class="comment">// 工具方法，将字符串转化成 Map，返回 function 来判断是否 这个Map 上包含所给的 key</span></span><br><span class="line"><span class="comment">// 这个在 vue2 里也有</span></span><br><span class="line"><span class="keyword">import</span> { makeMap } <span class="keyword">from</span> <span class="string">"@vue/shared"</span>;</span><br></pre></td></tr></tbody></table></figure><p>可以很清楚的看到，重点依赖项就是那一堆 <code>handler</code> 了，其他都是一些工具方法和泛型类型</p><p>接下来的源码里是一堆变量的定义，不过我们先跳过，先来看下 <code>reactive</code> 的方法和类型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面还有一大坨变量定义，很关键，但是我们先跳过，先看下有哪些方法，类型是什么样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖集合类型</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Dep</span> = <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt;</span><br><span class="line"><span class="comment">// 看名字就知道，是 key 和 Dep 集合的对应关系集合</span></span><br><span class="line"><span class="comment">// key 其实就是我们响应式数据上的 key，Dep 则是有哪些地方依赖到了这个 key</span></span><br><span class="line"><span class="comment">// 比如 const a = { foo: 1 }，如果在其他两处都用到了 a.foo，那么</span></span><br><span class="line"><span class="comment">// 这里的 key 就是 foo，Dep 就是这两处的 依赖集合</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">KeyToDepMap</span> = <span class="title class_">Map</span>&lt;string | symbol, <span class="title class_">Dep</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断对象能不能被观察的</span></span><br><span class="line"><span class="keyword">const</span> canObserve = (<span class="attr">value</span>: any): boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// only unwrap nested ref</span></span><br><span class="line"><span class="comment">// 解套 Ref 类型</span></span><br><span class="line">type <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">UnwrapRef</span>&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应式入口方法，入参是泛型，继承 object，返回值就是上面的解套 Ref 类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> reactive&lt;T <span class="keyword">extends</span> object&gt;(<span class="attr">target</span>: T): <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟 reactive 作用相同，只不过返回值是 Readonly 的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> readonly&lt;T <span class="keyword">extends</span> object&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">Readonly</span>&lt;<span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建响应式对象的关键方法，reactive 和 only 都调用了这个方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  toProxy: <span class="built_in">WeakMap</span>&lt;any, any&gt;,</span></span><br><span class="line"><span class="params">  toRaw: <span class="built_in">WeakMap</span>&lt;any, any&gt;,</span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;any&gt;,</span></span><br><span class="line"><span class="params">  collectionHandlers: ProxyHandler&lt;any&gt;</span></span><br><span class="line"><span class="params"></span>): any</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是响应式数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReactive</span>(<span class="params">value: any</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是只读的响应式数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReadonly</span>(<span class="params">value: any</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将响应式数据转化为原始数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(<span class="attr">observed</span>: T): T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 value 标记为 Readonly，在 reactive 方法里会判断是否是 Readonly 的原始数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> markReadonly&lt;T&gt;(<span class="attr">value</span>: T): T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 value 标记为不可响应数据，这个将会影响 canObserve 方法的判断</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> markNonReactive&lt;T&gt;(<span class="attr">value</span>: T): T</span><br></pre></td></tr></tbody></table></figure><p>看完方法和类型，大致有以下几个问题：</p><ol><li><code>Dep</code> 依赖是如何追踪的？</li><li><code>UnwrapRef</code> 是如何展开嵌套的响应式数据类型的（俗称解套）,比如 <code>reactive({ name: reactive(ref('Jooger')) })</code></li><li>如何判断是否是（只读的）响应式数据？往响应式数据上面挂载一个标记位来标记？还是用一个对象来存储响应式数据？</li><li>如何将响应式数据转化为原始数据？proxy 数据如何转化成 object？</li></ol><p>问题 1，后面的 <code>effect</code> 会讲，这里先不讨论</p><p>问题 2，后面的 <code>ref</code> 会讲，这里先不讨论</p><p>问题 3，4 就需要看下我刚才跳过的一堆变量的定义了：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The main WeakMap that stores {target -&gt; key -&gt; dep} connections.</span></span><br><span class="line"><span class="comment">// Conceptually, it's easier to think of a dependency as a Dep class</span></span><br><span class="line"><span class="comment">// which maintains a Set of subscribers, but we simply store them as</span></span><br><span class="line"><span class="comment">// raw Sets to reduce memory overhead.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// target 和 KeyToDepMap 的映射关系集合</span></span><br><span class="line"><span class="comment">// 一句话理解，有多个 target，每个 target 上有多个 key，每个 key 都有多个依赖</span></span><br><span class="line"><span class="comment">// 至于为什么要把映射关系存到 WeakMap 里，根据上面注释所述，是为了减少内存开销</span></span><br><span class="line"><span class="comment">// 这个在后续的 effect 部分会讲</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, <span class="title class_">KeyToDepMap</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMaps that store {raw &lt;-&gt; observed} pairs.</span></span><br><span class="line"><span class="comment">// 下面这四个变量就是为了解答 问题 3 和 4 的</span></span><br><span class="line"><span class="comment">// 根据上面的原英文注释，这四个变量是 raw 和 observed 的对应关系集合</span></span><br><span class="line"><span class="comment">// raw 是原始数据，observed 则是响应式数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据 -&gt; 响应式数据</span></span><br><span class="line"><span class="keyword">const</span> rawToReactive = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"><span class="comment">// 响应式数据 -&gt; 原始数据</span></span><br><span class="line"><span class="keyword">const</span> reactiveToRaw = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"><span class="comment">// 原始数据 -&gt; 只读响应式数据</span></span><br><span class="line"><span class="keyword">const</span> rawToReadonly = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"><span class="comment">// 只读响应式数据 -&gt; 原始数据</span></span><br><span class="line"><span class="keyword">const</span> readonlyToRaw = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakSets for values that are marked readonly or non-reactive during</span></span><br><span class="line"><span class="comment">// observable creation.</span></span><br><span class="line"><span class="comment">// 前面提到过的 markReadonly 和 markNonReactive 方法用到的</span></span><br><span class="line"><span class="comment">// 用来存储我们标记的特定数据，以便在创建响应式数据是来检查是否被上面两个方法标记过</span></span><br><span class="line"><span class="keyword">const</span> readonlyValues = <span class="keyword">new</span> <span class="title class_">WeakSet</span>&lt;any&gt;()</span><br><span class="line"><span class="keyword">const</span> nonReactiveValues = <span class="keyword">new</span> <span class="title class_">WeakSet</span>&lt;any&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是集合类型（Set, Map, WeakMap, WeakSet）</span></span><br><span class="line"><span class="comment">// 因为集合类型的代理 handler 和普通对象是不同的，需要特殊处理</span></span><br><span class="line"><span class="keyword">const</span> collectionTypes = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="title class_">Function</span>&gt;([<span class="title class_">Set</span>, <span class="title class_">Map</span>, <span class="title class_">WeakMap</span>, <span class="title class_">WeakSet</span>])</span><br><span class="line"><span class="comment">// 判断是否是可观察类型，有以下 6 类，在 canObserve 方法里会用到</span></span><br><span class="line"><span class="keyword">const</span> isObservableType = <span class="comment">/*#__PURE__*/</span> <span class="title function_">makeMap</span>(</span><br><span class="line">  [<span class="string">'Object'</span>, <span class="string">'Array'</span>, <span class="string">'Map'</span>, <span class="string">'Set'</span>, <span class="string">'WeakMap'</span>, <span class="string">'WeakSet'</span>]</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">t</span> =&gt;</span> <span class="string">`[object <span class="subst">${t}</span>]`</span>)</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">','</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>看完上面这些变量定义，我们来解答一下问题 3，4：</p><blockquote><p>问题 3：如何判断是否是（只读的）响应式数据？往响应式数据上面挂载一个标记位来标记？还是用一个对象来存储响应式数据？</p></blockquote><p>用 <code>readonlyToRaw</code> 来存储只读响应式数据的，参见下面代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReadonly</span>(<span class="params">value: any</span>): boolean {</span><br><span class="line">  <span class="keyword">return</span> readonlyToRaw.<span class="title function_">has</span>(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>问题 4：如何将响应式数据转化为原始数据？proxy 数据如何转化成 object？</p></blockquote><p>用 <code>reactiveToRaw</code> 和 <code>readonlyToRaw</code> 来存储<code>响应式数据 -&gt; 原始数据</code> 的映射关系，然后：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(<span class="attr">observed</span>: T): T {</span><br><span class="line">  <span class="keyword">return</span> reactiveToRaw.<span class="title function_">get</span>(observed) || readonlyToRaw.<span class="title function_">get</span>(observed) || observed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>总的来讲，就是利用各种集合来存储原始数据和响应式数据的映射关系，以便快速根据这种映射关系拿到对应的数据。</p><p>再回头看下 <code>canObserve</code> 方法，来看看到底有哪些数据是可以观察的：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canObserve = (<span class="attr">value</span>: any): <span class="function"><span class="params">boolean</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// Vue 实例不可观察，目前库里还没有 _isVue 的逻辑，不过猜测应该是内部在 setup 方法中挂载</span></span><br><span class="line">    !value.<span class="property">_isVue</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// virtual dom 不可观察</span></span><br><span class="line">    !value.<span class="property">_isVNode</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// 'Object', 'Array', 'Map', 'Set', 'WeakMap', 'WeakSet' 类型以外的不可观察</span></span><br><span class="line">    <span class="title function_">isObservableType</span>(<span class="title function_">toTypeString</span>(value)) &amp;&amp;</span><br><span class="line">    <span class="comment">// 已经标记为不可响应数据的不可观察</span></span><br><span class="line">    !nonReactiveValues.<span class="title function_">has</span>(value)</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>相比于 <code>Vue2</code> 的是否可观察判断，则少了很多条件：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我就不解析 Vue2 中的这段判断代码了</span></span><br><span class="line"><span class="comment">// 相比于 Vue2，少了 __ob__ ，ssr 以及 Object.isExtensible 的判断</span></span><br><span class="line"><span class="comment">// 这都是得益于 Proxy</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">hasOwn</span>(value, <span class="string">"__ob__"</span>) &amp;&amp; value.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) {</span><br><span class="line">  ob = value.<span class="property">__ob__</span>;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  shouldObserve &amp;&amp;</span><br><span class="line">  !<span class="title function_">isServerRendering</span>() &amp;&amp;</span><br><span class="line">  (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value) || <span class="title function_">isPlainObject</span>(value)) &amp;&amp;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) &amp;&amp;</span><br><span class="line">  !value.<span class="property">_isVue</span></span><br><span class="line">) {</span><br><span class="line">  ob = <span class="keyword">new</span> <span class="title class_">Observer</span>(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来就讲一下重点的 <code>reactive</code> 和 <code>readonly</code> 这两个核心方法的实现：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面讲过返回值就是上面的解套 Ref 类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: object</span>) {</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="comment">// 如果是一个只读响应式数据，直接返回，因为已经是响应式的了</span></span><br><span class="line">  <span class="keyword">if</span> (readonlyToRaw.<span class="title function_">has</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// target is explicitly marked as readonly by user</span></span><br><span class="line">  <span class="comment">// 如果曾经被标记为只读数据，直接调用 readonly 方法生成只读响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (readonlyValues.<span class="title function_">has</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readonly</span>(target)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建响应式对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target, <span class="comment">// 原始数据</span></span><br><span class="line">    rawToReactive, <span class="comment">// raw -&gt; observed</span></span><br><span class="line">    reactiveToRaw, <span class="comment">// observed -&gt; raw</span></span><br><span class="line">    mutableHandlers, <span class="comment">// 可变数据的 proxy handle</span></span><br><span class="line">    mutableCollectionHandlers <span class="comment">// 可变集合数据的 proxy handler</span></span><br><span class="line">  )</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> readonly&lt;T <span class="keyword">extends</span> object&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">Readonly</span>&lt;<span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;&gt; {</span><br><span class="line">  <span class="comment">// value is a mutable observable, retrieve its original and return</span></span><br><span class="line">  <span class="comment">// a readonly version.</span></span><br><span class="line">  <span class="comment">// 如果是响应式数据，那么获取原始数据来进行观察</span></span><br><span class="line">  <span class="keyword">if</span> (reactiveToRaw.<span class="title function_">has</span>(target)) {</span><br><span class="line">    target = reactiveToRaw.<span class="title function_">get</span>(target)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 创建响应式数据，同样</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target, <span class="comment">// 原始数据</span></span><br><span class="line">    rawToReadonly, <span class="comment">// raw -&gt; readonly observed</span></span><br><span class="line">    readonlyToRaw, <span class="comment">// readonly ovserved -&gt; raw</span></span><br><span class="line">    readonlyHandlers, <span class="comment">// 只读数据的 proxy handler</span></span><br><span class="line">    readonlyCollectionHandlers <span class="comment">// 只读集合数据的 proxy handler</span></span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实我们看 <code>Vue3</code> 的源码会发现，很多入口方法都变得短小精简，不像 <code>Vue2</code> 里的一些 exposed function 那样写的很长，这两个核心方法也一样，逻辑很简单，主要是进行一些原始数据检查和转换，核心实现逻辑都是放在 <code>createReactiveObject</code> 里的</p><p>下面继续看下核心实现方法 <code>createReactiveObject</code>：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建响应式对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any, <span class="comment">// 原始数据</span></span></span><br><span class="line"><span class="params">  toProxy: <span class="built_in">WeakMap</span>&lt;any, any&gt;, <span class="comment">// raw -&gt; (readonly) observed</span></span></span><br><span class="line"><span class="params">  toRaw: <span class="built_in">WeakMap</span>&lt;any, any&gt;, <span class="comment">// (readonly) observed -&gt; raw</span></span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;any&gt;, <span class="comment">// 只读/可变 数据的 proxy handler</span></span></span><br><span class="line"><span class="params">  collectionHandlers: ProxyHandler&lt;any&gt; <span class="comment">// 只读/可变 集合数据的 proxy handler</span></span></span><br><span class="line"><span class="params"></span>) {</span><br><span class="line">  <span class="comment">// 如果不是对象，则直接返回自身，包括 null，reactive(null) =&gt; null</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) {</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">${<span class="built_in">String</span>(target)}</span>`</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// target already has corresponding Proxy</span></span><br><span class="line">  <span class="comment">// 如果原始数据已经被观察过，直接通过 raw -&gt; observed 映射，返回响应式数据</span></span><br><span class="line">  <span class="keyword">let</span> observed = toProxy.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (observed !== <span class="keyword">void</span> <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> observed;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// target is already a Proxy</span></span><br><span class="line">  <span class="comment">// 如果原始数据本身就是响应式的，直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span> (toRaw.<span class="title function_">has</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// only a whitelist of value types can be observed.</span></span><br><span class="line">  <span class="comment">// 如果是不可观察对象，直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">canObserve</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 判断是采用基础数据（object|array）handler 还是集合数据 handler</span></span><br><span class="line">  <span class="keyword">const</span> handlers = collectionTypes.<span class="title function_">has</span>(target.<span class="property">constructor</span>)</span><br><span class="line">    ? collectionHandlers</span><br><span class="line">    : baseHandlers;</span><br><span class="line">  <span class="comment">// Proxy 创建代理对象，即响应式对象</span></span><br><span class="line">  observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handlers);</span><br><span class="line">  <span class="comment">// 创建后，设置好 raw &lt;-&gt; observed 的双向映射关系(*)</span></span><br><span class="line">  toProxy.<span class="title function_">set</span>(target, observed);</span><br><span class="line">  toRaw.<span class="title function_">set</span>(observed, target);</span><br><span class="line">  <span class="comment">// 上面讲到了 targetMap 的作用，这里是创建默认依赖追踪集合</span></span><br><span class="line">  <span class="keyword">if</span> (!targetMap.<span class="title function_">has</span>(target)) {</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, <span class="keyword">new</span> <span class="title class_">Map</span>());</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> observed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到：</p><ul><li>目前来看 <code>reactive</code> 和 <code>readonly</code> 的区别仅有两点：映射关系存储集合不同 and <code>proxy handler</code> 不同</li><li><code>object``array</code> 和集合类型 <code>Set``Map``WeakSet``WeakMap</code> 的 <code>proxy handler</code> 是不同的</li></ul><p>所以下面再来依次看下响应式核心中的核心 - 各种 <code>proxy handler</code></p><h2 id="baseHandler"><a href="#baseHandler" class="headerlink" title="baseHandler"></a>baseHandler</h2><p>方法跟上面一样，先看依赖：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面讲过，不过现在来看感觉像是是在 get set 这些 trap 方法里会调用</span></span><br><span class="line"><span class="keyword">import</span> { reactive, readonly, toRaw } <span class="keyword">from</span> <span class="string">"./reactive"</span>;</span><br><span class="line"><span class="comment">// 操作类型枚举，对应于 proxy handler 里的 trap 方法</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">OperationTypes</span> } <span class="keyword">from</span> <span class="string">"./operations"</span>;</span><br><span class="line"><span class="comment">// 依赖收集和触发依赖回调</span></span><br><span class="line"><span class="keyword">import</span> { track, trigger } <span class="keyword">from</span> <span class="string">"./effect"</span>;</span><br><span class="line"><span class="comment">// 全局锁，用来禁止 set 和 delete</span></span><br><span class="line"><span class="keyword">import</span> { <span class="variable constant_">LOCKED</span> } <span class="keyword">from</span> <span class="string">"./lock"</span>;</span><br><span class="line"><span class="comment">// 工具方法，类型判断</span></span><br><span class="line"><span class="keyword">import</span> { isObject, hasOwn, isSymbol } <span class="keyword">from</span> <span class="string">"@vue/shared"</span>;</span><br><span class="line"><span class="comment">// 判断是否是 ref，后面会讲到</span></span><br><span class="line"><span class="keyword">import</span> { isRef } <span class="keyword">from</span> <span class="string">"./ref"</span>;</span><br></pre></td></tr></tbody></table></figure><p>这里有两个疑问：</p><ol><li><code>track</code> 和 <code>trigger</code> 的实现</li><li><code>LOCKED</code> 的作用？为什么会有这个全局锁？</li></ol><p>问题 1 在后面的 <code>effect</code> 部分会讲到，现在只需要知道是用来追踪依赖和触发依赖回调方法就行</p><p>问题 2 现在我也不是特别了解，只知道是在组件 <code>mount</code> 和 <code>update</code> 的时候会对组件的 <code>props</code>的代理进行修改，因为我们都知道单向数据流中，子组件内部是不能更改 <code>props</code> 的，但是子组件更新，进行 vnode patch 后需要更新子组件的 <code>props</code>，包括一些动态 <code>props</code></p><p>再来看下变量和方法概览：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS 内部语言行为描述符集合，比如 Symbol.iterator 这些，在 get 里会用到</span></span><br><span class="line"><span class="keyword">const</span> builtInSymbols = <span class="keyword">new</span> <span class="title class_">Set</span>(</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Symbol</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">key</span> =&gt;</span> (<span class="title class_">Symbol</span> <span class="keyword">as</span> any)[key])</span><br><span class="line">    .<span class="title function_">filter</span>(isSymbol)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly: boolean</span>) {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  key: string | symbol,</span></span><br><span class="line"><span class="params">  value: any,</span></span><br><span class="line"><span class="params">  receiver: any</span></span><br><span class="line"><span class="params"></span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteProperty</span>(<span class="params">target: any, key: string | symbol</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params">target: any, key: string | symbol</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ownKeys</span>(<span class="params">target: any</span>): (string | number | symbol)[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;any&gt; = {</span><br><span class="line">  <span class="attr">get</span>: <span class="title function_">createGetter</span>(<span class="literal">false</span>),</span><br><span class="line">  set,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">readonlyHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;any&gt; = {</span><br><span class="line">  <span class="attr">get</span>: <span class="title function_">createGetter</span>(<span class="literal">true</span>),</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="attr">target</span>: any, <span class="attr">key</span>: string | symbol, <span class="attr">value</span>: any, <span class="attr">receiver</span>: any): boolean {</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable constant_">LOCKED</span>) {</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Set operation on key "<span class="subst">${<span class="built_in">String</span>(key)}</span>" failed: target is readonly.`</span>,</span><br><span class="line">          target</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="attr">target</span>: any, <span class="attr">key</span>: string | symbol): boolean {</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable constant_">LOCKED</span>) {</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Delete operation on key "<span class="subst">${<span class="built_in">String</span>(</span></span></span><br><span class="line"><span class="subst"><span class="string">            key</span></span></span><br><span class="line"><span class="subst"><span class="string">          )}</span>" failed: target is readonly.`</span>,</span><br><span class="line">          target</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，<code>mutableHandlers</code> 和 <code>readonlyHandlers</code> 都是定义了 5 个 trap 方法：<code>get</code>、<code>set</code>、<code>deleteProperty</code>、<code>has</code>、<code>ownKeys</code>，前 3 个不用多家介绍，<code>has</code> trap 针对与 <code>in</code> 操作符，而 <code>ownKeys</code> 针对于 <code>for in</code> 和 <code>Object.keys</code> 这些遍历操作的</p><p>而 <code>readonlyHandlers</code> 相比于 <code>mutableHandlers</code> 其实只是在 <code>get</code>、<code>set</code> 和 <code>deleteProperty</code> 这三个 trap 方法里有区别，而对于可能改变数据的 <code>set</code> 和 <code>deleteProperty</code> 方法，则是利用 <code>LOCKED</code> 来锁定，不让修改数据，这个变量我在上面也提了一下</p><p>下面来一个一个的看下各个 trap 方法</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 get trap 方法</span></span><br><span class="line"><span class="comment">// 如果是可变数据， isReadonly 是 false</span></span><br><span class="line"><span class="comment">// 如果是只读数据，那么 isReadonly 就是 true</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly: boolean</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: any, key: string | symbol, receiver: any</span>) {</span><br><span class="line">    <span class="comment">// 利用 Reflect 反射来获取原始值</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">    <span class="comment">// 如果是 JS 内置方法，不进行依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) &amp;&amp; builtInSymbols.<span class="title function_">has</span>(key)) {</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果是 ref 类型数据，则直接返回其 value</span></span><br><span class="line">    <span class="comment">// TODO 后面 ref 部分我们会讲到，ref(target) 其实在 get value 的时候做了依赖收集了，</span></span><br><span class="line">    <span class="comment">// 就不需要下面重复收集依赖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) {</span><br><span class="line">      <span class="keyword">return</span> res.<span class="property">value</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 类型操作的依赖收集</span></span><br><span class="line">    <span class="title function_">track</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">GET</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里其实很简单就是递归返回响应式对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isObject</span>(res)</span><br><span class="line">      ? isReadonly</span><br><span class="line">        ? <span class="comment">// need to lazy access readonly and reactive here to avoid</span></span><br><span class="line">          <span class="comment">// circular dependency</span></span><br><span class="line">          <span class="title function_">readonly</span>(res)</span><br><span class="line">        : <span class="title function_">reactive</span>(res)</span><br><span class="line">      : res;</span><br><span class="line">  };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看完 <code>get trap</code> 其实很简单，但是也会有写疑问：</p><h3 id="1-为什么用-Reflect-get，而不是直接-target-key-返回呢"><a href="#1-为什么用-Reflect-get，而不是直接-target-key-返回呢" class="headerlink" title="1. 为什么用 Reflect.get，而不是直接 target[key] 返回呢?"></a>1. 为什么用 <code>Reflect.get</code>，而不是直接 <code>target[key]</code> 返回呢?</h3><p>我们可以看它的第三个参数：</p><blockquote><p>receiver：如果 target 对象中指定了 getter，receiver 则为 getter 调用时的 this 值</p></blockquote><p>举个例子：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() {</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observed = <span class="title function_">reactive</span>(target);</span><br></pre></td></tr></tbody></table></figure><p>此时，如果不用 <code>Reflect.get</code>，而是 <code>target[key]</code>，那么 <code>this.foo</code> 中的 <code>this</code> 就指向的是 <code>target</code>，而不是 <code>observed</code>，此时 <code>this.foo</code> 就不能收集到 <code>foo</code> 的依赖了，如果 <code>observed.foo = 20</code> 改变了 foo 的值，那么是无法触发依赖回调的，所以需要利用 <code>Reflect.get</code> 将 getter 里的 <code>this</code> 指向代理对象</p><h3 id="2-为什么在结尾-return-的时候还要调用-reactive-或者-readoonly-呢？"><a href="#2-为什么在结尾-return-的时候还要调用-reactive-或者-readoonly-呢？" class="headerlink" title="2. 为什么在结尾 return 的时候还要调用 reactive 或者 readoonly 呢？"></a>2. 为什么在结尾 return 的时候还要调用 <code>reactive</code> 或者 <code>readoonly</code> 呢？</h3><p>原注释是这样写的：</p><blockquote><p>need to lazy access readonly and reactive here to avoid circular dependency<br>翻译过来是：需要延迟地使用 readonly 和 readtive 来避免循环引用</p></blockquote><p>为什么这样说呢？这里不得不说一下 <code>Proxy</code> 的特性：只能代理一层，对于嵌套的深层对象，如果不按源码中的方法，那就需要一层层递归来代理劫持对象，即每次递归都判断是否是对象，如果是对象，那么再调用 <code>reactive</code> 来响应式化</p><p>但是问题又来了，JS 里是有循环引用这个概念的，就像下面这样：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = {</span><br><span class="line">  <span class="attr">b</span>: {},</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">a.<span class="property">b</span>.<span class="property">c</span> = a;</span><br></pre></td></tr></tbody></table></figure><p>这样的话，如果每次递归调用 <code>reactive</code> 的话，会造成调用栈溢出 <code>Maximum call stack size exceeded</code>，但是我们只需要加上一个判断条件即可解决，在上面解析的 <code>createReactiveObject</code> 方法里我们知道如果原始数据已经被观察过，则直接返回对应的响应式数据，那么我们可以在递归调用 <code>reactive</code> 的时候判断 <code>toProxy.get(target)</code> 是否存在，如果存在就不往下递归了，我写了一个例子代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环引用对象</span></span><br><span class="line"><span class="keyword">const</span> target = { <span class="attr">b</span>: { <span class="attr">c</span>: <span class="number">1</span> } };</span><br><span class="line">target.<span class="property">b</span>.<span class="property">d</span> = target;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是上面讲的 原始数据 -&gt; 响应式数据的集合</span></span><br><span class="line"><span class="keyword">const</span> rawToReactive = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">data</span>) {</span><br><span class="line">  <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, {</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) {</span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">      <span class="keyword">const</span> observed = rawToReactive.<span class="title function_">get</span>(res);</span><br><span class="line">      <span class="keyword">return</span> observed || res;</span><br><span class="line">    },</span><br><span class="line">  });</span><br><span class="line">  rawToReactive.<span class="title function_">set</span>(data, observed);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) {</span><br><span class="line">    <span class="keyword">const</span> child = data[key];</span><br><span class="line">    <span class="comment">// 这里判断如果没有被观察过，那么继续 reactive 递归观察</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">"object"</span> &amp;&amp; !rawToReactive.<span class="title function_">get</span>(child)) {</span><br><span class="line">      <span class="title function_">reactive</span>(child);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> observed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title function_">reactive</span>(target);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">b</span>.<span class="property">d</span>.<span class="property">b</span>); <span class="comment">// Proxy {c: 1, d: {…}}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我试了一下。跟源码里的 reactive 的 get 结果是一样的</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>可以去看下我在 <a href="https://zhuanlan.zhihu.com/p/87409653">vue3 响应式源码解析-Reactive 篇</a> 这篇文章下的评论部分</p></blockquote><p>而源码中的 <code>lazy access</code> 方式很取巧，只代理一层，当用到某个属性值对象时，再进行响应式观察这一层</p><p>所以相比于初始化时递归劫持，延迟访问劫持的方式更能<strong>提升初始化性能</strong>，也有利于对数据劫持做更细的控制，特别是针对于数据对象比较大时（比如接口返回数据嵌套过深），有些数据并非需要劫持，所以按需劫持代理我们用到的数据这种方式更好</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  key: string | symbol,</span></span><br><span class="line"><span class="params">  value: any,</span></span><br><span class="line"><span class="params">  receiver: any</span></span><br><span class="line"><span class="params"></span>): boolean {</span><br><span class="line">  <span class="comment">// 如果是观察过响应式数据，那么获取它映射的原始数据</span></span><br><span class="line">  value = <span class="title function_">toRaw</span>(value);</span><br><span class="line">  <span class="comment">// 获取旧值</span></span><br><span class="line">  <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">  <span class="comment">// 如果旧值是 ref 类型数据，而新的值不是 ref，那么直接赋值给 oldValue.value</span></span><br><span class="line">  <span class="comment">// 因为 ref 数据在 set value 的时候就已经 trigger 依赖了，所以直接 return 就行</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) {</span><br><span class="line">    oldValue.<span class="property">value</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 对象上是否有这个 key，有则是 set，无则是 add</span></span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line">  <span class="comment">// 利用 Reflect 来执行 set 操作</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">  <span class="comment">// don't trigger if target is something up in the prototype chain of original</span></span><br><span class="line">  <span class="comment">// 如果 target 原型链上的数据，那么就不触发依赖回调</span></span><br><span class="line">  <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) {</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">      <span class="comment">// 开发环境操作，只比正式环境多了个 extraInfo 的调试信息</span></span><br><span class="line">      <span class="keyword">const</span> extraInfo = { oldValue, <span class="attr">newValue</span>: value };</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) {</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">ADD</span>, key, extraInfo);</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (value !== oldValue) {</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">SET</span>, key, extraInfo);</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 上面讲过，有这个 key 则是 set，无则是 add</span></span><br><span class="line">      <span class="keyword">if</span> (!hadKey) {</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">ADD</span>, key);</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (value !== oldValue) {</span><br><span class="line">        <span class="comment">// 只有当 value 改变的时候才触发</span></span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">SET</span>, key);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同样，<code>set trap</code> 看起来也很简单，但是同时也会有一些问题：</p><h3 id="1-target-toRaw-receiver-是什么鬼逻辑"><a href="#1-target-toRaw-receiver-是什么鬼逻辑" class="headerlink" title="1. target === toRaw(receiver) 是什么鬼逻辑?"></a>1. <code>target === toRaw(receiver)</code> 是什么鬼逻辑?</h3><p>首先看下</p><p><a href="https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set%23%E5%8F%82%E6%95%B0">handler.set()developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set#%E5%8F%82%E6%95%B0<img src="https://pic4.zhimg.com/v2-72382e605ce3eba8154aa310a712c403_ipico.jpg" alt="img"></a></p><p>的关于第三个参数的说明：</p><blockquote><p>最初被调用的对象。通常是 proxy 本身，但 handler 的 set 方法也有可能在原型链上或以其他方式被间接地调用（因此不一定是 proxy 本身）。<br>比如，假设有一段代码执行 obj.name = “jen”，obj 不是一个 proxy 且自身不含 name 属性，但它的原型链上有一个 proxy，那么那个 proxy 的 set 拦截函数会被调用，此时 obj 会作为 receiver 参数传进来</p></blockquote><p>上面已经给出例子了，这里我再写一下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child = { <span class="attr">name</span>: <span class="string">"child"</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">"parent"</span> },</span><br><span class="line">  {</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(target, receiver);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(child, parent);</span><br><span class="line"></span><br><span class="line">child.<span class="property">foo</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会打印出</span></span><br><span class="line"><span class="comment">// {name: "parent"} {name: "child"}</span></span><br></pre></td></tr></tbody></table></figure><p>这里有两个先决条件：</p><ol><li>child 的原型链是一个 Proxy</li><li>child 在设置值的时候，本身不包含 key 的</li></ol><p>可以看到，当满足上面两个条件的时候，设置 child 的值，会触发原型链上的 <code>set trap</code> 方法，并且 <code>target</code> 是原型链数据，而 <code>receiver</code> 则是真实数据</p><p>所以，源码中的那个条件逻辑也就不难看懂了，当满足上述两个条件时，我们当然不希望触发 parent 的 <code>set trap</code> 了</p><h3 id="2-像数组的-unshift，splice-这些操作是如何触发-set-trap方法的呢？"><a href="#2-像数组的-unshift，splice-这些操作是如何触发-set-trap方法的呢？" class="headerlink" title="2. 像数组的 unshift，splice 这些操作是如何触发 set trap方法的呢？"></a>2. 像数组的 <code>unshift</code>，<code>splice</code> 这些操作是如何触发 <code>set trap</code>方法的呢？</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 set 里加上这么一个 log</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  !hadKey ? <span class="string">"add"</span> : value !== oldValue ? <span class="string">"set"</span> : <span class="string">"unknow"</span>,</span><br><span class="line">  target,</span><br><span class="line">  key,</span><br><span class="line">  value,</span><br><span class="line">  oldValue</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>然后</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">a.<span class="title function_">unshift</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会打印</span></span><br><span class="line"><span class="comment">// add [1, 2, 3, 3] 3 3 undefined</span></span><br><span class="line"><span class="comment">// set [1, 2, 2, 3] 2 2 3</span></span><br><span class="line"><span class="comment">// set [1, 1, 2, 3] 1 1 2</span></span><br><span class="line"><span class="comment">// set [0, 1, 2, 3] 0 0 1</span></span><br><span class="line"><span class="comment">// unknow [0, 1, 2, 3] length 4 4</span></span><br></pre></td></tr></tbody></table></figure><p>一共打印了 5 次，根据打印内容我们可以看到 <code>unshift</code> 的实际操作过程，即把数组的每一项依次都往后移动一位，然后再把首位设置成 <code>0</code>，至于为什么这么操作，</p><p><a href="https://link.zhihu.com/?target=https://www.ecma-international.org/ecma-262/6.0/%23sec-array.prototype.unshift">ECMA-262 Array.property.unshiftwww.ecma-international.org/ecma-262/6.0/#sec-array.prototype.unshift</a></p><p>标准中有原理介绍，我就不赘述了，还有像 <code>shift</code> 和 <code>splice</code> 也是一样的操作步骤</p><p>可以看到 <code>unshift</code> 或者 <code>splice</code> 是会带来多次的 <code>trigger</code> 的，当然这些会有批量跟新优化的，有时间我再展开讲一下</p><p>细心的同学可能会发现，还触发了 <code>length</code> 属性的 set，而且 <code>value</code> 和 <code>oldValue</code> 是一样的，那么根据源码所示，就不会触发 set 类型的回调了呀，那我们如果在 template 里用到了 <code>a.length</code> 那也不会更新了么？</p><p>肯定是会更新的，解决办法就在 <code>trigger</code> 这个方法里，后续 <code>effect</code> 部分会讲到，先简单说一下，对于会导致数组 <code>length</code> 改变的操作，比如 add 和 delete，在 <code>effect</code> 的 <code>trigger</code> 方法里会单独处理，来触发 <code>length</code> 属性的依赖回调的</p><h3 id="其他-trap-方法"><a href="#其他-trap-方法" class="headerlink" title="其他 trap 方法"></a>其他 trap 方法</h3><p>还有 <code>deleteProperty</code>、<code>has</code> 和 <code>ownKeys</code> 这几个 trap，代码不多，都很简单，直接看下面的源码就能明白，我就不在赘述了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deleteProperty trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteProperty</span>(<span class="params">target: any, key: string | symbol</span>): boolean {</span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line">  <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key);</span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; hadKey) {</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">      <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">DELETE</span>, key, { oldValue });</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">DELETE</span>, key);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// has trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params">target: any, key: string | symbol</span>): boolean {</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, key);</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">HAS</span>, key);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ownKey trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ownKeys</span>(<span class="params">target: any</span>): (string | number | symbol)[] {</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">ITERATE</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>baseHandler</code> 是针对于数组和对象类型的数据的 proxy handler</li><li>每个 <code>trap</code> 方法都是用 <code>Reflect</code> 来反射到原始数据上的</li><li>对于 <code>get</code>、<code>has</code> 和 <code>ownKeys</code> 这一类读操作，会进行 <code>track</code> 来收集依赖，而对于 <code>set</code> 和 <code>deleteProperty</code> 这类写操作，则是会进行 <code>trigger</code> 来触发依赖回调</li><li>响应式数据的读取是 <code>lazy</code> 的，即初始化的时候不会对嵌套对象全盘观察，而是只有用到了每个值才会生成对应的响应式数据</li></ul><h2 id="collectionHandler"><a href="#collectionHandler" class="headerlink" title="collectionHandler"></a>collectionHandler</h2><p>还记得我们在看 <code>reactive</code> 方法那里有个 <code>collectionTypes</code> 的判断对吧，<code>collectionHandler</code> 就是专门来处理 <code>Set|Map|WeakSet|WeakMap</code> 这类集合类型数据的</p><p>这里可以参考相学长的</p><p><a href="https://link.zhihu.com/?target=https://juejin.im/post/5da9d7ebf265da5bbb1e52b7%23heading-12">vue3 响应式源码解析-Reactive 篇 - 掘金 juejin.im/post/5da9d7ebf265da5bbb1e52b7#heading-12</a></p><p>这篇文章，写的很详细，我这里也不再赘述了</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>最开始阅读 <code>reactive</code> 源码时，总体的逻辑是比较清晰的，但是仍然有几个地方当时有疑惑：</p><ul><li><code>rawToReactive|rawToReadonly</code> 等这几个变量是干嘛的？</li><li><code>targetMap</code> 的是干什么的？为什么是 <code>WeakMap&lt;any, KeyToDepMap&gt;</code> 类型</li><li><code>LOCKED</code> 是用来干嘛的?</li><li><code>baseHandler</code> 的 <code>get trap</code> 为什么又返回了一个 <code>reactive(res)</code>？</li><li><code>collectionHandler</code> 里的 trap 方法为什么只有 <code>get</code>？为什么跟 <code>baseHandler</code> 不一样？</li></ul><p>在读完源码后，除了 <code>LOCKED</code> 那个疑惑，其他几个问题我都已经找到答案，并且也在上面解惑了，我相信大家看完这篇文章后也应该都有自己的答案了</p><p>最后再来个源码里的知识点总结吧：</p><ul><li><code>reactive</code> 是利用 <code>Proxy</code> 来进行数据观察，<code>Reflect</code> 相关操作来反射到原始数据的，并且数据的访问是一个 <code>lazy reactive</code> 方式，即按需观察</li><li>普通对象、数组和集合类型数据的代理 handler 是不同的，这是因为 <code>Proxy</code> 的一些限制，参考</li></ul><p><a href="https://link.zhihu.com/?target=https://javascript.info/proxy%23proxy-limitations">Proxy and Reflectjavascript.info/proxy#proxy-limitations<img src="https://pic4.zhimg.com/v2-371dd24f02bbb7f17ea00a910ff8f70b_180x120.jpg" alt="img"></a></p><ul><li>利用几个 <code>WeakMap</code> 来存储原始数据 &lt;-&gt; 响应式数据的双向映射关系，以便在响应式入口方法里判断是否原始数据已经被观察过，这个相比于 Vue2 的直接在原始数据上挂载 <code>__ob__</code>要少一些冗余数据，并且由于 <code>WeakMap</code> 的 GC 特性，在运行时会有一定的内存优化</li><li>响应式数据的读操作会 <code>track</code> 来收集依赖，写操作则是会 <code>trigger</code> 来触发依赖回调</li></ul><p>整个 <code>reactive|readonly</code> 的流程如下：</p><p><img src="https://pic3.zhimg.com/80/v2-849f116c5d6f242c776ab5b8d610ee1a_720w.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 原理 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目优化</title>
      <link href="/2022/04/09/xing-neng-you-hua/"/>
      <url>/2022/04/09/xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="页面内容的呈现过程"><a href="#页面内容的呈现过程" class="headerlink" title="页面内容的呈现过程"></a>页面内容的呈现过程</h1><h2 id="页面的首屏加载性能-白屏时间是否过长？"><a href="#页面的首屏加载性能-白屏时间是否过长？" class="headerlink" title="页面的首屏加载性能 白屏时间是否过长？"></a>页面的首屏加载性能 白屏时间是否过长？</h2><h2 id="页面加载时的-loading-动画-是否需要骨架屏-骨架屏消失时使得否存在页面抖动"><a href="#页面加载时的-loading-动画-是否需要骨架屏-骨架屏消失时使得否存在页面抖动" class="headerlink" title="页面加载时的 loading 动画 是否需要骨架屏 骨架屏消失时使得否存在页面抖动"></a>页面加载时的 loading 动画 是否需要骨架屏 骨架屏消失时使得否存在页面抖动</h2><h2 id="数据为空时-页面模块的占位方式-数据返回时-是否会出现页面抖动"><a href="#数据为空时-页面模块的占位方式-数据返回时-是否会出现页面抖动" class="headerlink" title="数据为空时 页面模块的占位方式 数据返回时 是否会出现页面抖动"></a>数据为空时 页面模块的占位方式 数据返回时 是否会出现页面抖动</h2><h2 id="页面异常处理时-是否提供了合理的用户反馈"><a href="#页面异常处理时-是否提供了合理的用户反馈" class="headerlink" title="页面异常处理时 是否提供了合理的用户反馈"></a>页面异常处理时 是否提供了合理的用户反馈</h2><h2 id="页面适配-对于不同尺寸的设备-是否都能保证主要内容的首屏透出"><a href="#页面适配-对于不同尺寸的设备-是否都能保证主要内容的首屏透出" class="headerlink" title="页面适配 对于不同尺寸的设备 是否都能保证主要内容的首屏透出"></a>页面适配 对于不同尺寸的设备 是否都能保证主要内容的首屏透出</h2><h2 id="文本超长时是做阶段还是省略处理"><a href="#文本超长时是做阶段还是省略处理" class="headerlink" title="文本超长时是做阶段还是省略处理"></a>文本超长时是做阶段还是省略处理</h2><h2 id="图片加载时如何占位-加载失败时如何处理-是否需要做缩放处理"><a href="#图片加载时如何占位-加载失败时如何处理-是否需要做缩放处理" class="headerlink" title="图片加载时如何占位 加载失败时如何处理 是否需要做缩放处理"></a>图片加载时如何占位 加载失败时如何处理 是否需要做缩放处理</h2><h2 id="页面变化时是否有合理的过渡和动画"><a href="#页面变化时是否有合理的过渡和动画" class="headerlink" title="页面变化时是否有合理的过渡和动画"></a>页面变化时是否有合理的过渡和动画</h2><h1 id="页面交互的体验细节"><a href="#页面交互的体验细节" class="headerlink" title="页面交互的体验细节"></a>页面交互的体验细节</h1><h2 id="用户操作的响应性时间是否过长"><a href="#用户操作的响应性时间是否过长" class="headerlink" title="用户操作的响应性时间是否过长"></a>用户操作的响应性时间是否过长</h2><h2 id="按钮的点击区域是否合理"><a href="#按钮的点击区域是否合理" class="headerlink" title="按钮的点击区域是否合理"></a>按钮的点击区域是否合理</h2><h2 id="文字长按是否可以选中"><a href="#文字长按是否可以选中" class="headerlink" title="文字长按是否可以选中"></a>文字长按是否可以选中</h2><h2 id="页面滚动是否需要滚动栏"><a href="#页面滚动是否需要滚动栏" class="headerlink" title="页面滚动是否需要滚动栏"></a>页面滚动是否需要滚动栏</h2><h2 id="页面浮层是否存在点击或滚动穿透"><a href="#页面浮层是否存在点击或滚动穿透" class="headerlink" title="页面浮层是否存在点击或滚动穿透"></a>页面浮层是否存在点击或滚动穿透</h2><h2 id="图片长按是否可以保存"><a href="#图片长按是否可以保存" class="headerlink" title="图片长按是否可以保存"></a>图片长按是否可以保存</h2><h1 id="页面的可访问性"><a href="#页面的可访问性" class="headerlink" title="页面的可访问性"></a>页面的可访问性</h1>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带你剖析设计模式</title>
      <link href="/2022/04/09/qian-tan-she-ji-mo-shi/"/>
      <url>/2022/04/09/qian-tan-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态的思想是把”做什么”和“谁去做”分开来</p><p><strong>多态最根本的作用是通过过程化的条件分支语句转化为对象的多态性 从而消除这些条件分支语句</strong></p><p>将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//不用多态的版本</span><br><span class="line">var googleMap = {</span><br><span class="line"> show: function(){</span><br><span class="line"> console.log( '开始渲染谷歌地图' );</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var baiduMap = {</span><br><span class="line"> show: function(){</span><br><span class="line"> console.log( '开始渲染百度地图' );</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var renderMap = function( type ){</span><br><span class="line"> if ( type === 'google' ){</span><br><span class="line"> googleMap.show();</span><br><span class="line"> }else if ( type === 'baidu' ){</span><br><span class="line"> baiduMap.show();</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">renderMap( 'google' ); // 输出：开始渲染谷歌地图</span><br><span class="line">renderMap( 'baidu' ); // 输出：开始渲染百度地图</span><br><span class="line">//不断地在renderMap中堆砌条件分支语句 导致代码臃肿</span><br><span class="line">var renderMap = function( map ){</span><br><span class="line"> if ( map.show instanceof Function ){</span><br><span class="line"> map.show();</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">//使用多态 只需要关注发出show的动作 不必关心是谁的show做什么动作</span><br></pre></td></tr></tbody></table></figure><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><ul><li>所有数据都是对象</li><li>要得到一个对象 不是通过实例化一个类 而是找到一个对象并作为原型克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求 就会把这个请求委托给它自己的原型</li></ul><h1 id="this、call、apply"><a href="#this、call、apply" class="headerlink" title="this、call、apply"></a>this、call、apply</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this 总是指向一个对象 而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的 而非函数声明的环境</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>使用闭包的同时容易形成循环引用 如果闭包的作用域链中存在一些 DMO 节点 就可能造成内存泄漏</p><p>要解决循环引用带来的内存泄露问题 只需要讲循环引用中的变量设为 null 即可</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证一个类仅有一个实例 并提供一个访问它的全局访问点 <strong>即单例模式的核心是确保只有一个实例并提供全局访问</strong></p><p>作为开发者应该尽量减少全局变量的使用 可以使用闭包封装私有变量来避免对全局的命令污染</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user = (function(){</span><br><span class="line"> var __name = 'sven',</span><br><span class="line"> __age = 29;</span><br><span class="line"> return {</span><br><span class="line"> getUserInfo: function(){</span><br><span class="line"> return __name + '-' + __age;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>定义：定义一系列的算法 把它们一个一个封装起来 并且使它们可以互相替换 <strong>目的是将算法的使用与算法的实现分离开来</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var strategies = {</span><br><span class="line"> "S": function( salary ){</span><br><span class="line"> return salary * 4;</span><br><span class="line"> },</span><br><span class="line"> "A": function( salary ){</span><br><span class="line"> return salary * 3;</span><br><span class="line"> },</span><br><span class="line"> "B": function( salary ){</span><br><span class="line"> return salary * 2;</span><br><span class="line">图灵社区会员 轩辕 专享 尊重版权</span><br><span class="line">76 第 5 章 策略模式</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var calculateBonus = function( level, salary ){</span><br><span class="line"> return strategies[ level ]( salary );</span><br><span class="line">};</span><br><span class="line">console.log( calculateBonus( 'S', 20000 ) ); // 输出：80000</span><br><span class="line">console.log( calculateBonus( 'A', 10000 ) ); // 输出：30000</span><br></pre></td></tr></tbody></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>保护代理：代理可以帮助过滤掉一些请求</p><p>虚拟代理：虚拟代理把一些开销很大的对象延迟到真正需要它的时候才去创建</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">虚拟代理：</span><br><span class="line">var myImage = (function(){</span><br><span class="line"> var imgNode = document.createElement( 'img' );</span><br><span class="line"> document.body.appendChild( imgNode );</span><br><span class="line"> return {</span><br><span class="line"> setSrc: function( src ){</span><br><span class="line"> imgNode.src = src;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">var proxyImage = (function(){</span><br><span class="line"> var img = new Image;</span><br><span class="line"> img.onload = function(){</span><br><span class="line"> myImage.setSrc( this.src );</span><br><span class="line"> }</span><br><span class="line"> return {</span><br><span class="line"> setSrc: function( src ){</span><br><span class="line"> myImage.setSrc( 'file:// /C:/Users/svenzeng/Desktop/loading.gif' );</span><br><span class="line"> img.src = src;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">proxyImage.setSrc( 'http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg' );</span><br><span class="line">//加载中用一张本地图片 加载后才替换为对应url</span><br></pre></td></tr></tbody></table></figure><p>单一职责原则：一个类（通常包括对象和函数等）而言，应该仅有一个引起它变化的原因 如果一个对象承担的职责过多 就会导致脆弱和低内聚</p><p>**代理和本体应该拥有一样的主要逻辑功能 这样用户可以在不需要用到代理的时候直接将请求对象改成本体而无需修改本体的代码 **</p><p><strong>虚拟代理合并 http 请求</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">需求场景：同步文件 如果短时间内连续发送请求会导致服务器压力太大 可以设置代理函数收集一段时间内的请求最后一次性发送给服务器 除非是对实时性要求高的系统 不然延迟都不会带来太大的副作用却可以大大减轻服务器的压力</span><br><span class="line">var synchronousFile = function( id ){</span><br><span class="line"> console.log( '开始同步文件，id 为: ' + id );</span><br><span class="line">};</span><br><span class="line">var proxySynchronousFile = (function(){</span><br><span class="line"> var cache = [], // 保存一段时间内需要同步的 ID</span><br><span class="line"> timer; // 定时器</span><br><span class="line"> return function( id ){</span><br><span class="line"> cache.push( id );</span><br><span class="line"> if ( timer ){ // 保证不会覆盖已经启动的定时器</span><br><span class="line"> return;</span><br><span class="line"> }</span><br><span class="line"> timer = setTimeout(function(){</span><br><span class="line"> synchronousFile( cache.join( ',' ) ); // 2 秒后向本体发送需要同步的 ID 集合</span><br><span class="line"> clearTimeout( timer ); // 清空定时器</span><br><span class="line"> timer = null;</span><br><span class="line"> cache.length = 0; // 清空 ID 集合</span><br><span class="line"> }, 2000 );</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">var checkbox = document.getElementsByTagName( 'input' );</span><br><span class="line">for ( var i = 0, c; c = checkbox[ i++ ]; ){</span><br><span class="line">c.onclick = function(){</span><br><span class="line"> if ( this.checked === true ){</span><br><span class="line"> proxySynchronousFile( this.id );</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>缓存代理可以为一些开销很大的运算结果提供暂时的储存 在下次运算时 如果传递进来的参数跟之前的一样 就可以直接返回之前的计算结果</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">先创建一个用于求乘积的函数：</span><br><span class="line">var mult = function(){</span><br><span class="line"> console.log( '开始计算乘积' );</span><br><span class="line"> var a = 1;</span><br><span class="line"> for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"> a = a * arguments[i];</span><br><span class="line"> }</span><br><span class="line"> return a;</span><br><span class="line">};</span><br><span class="line">mult( 2, 3 ); // 输出：6</span><br><span class="line">mult( 2, 3, 4 ); // 输出：24</span><br><span class="line">现在加入缓存代理函数：</span><br><span class="line">var proxyMult = (function(){</span><br><span class="line"> var cache = {};</span><br><span class="line"> return function(){</span><br><span class="line"> var args = Array.prototype.join.call( arguments, ',' );</span><br><span class="line"> if ( args in cache ){</span><br><span class="line"> return cache[ args ];</span><br><span class="line"> }</span><br><span class="line"> return cache[ args ] = mult.apply( this, arguments );</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line"> proxyMult( 1, 2, 3, 4 ); // 输出：24</span><br><span class="line"> proxyMult( 1, 2, 3, 4 ); // 输出：24第二次并没有进行计算 而是直接返回之前计算好的结果 通过增加缓存代理的方式 mult函数可以继续专注于自身的职责-计算乘积 而缓存的功能时由代理对象实现的</span><br></pre></td></tr></tbody></table></figure><p><strong>缓存代理用于 api 请求</strong></p><p>在进行请求一些不变的数据的时候（分页需求）同一页的数据理论上只需要去后台拉取一次，这些已经拉取到的数据在某个地方被缓存之后 下次再请求同一页的时候 就可以直接使用之前的数据 可以通过缓存代理实现</p><p><strong>使用高阶函数动态创建代理</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**************** 计算乘积 *****************/</span><br><span class="line">var mult = function(){</span><br><span class="line"> var a = 1;</span><br><span class="line"> for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"> a = a * arguments[i];</span><br><span class="line"> }</span><br><span class="line"> return a;</span><br><span class="line">};</span><br><span class="line">/**************** 计算加和 *****************/</span><br><span class="line">var plus = function(){</span><br><span class="line"> var a = 0;</span><br><span class="line"> for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"> a = a + arguments[i];</span><br><span class="line"> }</span><br><span class="line"> return a;</span><br><span class="line">};</span><br><span class="line">/**************** 创建缓存代理的工厂 *****************/</span><br><span class="line">var createProxyFactory = function( fn ){</span><br><span class="line"> var cache = {};</span><br><span class="line"> return function(){</span><br><span class="line"> var args = Array.prototype.join.call( arguments, ',' );</span><br><span class="line"> if ( args in cache ){</span><br><span class="line"> return cache[ args ];</span><br><span class="line"> }</span><br><span class="line"> return cache[ args ] = fn.apply( this, arguments );</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var proxyMult = createProxyFactory( mult ),</span><br><span class="line">proxyPlus = createProxyFactory( plus );</span><br><span class="line">alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24</span><br><span class="line">alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24</span><br><span class="line">alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10</span><br><span class="line">alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10</span><br></pre></td></tr></tbody></table></figure><p>tips：编写业务的时候往往不需要预先去猜测是否需要使用代理模式 当真正发现不方便的时候直接访问某个对象的时候 再编写代理也不迟</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象 的内部表示</p><h1 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h1><p>发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状 态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型 来替代传统的发布—订阅模式。</p><p><strong>发布-订阅模式可以广泛用于异步编程中 是一种可以代替回调函数的方案 在异步编程中使用发布-订阅模式 我们就无需过多关注对象在一异步运行期间的内部状态 而只需要订阅感兴趣的事件发生点</strong></p><p><strong>发布-订阅模式可以取代对象之间的硬编码的通知方式 一个对象不再显式地调用另一个对象的某个接口实现松耦合 可以单独对订阅者和发布者做修改而不用去修改其引用</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">发布-订阅模式的步骤</span><br><span class="line">1.首先要指定谁充当发布者</span><br><span class="line">2.然后给发布者添加一个缓存列表 用于存放回调函数以便通知订阅者</span><br><span class="line">3.最后在发布消息的时候 发布者会遍历这个缓存列表 依次触发里面存放的订阅者函数 另外 可以往回调函数中加入一些参数 订阅者可以接收参数 这很有必要</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">var event = {</span><br><span class="line"> clientList: [],</span><br><span class="line"> listen: function( key, fn ){</span><br><span class="line"> if ( !this.clientList[ key ] ){</span><br><span class="line"> this.clientList[ key ] = [];</span><br><span class="line"> }</span><br><span class="line"> this.clientList[ key ].push( fn ); // 订阅的消息添加进缓存列表</span><br><span class="line"> },</span><br><span class="line"> trigger: function(){</span><br><span class="line"> var key = Array.prototype.shift.call( arguments ), // (1);</span><br><span class="line"> fns = this.clientList[ key ];</span><br><span class="line"> if ( !fns || fns.length === 0 ){ // 如果没有绑定对应的消息</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> for( var i = 0, fn; fn = fns[ i++ ]; ){</span><br><span class="line"> fn.apply( this, arguments ); // (2) // arguments 是 trigger 时带上的参数</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布—订阅功能：</span><br><span class="line">var installEvent = function( obj ){</span><br><span class="line"> for ( var i in event ){</span><br><span class="line"> obj[ i ] = event[ i ];</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">再来测试一番，我们给售楼处对象 salesOffices 动态增加发布—订阅功能：</span><br><span class="line">var salesOffices = {};</span><br><span class="line">installEvent( salesOffices );</span><br><span class="line">salesOffices.listen( 'squareMeter88', function( price ){ // 小明订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.listen( 'squareMeter100', function( price ){ // 小红订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.trigger( 'squareMeter88', 2000000 ); // 输出：2000000</span><br><span class="line">salesOffices.trigger( 'squareMeter100', 3000000 ); // 输出：3000000</span><br><span class="line">取消订阅的事件</span><br><span class="line">event.remove = function( key, fn ){</span><br><span class="line"> var fns = this.clientList[ key ];</span><br><span class="line"> if ( !fns ){ // 如果 key 对应的消息没有被人订阅，则直接返回</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> if ( !fn ){ // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅</span><br><span class="line"> fns &amp;&amp; ( fns.length = 0 );</span><br><span class="line"> }else{</span><br><span class="line"> for ( var l = fns.length - 1; l &gt;=0; l-- ){ // 反向遍历订阅的回调函数列表</span><br><span class="line"> var _fn = fns[ l ];</span><br><span class="line"> if ( _fn === fn ){</span><br><span class="line"> fns.splice( l, 1 ); // 删除订阅者的回调函数</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var salesOffices = {};</span><br><span class="line">var installEvent = function( obj ){</span><br><span class="line"> for ( var i in event ){</span><br><span class="line"> obj[ i ] = event[ i ];</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">installEvent( salesOffices );</span><br><span class="line">salesOffices.listen( 'squareMeter88', fn1 = function( price ){ // 小明订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.listen( 'squareMeter88', fn2 = function( price ){ // 小红订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.remove( 'squareMeter88', fn1 ); // 删除小明的订阅</span><br><span class="line">salesOffices.trigger( 'squareMeter88', 2000000 ); // 输出：2000000</span><br></pre></td></tr></tbody></table></figure><p><strong>全局的发布订阅模式</strong></p><p>发布订阅模式可以用一个全局的 Event 对象来实现 订阅者不需要了解消息来自哪个发布者 发布者也不知道消息会被推送给哪些订阅者 Event 作为一个类似于中介的角色把订阅者和发布者联系起来</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">var Event = (function(){</span><br><span class="line"> var clientList = {},</span><br><span class="line"> listen,</span><br><span class="line"> trigger,</span><br><span class="line"> remove;</span><br><span class="line"> listen = function( key, fn ){</span><br><span class="line"> if ( !clientList[ key ] ){</span><br><span class="line"> clientList[ key ] = [];</span><br><span class="line"> }</span><br><span class="line"> clientList[ key ].push( fn );</span><br><span class="line"> };</span><br><span class="line"> trigger = function(){</span><br><span class="line"> var key = Array.prototype.shift.call( arguments ),</span><br><span class="line"> fns = clientList[ key ];</span><br><span class="line"> if ( !fns || fns.length === 0 ){</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> for( var i = 0, fn; fn = fns[ i++ ]; ){</span><br><span class="line"> fn.apply( this, arguments );</span><br><span class="line">}</span><br><span class="line"> };</span><br><span class="line"> remove = function( key, fn ){</span><br><span class="line"> var fns = clientList[ key ];</span><br><span class="line"> if ( !fns ){</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> if ( !fn ){</span><br><span class="line"> fns &amp;&amp; ( fns.length = 0 );</span><br><span class="line"> }else{</span><br><span class="line"> for ( var l = fns.length - 1; l &gt;=0; l-- ){</span><br><span class="line"> var _fn = fns[ l ];</span><br><span class="line"> if ( _fn === fn ){</span><br><span class="line"> fns.splice( l, 1 );</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> };</span><br><span class="line"> return {</span><br><span class="line"> listen: listen,</span><br><span class="line"> trigger: trigger,</span><br><span class="line"> remove: remove</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">Event.listen( 'squareMeter88', function( price ){ // 小红订阅消息</span><br><span class="line"> console.log( '价格= ' + price ); // 输出：'价格=2000000'</span><br><span class="line">});</span><br><span class="line">Event.trigger( 'squareMeter88', 2000000 ); // 售楼处发布消息</span><br></pre></td></tr></tbody></table></figure><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的原理实现</title>
      <link href="/2022/04/09/vue-kuang-jia-jie-du-1.0/"/>
      <url>/2022/04/09/vue-kuang-jia-jie-du-1.0/</url>
      
        <content type="html"><![CDATA[<h1 id="权衡的艺术"><a href="#权衡的艺术" class="headerlink" title="权衡的艺术"></a>权衡的艺术</h1><h2 id="1-3-虚拟-dom"><a href="#1-3-虚拟-dom" class="headerlink" title="1.3 虚拟 dom"></a>1.3 虚拟 dom</h2><p>虚拟 dom 的耗时：创建 javascript 的计算量 + 创建真实 dom 的计算量 （数据变化量有关）</p><p>innerHtml 的耗时：拼接字符串的计算量 + innerHtml 的 DOM 计算量 （模板大小有关）</p><p><strong>原生 JavaScript &gt; 虚拟 dom &gt; innerHTML</strong></p><h2 id="1-4-运行和编译时"><a href="#1-4-运行和编译时" class="headerlink" title="1.4 运行和编译时"></a>1.4 运行和编译时</h2><h1 id="1-框架设计的核心要素"><a href="#1-框架设计的核心要素" class="headerlink" title="1 框架设计的核心要素"></a>1 框架设计的核心要素</h1><h2 id="2-1-缩减框架代码的体积"><a href="#2-1-缩减框架代码的体积" class="headerlink" title="2.1 缩减框架代码的体积"></a>2.1 缩减框架代码的体积</h2><p>例：vue3 源码的 warn 函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(_DEV_ &amp;&amp; ires) {</span><br><span class="line">warn(</span><br><span class="line">'faile to ....')</span><br><span class="line">};</span><br><span class="line">//vue.js使用rolllup.js对项目进项构建 这里的_DEV_实际上就是通过rollup.js的设置来预定义的 类似于webpack的DefinePlugin插件</span><br><span class="line">当用于开发环境时 _DEV_为true 即 if(true &amp;&amp; ires)</span><br><span class="line">而在构建生产环境中 _DEV_会被翻译为false 即 if(false &amp;&amp; _DEV_) 这样就永远不会执行</span><br><span class="line">**这种永远不会执行的代码称之为dead code 在构建最终项目的时候就会被移除 从而可以在开发环境中提供友好的提示 生产环境中减少代码的体积</span><br><span class="line">**vue3源码多出利用相似逻辑保证了开发环境的友好体验和生产环境的代码体积控制</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2Tree-Shaking"><a href="#2-2Tree-Shaking" class="headerlink" title="2.2Tree-Shaking"></a>2.2Tree-Shaking</h2><p>Tree-Shaking：消除永远不会使用到的代码 如上面说的<em>DEV</em></p><p><strong>能使用 Tree-Shaking 的必须是满足 ESM</strong></p><p>Tree-Shaking 会产生副作用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**加上标记来告诉系统可以安心清除副作用</span><br><span class="line">import {foo} from './utils';</span><br><span class="line">/*#_PURE_*/ foo();//   /*#_PURE_*/会告诉roupull.js可以放心进行Tree-Shaking</span><br><span class="line">vue3的源码多出使用/*#_PURE_*/来标记 都用于顶级调用</span><br><span class="line">export const isHTMLTag = /*#_PURE_*/ makeMap(HTML_TAGS);</span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-框架输出的产物"><a href="#2-3-框架输出的产物" class="headerlink" title="2.3 框架输出的产物"></a>2.3 框架输出的产物</h2><p>无论是 rollup.js 还是 webpack 在寻找资源文件的时候 如果 package.json 中存在 module 字段 都会优先使用 module 字段指向的资源代替 main 字段指向的资源</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">"main": 'index.js',</span><br><span class="line">"module": 'dist/vue.runtime.esm-bundler.js'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用处：当我们使用构建提供工具打包的 ESM 格式的资源时 不能直接把<em>DEV</em>转换成 true 或 false 需要使用(process.env.NODE* !== ‘production’)替换—DEV*常量</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if((process.env.NODE) !== 'production') {</span><br><span class="line">....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需求场景：当进行服务端渲染时 vue.js 的代码是在 Node.js 的环境中运行的 但是 Node.js 时 CommonJS 形式 所以可以更改 roullup.js 中的 format 配置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format: 'cjs'//指定模块形式</span><br></pre></td></tr></tbody></table></figure><h2 id="2-4-特定开关"><a href="#2-4-特定开关" class="headerlink" title="2.4 特定开关"></a>2.4 特定开关</h2><h2 id="2-5-错误处理"><a href="#2-5-错误处理" class="headerlink" title="2.5 错误处理"></a>2.5 错误处理</h2><h1 id="VUE-JS3-的设计思路"><a href="#VUE-JS3-的设计思路" class="headerlink" title="VUE.JS3 的设计思路"></a>VUE.JS3 的设计思路</h1><h2 id="3-2-渲染器"><a href="#3-2-渲染器" class="headerlink" title="3.2 渲染器"></a>3.2 渲染器</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function renderer(vnode, container) {</span><br><span class="line">  // 使用 vnode.tag 作为标签名称创建 DOM 元素</span><br><span class="line">const el = document.createElement(vnode.tag)</span><br><span class="line">  // 遍历 vnode.props 将属性、事件添加到 DOM 元素</span><br><span class="line">  for (const key in vnode.props) {</span><br><span class="line">    if (/^on/.test(key)) {</span><br><span class="line">      // 如果 key 以 on 开头，那么说明它是事件</span><br><span class="line">      el.addEventListener(</span><br><span class="line">        key.substr(2).toLowerCase(), // 事件名称 onClick ---&gt; click</span><br><span class="line">        vnode.props[key] // 事件处理函数</span><br><span class="line">      )</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 处理 children</span><br><span class="line">  if (typeof vnode.children === 'string') {</span><br><span class="line">    // 如果 children 是字符串，说明是元素的文本子节点</span><br><span class="line">    el.appendChild(document.createTextNode(vnode.children))</span><br><span class="line">  } else if (Array.isArray(vnode.children)) {</span><br><span class="line">    // 递归地调用 renderer 函数渲染子节点，使用当前元素 el 作为挂载点</span><br><span class="line">    vnode.children.forEach(child =&gt; renderer(child, el))</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 将元素添加到挂载点下</span><br><span class="line">  container.appendChild(el)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const vnode = {</span><br><span class="line">  tag: 'div',</span><br><span class="line">  props: {</span><br><span class="line">    onClick: () =&gt; alert('hello')</span><br><span class="line">  },</span><br><span class="line">  children: 'click me'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">renderer(vnode, document.body)；</span><br></pre></td></tr></tbody></table></figure><h1 id="响应系统的作用和实现"><a href="#响应系统的作用和实现" class="headerlink" title="响应系统的作用和实现"></a>响应系统的作用和实现</h1><h2 id="4-1-响应式数据与副作用"><a href="#4-1-响应式数据与副作用" class="headerlink" title="4.1 响应式数据与副作用"></a>4.1 响应式数据与副作用</h2><p>副作用函数：会产生副作用的函数 即该函数的执行会直接或间接地影响到其他函数或变量的执行</p><h2 id="4-2-响应式数据的基本实现"><a href="#4-2-响应式数据的基本实现" class="headerlink" title="4.2 响应式数据的基本实现"></a>4.2 响应式数据的基本实现</h2><ul><li><p>通过拦截一个对象的读取和设置操作</p><ul><li><p>```<br>//当读取obj.text的时候 就将副作用函数储存到一个桶里面<br>//当设置obj.text的时候 就将副作用从桶里面取出执行便可<br>/ 存储副作用函数的桶<br>const bucket = new Set()</p><p>// 原始数据<br>const data = { text: ‘hello world’ }<br>// 对原始数据的代理<br>const obj = new Proxy(data, {<br>  // 拦截读取操作<br>  get(target, key) {</p><pre><code>// 将副作用函数 effect 添加到存储副作用函数的桶中bucket.add(effect)// 返回属性值return target[key]</code></pre><p>  },<br>  // 拦截设置操作<br>  set(target, key, newVal) {</p><pre><code>// 设置属性值target[key] = newVal// 把副作用函数从桶里取出并执行bucket.forEach(fn =&gt; fn())</code></pre><p>  }<br>})</p><p>function effect() {<br>  document.body.innerText = obj.text<br>}<br>effect()</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    **缺陷**：如果副作用改名或者是匿名函数 则该响应系统失效</span><br><span class="line"></span><br><span class="line">- 设计一个完善的响应系统</span><br><span class="line"></span><br><span class="line">  - 提供一个用来注册副作用函数的机制来解决上面的问题</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    //用一个变量春促当前激活的effect函数</span><br><span class="line">    let activeEffect;</span><br><span class="line">    function effect(fn) {</span><br><span class="line">    //当调用effect注册副作用函数是 将副作用函数赋值给activeEffect</span><br><span class="line">    activeEffect = fn;</span><br><span class="line">    fn(0);//执行副作用函数</span><br><span class="line">    };</span><br><span class="line">    effect(() =&gt; {</span><br><span class="line">    console.log('effect do');</span><br><span class="line">    documrnt.body.innerText = obj.text;//进行读取操作</span><br><span class="line">    })</span><br><span class="line">    const obj = new Proxy(data, {</span><br><span class="line">    get(target, key) {</span><br><span class="line">    //将当前被调用的副作用函数加入到桶中</span><br><span class="line">    if(activeEffect) {</span><br><span class="line">    bucket.add(activeEffect)//新增</span><br><span class="line">    }</span><br><span class="line">    return target[key];</span><br><span class="line">    },</span><br><span class="line">    set(target, key, newVal) {</span><br><span class="line">    target[key] = newVal;</span><br><span class="line">    bucket.forEach( fn =&gt; fn());</span><br><span class="line">    return true;</span><br><span class="line">    }</span><br><span class="line">    })</span><br></pre></td></tr></tbody></table></figure><p><strong>完成了可以添加匿名或任意名字的副作用函数</strong></p><p><strong>缺陷：无法监听指定属性，即如果进行类似于新增不存在的属性 该副作用函数依然会被执行（正常不应该被执行）</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">测试：新增不存在的obj.text2属性</span><br><span class="line">effect(() =&gt; {</span><br><span class="line">obj.body.innerText = obj.text</span><br><span class="line"></span><br><span class="line">console.log('effect done')</span><br><span class="line">});</span><br><span class="line">setTimeout(() =&gt; {</span><br><span class="line">obj.text2 = 'none exists';//新增一个不存在的属性</span><br><span class="line">})</span><br><span class="line">//运行结果：effect done 执行两次</span><br><span class="line">//分析：每次修改对象obj都会将effect存入桶中 导致读取时执行不该执行的副作用</span><br><span class="line">//没有在副作用函数与被操作的目标之间建立明确的联系</span><br><span class="line">**解决方法：在副作用函数与被操作的字段之间建立联系 可以使用weakMap</span><br><span class="line">//储存副作用的桶</span><br><span class="line">const bucket = new WeakMap();</span><br><span class="line">//修改拦截器</span><br><span class="line">const obj = new Proxy(data, {</span><br><span class="line">//拦截读取行为</span><br><span class="line">get(target, key) {</span><br><span class="line">//没有activeEffect 直接return</span><br><span class="line">if(!activeEffect) return;</span><br><span class="line">//根据traget从桶中取得desMap， ：key --&gt; effects</span><br><span class="line">let desMap = bucket.get(target);</span><br><span class="line">//如果不存在desMap 那么就创建一个WeakMap</span><br><span class="line">if(!desMap) {</span><br><span class="line">bucket.set(target, (desMap = new Map()))</span><br><span class="line">}</span><br><span class="line">//根据key自从desMap中读取deps deps时一个set类型</span><br><span class="line">//里面储存着所有与当前key有相关的副作用函数:effects</span><br><span class="line">let deps = desMap.get(key);</span><br><span class="line">if(!deps) {</span><br><span class="line">desMap.set(key, (deps = new Set()));</span><br><span class="line">}</span><br><span class="line">deps.add(activeEffect);//将激活的副作用函数存储到桶里</span><br><span class="line">return target[key];//返回属性值</span><br><span class="line">};</span><br><span class="line">//拦截设置操作</span><br><span class="line">set(target, key, newVal) {</span><br><span class="line">//设置属性值</span><br><span class="line">target[key] = newVal;</span><br><span class="line">//根据target从decket中取出desMap</span><br><span class="line">let desMap = ducket.get(target);</span><br><span class="line">if(!desMap) return;</span><br><span class="line">//根据key取得所有的副作用函数并依次执行</span><br><span class="line">let deps = desMap.get(key);</span><br><span class="line">deps &amp;&amp; deps.forEach( fn =&gt; fn());//判空再执行</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><img src="https://i.bmp.ovh/imgs/2022/04/01/5648b7ab427b5fd9.jpg" style="zoom: 50%;"></li><li><p><strong>为什么使用 WeakMap 不使用 Map</strong></p><ul><li>weakMap 是弱引用 不会影响垃圾回收</li><li>只有当 key 所引用的对象存在时（没有被回收时）才有价值的信息都优先使用 weakMap 来存储</li></ul></li><li><p>**存在问题：代码耦合度高 **</p></li><li><p><strong>解决方法： 抽离封装</strong></p></li><li><pre><code>function track(target, key) {  let depsMap = bucket.get(target)  if (!depsMap) {    bucket.set(target, (depsMap = new Map()))  }  let deps = depsMap.get(key)  if (!deps) {    depsMap.set(key, (deps = new Set()))  }  deps.add(activeEffect)}function trigger(target, key) {  const depsMap = bucket.get(target)  if (!depsMap) return  const effects = depsMap.get(key)  effects &amp;&amp; effects.forEach(fn =&gt; fn())}// 对原始数据的代理const obj = new Proxy(data, {  // 拦截读取操作  get(target, key) {    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中    track(target, key)    // 返回属性值    return target[key]  },  // 拦截设置操作  set(target, key, newVal) {    // 设置属性值    target[key] = newVal    // 把副作用函数从桶里取出并执行    trigger(target, key)  }})<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 4.4 切换分支与 cleanup</span><br><span class="line"></span><br><span class="line">分支切换可能会产生遗留的副作用函数</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>effect(function effectFn() {    document.body.innerText = obj.ok? obj.text : 'not'})//此时依赖函数被obj.ok和obj.text同时依赖 当obj.ok为false时 无论obj.text怎么变化 都是'not' 所以不应该触发副作用函数//解决方法：每次副作用函数执行时 都把它从所有与之关联的依赖集合中删除//当副作用执行完毕后 会建立联系 但再新的联系中不会包含遗留的副作用函数<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**副作用依赖函数集合**</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>//用一个全局变量储存被注册的副作用函数let activeEffect;function effect(fn) {//当effectFn被执行时 将其设置为当前的激活的副作用函数    const effectFn = () =&gt; {        activeEffect = effectFn;        fn();    }    //effectEffect.deps 用来储存所有与该副作用函数想关联的依赖集合    effectEn.dep = [];    //执行副作用函数    effectFn();}<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **Track 函数**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  function track(target, key) {</span><br><span class="line">  if(!activeEffect) return;</span><br><span class="line">  let depsMap = bucket.get(key);</span><br><span class="line">  if(!depsMap) {</span><br><span class="line">  bucket.set(target, (desMap =&gt; new Map()));</span><br><span class="line">  }</span><br><span class="line">  let deps = depsMap.get(key);</span><br><span class="line">  if(!deps) {</span><br><span class="line">  depsMap.set(key, ( deps =&gt; new Set()))</span><br><span class="line">  };</span><br><span class="line">  //把当前激活的副作用函数添加到依赖集合deps中</span><br><span class="line">  deps.add(activeEffect);</span><br><span class="line">  //deps就是一个与当前副作用函数存在联系的集合</span><br><span class="line">  //将其添加到activeEffects.deps中</span><br><span class="line">  activeEffect.deps.push(deps);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>- 有了这个联系后 再每次执行副作用函数时 根据 effectFn.deps 获取所有的相关联的依赖集合 从而将副作用函数从依赖集合中清除- ```  let activeEffect;  function effect(fn) {      const effectFn = () =&gt; {          //调用cleanUp函数完成清除依赖          cleanup(effectFn);          activeEffect = effectFn;          fn();      }  }  function cleanup(effectFn) {  //遍历effectFn.deps数组    for (let i = 0; i &lt; effectFn.deps.length; i++) {    //deps时依赖集合      const deps = effectFn.deps[i]      //将effectFn从依赖集合中删除      deps.delete(effectFn)    }    //重置effectFn.deps数组    effectFn.deps.length = 0  }  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    -</span><br><span class="line"></span><br><span class="line"># 非原始值的响应式方案</span><br><span class="line"></span><br><span class="line">## 5.1Proxy 以及 Reflect</span><br><span class="line"></span><br><span class="line">**proxy 只能代理对象 不能代理其他类型的数据**</span><br><span class="line"></span><br><span class="line">### 5.1.2 Reflect</span><br><span class="line"></span><br><span class="line">Reflect 可以接受第三个参数 即 receiver 相当于函数调用过程中的 this</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>const obj = {foo: 1};Reflect.get(obj, foo, {foo: 2});//输出2</code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学Vue第一天</title>
      <link href="/2022/04/09/chong-xue-vue/"/>
      <url>/2022/04/09/chong-xue-vue/</url>
      
        <content type="html"><![CDATA[<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span :title="toTitleDate(date)"&gt;</span><br><span class="line">  {{ formatDate(date) }}//formatData不应该时更改数据或者触发异步操作</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>每次组件更新时 都会调用绑定表达式内部调用的函数 因此他们不应该产生任何副作用 例如更改数据或触发异步操作</strong></p><h4 id="受限的全局访问"><a href="#受限的全局访问" class="headerlink" title="受限的全局访问"></a>受限的全局访问</h4><p>魔棒表达式是沙盒化的 只能访问全局的受限列表（该列表公布了常用的内置全局变量 如 Math Date）未明确包含在列表中的全局变量（用户附加属性）</p><p>将无法在模板表达式中访问 可以将所有 Vue 表达式添加到<code>app.config.globalProperties</code>来显式定义其他全局变量（window）</p><h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:[attributeName]="url"&gt; ... &lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- shorthand --&gt;</span><br><span class="line">&lt;a :[attributeName]="url"&gt; ... &lt;/a&gt;</span><br><span class="line">//如果组件实例具有数据属性 则此绑定等价于 attributeName attributeName 'href' v-bind:href</span><br><span class="line">//避免使用大写字符命名键 因为浏览器会强制将属性名称转化为小写 someAttr -&gt; someattr</span><br></pre></td></tr></tbody></table></figure><h4 id="DOM-更新时间"><a href="#DOM-更新时间" class="headerlink" title="DOM 更新时间"></a>DOM 更新时间</h4><p>dom 更新不是同步更新的 vue 会缓冲它们知道更新周期的下一个“next tick” 以确保不管进行了多少状态更改 每个组件都只需要更新依次</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//要在状态更改后等待DOM更新完成 可以使用nextTick全局API</span><br><span class="line">Import {nextTick} form 'vue';</span><br><span class="line">function increment() {</span><br><span class="line">  state.count++</span><br><span class="line">  nextTick(() =&gt; {</span><br><span class="line">    // access updated DOM</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 vue 中默认深度响应的 即在嵌套的对象或数组中也可以检测到更改 也可以显式地创建浅反应对象 仅在跟级别跟踪反应性 但是通常仅在高级用例中需要（后面学到补充）</p><h4 id="反应式代理与原始"><a href="#反应式代理与原始" class="headerlink" title="反应式代理与原始"></a>反应式代理与原始</h4><p><strong>reactive（）是原对象的代理 而不是原对象的返回值</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const raw = {}</span><br><span class="line">const proxy = reactive(raw)//返回的是代理Proxy对象</span><br><span class="line"></span><br><span class="line">// proxy is NOT equal to the original.</span><br><span class="line">console.log(proxy === raw) // false</span><br></pre></td></tr></tbody></table></figure><p>如果只是代理反应 那么改变原始对象不会触发更新 所以 Vue 的响应式系统是使用状态的代理版本 为了确保对代理的始终统一访问 使用 reactive 同一个对象 然后调用 reacitive 一个现有的代理也返回同一个代理</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// calling reactive() on the same object returns the same proxy</span><br><span class="line">console.log(reactive(raw) === proxy) // true</span><br><span class="line"></span><br><span class="line">// calling reactive() on a proxy returns itself</span><br><span class="line">console.log(reactive(proxy) === proxy) // true</span><br></pre></td></tr></tbody></table></figure><p><strong>由于 Vue 的响应式适用于属性访问 因此我们必须保持响应式对象的相同引用 这意味着我们不能轻易地替换反应式对象 以为与第一个引用的反应性连接丢失了</strong></p><p>这也意味着当我们将反应性对象的属性分配或解构为局部变量时 或者将属性传递给函数时 将失去响应性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const state = reactive({ count: 0 })</span><br><span class="line"></span><br><span class="line">// n is a local variable that is disconnected</span><br><span class="line">// from state.count.</span><br><span class="line">let n = state.count</span><br><span class="line">// does not affect original state</span><br><span class="line">n++</span><br><span class="line"></span><br><span class="line">// count is also disconnected from state.count.</span><br><span class="line">let { count } = state</span><br><span class="line">// does not affect original state</span><br><span class="line">count++</span><br><span class="line"></span><br><span class="line">// the function receives a plain number and</span><br><span class="line">// won't be able to track changes to state.count</span><br><span class="line">callSomeFunction(state.count)</span><br></pre></td></tr></tbody></table></figure><h4 id="ref（）"><a href="#ref（）" class="headerlink" title="ref（）"></a>ref（）</h4><p>当持有对象类型时 ref 会自动将其.value 与 reactive（） 包含对象值的 ref 可以反应性替换整个对象</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const objectRef = ref({ count: 0 })</span><br><span class="line"></span><br><span class="line">// this works reactively</span><br><span class="line">objectRef.value = { count: 1 }</span><br></pre></td></tr></tbody></table></figure><p>Refs 也可以传递给函数或从普通对象中解构，而不会失去反应性：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj = {</span><br><span class="line">  foo: ref(1),</span><br><span class="line">  bar: ref(2)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// the function receives a ref</span><br><span class="line">// it needs to access the value via .value but it</span><br><span class="line">// will retain the reactivity connection</span><br><span class="line">callSomeFunction(obj.foo)</span><br><span class="line"></span><br><span class="line">// still reactive</span><br><span class="line">const { foo, bar } = obj</span><br></pre></td></tr></tbody></table></figure><p><strong>换句话说，<code>ref()</code>允许我们创建对任何值的“引用”并在不失去反应性的情况下传递它。此功能非常重要，因为它在将逻辑提取到<a href="https://vuejs.org/guide/reusability/composables.html">Composable Functions</a>时经常使用。</strong></p><p>当 ref 作为响应式对象的属性被访问或改变时 他会自动被解包 因此它的行为类似于普通属性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const count = ref(0)</span><br><span class="line">const state = reactive({</span><br><span class="line">  count</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">console.log(state.count) // 0</span><br><span class="line"></span><br><span class="line">state.count = 1</span><br><span class="line">console.log(count.value) // 1</span><br></pre></td></tr></tbody></table></figure><p>如果将新的 ref 分配给现有的 ref 属性 他将替代旧的 ref</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line">const state = reactive({</span><br><span class="line">  count</span><br><span class="line">})</span><br><span class="line">const otherCount = ref(2)</span><br><span class="line"></span><br><span class="line">state.count = otherCount</span><br><span class="line">console.log(count.value) // 0</span><br><span class="line">console.log(state.count) // 2</span><br><span class="line"></span><br><span class="line">state.count = 3</span><br><span class="line">console.log(count.value) // 0</span><br><span class="line">console.log(otherCount.value)//3</span><br></pre></td></tr></tbody></table></figure><p>*<em>Ref 展开仅在嵌套在深层反应对象时发生 当它作为浅反应对象的属性被访问时 它不适用</em></p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>computed（）函数需要传递一个 getter 函数 返回值是一个计算的 ref 计算属性会自动跟踪其反应性依赖关系</p><p>getters 没有副作用 ：计算属性只执行纯计算并且没有副作用 所以不要发出异步请求或者在计算的 getter 上改变 DOM</p><h2 id="类和样式绑定"><a href="#类和样式绑定" class="headerlink" title="类和样式绑定"></a>类和样式绑定</h2><p>可以绑定到返回对象的计算属性 这是一种常见且强大的模式</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const isActive = ref(true)</span><br><span class="line">const error = ref(null)</span><br><span class="line"></span><br><span class="line">const classObject = computed(() =&gt; ({</span><br><span class="line">  active: isActive.value &amp;&amp; !error.value,</span><br><span class="line">  'text-danger': error.value &amp;&amp; error.value.type === 'fatal'</span><br><span class="line">}))</span><br><span class="line">&lt;div :class="classObject"&gt;&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果想要 有条件切换列表中的值 可以用三元表达式实现</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :class="[isActive ? activeClass : '', errorClass]"&gt;&lt;/div&gt;</span><br><span class="line">//这将始终适用errorClass 但是activeClass仅在为真的时候才适用</span><br><span class="line">//如果有多个条件类 可以使用对象语法</span><br><span class="line">&lt;div :class="[{ active: isActive }, errorClass]"&gt;&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p>当在具有单个根元素的组件上使用该属性时 这些类将添加到组件的根元素中 并与该组件上已有的现有类合并</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- child component template --&gt;</span><br><span class="line">&lt;p class="foo bar"&gt;Hi!&lt;/p&gt;</span><br><span class="line">!-- when using the component --&gt;</span><br><span class="line">&lt;my-component class="baz boo"&gt;&lt;/my-component&gt;</span><br><span class="line">呈线的html将为</span><br><span class="line">&lt;p class="foo bar baz boo"&gt;Hi&lt;/p&gt;</span><br><span class="line">类绑定也是这样</span><br><span class="line">如果组件有多个根元素 则需要定义哪些元素将接收此类 可以使用$attrs组件属性来执行此操作</span><br><span class="line">&lt;!-- my-component template using $attrs --&gt;</span><br><span class="line">&lt;p :class="$attrs.class"&gt;Hi!&lt;/p&gt;</span><br><span class="line">&lt;span&gt;This is a child component&lt;/span&gt;</span><br><span class="line">&lt;my-component class="baz"&gt;&lt;/my-component&gt;</span><br><span class="line">将渲染为</span><br><span class="line">&lt;p class="baz"&gt;Hi!&lt;/p&gt;</span><br><span class="line">&lt;span&gt;This is a child component&lt;/span&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><p>v-if 是一个指令 必须添加到单个元素上 可以将 v-if 在一个 template 上使用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if="ok"&gt;&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>v-show 将始终被渲染在 DOM 中 仅切换 display 元素的 css 属性 不支持使用在 template</p><p>经常切换使用 v-show 不经常使用则用 v-show</p><p><strong>v-for 遍历对象时 顺序基于枚举顺序 Objects.keys(), 这不能保证在 JavaScript 引擎实现中保持一致</strong>、</p><p>可以在 template 中使用 v-for 来渲染一个包含多个元素的块</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;template v-for="item in items"&gt;</span><br><span class="line">    &lt;li&gt;{{ item.msg }}&lt;/li&gt;</span><br><span class="line">    &lt;li class="divider" role="presentation"&gt;&lt;/li&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>为什么 v-for 要提供 key</strong></p><ul><li>当 vue 更新使用渲染的元素列表时 v-for 默认使用就地补丁策略（如果数据项的顺序发生了变化 而不是移动 DOM 元素来匹配项的顺序 VUE 将就地补丁修补每个元素并确保他们反映应该在该特定索引处呈现的内容）但这种模式仅适用于列表的渲染输出不依赖子组件或者临时 DOM 状态（表单输入值）的情况</li><li>为了给 vue 一个提示以便它可以跟踪每个节点的身份 从而重用或重新排序现有元素 需要提供一个唯一的 key</li></ul><h4 id="数组变化侦测"><a href="#数组变化侦测" class="headerlink" title="数组变化侦测"></a>数组变化侦测</h4><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><p>在 vue 中 将一个数组替换为另一个数组包含重叠对象的数组是一种高效的操作 如使用新数组替换旧数组:concact() slice()</p><p>当我们需要显示一个经过过滤或排序的数组版本 而不需要实际改变或重置原始数据 可以创建一个返回过滤或排序数组的计算属性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const numbers = ref([1, 2, 3, 4, 5])</span><br><span class="line"></span><br><span class="line">const evenNumbers = computed(() =&gt; {</span><br><span class="line">  return numbers.value.filter((n) =&gt; n % 2 === 0)</span><br><span class="line">})</span><br><span class="line">&lt;li v-for="n in evenNumbers"&gt;{{ n }}&lt;/li&gt;</span><br></pre></td></tr></tbody></table></figure><p>在计算属性不行使 比如嵌套的 v-for 循环中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const sets = ref([</span><br><span class="line">  [1, 2, 3, 4, 5],</span><br><span class="line">  [6, 7, 8, 9, 10]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">function even(numbers) {</span><br><span class="line">  return numbers.filter((number) =&gt; number % 2 === 0)</span><br><span class="line">}</span><br><span class="line">&lt;ul v-for="numbers in sets"&gt;</span><br><span class="line">  &lt;li v-for="n in even(numbers)"&gt;{{ n }}&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">输出：2 4 6 8 10</span><br></pre></td></tr></tbody></table></figure><p><strong>在计算属性中使用 reverse 和 sort 要小心 因为他们会改变原始数组 在计算属性的 getter 中应该避免这种情况 在调用前先创建原始数据的副本</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- return numbers.reverse()</span><br><span class="line">+ return [...numbers].reverse()</span><br></pre></td></tr></tbody></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>当我们需要访问内联处理程序中的原始 DOM 事件 可以用特殊变量将其传递给方法$event 或者使用内联箭头函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click="warn('Form cannot be submitted yet.', $event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- using inline arrow function --&gt;</span><br><span class="line">&lt;button @click="(event) =&gt; warn('Form cannot be submitted yet.', event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="表单上输入绑定"><a href="#表单上输入绑定" class="headerlink" title="表单上输入绑定"></a>表单上输入绑定</h4><ul><li><code>&lt;input&gt;</code>文本类型和<code>&lt;textarea&gt;</code>元素使用<code>value</code>属性和<code>input</code>事件；</li><li><code>&lt;input type="checkbox"&gt;``&lt;input type="radio"&gt;</code>使用<code>checked</code>和事件<code>change</code>；</li><li><code>&lt;select&gt;</code>用作<code>value</code>和<code>change</code>事件。</li></ul><p><strong>v-model<code>将忽略在任何表单元素上找到的初始或属性</code>value<code>。它将始终将当前绑定的 JavaScript 状态视为事实来源。您应该使用反应性 API在 JavaScript 端声明初始值。</code>checked``selected</strong></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue TS 框架 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
