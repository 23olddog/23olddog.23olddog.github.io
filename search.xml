<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用Sentry做监控和性能分析</title>
      <link href="/2022/11/04/shi-yong-sentry-jian-kong/"/>
      <url>/2022/11/04/shi-yong-sentry-jian-kong/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-sentry-做异常监控"><a href="#使用-sentry-做异常监控" class="headerlink" title="使用 sentry 做异常监控"></a>使用 sentry 做异常监控</h2><h3 id="sentry-异常监控原理"><a href="#sentry-异常监控原理" class="headerlink" title="sentry 异常监控原理"></a>sentry 异常监控原理</h3><h4 id="异常详情获取"><a href="#异常详情获取" class="headerlink" title="异常详情获取"></a>异常详情获取</h4><p><strong>sentry</strong>通过覆写 <code>window.onerror</code>和 <code>window.unhandlerejection</code>这两个<code>api</code>来实现自动捕获异常</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//覆写window.onerror</span></span><br><span class="line">oldErrorHandler = <span class="variable language_">window</span>.<span class="property">onerror</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">msg, url, line, colum, error</span>) {</span><br><span class="line">  <span class="comment">//收集异常信息并上报</span></span><br><span class="line">  <span class="title function_">triggerHandlers</span>(<span class="string">"error"</span>, {</span><br><span class="line">    column,</span><br><span class="line">    error,</span><br><span class="line">    line,</span><br><span class="line">    msg,</span><br><span class="line">    url,</span><br><span class="line">  });</span><br><span class="line">  <span class="keyword">if</span> (oldErrorHandler) {</span><br><span class="line">    <span class="keyword">return</span> oldErrorHandler.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//覆写window.unhandledrejection</span></span><br><span class="line">oldOnUnhandleRejectionHandler = <span class="variable language_">window</span>.<span class="property">onunhandledrejection</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onunhandledrejection</span> = <span class="keyword">function</span> (<span class="params">e</span>) {</span><br><span class="line">  <span class="comment">//收集异常信息并上报</span></span><br><span class="line">  <span class="title function_">triggerHandler</span>(<span class="string">"unhandledrejection"</span>, e);</span><br><span class="line">  <span class="keyword">if</span> (oldOnUnhandledRejectionHandler) {</span><br><span class="line">    <span class="keyword">return</span> oldUnhandleRejectionHandler.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>为了在捕获到异常时能获取更详尽的信息 被捕获的异常需要带上一些标记（<code>event name | event target</code>等）</p><p>这里我们先看下一个使用使用频繁的函数 <code>wrap</code> <code>sentry</code>就是通过它对<code>callback</code>进行<code>trycatch</code>的</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://github1s.com/getsentry/sentry-javascript/blob/master/packages/browser/src/helpers.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">wrap</span>(<span class="params"></span></span><br><span class="line"><span class="params">fn: WrappedFunction,</span></span><br><span class="line"><span class="params">     options: {</span></span><br><span class="line"><span class="params">    mechainism?: Mechanism;</span></span><br><span class="line"><span class="params">} = {},</span></span><br><span class="line"><span class="params">     before?: WrappedFunction</span></span><br><span class="line"><span class="params"></span>) {</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) {</span><br><span class="line">        <span class="keyword">return</span> fn; <span class="comment">//如果传入的不是函数 则直接返回</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//对传入的callback进行trycatch处理</span></span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        <span class="comment">//判断callback是否之前就被处理过了 如果已经处理过就直接返回结束流程</span></span><br><span class="line">        <span class="keyword">const</span> wrapper = fn.<span class="property">_sentry_wrapped_</span>;</span><br><span class="line">        <span class="keyword">if</span>(wrapper) {</span><br><span class="line">            <span class="keyword">return</span> wrapper</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//如果我们不想对该函数进行二次包装</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">getOriginalFunction</span>(fn)) {</span><br><span class="line">            <span class="keyword">return</span> fn;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span>(e) {</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//注意 这里不能用箭头函数 因为需要保存this的上下文环境</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">sentryWrapped</span>: <span class="title class_">WrappedFunction</span> = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: unknow</span>): <span class="built_in">void</span> {</span><br><span class="line">        <span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">        <span class="keyword">try</span> { <span class="comment">//判断是否有before预处理函数</span></span><br><span class="line">            <span class="keyword">if</span>(before &amp;&amp; <span class="keyword">typeof</span> before === <span class="string">'function'</span>) {</span><br><span class="line">                before.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">const</span> wrappedArguments = args.<span class="title function_">map</span>(<span class="function"><span class="params">arg</span> =&gt;</span> <span class="title function_">wrap</span>(arg, options))</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>标记<code>xhr</code>接口回调</li></ul><p>为了标记<code>xhr</code>接口回调 需要先对<code>XMLHttpRequest.prototype.send</code>方法劫持覆写 等到实例是用了被覆写的方法后 就会对<code>xhr</code>对象的 <code>onload | onerror | onprogress | onreadystateChange</code>等进行覆写 使用 <code>try..catch..</code>传入捕获异常的<code>callback</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//先对send进行覆写</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">_options</span>.<span class="property">XMLHttpRequest</span> &amp;&amp; <span class="string">'XMLHttpRequest'</span> <span class="keyword">in</span> <span class="variable constant_">WINDOW</span>) {</span><br><span class="line">    <span class="title function_">fill</span>(<span class="title class_">XMLHttpRequest</span>.<span class="property">propotype</span>, <span class="string">'send'</span>, _wraqXHR);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用到了这个实例的send 就会对后面的onlaod onerror onprogress onreadystateChange进行覆写</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_warpXHR</span>(<span class="params">originalSend: () =&gt; <span class="built_in">void</span></span>): <span class="function">() =&gt;</span> <span class="built_in">void</span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: XMLHttpRequest, ...args: <span class="built_in">any</span>[]</span>):<span class="built_in">void</span> {</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="variable language_">this</span>;<span class="comment">//保存this</span></span><br><span class="line">        <span class="keyword">const</span> <span class="attr">xmlHttpRequestProps</span>: <span class="title class_">XMLHttpRequestProp</span>[] = [<span class="string">'onload'</span>, <span class="string">'onerror'</span>, <span class="string">'onprogress'</span>, <span class="string">'onreadystatechange'</span>];</span><br><span class="line">    <span class="comment">//分别对 onload onerror onprogress onreadystatechange四个事件进行覆写</span></span><br><span class="line">    xmlHttpRequestProps.<span class="title function_">forEach</span>(<span class="function"><span class="params">prop</span> =&gt;</span> {</span><br><span class="line">        <span class="keyword">if</span>(prop <span class="keyword">in</span> xhr &amp;&amp; typeop xhr == <span class="string">'function'</span>) {</span><br><span class="line">            <span class="title function_">fill</span>(xhr, prop, <span class="keyword">function</span>(<span class="params">original: WrappedFunction</span>): <span class="function">() =&gt;</span> <span class="built_in">any</span> {</span><br><span class="line">                <span class="keyword">const</span> warpOptions = {</span><br><span class="line">                    <span class="attr">mechanism</span>: {</span><br><span class="line">                        <span class="attr">data</span>: {</span><br><span class="line">                            <span class="attr">function</span>: prop,</span><br><span class="line">                            <span class="attr">handler</span>: <span class="title function_">getFunctionName</span>(original)</span><br><span class="line">                        },</span><br><span class="line">                        <span class="attr">handled</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">'instrument'</span></span><br><span class="line">                    }</span><br><span class="line">                };</span><br><span class="line">            <span class="comment">//如果这个方法在之前已经被trycatch调用过了 则直接获取原始函数的名称</span></span><br><span class="line">             <span class="keyword">const</span> originalFunction = <span class="title function_">getOriginalFunction</span>(original);</span><br><span class="line">                <span class="keyword">if</span>(originalFunction) {</span><br><span class="line">                    wrapOptions.<span class="property">mechanism</span>.<span class="property">data</span>.<span class="property">handler</span> = <span class="title function_">getFucntionName</span>(originalFunction)</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">wrap</span>(original, wrapOptions)</span><br><span class="line"></span><br><span class="line">            })</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">return</span> oriinalSend.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>实现 <code>setTimeout | setInterval | requestAnimationFrame</code></li></ul><p>通过覆写这些原生方法 在调用时会触发 <code>try...catch</code>的 <code>callback</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现setTimeout的覆写</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">_options</span>.<span class="property">setTimeout</span>) {</span><br><span class="line">    <span class="title function_">fill</span>(<span class="variable constant_">WINDOW</span>, <span class="string">'setTimeout'</span>, _warpTimeFunction)</span><br><span class="line">};</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_wrapTimeFunction</span>(<span class="params">original: () =&gt; <span class="built_in">void</span></span>): <span class="function">() =&gt;</span> <span class="built_in">number</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>: []</span>): <span class="built_in">number</span> {</span><br><span class="line">        <span class="keyword">const</span> originalCallback = args[<span class="number">0</span>]; <span class="comment">//读取callback</span></span><br><span class="line">        <span class="comment">//wrap会对传入的函数进行trrycatch的处理</span></span><br><span class="line">        args[<span class="number">0</span>] = <span class="title function_">wrap</span>(originalCallback, {</span><br><span class="line">            <span class="attr">mechanism</span>: {</span><br><span class="line">                <span class="attr">data</span>: {<span class="attr">function</span>: <span class="title function_">getFunctionName</span>(original)},</span><br><span class="line">                <span class="attr">handled</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="string">'increment'</span></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//实现setInterval的覆写  setInterval是和setTimeout一样的逻辑</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_options</span>.<span class="property">setInterval</span>) {</span><br><span class="line">      <span class="title function_">fill</span>(<span class="variable constant_">WINDOW</span>, <span class="string">'setInterval'</span>, _wrapTimeFunction);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//实现requestAnimationFrame的覆写</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_options</span>.<span class="property">requestAnimationFrame</span>) {</span><br><span class="line">      <span class="title function_">fill</span>(<span class="variable constant_">WINDOW</span>, <span class="string">'requestAnimationFrame'</span>, _wrapRAF);</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_wrapRAF</span>(<span class="params">original: <span class="built_in">any</span></span>): <span class="function">(<span class="params">callback: () =&gt; <span class="built_in">void</span></span>) =&gt;</span> <span class="built_in">any</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, callback: () =&gt; <span class="built_in">void</span></span>): <span class="function">() =&gt;</span> <span class="built_in">void</span> {</span><br><span class="line">    <span class="keyword">return</span> original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [</span><br><span class="line">      <span class="title function_">wrap</span>(callback, {</span><br><span class="line">        <span class="attr">mechanism</span>: {</span><br><span class="line">          <span class="attr">data</span>: {</span><br><span class="line">            <span class="attr">function</span>: <span class="string">'requestAnimationFrame'</span>,</span><br><span class="line">            <span class="attr">handler</span>: <span class="title function_">getFunctionName</span>(original),</span><br><span class="line">          },</span><br><span class="line">          <span class="attr">handled</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">'instrument'</span>,</span><br><span class="line">        },</span><br><span class="line">      }),</span><br><span class="line">    ]);</span><br><span class="line">  };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>标记<code>dom</code>事件</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_warpEventTarget</span>(<span class="params">target: <span class="built_in">string</span></span>): <span class="built_in">void</span> {</span><br><span class="line">    <span class="keyword">const</span> globalObject = <span class="variable constant_">WINDOW</span> <span class="keyword">as</span> {[<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>}<span class="string">'</span></span><br><span class="line"><span class="string">    const proto = globalObject[target] &amp;&amp; globalObject[target].prototype;</span></span><br><span class="line"><span class="string">    if(!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('</span>addEventListener<span class="string">')) {</span></span><br><span class="line"><span class="string">        //如果是null或者是createObject(null)或者是没有addEventListener的属性 则直接返回</span></span><br><span class="line"><span class="string">        return;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    //对adEventListener进行覆写</span></span><br><span class="line"><span class="string">    fill(proto, '</span>addEventListener<span class="string">', function(original) {</span></span><br><span class="line"><span class="string">        try {</span></span><br><span class="line"><span class="string">            if(typeof fn.handleEvent === '</span><span class="keyword">function</span><span class="string">') {</span></span><br><span class="line"><span class="string">                //使用wrap处理handle</span></span><br><span class="line"><span class="string">                fn.handleEvent = wrap$1(fn.handleEvent.bind(fn), {</span></span><br><span class="line"><span class="string">                        mechanism: {</span></span><br><span class="line"><span class="string">                            data: {</span></span><br><span class="line"><span class="string">                                function: '</span>handleEvent<span class="string">',</span></span><br><span class="line"><span class="string">                                handler: getFunctionName(fn),</span></span><br><span class="line"><span class="string">                                target: target,</span></span><br><span class="line"><span class="string">                            },</span></span><br><span class="line"><span class="string">                            handled: true,</span></span><br><span class="line"><span class="string">                            type: '</span>instrument<span class="string">',</span></span><br><span class="line"><span class="string">                        },</span></span><br><span class="line"><span class="string">                    });</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">        } catch (e) {</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        return original.apply(this, {</span></span><br><span class="line"><span class="string">            eventName,</span></span><br><span class="line"><span class="string">            wrap(fn,</span></span><br><span class="line"><span class="string">                   mechanism: {</span></span><br><span class="line"><span class="string">                        data: {</span></span><br><span class="line"><span class="string">                            function: '</span>addEventListener<span class="string">',</span></span><br><span class="line"><span class="string">                            handler: getFunctionName(fn),</span></span><br><span class="line"><span class="string">                            target: target,</span></span><br><span class="line"><span class="string">                        },</span></span><br><span class="line"><span class="string">                        handled: true,</span></span><br><span class="line"><span class="string">                        type: '</span>instrument<span class="string">',</span></span><br><span class="line"><span class="string">                    },</span></span><br><span class="line"><span class="string">                }),</span></span><br><span class="line"><span class="string">                options,</span></span><br><span class="line"><span class="string">            ]);</span></span><br><span class="line"><span class="string">                 )</span></span><br><span class="line"><span class="string">        })</span></span><br><span class="line"><span class="string">    })</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><h4 id="行为获取"><a href="#行为获取" class="headerlink" title="行为获取"></a>行为获取</h4><p>sentry 接入应用以后 收集用户的行为（<code>页面跳转、click、keypress、fetch/xhr、console等行为</code>）然后和异常信息一起上报 而<code>sentry</code>通过覆写对应的<code>api</code>来实现效果</p><h5 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h5><p>通过覆写 <code>window.onpopstate \ history.pushstate / history.replaceState</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//window.onpopstate</span></span><br><span class="line"><span class="keyword">const</span> oldOnPopState = <span class="variable constant_">WINDOW</span>.<span class="property">onpopstate</span>;</span><br><span class="line"><span class="variable constant_">WINDOW</span>.<span class="property">onpopstate</span> = <span class="keyword">function</span>(<span class="params"><span class="variable language_">this</span>, ...args</span>) {</span><br><span class="line"><span class="keyword">const</span> to = <span class="variable constant_">WINDOW</span>.<span class="property">href</span>;</span><br><span class="line">    <span class="keyword">const</span> form = lastHref;</span><br><span class="line">    lastHref = to;</span><br><span class="line">    <span class="comment">//收集页面跳转行为</span></span><br><span class="line">    <span class="title function_">triggerHandlers</span>(<span class="string">'history'</span>, {</span><br><span class="line">        <span class="keyword">from</span>,</span><br><span class="line">        to</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">if</span>(oldOnPropState) {</span><br><span class="line">         <span class="keyword">try</span> {</span><br><span class="line">         <span class="comment">//使用原生的popstate</span></span><br><span class="line">        <span class="keyword">return</span> oldOnPopState.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      } <span class="keyword">catch</span> (_oO) {</span><br><span class="line">        <span class="comment">// no-empty</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//覆写 pushState replaceState</span></span><br><span class="line"><span class="comment">// 保存原生的 pushState 方法</span></span><br><span class="line"><span class="keyword">var</span> originPushState = <span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">pushState</span>;</span><br><span class="line"><span class="comment">// 保存原生的 replaceState 方法</span></span><br><span class="line"><span class="keyword">var</span> originReplaceState = <span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">replaceState</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 劫持覆写 pushState</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">pushState</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) {</span><br><span class="line">        args[i] = <span class="variable language_">arguments</span>[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> url = args.<span class="property">length</span> &gt; <span class="number">2</span> ? args[<span class="number">2</span>] : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">if</span> (url) {</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">from</span> = lastHref;</span><br><span class="line">        <span class="keyword">var</span> to = <span class="title class_">String</span>(url);</span><br><span class="line">        lastHref = to;</span><br><span class="line">        <span class="comment">// 将页面跳转行为收集起来</span></span><br><span class="line">        <span class="title function_">triggerHandlers</span>(<span class="string">'history'</span>, {</span><br><span class="line">            <span class="attr">from</span>: <span class="keyword">from</span>,</span><br><span class="line">            <span class="attr">to</span>: to,</span><br><span class="line">        });</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">// 使用原生的 pushState 做页面跳转</span></span><br><span class="line">     <span class="keyword">return</span> originPushState.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 劫持覆写 replaceState</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">replaceState</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) {</span><br><span class="line">        args[i] = <span class="variable language_">arguments</span>[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> url = args.<span class="property">length</span> &gt; <span class="number">2</span> ? args[<span class="number">2</span>] : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">if</span> (url) {</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">from</span> = lastHref;</span><br><span class="line">        <span class="keyword">var</span> to = <span class="title class_">String</span>(url);</span><br><span class="line">        lastHref = to;</span><br><span class="line">        <span class="comment">// 将页面跳转行为收集起来</span></span><br><span class="line">        <span class="title function_">triggerHandlers</span>(<span class="string">'history'</span>, {</span><br><span class="line">            <span class="attr">from</span>: <span class="keyword">from</span>,</span><br><span class="line">            <span class="attr">to</span>: to,</span><br><span class="line">        });</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">// 使用原生的 replaceState 做页面跳转</span></span><br><span class="line">     <span class="keyword">return</span> originReplaceState.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="click-keypress"><a href="#click-keypress" class="headerlink" title="click | keypress"></a>click | keypress</h5><ul><li><p>通过<code>document</code>代理<code>click、keypress</code>事件来收集 <code>click、keypress</code></p></li><li><p>通过劫持 <code>addEventListener</code>来收集<code>click、keypress</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理DOM</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">instructDOM</span>(<span class="params"></span>);<span class="built_in">void</span> {</span><br><span class="line"><span class="keyword">if</span>( !(<span class="string">'document'</span> <span class="keyword">in</span> <span class="variable constant_">WINDOW</span>)) { <span class="comment">//如果不支持document</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//triggerDOMHandler用来收集用户click/keypress行为</span></span><br><span class="line"> <span class="keyword">var</span> triggerDOMHandler = triggerHandlers.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">'dom'</span>);</span><br><span class="line">    <span class="keyword">var</span> globalDOMEventHandler = <span class="title function_">makeDOMEventHandler</span>(triggerDOMHandler, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 document 代理 click、keypress 事件的方式收集 click、keypress 行为</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">'click'</span>, globalDOMEventHandler, <span class="literal">false</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">'keypress'</span>, globalDOMEventHandler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    [<span class="string">'EventTarget'</span>, <span class="string">'Node'</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">target</span>) {</span><br><span class="line">        <span class="keyword">var</span> proto = <span class="variable language_">window</span>[target] &amp;&amp; <span class="variable language_">window</span>[target].<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!proto || !proto.<span class="property">hasOwnProperty</span> || !proto.<span class="title function_">hasOwnProperty</span>(<span class="string">'addEventListener'</span>)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 劫持覆写 Node.prototype.addEventListener 和 EventTarget.prototype.addEventListener</span></span><br><span class="line">        <span class="title function_">fill</span>(proto, <span class="string">'addEventListener'</span>, <span class="keyword">function</span> (<span class="params">originalAddEventListener</span>) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回新的 addEventListener 覆写原生的 addEventListener</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="keyword">type</span>, listener, options</span>) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">// click、keypress 事件，要做特殊处理，</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">'click'</span> || <span class="keyword">type</span> == <span class="string">'keypress'</span>) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="keyword">var</span> el = <span class="variable language_">this</span>;</span><br><span class="line">                        <span class="keyword">var</span> handlers_1 = (el.<span class="property">__sentry_instrumentation_handlers__</span> = el.<span class="property">__sentry_instrumentation_handlers__</span> || {});</span><br><span class="line">                        <span class="keyword">var</span> handlerForType = (handlers_1[<span class="keyword">type</span>] = handlers_1[<span class="keyword">type</span>] || { <span class="attr">refCount</span>: <span class="number">0</span> });</span><br><span class="line">                        <span class="comment">// 如果没有收集过 click、keypress 行为</span></span><br><span class="line">                        <span class="keyword">if</span> (!handlerForType.<span class="property">handler</span>) {</span><br><span class="line">                            <span class="keyword">var</span> handler = <span class="title function_">makeDOMEventHandler</span>(triggerDOMHandler);</span><br><span class="line">                            handlerForType.<span class="property">handler</span> = handler;</span><br><span class="line">                            originalAddEventListener.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="keyword">type</span>, handler, options);</span><br><span class="line">                        }</span><br><span class="line">                        handlerForType.<span class="property">refCount</span> += <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">catch</span> (e) {</span><br><span class="line">                        <span class="comment">// Accessing dom properties is always fragile.</span></span><br><span class="line">                        <span class="comment">// Also allows us to skip `addEventListenrs` calls with no proper `this` context.</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 使用原生的 addEventListener 方法注册事件</span></span><br><span class="line">                <span class="keyword">return</span> originalAddEventListener.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="keyword">type</span>, listener, options);</span><br><span class="line">            };</span><br><span class="line">        });</span><br><span class="line">        ...</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="收集-fetch-xhr-接口行为"><a href="#收集-fetch-xhr-接口行为" class="headerlink" title="收集 fetch/xhr 接口行为"></a>收集 fetch/xhr 接口行为</h5><p><code>sentry</code>对原生的<code>fetch</code>和<code>xhr</code>做了劫持覆写</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//劫持fetch</span></span><br><span class="line"><span class="keyword">var</span> originFetch = <span class="variable language_">window</span>.<span class="property">fetch</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">fetch</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; _i++) {</span><br><span class="line">        args[_i] = <span class="variable language_">arguments</span>[_i];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取接口 url、method 类型、参数、接口调用时间信息</span></span><br><span class="line">    <span class="keyword">var</span> handlerData = {</span><br><span class="line">        <span class="attr">args</span>: args,</span><br><span class="line">        <span class="attr">fetchData</span>: {</span><br><span class="line">            <span class="attr">method</span>: <span class="title function_">getFetchMethod</span>(args),</span><br><span class="line">            <span class="attr">url</span>: <span class="title function_">getFetchUrl</span>(args),</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">startTimestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">    };</span><br><span class="line">    <span class="comment">// 收集接口调用信息</span></span><br><span class="line">    <span class="title function_">triggerHandlers</span>(<span class="string">'fetch'</span>, <span class="title function_">__assign</span>({}, handlerData));</span><br><span class="line">    <span class="keyword">return</span> originalFetch.<span class="title function_">apply</span>(<span class="variable language_">window</span>, args).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) {</span><br><span class="line">        <span class="comment">// 接口请求成功，收集返回数据</span></span><br><span class="line">        <span class="title function_">triggerHandlers</span>(<span class="string">'fetch'</span>, <span class="title function_">__assign</span>(<span class="title function_">__assign</span>({}, handlerData), { <span class="attr">endTimestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(), <span class="attr">response</span>: response }));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    }, <span class="keyword">function</span> (<span class="params">error</span>) {</span><br><span class="line">        <span class="comment">// 接口请求失败，收集接口异常数据</span></span><br><span class="line">        <span class="title function_">triggerHandlers</span>(<span class="string">'fetch'</span>, <span class="title function_">__assign</span>(<span class="title function_">__assign</span>({}, handlerData), { <span class="attr">endTimestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(), <span class="attr">error</span>: error }));</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"><span class="comment">//劫持xhr 主要通过劫持覆写open | send 方法实现接收集接口请求的行为</span></span><br><span class="line"><span class="comment">//当调用open 实际调用的是覆写的open 而覆写的open内部又覆写了onreadystatechange 这样就可以收集到接口请求返回的结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">instrumentXHR</span>(<span class="params"></span>) {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> xhrproto = <span class="title class_">XMLHttpRequest</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="comment">// 覆写 XMLHttpRequest.prototype.open</span></span><br><span class="line">    <span class="title function_">fill</span>(xhrproto, <span class="string">'open'</span>, <span class="keyword">function</span> (<span class="params">originalOpen</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">var</span> onreadystatechangeHandler = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">                <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) {</span><br><span class="line">                    ...</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 收集接口调用结果</span></span><br><span class="line">                    <span class="title function_">triggerHandlers</span>(<span class="string">'xhr'</span>, {</span><br><span class="line">                        <span class="attr">args</span>: args,</span><br><span class="line">                        <span class="attr">endTimestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">                        <span class="attr">startTimestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">                        <span class="attr">xhr</span>: xhr,</span><br><span class="line">                    });</span><br><span class="line">                }</span><br><span class="line">            };</span><br><span class="line">            <span class="comment">// 覆写 onreadystatechange</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'onreadystatechange'</span> <span class="keyword">in</span> xhr &amp;&amp; <span class="keyword">typeof</span> xhr.<span class="property">onreadystatechange</span> === <span class="string">'function'</span>) {</span><br><span class="line">                <span class="title function_">fill</span>(xhr, <span class="string">'onreadystatechange'</span>, <span class="keyword">function</span> (<span class="params">original</span>) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">                        <span class="keyword">var</span> readyStateArgs = [];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; _i++) {</span><br><span class="line">                            readyStateArgs[_i] = <span class="variable language_">arguments</span>[_i];</span><br><span class="line">                        }</span><br><span class="line">                        <span class="title function_">onreadystatechangeHandler</span>();</span><br><span class="line">                        <span class="keyword">return</span> original.<span class="title function_">apply</span>(xhr, readyStateArgs);</span><br><span class="line">                    };</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                xhr.<span class="title function_">addEventListener</span>(<span class="string">'readystatechange'</span>, onreadystatechangeHandler);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> originalOpen.<span class="title function_">apply</span>(xhr, args);</span><br><span class="line">        };</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写 XMLHttpRequest.prototype.send</span></span><br><span class="line">    <span class="title function_">fill</span>(xhrproto, <span class="string">'send'</span>, <span class="keyword">function</span> (<span class="params">originalSend</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 收集接口调用行为</span></span><br><span class="line">            <span class="title function_">triggerHandlers</span>(<span class="string">'xhr'</span>, {</span><br><span class="line">                <span class="attr">args</span>: args,</span><br><span class="line">                <span class="attr">startTimestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">                <span class="attr">xhr</span>: <span class="variable language_">this</span>,</span><br><span class="line">            });</span><br><span class="line">            <span class="keyword">return</span> originalSend.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        };</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="收集-console"><a href="#收集-console" class="headerlink" title="收集 console"></a>收集 console</h5><p>实际上就是对 <code>debug/info/warn/error/log/assert</code>这些<code>api</code>进行覆写</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originConsoleLog = <span class="variable language_">console</span>.<span class="property">log</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; _i++) {</span><br><span class="line">    args[_i] = <span class="variable language_">arguments</span>[_i];</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 收集 console.log 行为</span></span><br><span class="line">  <span class="title function_">triggerHandlers</span>(<span class="string">"console"</span>, { <span class="attr">args</span>: args, <span class="attr">level</span>: <span class="string">"log"</span> });</span><br><span class="line">  <span class="keyword">if</span> (originConsoleLog) {</span><br><span class="line">    originConsoleLog.<span class="title function_">apply</span>(<span class="variable language_">console</span>, args);</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="使用-Sentry-上报异常"><a href="#使用-Sentry-上报异常" class="headerlink" title="使用 Sentry 上报异常"></a>使用 Sentry 上报异常</h3><p>1.在 sentry 构建一个项目 项目会自动生成一个<code>dns</code> 这个<code>dns</code>在项目接入 Sentry 使用</p><p>2.使用<code>Sentry</code>提供的<code>init</code>接入就行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//以react为例</span><br><span class="line">(Sentry as any).init({</span><br><span class="line">dsn: "https://83c5abfb9bc54d708ce01bd9993eeddf@o1424804.ingest.sentry.io/4504083781582848",</span><br><span class="line">integrations: [new BrowserTracing()],</span><br><span class="line">tracesSampleRate: 1.0</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>3.接下来就能使用<code>sentry</code>来接收异常了</p><p><img src="https://pic.lxtlovely.top/XUXI/image-20221104200524905.png" alt="image-20221104200524905"></p><p>4.接入飞书平台 使用飞书群聊功能自动通知人员</p><ol><li><p>创建异常上报群并设置群聊机器人</p><p><img src="https://pic.lxtlovely.top/XUXI/image-20221104200704236.png" alt="image-20221104200704236"></p></li><li><p>生成机器人的<code>webhook</code> 记住保存后面用</p><p><img src="https://pic.lxtlovely.top/XUXI/image-20221104200751332.png" alt="image-20221104200751332"></p></li><li><p>sentry 平台设置对应的<code>webhook</code></p><p><img src="https://pic.lxtlovely.top/XUXI/image-20221104200908164.png" alt="image-20221104200908164"></p></li><li><p>创建飞书捷径并设置操作</p><p><img src="https://pic.lxtlovely.top/XUXI/image-20221104200958281.png" alt="image-20221104200958281"></p></li><li><p>接下来 只要项目发生异常 就会通知<code>sentry</code> <code>sentry</code>就会将异常信息发布到飞书通知群通知对应人员去修复</p></li></ol></li></ul><h2 id="使用-sentry-做性能分析"><a href="#使用-sentry-做性能分析" class="headerlink" title="使用 sentry 做性能分析"></a>使用 sentry 做性能分析</h2><h3 id="常见的性能优化指标及获取方式"><a href="#常见的性能优化指标及获取方式" class="headerlink" title="常见的性能优化指标及获取方式"></a>常见的性能优化指标及获取方式</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64e30109b49e455385113c626060a4aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timing = <span class="variable language_">window</span>.<span class="property">performance</span>.<span class="property">timing</span>;</span><br><span class="line">{</span><br><span class="line">    navigationStart, <span class="comment">//同一个浏览器上下文中 上一个文档结束时的时间戳 如果没有上一个文档 这个值会和fetchStart相同</span></span><br><span class="line">    unloadEventStart,<span class="comment">//上一个文档unload事件触发的时间戳 如果没有上一个文档 为0</span></span><br><span class="line">    unloadEventEnd,<span class="comment">//上一个unload事件结束时的时间戳 如果没有上一个文档 为0</span></span><br><span class="line">    redirectStart，<span class="comment">//表示最后一个http重定向开始时的时间戳 如果没有重定向或者有一个非同源的重定向 为0</span></span><br><span class="line">    redirectEnd，<span class="comment">//最后一个重定向结束时的时间戳 如果没有重定向或者有一个非同源的重定向 为 0</span></span><br><span class="line">    fetchStart， <span class="comment">//浏览器准备好使用http请求获取文档的时间戳 这个时间会在检查任何缓存之前</span></span><br><span class="line">    domainLookupEnd/<span class="title class_">Start</span>， <span class="comment">//域名查询开始/结束时的时间戳 如果用了持久连接或者本地有缓存 则和fetchStart相同</span></span><br><span class="line">    connectStart， <span class="comment">//http请求向服务器发送链接请求的时间戳 如果是用了持久连接 这个值和fechStart相同</span></span><br><span class="line">    connectEnd, <span class="comment">//浏览器和服务器之间建立起链接的时间 所有握手和认证过程全部结束 如果使用了持久链接 这个值和fetchStart相同</span></span><br><span class="line">    secureConnectionStart, <span class="comment">// 浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，返回 0。</span></span><br><span class="line">    requestStart, <span class="comment">// 浏览器向服务器发起 http 请求(或者读取本地缓存)时的时间戳，即获取 html 文档。</span></span><br><span class="line">    responseStart, <span class="comment">// 浏览器从服务器接收到第一个字节时的时间戳。</span></span><br><span class="line">    responseEnd, <span class="comment">// 浏览器从服务器接受到最后一个字节时的时间戳。</span></span><br><span class="line">    domLoading, <span class="comment">// dom 结构开始解析的时间戳，document.readyState 的值为 loading。</span></span><br><span class="line">    domInteractive, <span class="comment">// dom 结构解析结束，开始加载内嵌资源的时间戳，document.readyState 的状态为 interactive。</span></span><br><span class="line">    domContentLoadedEventStart, <span class="comment">// DOMContentLoaded 事件触发时的时间戳，所有需要执行的脚本执行完毕。</span></span><br><span class="line">    domContentLoadedEventEnd,  <span class="comment">// DOMContentLoaded 事件结束时的时间戳</span></span><br><span class="line">    domComplete, <span class="comment">// dom 文档完成解析的时间戳， document.readyState 的值为 complete。</span></span><br><span class="line">    loadEventStart, <span class="comment">// load 事件触发的时间。</span></span><br><span class="line">    loadEventEnd <span class="comment">// load 时间结束时的时间。</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="页面何时开始渲染-FP-amp-FCP"><a href="#页面何时开始渲染-FP-amp-FCP" class="headerlink" title="页面何时开始渲染 FP &amp; FCP"></a>页面何时开始渲染 FP &amp; FCP</h4><ul><li><code>first paint</code>表示页面开始首次绘制的时间戳 值越小越好 在<code>FP</code>事件点之前 用户看到的是导航之前的页面</li><li><code>first contentful paint</code>表示首次绘制任何文本、图像、非空白<code>canvas</code>或者<code>SVG</code>的时间点 值越小越好</li></ul><p>可以通过 <code>perfermance.getEntry | performance.getEntriesByName | performanceObserver</code>来获取</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">performance.<span class="title function_">getEntries</span>().<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">name</span> === <span class="string">'first-paint'</span>)[<span class="number">0</span>];  <span class="comment">// 获取 FP 时间</span></span><br><span class="line"></span><br><span class="line">performance.<span class="title function_">getEntries</span>().<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">name</span> === <span class="string">'first-contentful-paint'</span>)[<span class="number">0</span>];  <span class="comment">// 获取 FCP 时间</span></span><br><span class="line"></span><br><span class="line">performance.<span class="title function_">getEntriesByName</span>(<span class="string">'first-paint'</span>); <span class="comment">// 获取 FP 时间</span></span><br><span class="line"></span><br><span class="line">performance.<span class="title function_">getEntriesByName</span>(<span class="string">'first-contentful-paint'</span>);  <span class="comment">// 获取 FCP 时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以通过 performanceObserver 的方式获取</span></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">PerformanceObserver</span>(<span class="keyword">function</span>(<span class="params">list, obj</span>) {</span><br><span class="line">    <span class="keyword">var</span> entries = list.<span class="title function_">getEntries</span>();</span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> {</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">name</span> === <span class="string">'first-paint'</span>) {</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">name</span> === <span class="string">'first-contentful-paint'</span>) {</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">});</span><br><span class="line">observer.<span class="title function_">observe</span>({<span class="attr">type</span>: <span class="string">'paint'</span>});</span><br></pre></td></tr></tbody></table></figure><h4 id="页面何时渲染主要内容-SI-amp-LCP"><a href="#页面何时渲染主要内容-SI-amp-LCP" class="headerlink" title="页面何时渲染主要内容 SI &amp; LCP"></a>页面何时渲染主要内容 SI &amp; LCP</h4><ul><li><p><code>LCP</code> 页面首次加载时最大元素的绘制事件点 可以通过 <code>performanceObserver</code>获取</p></li><li><p>```js<br>new PerformanceObserver((entryList) =&gt; {<br>  for (const entry of entryList.getEntries()) {</p><pre><code>console.log("LCP candidate", entry.startTime, entry);</code></pre><p>  }<br>}).observe({ type: “largest-contentful-paint”, buffered: true });</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 页面可以交互 TTI &amp; TBT</span><br><span class="line"></span><br><span class="line">- `time to ineractive`可交互时间 用于测量页面从开始加载到主要资源加载完成渲染 并能快速、可靠地响应用户输入所需的时间</span><br><span class="line"></span><br><span class="line">- `total blocking time` 总的阻塞时间</span><br><span class="line"></span><br><span class="line">#### 交互是否有延迟 FID &amp; LONG TASK</span><br><span class="line"></span><br><span class="line">- `FID` `first input delay` 衡量从用户第一次与页面交互（比如点击链接 按钮 自定义控件）直到浏览器对交互做出响应 并实际能够开始处理事件处理程序的事件 通过 `performanceObserver`获取</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  new PerformanceObserver((entryList) =&gt; {</span><br><span class="line">    for (const entry of entryList.getEntries()) {</span><br><span class="line">      const delay = entry.processingStart - entry.startTime;</span><br><span class="line">      console.log("FID candidate", delay, entry);</span><br><span class="line">    }</span><br><span class="line">  }).observer({ type: "first-input", buffered: true });</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>Long Task</code> 衡量用户在使用过程中遇到的交互延迟 阻塞情况 可以告诉我们那些任务耗时过久（一般超过 <code>50ms</code>就是长任务）</p></li><li><p>```js<br>new PerformanceObserver(function(list) {</p><pre><code>var perfEntries = list.getEntries();for (var i = 0; i &lt; perfEntries.length; i++) {    ...}</code></pre><p>})observe({ type: ‘longtask’});</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 页面是否稳定 CLS</span><br><span class="line"></span><br><span class="line">- `CLS Cumulative Layout Shift` 用于测量整个页面生命周期内发生的意外布局偏移中最大一连串的布局偏移情况</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  new PerformanceObserver(function(list) {</span><br><span class="line">      var perfEntries = list.getEntries();</span><br><span class="line">      for (var i = 0; i &lt; perfEntries.length; i++) {</span><br><span class="line">          ...</span><br><span class="line">      }</span><br><span class="line">  })observe({type: 'layout-shift', buffered: true});</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="性能分析关键指标"><a href="#性能分析关键指标" class="headerlink" title="性能分析关键指标"></a>性能分析关键指标</h4><ul><li><code>lighthouse</code>： <code>TCP \ LCP \SI \TTI \ TBT \ CLS</code></li><li><code>Sentry</code>： <code>FCP \ LCP \ FID \ CLS</code></li></ul><h3 id="Sentry-性能监控的原理"><a href="#Sentry-性能监控的原理" class="headerlink" title="Sentry 性能监控的原理"></a>Sentry 性能监控的原理</h3><p>通过 <code>window.performance.getEntries \ performanceObserver</code> 获取用户在使用应用过程中涉及的 <code>load</code>相关 <code>FCP / LCP / FID / CLS</code>等指标数据 然后上报 监控平台拿到数据后 通过可视化的方式展示指标数据 帮助我们分析</p><p><code>sentry</code>将性能指标数据分为两部分 首屏加载相关和页面切换相关</p><h4 id="首屏加载（pageload）"><a href="#首屏加载（pageload）" class="headerlink" title="首屏加载（pageload）"></a>首屏加载（pageload）</h4><p>1.应用加载时使用 <code>sentry.init</code>方法进行初始化</p><p>在初始化时 通过<code>setTimeout</code>实现首屏完成后再上报首屏性能指标数据 （默认为<code>1000ms</code> 如果我们的首屏时间超过<code>1000ms</code> 则需要手动设置<code>timeout</code>）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Sentry</span>.<span class="title function_">init</span>({</span><br><span class="line">     <span class="attr">dsn</span>: <span class="string">"https://examplePublicKey@o0.ingest.sentry.io/0"</span>,</span><br><span class="line">    <span class="attr">integrations</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BrowserTracing</span>({</span><br><span class="line">            <span class="attr">idleTimeout</span>: <span class="number">3000</span>,</span><br><span class="line">            ...</span><br><span class="line">        }),</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">tracesSampleRate</span>: <span class="number">1.0</span>,</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>2.在<code>setTimeout</code>的<code>callback</code>中通过 <code>window.performance.getEntries | performanceObserver</code>获取性能指标数据 然后通过接口上报</p><h4 id="页面切换（navigation）"><a href="#页面切换（navigation）" class="headerlink" title="页面切换（navigation）"></a>页面切换（navigation）</h4><p>1.在 <code>Sentry.init</code> 初始化过程中对 <code>history.pushState / history.replaceState / window.onpopState</code> 进行覆写 拦截路由切换操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">historyReplacementFunction</span>(<span class="params">originalHistoryFunction: () =&gt; <span class="keyword">void</span></span>): <span class="function">() =&gt;</span> <span class="keyword">void</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: History, ...args: any[]</span>): <span class="keyword">void</span> {</span><br><span class="line">      <span class="keyword">const</span> url = args.<span class="property">length</span> &gt; <span class="number">2</span> ? args[<span class="number">2</span>] : <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">if</span> (url) {</span><br><span class="line">        <span class="comment">// coerce to string (this is what pushState does)</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">from</span> = lastHref;</span><br><span class="line">        <span class="keyword">const</span> to = <span class="title class_">String</span>(url);</span><br><span class="line">        <span class="comment">// keep track of the current URL state, as we always receive only the updated state</span></span><br><span class="line">        lastHref = to;</span><br><span class="line">        <span class="title function_">triggerHandlers</span>(<span class="string">'history'</span>, {</span><br><span class="line">          <span class="keyword">from</span>,</span><br><span class="line">          to,</span><br><span class="line">        });</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> originalHistoryFunction.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    };</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//对pushState replaceState进行覆写</span></span><br><span class="line">  <span class="title function_">fill</span>(<span class="variable constant_">WINDOW</span>.<span class="property">history</span>, <span class="string">'pushState'</span>, historyReplacementFunction);</span><br><span class="line">  <span class="title function_">fill</span>(<span class="variable constant_">WINDOW</span>.<span class="property">history</span>, <span class="string">'replaceState'</span>, historyReplacementFunction);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">instrumentHistory</span>(<span class="params"></span>): <span class="keyword">void</span> {</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">supportsHistory</span>()) {</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oldOnPopState = <span class="variable constant_">WINDOW</span>.<span class="property">onpopstate</span>;</span><br><span class="line">  <span class="variable constant_">WINDOW</span>.<span class="property">onpopstate</span> = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: WindowEventHandlers, ...args: any[]</span>): any {</span><br><span class="line">    <span class="keyword">const</span> to = <span class="variable constant_">WINDOW</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line">    <span class="comment">// keep track of the current URL state, as we always receive only the updated state</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">from</span> = lastHref;</span><br><span class="line">    lastHref = to;</span><br><span class="line">    <span class="title function_">triggerHandlers</span>(<span class="string">'history'</span>, {</span><br><span class="line">      <span class="keyword">from</span>,</span><br><span class="line">      to,</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">if</span> (oldOnPopState) {</span><br><span class="line">      <span class="comment">// Apparently this can throw in Firefox when incorrectly implemented plugin is installed.</span></span><br><span class="line">      <span class="comment">// https://github.com/getsentry/sentry-javascript/issues/3344</span></span><br><span class="line">      <span class="comment">// https://github.com/bugsnag/bugsnag-js/issues/469</span></span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> oldOnPopState.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      } <span class="keyword">catch</span> (_oO) {</span><br><span class="line">        <span class="comment">// no-empty</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  };</span><br></pre></td></tr></tbody></table></figure><p>2.页面切换以后 <code>window.performance.genEntires</code>获取性能指标数据 然后通过接口上报 通过<code>performance。getEntries</code>获取性能指标数据时 sentry 会记录上次上报时的<code>oldIndex</code> 等到下次上报 <code>oldIndex + 1</code>开始获取指标性能数据</p><h3 id="使用-sentry-进行性能分析"><a href="#使用-sentry-进行性能分析" class="headerlink" title="使用 sentry 进行性能分析"></a>使用 sentry 进行性能分析</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以react为例</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Sentry</span> <span class="keyword">from</span> <span class="string">"@sentry/react"</span>;</span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">BrowserTracing</span> } <span class="keyword">from</span> <span class="string">"@sentry/tracing"</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Sentry</span>.<span class="title function_">init</span>({</span><br><span class="line">  <span class="attr">dsn</span>: <span class="string">"https://examplePublicKey@o0.ingest.sentry.io/0"</span>,</span><br><span class="line">  <span class="attr">integrations</span>: [<span class="keyword">new</span> <span class="title class_">BrowserTracing</span>()],</span><br><span class="line">  <span class="attr">tracesSampleRate</span>: <span class="number">0.2</span>, <span class="comment">//采样率 决定了性能指标数据上报的频率 最大值为1</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9181f4cad5ed4452880b2403868b6bf1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d589ba9ec62145d38818d8b752c8e27d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Oct-04-2022 21-51-03.gif"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e390563b1d4422ae752e1f369f8eb3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h3 id="怎么做性能优化"><a href="#怎么做性能优化" class="headerlink" title="怎么做性能优化"></a>怎么做性能优化</h3><p>优化性能 分为让用户更快地看到页面内容（<code>FCP/ LCP</code>）、更早、更流畅地操作页面（<code>FID/TTI/TTB</code>）以及更好的视觉体验（<code>CLS</code>）</p><h4 id="LCP-amp-FCP"><a href="#LCP-amp-FCP" class="headerlink" title="LCP &amp;FCP"></a>LCP &amp;FCP</h4><p><strong>优化 FCP</strong></p><ul><li>减少服务器响应时间-：避免多次重定向 提前建立连接 <code>preconnect</code>、 <code>dns</code>预解析、<code>http2</code>、 使用高效的缓存策略、使用 <code>CDN</code> 使用 <code>SSG</code>代替 <code>SSR</code></li><li>优化加载速度：预加载关键资源 压缩 <code>js、css、图片等静态资源</code>、移除未使用的资源</li><li>延迟加载未使用的资源：<code>defer/async</code>、懒加载</li><li>减少<code>js</code>的阻塞渲染： 尽快尽早地加载需要的资源、使用<code>worker</code></li><li>在请求数和请求文件之间寻找最佳的平衡点</li><li>避免<code>DOM</code>过大</li><li>减少关键请求的深度</li></ul><p><strong>优化 LCP</strong></p><p>优化<code>LCP</code> 除了上面的手段 还可以将客户端渲染改成服务端渲染 提前将页面主体渲染出来</p><h4 id="优化-FID-TTI-TBT"><a href="#优化-FID-TTI-TBT" class="headerlink" title="优化 FID / TTI / TBT"></a>优化 FID / TTI / TBT</h4><p>更关键的是 js 的阻塞时间</p><ul><li>优化资源加载速度：预加载<code>js</code>资源 压缩<code>js</code>大小 使用 <code>CDN</code> 使用缓存</li><li>减少<code>js</code>执行时间： 延迟加载未使用的<code>js</code> 使用 <code>worker</code></li><li>减少关键请求的深度</li></ul><h4 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a>CLS</h4><ul><li>提前确定好 <code>img、视频</code>等媒体节点的尺寸</li><li>首选<code>transform</code>动画 而不是触发布局偏移（引发回流重绘）的属性动画</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常监控 </tag>
            
            <tag> Sentry </tag>
            
            <tag> 性能分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0到1搭建前端监控系统</title>
      <link href="/2022/11/01/qian-duan-yi-chang-jian-kong/"/>
      <url>/2022/11/01/qian-duan-yi-chang-jian-kong/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建异常监控系统"><a href="#搭建异常监控系统" class="headerlink" title="搭建异常监控系统"></a>搭建异常监控系统</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>收集异常报错</li><li>上报异常信息</li><li>构建时将<code>sourcemap</code>文件上传至服务器</li><li>报错时服务器接收错误并记录到日志中</li><li>根据<code>sourcemap</code>和错误日志内容进行错误分析</li></ol><h2 id="收集异常报错"><a href="#收集异常报错" class="headerlink" title="收集异常报错"></a>收集异常报错</h2><h3 id="代码异常"><a href="#代码异常" class="headerlink" title="代码异常"></a>代码异常</h3><h4 id="JS-执行异常"><a href="#JS-执行异常" class="headerlink" title="JS 执行异常"></a>JS 执行异常</h4><ul><li><code>Error</code>： 最基本的错误类型 其他类型的原型</li><li><code>RangeError</code>：范围异常 比如栈溢出和索引越界</li><li><code>ReferenceError</code>：引用错误 比如引用一个不存在的对象</li><li><code>SyntaxError</code>：语法错误</li><li><code>TypeError</code>： 类型错误</li><li><code>URIError</code>：向全局<code>URI</code>处理函数传递一个不合理的<code>URI</code>时 比如 <code>decodeURI('%')</code></li><li><code>EvalError</code>: 关于<code>eval</code>的异常 不会被 js 抛出</li></ul><p>可以使用 <code>try...catch| window.onerror = callback | window.addEventListener('error', callback)</code>进行全局捕获</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">msg, url, row, col, error</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">table</span>({ msg, url, row, col, <span class="attr">error</span>: error.<span class="property">stack</span> })</span><br><span class="line">    <span class="keyword">let</span> errorMsg = {</span><br><span class="line">        <span class="attr">type</span>: <span class="string">'javascript'</span>,</span><br><span class="line">        <span class="comment">// msg错误消息，error是错误对象，这里拿的是error.stack(异常信息)</span></span><br><span class="line">        <span class="attr">msg</span>: error &amp;&amp; error.<span class="property">stack</span> ? error.<span class="property">stack</span> || msg,</span><br><span class="line">        <span class="comment">// 发生错误的行数</span></span><br><span class="line">        row,</span><br><span class="line">        <span class="comment">// 列数，也就是第几个字符</span></span><br><span class="line">        col,</span><br><span class="line">        <span class="comment">// 发生错误的页面地址</span></span><br><span class="line">        url,</span><br><span class="line">        <span class="comment">// 发生错误的时间</span></span><br><span class="line">        <span class="attr">time</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后可以把这个 errorMsg 存到一个数组里，统一上报</span></span><br><span class="line">    <span class="comment">// 也可以直接上报</span></span><br><span class="line">    <span class="title class_">Axios</span>.<span class="title function_">post</span>({ <span class="string">'https://xxxx'</span>, errorMsg })</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果return true，错误就不会抛到控制台</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="资源加载异常"><a href="#资源加载异常" class="headerlink" title="资源加载异常"></a>资源加载异常</h4><p>可以使用 <code>window.addEventListener('error', callback, true)</code></p><blockquote><p>使用 <code>window.onerror = callback</code>是无法捕获静态资源类异常的 因为资源类错误没有冒泡 只能在捕获阶段捕获 所以可以使用 <code>window.addEventListener('error', callback, true)</code>的方式捕获（第三个参数表示是否在捕获阶段调用事件处理 所以可以用来捕获在捕获阶段才会触发的错误类型）</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">"error"</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">const</span> target = e.<span class="property">target</span>;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="variable language_">window</span>) {</span><br><span class="line">      <span class="comment">//这里收集错误信息</span></span><br><span class="line">      <span class="keyword">let</span> errorMsg = {</span><br><span class="line">        <span class="attr">type</span>: target.<span class="property">localName</span>, <span class="comment">//错误来源名称</span></span><br><span class="line">        <span class="attr">url</span>: target.<span class="property">src</span> || target.<span class="property">href</span>, <span class="comment">//错误来源的链接</span></span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">      };</span><br><span class="line">      <span class="comment">//将这个errorMag存入数组中 然后统一上报</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><h4 id="Promise-异常"><a href="#Promise-异常" class="headerlink" title="Promise 异常"></a>Promise 异常</h4><p>在使用 <code>promise</code>时 如果被<code>reject</code>但是没有被<code>catch</code>处理 就会抛出 <code>promise</code>类异常</p><p><code>promise</code>类型的异常无法被 <code>try...catch</code>捕获 也没法被 <code>window.onerror = callback</code>或者 <code>window.addEventListener('error', callback, true)</code>全局捕获 可以通过 <code>window.onrejectionhandled = callback</code> 或者 <code>window.addEventListener('rejectionhandled', callback)</code>去全局捕获</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">"unhandledrejection"</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">    <span class="keyword">let</span> errorMsg = {</span><br><span class="line">        <span class="attr">type</span>: <span class="string">'promise'</span>,</span><br><span class="line">        <span class="attr">msg</span>: e.<span class="property">reason</span>.<span class="property">stack</span> || e.<span class="property">reason</span></span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">    }</span><br><span class="line">    <span class="title class_">Axios</span>.<span class="title function_">post</span>({ <span class="string">'https://xxxx'</span>, errorMsg })</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果return true，错误就不会抛到控制台</span></span><br><span class="line">})</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    s</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="接口请求异常"><a href="#接口请求异常" class="headerlink" title="接口请求异常"></a>接口请求异常</h4><ul><li>通过<code>fetch</code>则通过 <code>fetch(url).then(callback).catch(callback)</code></li><li>通过<code>xhr</code>示例发起 则使用 <code>window.addEventListener('error', callback) | window.onerror = callback</code>的方式捕获</li><li>如果是 <code>xhr.send</code>方法出现错误 则使用 <code>xhr.onerror | xhr.addEventListener('error', callback)</code>的方式捕获异常</li></ul><h4 id="跨域脚本执行异常"><a href="#跨域脚本执行异常" class="headerlink" title="跨域脚本执行异常"></a>跨域脚本执行异常</h4><p>如果是跨域脚本出现问题 可以使用 <code>window.addEventListener('error', callback) | window.onerror</code> 捕获异常</p><p>此外我们还需要做以下额外操作才能保证获取到</p><ul><li>在发起请求的<code>script</code>标签上添加 <code>crossorign = "annoymous"</code></li><li>响应头中添加 <code>Access-Control-Origin: *</code></li></ul><h4 id="Vue-异常"><a href="#Vue-异常" class="headerlink" title="Vue 异常"></a>Vue 异常</h4><h5 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h5><p><strong>errorHandle</strong></p><p>为应用内抛出的未捕获错误指定一个全局处理函数（错误一旦被捕获后 就不会被抛到控制台）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.config.errorHandler = (err, instance, info) =&gt; { //</span><br><span class="line">处理错误，例如：报告给一个服务 }</span><br></pre></td></tr></tbody></table></figure><p><strong>app.congfig.warnHandler</strong></p><p>用于为<code>Vue</code>的运行时警告指定一个自定义函数（只在开发环境有效 生产环境会被自忽略）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="property">config</span>.<span class="property">warnHandler</span> = <span class="function">(<span class="params">msg, instance, trace</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// `trace` is the component hierarchy trace</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>renderError</strong></p><p>默认的渲染函数遇到错误时 提供了一个替代渲染输出的（和热重载一起使用很好用）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">  <span class="title function_">render</span>(<span class="params">h</span>) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"oops"</span>);</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">renderError</span>(<span class="params">h, err</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">"per"</span>, { <span class="attr">style</span>: { <span class="attr">color</span>: red } }, err.<span class="property">stack</span>);</span><br><span class="line">  },</span><br><span class="line">}).$mount(<span class="string">"#app"</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>errorCaptured</strong></p><p>在捕获了后代组件传递的错误时调用</p><ul><li>默认情况下 所有的错误会被发送到 <code>app.config.errorHandler</code> 这些错误能够在这里进行分析并发送给服务器</li><li>如果组件的继承链或者组件链上存在多个 <code>errorCaptured</code>钩子 对于同一个错误 这些狗子会按从底到上的顺序调用 类似于冒泡机制</li><li>如果 <code>errorCaptured</code>钩子本身抛出了一个错误 那么这个错误和原来捕获到的错误都将被发送到<code>app.config.errorHandler</code>中</li><li><code>errorCaptured</code>钩子可以通过返回 <code>false</code>来组织错误继续向上传递</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component('ErrorBoundary',{</span><br><span class="line">    data: () =&gt; { ... }</span><br><span class="line">    errorCaptured(err, vm, info){</span><br><span class="line">        // err 错误信息</span><br><span class="line">        // vm 触发错误的组件实例</span><br><span class="line">        // info 错误捕获位置信息</span><br><span class="line">        return false</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h5 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h5><p><code>onErrorCaptured</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onErrorCaptured</span>(<span class="keyword">function</span> (<span class="params">err, instance, info</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"[errorCaptured]"</span>, err, instance, info);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="React-异常"><a href="#React-异常" class="headerlink" title="React 异常"></a>React 异常</h4><p><strong>getDerivedStateFromError</strong></p><p>在后代组件抛出错误时被钓鱼呢（在渲染阶段调用的 所以不允许出现副作用函数）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component {</span><br><span class="line">    constructor(props) {</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = { hasError: false }</span><br><span class="line">    }</span><br><span class="line">    static getDerivedStateFromError(error) {</span><br><span class="line">        // 更新 state 使下一次渲染可以显降级 UI</span><br><span class="line">        return { hasError: true }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>componentDidCatch</strong></p><p>在后代组件抛出错误时被调用 大那是不会捕获事件处理器和异步代码的异常 会在 <code>commit</code>阶段被调用 允许出现副作用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) {</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) {</span><br><span class="line">    <span class="comment">// error 错误信息</span></span><br><span class="line">    <span class="comment">// info.componentStack 错误组件位置</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是<code>errorboundaries</code>并不会捕捉这些错误</p><ul><li>事件处理程序</li><li>异步代码</li><li>服务端的渲染代码</li><li><code>error boundaries</code>自己抛出的错误</li></ul><blockquote><p>可以使用 <code>react-error-catch</code>这个库来对上面的错误捕获</p></blockquote><h4 id="页面崩溃和卡顿"><a href="#页面崩溃和卡顿" class="headerlink" title="页面崩溃和卡顿"></a>页面崩溃和卡顿</h4><ol><li>使用 <code>load</code>和 <code>beforeunload</code>来对网页奔溃进行监控</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">"load"</span>, <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  sessionStorage.<span class="title function_">setItem</span>(<span class="string">"good_exit"</span>, <span class="string">"pending"</span>);</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    sessionStorage.<span class="title function_">setItem</span>(<span class="string">"time_before_crash"</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toString</span>());</span><br><span class="line">  }, <span class="number">1000</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">"beforeunload"</span>, <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  sessionStorage.<span class="title function_">setItem</span>(<span class="string">"good_exit"</span>, <span class="string">"true"</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  sessionStorage.<span class="title function_">getItem</span>(<span class="string">"good_exit"</span>) &amp;&amp;</span><br><span class="line">  sessionStorage.<span class="title function_">getItem</span>(<span class="string">"good_exit"</span>) !== <span class="string">"true"</span></span><br><span class="line">) {</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">        insert crash logging code here</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="title function_">alert</span>(</span><br><span class="line">    <span class="string">"Hey, welcome back from your crash, looks like you crashed on: "</span> +</span><br><span class="line">      sessionStorage.<span class="title function_">getItem</span>(<span class="string">"time_before_crash"</span>)</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2.使用 <code>Server Worker</code>来监控网页的崩溃</p><ul><li><code>Server Worker</code>有自己独立的工作线程 与网页区分开 即使网页崩溃了 <code>Server Worker</code>一般不会崩溃</li><li><code>Server Worker</code>生命周期一般比网页还要长 可以用来监控网页的状态</li><li>网页可以通过 <code>navigator.serviceWorker.controller.postMessage API</code> 向掌管自己的 <code>SW</code> 发送消息</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><table><thead><tr><th>异常类型</th><th>同步方法</th><th>异步方法</th><th>资源加载</th><th>promise</th><th>async/await</th></tr></thead><tbody><tr><td>try/catch</td><td>✔️</td><td></td><td></td><td></td><td>✔️</td></tr><tr><td>onerror</td><td>✔️</td><td>✔️</td><td></td><td></td><td></td></tr><tr><td>err 事件监听</td><td>✔️</td><td>✔️</td><td>✔️</td><td></td><td></td></tr><tr><td>unhandledrejection</td><td></td><td></td><td></td><td>✔️</td><td>✔️</td></tr></tbody></table><p>实际上 我们只要将 <code>unhandledrejection</code>事件抛出的异常再次抛出就可以统一通过<code>error</code>事件进行处理了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">"unhandledrejection"</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">throw</span> e.<span class="property">reason</span>;</span><br><span class="line">});</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">"error"</span>,</span><br><span class="line">  <span class="function">(<span class="params">args</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"error event"</span>, args);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  },</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><h3 id="行为异常收集"><a href="#行为异常收集" class="headerlink" title="行为异常收集"></a>行为异常收集</h3><h4 id="1-点击行为"><a href="#1-点击行为" class="headerlink" title="1.点击行为"></a>1.点击行为</h4><p>使用 <code>addEventListener</code>全局监听点击事件 将用户行为（<code>click、input</code>）和 <code>dom</code>元素名字收集</p><p>当错误发生将错误和行为一起上报</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">_breadcrumbEventHandler</span> = (<span class="params">evtName</span>) =&gt; {</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">evt</span>) {</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">_lastCaptureEvent</span> === evt) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    self.<span class="property">_lastCapturedEvent</span> = evt;</span><br><span class="line">    <span class="keyword">let</span> target;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      target = <span class="title function_">htmlTreeAsString</span>(evt.<span class="property">target</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (e) {</span><br><span class="line">      target = <span class="string">"&lt;unknown&gt;"</span>;</span><br><span class="line">    }</span><br><span class="line">    self.<span class="title function_">captureBreadcrumb</span>({</span><br><span class="line">      <span class="comment">//在这里捕获到错误</span></span><br><span class="line">      <span class="attr">category</span>: <span class="string">`ui.<span class="subst">${evtName}</span>`</span>,</span><br><span class="line">      <span class="attr">message</span>: target,</span><br><span class="line">    });</span><br><span class="line">  };</span><br><span class="line">};</span><br><span class="line"><span class="comment">//全局监听点击</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, self.<span class="title function_">_breadcrumbEventHandler</span>(<span class="string">"click"</span>), <span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="2-发送请求行为"><a href="#2-发送请求行为" class="headerlink" title="2.发送请求行为"></a>2.发送请求行为</h4><p>监听<code>XMLHttpRequest</code>对象的<code>onreadystateChange</code>回调函数 在回调函数执行时收集数据</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onreadystatechangeHandler</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">__skynet_xhr</span> &amp;&amp; xhr.<span class="property">readyState</span> === <span class="number">4</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            xhr.<span class="property">__skynet_xhr</span>.<span class="property">status_code</span> = xhr.<span class="property">status</span>;</span><br><span class="line">        } <span class="keyword">catch</span>(e) {</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        }</span><br><span class="line">        self.<span class="title function_">captureBreadcrumb</span>({ <span class="comment">//在这里收集到错误</span></span><br><span class="line">            <span class="attr">type</span>: <span class="string">'http'</span>,</span><br><span class="line">            <span class="attr">category</span>: <span class="string">'xhr'</span>,</span><br><span class="line">            <span class="attr">data</span>: xhr.<span class="property">__skynet_xhr</span></span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(<span class="string">'onreadystatechange'</span> <span class="keyword">in</span> xhr &amp;&amp; <span class="title function_">isFunction</span>(xhr.<span class="property">onreadystatechange</span>)) {</span><br><span class="line">    <span class="title function_">fill</span>(</span><br><span class="line">    xhr,</span><br><span class="line">        <span class="string">'onreadystatechange'</span>,</span><br><span class="line">        <span class="keyword">function</span>(<span class="params">orig</span>) {</span><br><span class="line">            <span class="keyword">return</span> self.<span class="title function_">wrap</span>(orig, <span class="literal">undefined</span>, onreadystatechangeHandler) <span class="comment">//</span></span><br><span class="line">        }</span><br><span class="line">    )<span class="keyword">else</span> {</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = onredystatechcangeHnadler;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>不管是<code>axios</code>还是<code>fetch</code> 底层走的都是<code>XMLHttpRequest</code> 所以不用担心你使用的请求行为捕捉不到</p></blockquote><h4 id="3-页面跳转"><a href="#3-页面跳转" class="headerlink" title="3.页面跳转"></a>3.页面跳转</h4><p>监控 <code>window.onpopstate</code>, 页面跳转时会触发次方法 将信息收集</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldOnPopState = <span class="variable language_">window</span>.<span class="property">onpopstate</span>; <span class="comment">//先将window.onpopstate 赋值给临时变量</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onpopstate</span> = <span class="keyword">function</span> (<span class="params">...args</span>) {</span><br><span class="line">  <span class="keyword">let</span> currentHref = location.<span class="property">href</span>;</span><br><span class="line">  self.<span class="title function_">_captureUrlChange</span>(self.<span class="property">_lastHref</span>, currentHref); <span class="comment">//当前url捕获记录</span></span><br><span class="line">  <span class="keyword">if</span> (oldOnPopState) {</span><br><span class="line">    <span class="keyword">return</span> oldOnPopState.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args); <span class="comment">//原生方法抛出继续执行</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="控制台行为"><a href="#控制台行为" class="headerlink" title="控制台行为"></a>控制台行为</h4><p>通过改写 <code>console</code>对象的 <code>info | warn | error</code> 在<code>console</code>执行时将信息收集</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">wrapConsoleMethod</span> = (<span class="params"><span class="variable language_">console</span>, level, callback</span>) =&gt; {</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="variable language_">console</span>[level] = <span class="function">(<span class="params">...args</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    callback &amp;&amp; <span class="title function_">callback</span>(msg, data);</span><br><span class="line">  };</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> consoleMethodCallback = <span class="keyword">function</span> (<span class="params">msg, data</span>) {</span><br><span class="line">  self.<span class="title function_">captureBreadcrumb</span>({</span><br><span class="line">    <span class="attr">message</span>: msg,</span><br><span class="line">    <span class="attr">level</span>: data.<span class="property">level</span>,</span><br><span class="line">    <span class="attr">category</span>: <span class="string">"console"</span>,</span><br><span class="line">  });</span><br><span class="line">};</span><br><span class="line"><span class="title function_">each</span>([<span class="string">"info"</span>, <span class="string">"warn"</span>, <span class="string">"error"</span>], <span class="function">(<span class="params">_, level</span>) =&gt;</span> {</span><br><span class="line">  <span class="title function_">wrapConsoleMethod</span>(<span class="variable language_">console</span>, level, consoleMethodCallback);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><blockquote><p>AOP：针对业务处理过程中的切面（非业务逻辑部分，例如错误处理 埋点 日志等进行提取）即通过动态的方式将非关注点插入到主关注点中 即改写原生方法 在某些时间段例如 <code>after | before</code>等插入其他方法来达到覆写功能</p></blockquote><h2 id="异常上报和数据清洗"><a href="#异常上报和数据清洗" class="headerlink" title="异常上报和数据清洗"></a>异常上报和数据清洗</h2><h3 id="上报方式"><a href="#上报方式" class="headerlink" title="上报方式"></a>上报方式</h3><h4 id="1-动态创建-img-标签"><a href="#1-动态创建-img-标签" class="headerlink" title="1.动态创建 img 标签"></a>1.动态创建 img 标签</h4><p>可以异常信息拼接在<code>img</code>标签的<code>url</code>上来上报异常</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Image().src = 'https://localhost:3000/error'+  '?info=xxxx'</span><br></pre></td></tr></tbody></table></figure><p><strong>推荐使用 gift 的原因</strong></p><ul><li>不会出现跨域问题 不用专门对跨域做配置</li><li><code>gift</code>类型的图片体积很小</li><li>不需要等待服务器返回数据</li><li>无需加载任何库 且页面是无刷新的 不会对用户使用体验造成影响</li><li>兼容性好</li><li>不会携带当前域名<code>cookie</code></li></ul><p><strong>Q</strong>为啥不用请求其他的文件资源（<code>JS| CSS | TTF</code>）的方式上报</p><p><strong>A：</strong>创建资源节点后只有将插入到<code>DOM</code>树之后浏览器才可以发送实际请求 而且载入 <code>js/css</code>资源还会阻塞特面渲染 影响用户体验 而构造图片打点不仅不用插入<code>DOM</code> 只要在 js 中<code>new</code>出<code>Image</code>对象就可以发起请求 而且没有阻塞问题 在不支持<code>js</code>的浏览器中也可以使用</p><h4 id="2-Ajax-fetch-上报"><a href="#2-Ajax-fetch-上报" class="headerlink" title="2.Ajax | fetch 上报"></a>2.Ajax | fetch 上报</h4><h3 id="3-sendBeacon"><a href="#3-sendBeacon" class="headerlink" title="3.sendBeacon"></a>3.sendBeacon</h3><p><code>navigator.sendBeacon()</code>方法可用于通过 <code>HTTP POST</code>将少量的数据异步传输到<code>Web</code>服务端 主要用于将统计数据发送至服务器 同时避免了用传统技术（<code>XMLHttpRequest</code>）发送分析数据的一些问题（<code>navigator.sendBeacon(url, data)</code> <code>data包括ArrayBuffer/ArrayBufferView/Blob/DOMString/FormData/URLSearchParams</code>）</p><blockquote><p><code>sendBeacon</code>主要用于满足统计和诊断代码的需要 这些代码通常在<code>unload</code>之前像服务器发送数据 过早的发送可能会漏掉一些数据 但是以前的开发者很难保证在文档卸载期间发送数据（一般需要发起一个同步<code>XMLHttpRequest</code>来发送数据 然后创建一个<code>img</code>并设置<code>src</code>以延迟卸载文档 因为还有图像要加载 然后创建一个<code>no-op</code>循环 这都是一种强制延迟文档卸载的方案 会影响下一个导航的呈现） 而<code>sendBeacon</code>是用户代理有机会异步地向服务器发送数据 同时不会延迟页面的卸载或影响下一导航的载入性能 这意味着数据发送是可靠的 数据传输是异步的 不会影响下一导航的载入</p><p>如果希望在用户完成页面浏览时向服务器发送分析或诊断数据 最好使用 <code>visibilitychange</code>事件发生时发送数据</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">"visibilitychange"</span>, <span class="keyword">function</span> <span class="title function_">logData</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">visibilityState</span> === <span class="string">"hidden"</span>) {</span><br><span class="line">    navagator, <span class="title function_">sendBeacon</span>(<span class="string">"/log"</span>, analyticsData);</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>避免在 <code>unload</code>或者 <code>beforeunload</code>事件以在会话结束时发送统计数据 但是这是不可靠的 因为有一些情况下（热别是移动端）是不会触发这些事件的（比如用户加载了网页并与其交互、完成浏览后用户切换到其他原因程序而不是关闭选项卡、用户通过手机的应用管理器关闭了浏览器应用）此外 <code>unload</code>事件和现在推荐的往返缓存（<code>becache</code>）不兼容</p><p><strong>可以使用 pagehide</strong>来兼容不兼容<code>visibilitychange</code>事件的浏览器</p></blockquote><h4 id="上报的内容"><a href="#上报的内容" class="headerlink" title="上报的内容"></a>上报的内容</h4><h5 id="上报的信息内容"><a href="#上报的信息内容" class="headerlink" title="上报的信息内容"></a>上报的信息内容</h5><p><code>error</code>事件参数</p><ul><li><code>message</code>: 错误信息</li><li><code>filename</code>：异常的资源<code>url</code></li><li><code>lineno</code>：异常行号</li><li><code>colno</code>：异常列号</li><li><code>error</code>：错误对象</li><li><code>error.message</code>:错误信息</li><li><code>error: stack</code>:错误信息（错误栈 定义错误最核心的信息）</li></ul><h5 id="上报数据序列化"><a href="#上报数据序列化" class="headerlink" title="上报数据序列化"></a>上报数据序列化</h5><p>使用字符串形式传送异常信息 所以需要对对象进行序列化处理（后端接收到后再做相应的反序列化处理）</p><ol><li>将异常信息从属性中解构出来存入一个 JSON 对象</li><li>将 JSON 字符串转换为字符串</li><li>将字符串转换为<code>Base64</code></li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unloadError</span>(<span class="params">{</span></span><br><span class="line"><span class="params">  lineno,</span></span><br><span class="line"><span class="params">  colno,</span></span><br><span class="line"><span class="params">  error: { stack },</span></span><br><span class="line"><span class="params">  timeStamp,</span></span><br><span class="line"><span class="params">  message,</span></span><br><span class="line"><span class="params">  filename,</span></span><br><span class="line"><span class="params">}</span>) {</span><br><span class="line">  <span class="comment">//过滤</span></span><br><span class="line">  <span class="keyword">const</span> info = {</span><br><span class="line">    lineno,</span><br><span class="line">    colno,</span><br><span class="line">    stack,</span><br><span class="line">    timeStamp,</span><br><span class="line">    message,</span><br><span class="line">    filename,</span><br><span class="line">  };</span><br><span class="line">  <span class="comment">//序列化</span></span><br><span class="line">  <span class="keyword">const</span> error = <span class="variable language_">window</span>.<span class="title function_">btoa</span>(<span class="title class_">JSON</span>.<span class="title function_">stringfy</span>(info));</span><br><span class="line">  <span class="keyword">const</span> src = <span class="string">"http://olddog/error"</span>;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Image</span>().<span class="property">src</span> = <span class="string">`<span class="subst">${src}</span>?info=<span class="subst">${error}</span>`</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>流程：获取数据 -&gt; 数据预处理 -&gt; 数据聚合</p><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><p>可以使用 <code>ES</code>获取数据 ES 底层是基于<code>Lucene</code>的搜索服务器 提供了一个分布式多用户能力的全文搜索引擎 基于<code>RESTful Web</code>接口 只需要像平时开发一样即可</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.比如通过get请求从ES获取近一分钟的错误信息</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getDataFromElasticSearch</span>(<span class="params">type, lastTimestamp</span>) {</span><br><span class="line"><span class="keyword">const</span> searchData = {</span><br><span class="line">        <span class="attr">index</span>: elasticConfig.<span class="property">indexs</span>.<span class="property">monitor</span>.<span class="title function_">index</span>(),</span><br><span class="line">        <span class="attr">type</span>: elasticConfig.<span class="property">indexes</span>.<span class="property">monitor</span>.<span class="property">type</span>,</span><br><span class="line">        <span class="attr">body</span>: {</span><br><span class="line">            <span class="attr">query</span>: {</span><br><span class="line">                <span class="attr">bool</span>: {</span><br><span class="line">                    <span class="attr">must</span>: [</span><br><span class="line">                        {</span><br><span class="line">                            <span class="attr">wildcard</span>: {</span><br><span class="line">                                <span class="string">'eventEs.tag'</span>: <span class="string">`*<span class="subst">${type}</span>`</span>, <span class="comment">//类型</span></span><br><span class="line">                            },</span><br><span class="line">                        },</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">filter</span>: {</span><br><span class="line">                        <span class="attr">range</span>: {</span><br><span class="line">                            <span class="string">'eventEs.timestamp'</span>: {</span><br><span class="line">                                <span class="attr">gt</span>: lastTimestamp, <span class="comment">//选择时间范围</span></span><br><span class="line">                            },</span><br><span class="line">                        },</span><br><span class="line">                    },</span><br><span class="line">                    <span class="attr">must_not</span>: [</span><br><span class="line">                        {</span><br><span class="line">                            <span class="attr">wildcard</span>: {</span><br><span class="line">                                <span class="string">'eventEs.tag'</span>: <span class="string">'*develop*'</span> <span class="comment">//排除开发环境</span></span><br><span class="line">                            },</span><br><span class="line">                        },</span><br><span class="line">                    ],</span><br><span class="line">                },</span><br><span class="line">            },</span><br><span class="line">        },</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">let</span> body = {}</span><br><span class="line">    body = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">elasticClient</span>.<span class="title function_">search</span>(serachData);</span><br><span class="line">    <span class="keyword">return</span> body; <span class="comment">//从ES获取数据</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>设置阈值：为了在大量爆发错误的时候避免服务器过载</p><ul><li><p>设置获取上线：每分钟数据获取上线 1000 跳 超过就采样入库</p></li><li><p>同类型错误大于 200 条 只统计错误</p></li></ul><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><p>对于获取到的数据 应该对数据信息进行适当的提取 只将有需要的数据提取出来 并且还要去除原始数据中的无用信息 减少存储体积</p><h4 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h4><p>聚合的目的：</p><ol><li>存储性能：存储小</li><li>查询性能：查询快</li></ol><p>聚合的维度：业务、错误类型、错误信息</p><p>最基础的聚合方式就是对上报的全部内容进行一个散列 求 MD5 的值 然后将所有散列值相同的错误聚合成同一类错误（简单粗暴 但是聚合度很低 很多明明是同一种错误被聚合成不同的错误）</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>在错误大量发生时进行削锋处理 避免监控系统在大量错误爆发时挂掉</p><p>例如可以在每次轮询时从<code>ES</code>中拉取最新的 10000 条错误日志 同时聚合过后 同一类型的错误只取部分数量（例如 300 条）写入具体的事件数据库 其他的可以将其增加改类型的错误发生数量即可（这样子可以保证我们处理的永远都是最新的错误 既能避免大量的数据读写 也能让数据处理任务更快完成）</p><h3 id="辅助错误分析"><a href="#辅助错误分析" class="headerlink" title="辅助错误分析"></a>辅助错误分析</h3><p>针对前端 我们记录了前端用户在页面上发的 ajax 请求、点击事件、跳转事件以及控制台请求，当发生错误时 将这些行为日志和错误日志关联起来 就可以更快地判断用户是在那些操作的时候发生的错误</p><p>当我们在进行问题分析时 仅依靠日志上报的信息 很多时候是不够的 因为缺少了了用户浏览路劲以及操作行为等信息 而客户端错误很多都是特定前景下发生的</p><p>可以给客户端建立一套日志链路 从客户端的一次冷启动开始 就生成一个链路 id 后续的所有行为日志 网络日志和崩溃日志都会带上这个 id 帮我们记录一些关键节点（页面跳转、网络环境变化、错误的网络请求、用户操作行为等）这样就可以通过这些<code>id</code>直接关联到相关的行为日志 方便后续的错误排查</p><p><img src="../../../../AppData/Roaming/Typora/typora-user-images/image-20221031205641480.png" alt="image-20221031205641480"></p><h2 id="异常收集"><a href="#异常收集" class="headerlink" title="异常收集"></a>异常收集</h2><p>用<code>eggjs</code>来写下<code>demo</code>后台</p><h3 id="编写-error-上传接口"><a href="#编写-error-上传接口" class="headerlink" title="编写 error 上传接口"></a>编写 error 上传接口</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个路由用来接收上报的异常信息</span></span><br><span class="line"><span class="comment">//app/router,js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">app</span> =&gt;</span> {</span><br><span class="line"><span class="keyword">const</span> {router, controller} = app;</span><br><span class="line">    router.<span class="title function_">get</span>(<span class="string">'/'</span>, controller.<span class="property">home</span>.<span class="property">index</span>);</span><br><span class="line">    <span class="comment">//创建一个新的路由</span></span><br><span class="line">    router.<span class="title function_">get</span>(<span class="string">'/monitor/error'</span>, controller.<span class="property">monitor</span>.<span class="property">index</span>)</span><br><span class="line">    <span class="comment">//添加上传路由</span></span><br><span class="line">    router.<span class="title function_">post</span>(<span class="string">'/monitor/sourcemap'</span>, controller.<span class="property">monitor</span>.<span class="property">uplaod</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//创建controller控制层</span></span><br><span class="line"><span class="comment">//app/controller/monitor</span></span><br><span class="line"><span class="keyword">import</span> {<span class="title class_">Controller</span>} <span class="keyword">from</span> <span class="string">'egg'</span>;</span><br><span class="line"><span class="keyword">import</span> {getOriginSource} <span class="keyword">from</span> <span class="string">'../utils/sourcemap'</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonitorController</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Controller</span> {</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">index</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">const</span> {ctx} = <span class="variable language_">this</span>;</span><br><span class="line">        cost {info} = ctx.<span class="property">query</span>;</span><br><span class="line">        <span class="keyword">const</span> json = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(info, <span class="string">'base64'</span>).<span class="title function_">toString</span>(<span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'froneterror'</span>, json);</span><br><span class="line">        ctx.<span class="property">body</span> = <span class="string">''</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//添加上传接口</span></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">upload</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">const</span> {ctx} = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">const</span> stream = ctx.<span class="property">req</span>;</span><br><span class="line">        <span class="keyword">const</span> filename = crx.<span class="property">query</span>.<span class="property">name</span></span><br><span class="line">        <span class="keyword">const</span> dir = path.<span class="title function_">join</span>(<span class="variable language_">this</span>.<span class="property">config</span>.<span class="property">baseDir</span>, <span class="string">'uploads'</span>)</span><br><span class="line">        <span class="comment">//判断uplaod目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!fs.<span class="title function_">existSync</span>(dir)) {</span><br><span class="line">            fs.<span class="title function_">mkdirSync</span>(dir)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">const</span> target = path.<span class="title function_">join</span>(dir, filename);</span><br><span class="line">        <span class="keyword">const</span> writeStream = fs.<span class="title function_">createWriteStream</span>(target);</span><br><span class="line">        stream.<span class="title function_">pipe</span>(writeStream)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">MonitorController</span>;</span><br><span class="line"><span class="comment">//记录日志文件</span></span><br><span class="line"><span class="comment">//增加错误日志</span></span><br><span class="line"><span class="comment">//config/config.defult.js</span></span><br><span class="line">config.<span class="property">customLogger</span> = {</span><br><span class="line">    <span class="attr">frontentLogger</span>: {</span><br><span class="line">        <span class="attr">file</span>: path.<span class="title function_">join</span>(appInfo.<span class="property">root</span>, <span class="string">'logs/fronted.log'</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// app/controller/monitor.js添加日志记录</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">index</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> { ctx } = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> { info } = ctx.<span class="property">query</span></span><br><span class="line">    <span class="keyword">const</span> json = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(info, <span class="string">'base64'</span>).<span class="title function_">toString</span>(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'fronterror:'</span>, json)</span><br><span class="line">    <span class="comment">// 记入错误日志</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="title function_">getLogger</span>(<span class="string">'frontendLogger'</span>).<span class="title function_">error</span>(json)</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e610b7d59a9e4f8995ec570561435e38~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20200206171529549"></p><h2 id="异常分析"><a href="#异常分析" class="headerlink" title="异常分析"></a>异常分析</h2><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h4 id="webpack-插件实现-SourceMap-上传"><a href="#webpack-插件实现-SourceMap-上传" class="headerlink" title="webpack 插件实现 SourceMap 上传"></a>webpack 插件实现 SourceMap 上传</h4><p>在<code>webpack</code>构建时生成<code>sourcemap</code>文件 将文件上传到异常监控服务器</p><h5 id="1-创建-webpack-插件"><a href="#1-创建-webpack-插件" class="headerlink" title="1.创建 webpack 插件"></a>1.创建 webpack 插件</h5><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">"fs"</span>;</span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">"http"</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UploadSourceMapWebpackPlugin</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span> = options;</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) {</span><br><span class="line">    <span class="comment">//在打包完成后执行</span></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">done</span>.<span class="title function_">tap</span>(<span class="string">"upload-sourcemap-plugin"</span>, <span class="keyword">async</span> (status) =&gt; {</span><br><span class="line">      <span class="comment">//读取sourcemap文件</span></span><br><span class="line">      <span class="keyword">const</span> list = glob.<span class="title function_">sync</span>(</span><br><span class="line">        path.<span class="title function_">join</span>(status.<span class="property">compilation</span>.<span class="property">outputOptions</span>.<span class="property">path</span>, <span class="string">"./**/*.${js.map}"</span>)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> filename <span class="keyword">of</span> list) {</span><br><span class="line">        <span class="comment">//依次上传文件</span></span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">upload</span>(<span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">uploadUrl</span>, filename);</span><br><span class="line">      }</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"webapck running"</span>);</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//上传文件的功能</span></span><br><span class="line">  <span class="title function_">upload</span>(<span class="params">url, file</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"upload"</span>, file);</span><br><span class="line">      <span class="keyword">const</span> req = http.<span class="title function_">request</span>(<span class="string">`<span class="subst">${url}</span>?name=<span class="subst">${path.basename(file)}</span>`</span>, {</span><br><span class="line">        <span class="attr">method</span>: <span class="string">"POST"</span>,</span><br><span class="line">        <span class="attr">headers</span>: {</span><br><span class="line">          <span class="string">"Content-Type"</span>: <span class="string">"application/octest-stream"</span>,</span><br><span class="line">          <span class="title class_">Connection</span>: <span class="string">"keep-alive"</span>,</span><br><span class="line">          <span class="string">"Transfer-Encoding"</span>: <span class="string">"chunked"</span>,</span><br><span class="line">        },</span><br><span class="line">      });</span><br><span class="line">      fs.<span class="title function_">createReadStream</span>(file)</span><br><span class="line">        .<span class="title function_">on</span>(<span class="string">"data"</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> {</span><br><span class="line">          req.<span class="title function_">write</span>(chunk);</span><br><span class="line">        })</span><br><span class="line">        .<span class="title function_">on</span>(<span class="string">"end"</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">          req.<span class="title function_">end</span>();</span><br><span class="line">          <span class="title function_">resolve</span>();</span><br><span class="line">        });</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">UploadSourceMapWebpackPlugin</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="2-加载-webpack-插件"><a href="#2-加载-webpack-插件" class="headerlink" title="2.加载 webpack 插件"></a>2.加载 webpack 插件</h5><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">UploadSourceMapWebpackPlugin</span> form <span class="string">'./plugin/uploadSourceMapWebpakcPlugin'</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">//添加自动上传插件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">UploadSourceMapWebpackPlugin</span>({</span><br><span class="line">        <span class="attr">uploadUrl</span>: <span class="string">'https://olddog/monitor/sourcemap'</span>,</span><br><span class="line">        <span class="attr">apiKey</span>: <span class="string">'olddog'</span></span><br><span class="line">    })</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>这样子执行 webpack 打包时调用插件<code>sourcemap</code>将被上传至服务器</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9c533a968594f3d8d6e269aac493d7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20200206202732716"></p><h3 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h3><p>由于<code>vite</code>使用<code>rollup</code>作为模块打包器 所以可以编写<code>rollup</code>插件 在打包完成后读取所有<code>sourcemap</code>上传到后台 并且将打包输出目录中的<code>sourcemap</code>文件删除 减少线上环境的资源请求</p><h4 id="1-编写插件"><a href="#1-编写插件" class="headerlink" title="1.编写插件"></a>1.编写插件</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob <span class="keyword">from</span> <span class="string">'glob'</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> htrp <span class="keyword">from</span> <span class="string">'http'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">uploadSourceMap</span>(<span class="params">{</span></span><br><span class="line"><span class="params">    //基础接口地址</span></span><br><span class="line"><span class="params">    baseUrl,</span></span><br><span class="line"><span class="params">    //处理目标文件夹接口地址</span></span><br><span class="line"><span class="params">    handleTargetFolderUrl,</span></span><br><span class="line"><span class="params">    //上传sourceMap文件地址</span></span><br><span class="line"><span class="params">    uploadUrl</span></span><br><span class="line"><span class="params">}</span>) {</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        <span class="attr">name</span>: <span class="string">'upload-sourcemap'</span>,</span><br><span class="line">        <span class="comment">//打包完成的钩子</span></span><br><span class="line">        <span class="title function_">closeBundle</span>(<span class="params"></span>) {</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'closeBundle'</span>);</span><br><span class="line">            <span class="comment">//获取当前环境</span></span><br><span class="line">            <span class="keyword">let</span> env = <span class="string">'uat'</span>;</span><br><span class="line">            <span class="keyword">if</span>(baseUrl === <span class="string">'生产环境的url'</span>) {</span><br><span class="line">                env = <span class="string">'prod'</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//上传文件的方法</span></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">upload</span>(<span class="params">url, file, env</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> {</span><br><span class="line">                    <span class="keyword">const</span> req = http.<span class="title function_">request</span>(</span><br><span class="line">                        <span class="string">`<span class="subst">${url}</span>?name=<span class="subst">${path.basename(file)}</span>&amp;&amp;env=<span class="subst">${env}</span>`</span>,</span><br><span class="line">                        {</span><br><span class="line">                            <span class="attr">method</span>: <span class="string">'POST'</span>,</span><br><span class="line">                            <span class="attr">headers</span>: {</span><br><span class="line">                                <span class="string">'Content-Type'</span>: <span class="string">'application/octet-stream'</span>,</span><br><span class="line">                                <span class="title class_">Connection</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">                                <span class="string">'Transfer-Encoding'</span>: <span class="string">'chunked'</span></span><br><span class="line">                            },</span><br><span class="line">                        }</span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">//读取文件并给到上传请求的对象</span></span><br><span class="line">                    fs.<span class="title function_">createReadStream</span>(file)</span><br><span class="line">                    .<span class="title function_">on</span>(<span class="string">'data'</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> {</span><br><span class="line">                        req.<span class="title function_">write</span>(chunk)</span><br><span class="line">                    })</span><br><span class="line">                })</span><br><span class="line">                .<span class="title function_">on</span>(<span class="string">'end'</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">                    req.<span class="title function_">end</span>();</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="string">'end'</span>)</span><br><span class="line">                })</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//除了目标文件夹（没有就创建 有就清空）</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">handleTargetFolder</span>(<span class="params"></span>) {</span><br><span class="line">            http.<span class="title function_">get</span>(<span class="string">`<span class="subst">${handleTargetFolderUrl}</span>?env=<span class="subst">${env}</span>`</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'handleTargetFolderUrl success'</span>)</span><br><span class="line">            })</span><br><span class="line">            .<span class="title function_">on</span>(<span class="string">'error'</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> {</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'handle folder err'</span>, e)</span><br><span class="line">            })</span><br><span class="line">        }</span><br><span class="line">    <span class="title function_">handleTargetFolder</span>();</span><br><span class="line">    <span class="comment">//读取sourcemap文件并删除</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">uploadDel</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">const</span> list = glob.<span class="title function_">sync</span>(path.<span class="title function_">join</span>(<span class="string">'./dist'</span>, <span class="string">'./**/*.{js.map}'</span>));<span class="comment">//读取sourcemap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> filename <span class="keyword">of</span> list) {</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">upload</span>(uploadUrl, filename, env);</span><br><span class="line">            <span class="keyword">await</span> fs.<span class="title function_">unlinkSync</span>(filename);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="title function_">uploadDel</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-引入插件并使用"><a href="#2-引入插件并使用" class="headerlink" title="2.引入插件并使用"></a>2.引入插件并使用</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> { loadEnv } <span class="keyword">from</span> <span class="string">"env"</span>;</span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">"@vitejs/plugin-vite"</span>;</span><br><span class="line"><span class="keyword">import</span> uploadSourceMap <span class="keyword">from</span> <span class="string">"./src/plugins/rollup-plugin-upload-sourcemap"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ({ mode }) =&gt; {</span><br><span class="line">  <span class="keyword">const</span> env = <span class="title function_">loadEnv</span>(mode, process.<span class="title function_">cwd</span>());</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">server</span>: {</span><br><span class="line">      <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">      <span class="attr">host</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">      <span class="attr">proxy</span>: {</span><br><span class="line">        <span class="comment">// 本地测试异常监控用</span></span><br><span class="line">        <span class="string">"/mointor"</span>: {</span><br><span class="line">          <span class="attr">target</span>: <span class="string">"http://127.0.0.1:7001"</span>,</span><br><span class="line">          <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        },</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="title function_">vue</span>(),</span><br><span class="line">      <span class="title function_">uploadSourceMap</span>({</span><br><span class="line">        <span class="comment">//基本路径 判断当前环境使用</span></span><br><span class="line">        <span class="attr">baseUrl</span>: env.<span class="property">VITE_BASE_API</span>,</span><br><span class="line">        <span class="comment">//处理目标文件夹接口地址</span></span><br><span class="line">        <span class="attr">handleTargetFolderUrl</span>: <span class="string">`<span class="subst">${env.VITE_MONITOR_UPLOAD_API}</span>/emptyFolder`</span>,</span><br><span class="line">        <span class="comment">// 上传sourcemap文件接口地址</span></span><br><span class="line">        <span class="attr">uploadUrl</span>: <span class="string">`<span class="subst">${env.VITE_MONITOR_UPLOAD_API}</span>/uploadSourceMap`</span>,</span><br><span class="line">      }),</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">build</span>: {</span><br><span class="line">      <span class="comment">//构建后生成sourcemap文件</span></span><br><span class="line">      <span class="attr">sourcemap</span>: <span class="literal">true</span>,</span><br><span class="line">    },</span><br><span class="line">  };</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="3-后台服务接收上传的-sourcemap-文件并保存"><a href="#3-后台服务接收上传的-sourcemap-文件并保存" class="headerlink" title="3.后台服务接收上传的 sourcemap 文件并保存"></a>3.后台服务接收上传的 sourcemap 文件并保存</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">uploadSourcemap</span>(<span class="params"></span>) {</span><br><span class="line"><span class="keyword">const</span> {ctx} = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> stream = ctx.<span class="property">req</span>,</span><br><span class="line">          filename = ctx.<span class="property">query</span>.<span class="property">name</span>,</span><br><span class="line">          env = ctx.<span class="property">query</span>.<span class="property">env</span>;</span><br><span class="line">    <span class="comment">//要上传的目标路径</span></span><br><span class="line">    <span class="keyword">const</span> dir = path.<span class="title function_">join</span>(<span class="variable language_">this</span>.<span class="property">config</span>.<span class="property">baseDir</span>, <span class="string">`upload/<span class="subst">${env)<span class="string">`);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">//目标文件 const target = path.join(dir, filename);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">//写入文件内容 const writeStream = fs.createWriteStream(target)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">stream.pipe(writeStream)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">}</span></span></span></span><br></pre></td></tr></tbody></table></figure><h4 id="4-利用-errorHandler-进行异常捕获并上送报错信息到后台"><a href="#4-利用-errorHandler-进行异常捕获并上送报错信息到后台" class="headerlink" title="4.利用 errorHandler 进行异常捕获并上送报错信息到后台"></a>4.利用 errorHandler 进行异常捕获并上送报错信息到后台</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> handleError <span class="keyword">from</span> <span class="string">'./utils/monitor'</span>;</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line"><span class="comment">//异常监控上送报错信息 接口地址</span></span><br><span class="line"><span class="title function_">handleError</span>(app, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_MOBNITOR_REPORT_API</span>);</span><br><span class="line"><span class="comment">//monitor.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"><span class="comment">// 获取浏览器信息</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getBrowserInfo</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">const</span> agent = navigator.<span class="property">userAgent</span>.<span class="title function_">toLowerCase</span>();</span><br><span class="line">  <span class="keyword">const</span> regIE = <span class="regexp">/msie [\d.]+;/gi</span>;</span><br><span class="line">  <span class="keyword">const</span> regIE11 = <span class="regexp">/rv:[\d.]+/gi</span>;</span><br><span class="line">  <span class="keyword">const</span> regFireFox = <span class="regexp">/firefox/</span>[\d.]+/gi;</span><br><span class="line">  <span class="keyword">const</span> regQQ = <span class="regexp">/qqbrowser/</span>[\d.]+/gi;</span><br><span class="line">  <span class="keyword">const</span> regEdg = <span class="regexp">/edg/</span>[\d.]+/gi;</span><br><span class="line">  <span class="keyword">const</span> regSafari = <span class="regexp">/safari/</span>[\d.]+/gi;</span><br><span class="line">  <span class="keyword">const</span> regChrome = <span class="regexp">/chrome/</span>[\d.]+/gi;</span><br><span class="line">  <span class="comment">// IE10及以下</span></span><br><span class="line">  <span class="keyword">if</span> (regIE.<span class="title function_">test</span>(agent)) {</span><br><span class="line">    <span class="keyword">return</span> agent.<span class="title function_">match</span>(regIE)[<span class="number">0</span>];</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// IE11</span></span><br><span class="line">  <span class="keyword">if</span> (regIE11.<span class="title function_">test</span>(agent)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"IE11"</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// firefox</span></span><br><span class="line">  <span class="keyword">if</span> (regFireFox.<span class="title function_">test</span>(agent)) {</span><br><span class="line">    <span class="keyword">return</span> agent.<span class="title function_">match</span>(regFireFox)[<span class="number">0</span>];</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// QQ</span></span><br><span class="line">  <span class="keyword">if</span> (regQQ.<span class="title function_">test</span>(agent)) {</span><br><span class="line">    <span class="keyword">return</span> agent.<span class="title function_">match</span>(regQQ)[<span class="number">0</span>];</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// Edg</span></span><br><span class="line">  <span class="keyword">if</span> (regEdg.<span class="title function_">test</span>(agent)) {</span><br><span class="line">    <span class="keyword">return</span> agent.<span class="title function_">match</span>(regEdg)[<span class="number">0</span>];</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// Chrome</span></span><br><span class="line">  <span class="keyword">if</span> (regChrome.<span class="title function_">test</span>(agent)) {</span><br><span class="line">    <span class="keyword">return</span> agent.<span class="title function_">match</span>(regChrome)[<span class="number">0</span>];</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// Safari</span></span><br><span class="line">  <span class="keyword">if</span> (regSafari.<span class="title function_">test</span>(agent)) {</span><br><span class="line">    <span class="keyword">return</span> agent.<span class="title function_">match</span>(regSafari)[<span class="number">0</span>];</span><br><span class="line">  }}</span><br><span class="line"><span class="comment">// 捕获报错方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">handleError</span>(<span class="params">Vue,baseUrl</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!baseUrl) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"baseUrl"</span>, baseUrl);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">errorHandler</span> = <span class="function">(<span class="params">err, vm</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// 获取当前环境</span></span><br><span class="line">    <span class="keyword">let</span> environment = <span class="string">"测试环境"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_BASE_API</span> === <span class="string">"production_base_api"</span>) {</span><br><span class="line">      environment = <span class="string">"生产环境"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发送请求上送报错信息</span></span><br><span class="line">    <span class="title function_">axios</span>({</span><br><span class="line">      <span class="attr">method</span>: <span class="string">"post"</span>,</span><br><span class="line">      <span class="attr">url</span>: <span class="string">`<span class="subst">${baseUrl}</span>/reportError`</span>,</span><br><span class="line">      <span class="attr">data</span>: {</span><br><span class="line">        environment,</span><br><span class="line">        <span class="attr">location</span>: <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>,</span><br><span class="line">        <span class="attr">message</span>: err.<span class="property">message</span>,</span><br><span class="line">        <span class="attr">stack</span>: err.<span class="property">stack</span>,</span><br><span class="line">        <span class="comment">// 浏览器信息</span></span><br><span class="line">        <span class="attr">browserInfo</span>: <span class="title function_">getBrowserInfo</span>(),</span><br><span class="line">        <span class="comment">// 以下信息可以放在vuex store中维护</span></span><br><span class="line">        <span class="comment">// 用户ID</span></span><br><span class="line">        <span class="attr">userId</span>:<span class="string">"001"</span>,</span><br><span class="line">        <span class="comment">// 用户名称</span></span><br><span class="line">        <span class="attr">userName</span>:<span class="string">"张三"</span>,</span><br><span class="line">        <span class="comment">// 路由记录</span></span><br><span class="line">        <span class="attr">routerHistory</span>:[</span><br><span class="line">          {</span><br><span class="line">            <span class="attr">fullPath</span>:<span class="string">"/login"</span>,</span><br><span class="line">            <span class="attr">name</span>:<span class="string">"Login"</span>,</span><br><span class="line">            <span class="attr">query</span>:{},</span><br><span class="line">            <span class="attr">params</span>:{},</span><br><span class="line">          },{</span><br><span class="line">            <span class="attr">fullPath</span>:<span class="string">"/home"</span>,</span><br><span class="line">            <span class="attr">name</span>:<span class="string">"Home"</span>,</span><br><span class="line">            <span class="attr">query</span>:{},</span><br><span class="line">            <span class="attr">params</span>:{},</span><br><span class="line">          }</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 点击记录</span></span><br><span class="line">        <span class="attr">clickHistory</span>:[</span><br><span class="line">          {</span><br><span class="line">            <span class="attr">pageX</span>:<span class="number">50</span>,</span><br><span class="line">            <span class="attr">pageY</span>:<span class="number">50</span>,</span><br><span class="line">            <span class="attr">nodeName</span>:<span class="string">"div"</span>,</span><br><span class="line">            <span class="attr">className</span>:<span class="string">"test"</span>,</span><br><span class="line">            <span class="attr">id</span>:<span class="string">"test"</span>,</span><br><span class="line">            <span class="attr">innerText</span>:<span class="string">"测试按钮"</span></span><br><span class="line">          }</span><br><span class="line">        ],</span><br><span class="line">      },</span><br><span class="line">    });</span><br><span class="line">  };}</span><br></pre></td></tr></tbody></table></figure><h4 id="4-后台收到报错结合-sourcemap-文件解析错误通知开发人员"><a href="#4-后台收到报错结合-sourcemap-文件解析错误通知开发人员" class="headerlink" title="4.后台收到报错结合 sourcemap 文件解析错误通知开发人员"></a>4.后台收到报错结合 sourcemap 文件解析错误通知开发人员</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端报错，上报</span></span><br><span class="line">errorasync <span class="title function_">reportError</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">const</span> { ctx } = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> { environment, location, message, stack, browserInfo, userId, userName, routerHistory, clickHistory } = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">  <span class="keyword">let</span> env = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span> (environment === <span class="string">'测试环境'</span>) {</span><br><span class="line">    env = <span class="string">'uat'</span>;</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (environment === <span class="string">'生产环境'</span>) {</span><br><span class="line">    env = <span class="string">'prod'</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 组合sourcemap文件路径</span></span><br><span class="line">  <span class="keyword">const</span> sourceMapDir = path.<span class="title function_">join</span>(<span class="variable language_">this</span>.<span class="property">config</span>.<span class="property">baseDir</span>, <span class="string">`upload/<span class="subst">${env}</span>`</span>);</span><br><span class="line">  <span class="comment">// 解析报错信息</span></span><br><span class="line">  <span class="keyword">const</span> stackParser = <span class="keyword">new</span> <span class="title class_">StackParser</span>(sourceMapDir);</span><br><span class="line">  <span class="keyword">let</span> routerHistoryStr = <span class="string">'&lt;h3&gt;router history&lt;/h3&gt;'</span>,</span><br><span class="line">    clickHistoryStr = <span class="string">'&lt;h3&gt;click history&lt;/h3&gt;'</span>;</span><br><span class="line">    <span class="comment">// 组合路由历史信息</span></span><br><span class="line">  routerHistory &amp;&amp; routerHistory.<span class="property">length</span> &amp;&amp; routerHistory.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> {</span><br><span class="line">    routerHistoryStr += <span class="string">`&lt;p&gt;name:<span class="subst">${item.name}</span> | fullPath:<span class="subst">${item.fullPath}</span>&lt;/p&gt;`</span>;</span><br><span class="line">    routerHistoryStr += <span class="string">`&lt;p&gt;params:<span class="subst">${<span class="built_in">JSON</span>.stringify(item.params)}</span> | query:<span class="subst">${<span class="built_in">JSON</span>.stringify(item.query)}</span>&lt;/p&gt;&lt;p&gt;--------------------&lt;/p&gt;`</span>;</span><br><span class="line">  });</span><br><span class="line">  <span class="comment">// 组合点击历史信息</span></span><br><span class="line">  clickHistory &amp;&amp; clickHistory.<span class="property">length</span> &amp;&amp; clickHistory.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> {</span><br><span class="line">    clickHistoryStr += <span class="string">`&lt;p&gt;pageX:<span class="subst">${item.pageX}</span> | pageY:<span class="subst">${item.pageY}</span>&lt;/p&gt;`</span>;</span><br><span class="line">    clickHistoryStr += <span class="string">`&lt;p&gt;nodeName:<span class="subst">${item.nodeName}</span> | className:<span class="subst">${item.className}</span> | id:<span class="subst">${item.id}</span>&lt;/p&gt;`</span>;</span><br><span class="line">    clickHistoryStr += <span class="string">`&lt;p&gt;innerText:<span class="subst">${item.innerText}</span>&lt;/p&gt;&lt;p&gt;--------------------&lt;/p&gt;`</span>;</span><br><span class="line">  });</span><br><span class="line">  <span class="comment">// 通过上送的sourcemap文件，配合error信息，解析报错信息</span></span><br><span class="line">  <span class="keyword">const</span> errInfo = <span class="keyword">await</span> stackParser.<span class="title function_">parseStackTrack</span>(stack, message);</span><br><span class="line">  <span class="comment">// 获取当前时间</span></span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  <span class="keyword">const</span> time = <span class="string">`<span class="subst">${now.getFullYear()}</span>-<span class="subst">${now.getMonth() + <span class="number">1</span>}</span>-<span class="subst">${now.getDate()}</span> <span class="subst">${now.getHours()}</span>:<span class="subst">${now.getMinutes()}</span>:<span class="subst">${now.getSeconds()}</span>`</span>;</span><br><span class="line">  <span class="comment">// 组织邮件正文</span></span><br><span class="line">  <span class="keyword">const</span> mailMsg = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;h3&gt;message:<span class="subst">${message}</span>&lt;/h3&gt;</span></span><br><span class="line"><span class="string">  &lt;h3&gt;location:<span class="subst">${location}</span>&lt;/h3&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;source:<span class="subst">${errInfo.source}</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;line::<span class="subst">${errInfo.lineNumber}</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;column:<span class="subst">${errInfo.columnNumber}</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;fileName:<span class="subst">${errInfo.fileName}</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;functionName:<span class="subst">${errInfo.functionName}</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;time::<span class="subst">${time}</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;browserInfo::<span class="subst">${browserInfo}</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;userId::<span class="subst">${userId}</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;userName::<span class="subst">${userName}</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">${routerHistoryStr}</span></span></span><br><span class="line"><span class="string">  <span class="subst">${clickHistoryStr}</span></span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  <span class="comment">// sendMail('发件箱地址', '发件箱授权码', '收件箱地址', 主题 environment, 正文 mailMsg);</span></span><br><span class="line">  <span class="title function_">sendMail</span>(<span class="string">'发件箱地址'</span>, <span class="string">'发件箱授权码'</span>, <span class="string">'收件箱地址'</span>, environment, mailMsg);</span><br><span class="line">  ctx.<span class="property">body</span> = {</span><br><span class="line">    <span class="attr">header</span>: {</span><br><span class="line">      <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">'OK'</span>,</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">  ctx.<span class="property">status</span> = <span class="number">200</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="5-发送邮件方法"><a href="#5-发送邮件方法" class="headerlink" title="5.发送邮件方法"></a>5.发送邮件方法</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">"nodemailer"</span>);</span><br><span class="line"><span class="comment">// 发送邮件方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sendMail</span>(<span class="params"><span class="keyword">from</span>, fromPass, receivers, subject, msg</span>) {</span><br><span class="line">  <span class="keyword">const</span> smtpTransport = nodemailer.<span class="title function_">createTransport</span>({</span><br><span class="line">    <span class="attr">host</span>: <span class="string">"smtp.qq.email"</span>,</span><br><span class="line">    <span class="attr">service</span>: <span class="string">"qq"</span>,</span><br><span class="line">    <span class="attr">secureConnection</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// use SSL</span></span><br><span class="line">    <span class="attr">secure</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">465</span>,</span><br><span class="line">    <span class="attr">auth</span>: {</span><br><span class="line">      <span class="attr">user</span>: <span class="keyword">from</span>,</span><br><span class="line">      <span class="attr">pass</span>: fromPass,</span><br><span class="line">    },</span><br><span class="line">  });</span><br><span class="line">  smtpTransport.<span class="title function_">sendMail</span>(</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">from</span>,</span><br><span class="line">      <span class="comment">// 收件人邮箱，多个邮箱地址间用英文逗号隔开</span></span><br><span class="line">      <span class="attr">to</span>: receivers,</span><br><span class="line">      <span class="comment">// 邮件主题</span></span><br><span class="line">      subject,</span><br><span class="line">      <span class="comment">// 邮件正文</span></span><br><span class="line">      <span class="attr">html</span>: msg,</span><br><span class="line">    },</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> {</span><br><span class="line">      <span class="keyword">if</span> (err) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"send mail error: "</span>, err);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = sendMail;</span><br></pre></td></tr></tbody></table></figure><h2 id="根据-sourcemap-分析异常信息"><a href="#根据-sourcemap-分析异常信息" class="headerlink" title="根据 sourcemap 分析异常信息"></a>根据 sourcemap 分析异常信息</h2><p>将分析的功能开发成单独的函数并用 jest 做单元测试</p><p>需求： 输入 -&gt; sourceMap 查找 -&gt; 源码错误栈并返回信息</p><h4 id="1-创建-utils-stackparser-js"><a href="#1-创建-utils-stackparser-js" class="headerlink" title="1.创建/utils/stackparser.js"></a>1.创建/utils/stackparser.js</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">class</span> <span class="title class_">StackParser</span> = {</span><br><span class="line">    <span class="title function_">constroutor</span>(<span class="params">sourceMapDir</span>) {</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">consumers</span> = {}</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sourceMapDir</span> = sourceMapDir</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-反序列-Error-对象"><a href="#2-反序列-Error-对象" class="headerlink" title="2.反序列 Error 对象"></a>2.反序列 Error 对象</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ErrorStackParser</span> = <span class="built_in">require</span>(<span class="string">'error-stack-parser'</span>);</span><br><span class="line"><span class="title function_">parserStackTrack</span>(<span class="params">stack, message</span>) {</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(message)</span><br><span class="line">    error.<span class="property">stack</span> = stack</span><br><span class="line">    <span class="keyword">const</span> stackFrame = <span class="title class_">ErrorStackParser</span>.<span class="title function_">parse</span>(error)</span><br><span class="line">    <span class="keyword">return</span> stackFrame</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-创建测试文件-stackparser-spec-js"><a href="#3-创建测试文件-stackparser-spec-js" class="headerlink" title="3.创建测试文件 stackparser.spec.js"></a>3.创建测试文件 stackparser.spec.js</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">StackParser</span> = <span class="built_in">require</span>(<span class="string">"../stackparser"</span>);</span><br><span class="line"><span class="keyword">const</span> { resolve } = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> error = {</span><br><span class="line">  <span class="attr">stack</span>:</span><br><span class="line">    <span class="string">"ReferenceError: xxx is not defined\n"</span> +</span><br><span class="line">    <span class="string">"    at http://localhost:7001/public/bundle.e7877aa7bc4f04f5c33b.js:1:1392"</span>,</span><br><span class="line">  <span class="attr">message</span>: <span class="string">"Uncaught ReferenceError: xxx is not defined"</span>,</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">"http://localhost:7001/public/bundle.e7877aa7bc4f04f5c33b.js"</span>,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="title function_">it</span>(<span class="string">"stackparser on-the-fly"</span>, <span class="keyword">async</span> () =&gt; {</span><br><span class="line">  <span class="keyword">const</span> stackParser = <span class="keyword">new</span> <span class="title class_">StackParser</span>(__dirname);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断言</span></span><br><span class="line">  <span class="title function_">expect</span>(originStack[<span class="number">0</span>]).<span class="title function_">toMatchObject</span>({</span><br><span class="line">    <span class="attr">source</span>: <span class="string">"webpack:///src/index.js"</span>,</span><br><span class="line">    <span class="attr">line</span>: <span class="number">24</span>,</span><br><span class="line">    <span class="attr">column</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">"xxx"</span>,</span><br><span class="line">  });</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="4-将错误栈中的代码位置转换为源码位置"><a href="#4-将错误栈中的代码位置转换为源码位置" class="headerlink" title="4.将错误栈中的代码位置转换为源码位置"></a>4.将错误栈中的代码位置转换为源码位置</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> {<span class="title class_">SourceMapConsumer</span>} <span class="keyword">from</span> <span class="string">'source-map'</span>;</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getOriginalErrorStack</span>(<span class="params">stckFrame</span>) {</span><br><span class="line">    <span class="keyword">const</span> origin = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> stackFrame) {</span><br><span class="line">        origin.<span class="title function_">push</span>(<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">getOriginPosition</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//销毁所有的comsumenr</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">cosumer</span>).<span class="title function_">forEach</span>( <span class="function"><span class="params">key</span> =&gt;</span> {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'key'</span>, key);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">consumers</span>[key].<span class="title function_">destory</span>()</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">return</span> origin</span><br><span class="line">}</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getOriginPosition</span>(<span class="params">stackFrame</span>) {</span><br><span class="line">    <span class="keyword">let</span> {columnNumber, lineNumber, fileName} = stackFrame;</span><br><span class="line">    fileName = path.<span class="title function_">basename</span>(filename);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'filename'</span>, fileName);</span><br><span class="line">    <span class="comment">//判断是否存在</span></span><br><span class="line">    <span class="keyword">let</span> consumer = <span class="variable language_">this</span>.<span class="property">consumer</span>[fileName];</span><br><span class="line">    <span class="keyword">if</span>( consumer == <span class="literal">undefined</span>) {</span><br><span class="line">        <span class="comment">//读取sourcemap</span></span><br><span class="line">        <span class="keyword">const</span> sourceMapPath = path.<span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">sourceMapDir</span>, fileName + <span class="string">'.map'</span>);</span><br><span class="line">        <span class="comment">//判断目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!fs.<span class="title function_">existsSync</span>(sourceMapPath)) {</span><br><span class="line">            <span class="keyword">return</span> stackFrame</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">const</span> content = fs,<span class="title function_">readFileSync</span>(sourceMap, <span class="string">'utf8'</span>)</span><br><span class="line">        consumer = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">SourceMapConsumer</span>(content, <span class="literal">null</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">consumer</span>[fileName] = consumer</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">const</span> postData = consumer.<span class="title function_">originalPositionFor</span>({<span class="attr">line</span>: lineNumber, <span class="attr">column</span>: columnNumber})</span><br><span class="line">    <span class="keyword">return</span> postData;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将源码位置计入日志</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">index</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="property">log</span></span><br><span class="line">    <span class="keyword">const</span> { ctx } = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> { info } = ctx.<span class="property">query</span></span><br><span class="line">    <span class="keyword">const</span> json = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(info, <span class="string">'base64'</span>).<span class="title function_">toString</span>(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'fronterror:'</span>, json)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为源码位置</span></span><br><span class="line">    <span class="keyword">const</span> stackParser = <span class="keyword">new</span> <span class="title class_">StackParser</span>(path.<span class="title function_">join</span>(<span class="variable language_">this</span>.<span class="property">config</span>.<span class="property">baseDir</span>, <span class="string">'uploads'</span>))</span><br><span class="line">    <span class="keyword">const</span> stackFrame = stackParser.<span class="title function_">parseStackTrack</span>(json.<span class="property">stack</span>, json.<span class="property">message</span>)</span><br><span class="line">    <span class="keyword">const</span> originStack = <span class="keyword">await</span> stackParser.<span class="title function_">getOriginalErrorStack</span>(stackFrame)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="title function_">getLogger</span>(<span class="string">'frontendLogger'</span>).<span class="title function_">error</span>(json,originStack)</span><br><span class="line"></span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">''</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h4 id="5-接下来使用-jest-测试一下"><a href="#5-接下来使用-jest-测试一下" class="headerlink" title="5.接下来使用 jest 测试一下"></a>5.接下来使用 jest 测试一下</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">"stackparser on-the-fly"</span>, <span class="keyword">async</span> () =&gt; {</span><br><span class="line">  <span class="keyword">const</span> stackParser = <span class="keyword">new</span> <span class="title class_">StackParser</span>(__dirname);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Stack:"</span>, error.<span class="property">stack</span>);</span><br><span class="line">  <span class="keyword">const</span> stackFrame = stackParser.<span class="title function_">parseStackTrack</span>(error.<span class="property">stack</span>, error.<span class="property">message</span>);</span><br><span class="line">  stackFrame.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"stackFrame"</span>, v);</span><br><span class="line">  });</span><br><span class="line">  <span class="keyword">const</span> originStack = <span class="keyword">await</span> stackParser.<span class="title function_">getOriginalErrorStack</span>(stackFrame);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断言</span></span><br><span class="line">  <span class="title function_">expect</span>(originStack[<span class="number">0</span>]).<span class="title function_">toMatchObject</span>({</span><br><span class="line">    <span class="attr">source</span>: <span class="string">"webpack:///src/index.js"</span>,</span><br><span class="line">    <span class="attr">line</span>: <span class="number">24</span>,</span><br><span class="line">    <span class="attr">column</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">"xxx"</span>,</span><br><span class="line">  });</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eeact/Vue的Diff算法</title>
      <link href="/2022/10/25/kuang-jia-de-diff-suan-fa/"/>
      <url>/2022/10/25/kuang-jia-de-diff-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p><code>React16</code>之前是直接递归渲染 <code>vdom</code> <code>setState</code>会触发重新渲染 对比渲染出的新旧<code>vdom</code> 对差异部分进行 dom 操作</p><p><code>React16</code>之后 为了性能优化 会先将 <code>vdom</code>转换为<code>fiber</code> （从树转换成链表） 然后在渲染</p><ul><li><code>render</code>阶段： 从<code>vdom</code>转换为 <code>fiber</code> 并且对需要 dom 操作的节点打上 <code>effectTag</code>的标记</li><li><code>commit</code>阶段： 对有 <code>effectTag</code>标记的 <code>fiber</code>节点进行 dom 操作 并执行所有的<code>effect</code>副作用函数</li></ul><blockquote><p>从<code>vdom</code>转换成<code>fiber</code>这个阶段叫做调和（<code>reconcile</code>） 由<code>scheduler</code>调度执行 是可以打断的</p></blockquote><p><code>diff</code>算法作用在<code>reconcile</code>阶段 第一次渲染不需要<code>diff</code> 直接<code>vdom</code>转 <code>fiber</code> 再次渲染的时候 会产生新的<code>vdom</code> 这个时候就要和之前的 <code>fiber</code>进行对比决定如何产生新的<code>fiber</code> 对于可复用的节点打上修改标记 剩余的旧节点打上删除的标记 新节点打上新增标记</p><blockquote><p>打上<code>effectTag</code>可以标识这个<code>fiber</code>发生了怎么样的变化（新增、更新、删除） 这些被打上标记的<code>fiber</code>会在<code>complete</code>阶段被收集起来 形成一个<code>effectList</code>链表 只包含这些需要操作的<code>fiber</code> 最后在<code>commit</code>阶段被更新掉</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3976e170f634ab4a8a79583b47236c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><h2 id="Diff-的主体"><a href="#Diff-的主体" class="headerlink" title="Diff 的主体"></a>Diff 的主体</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">workInProgress.<span class="property">child</span> = <span class="title function_">reconcileChildFibers</span>(</span><br><span class="line">  workInProgress, <span class="comment">//作为父节点传入 新生成的第一个fiber的return会指向它</span></span><br><span class="line">  current.<span class="property">child</span>, <span class="comment">//旧fiber节点 diff生成新的fiber节点时会用新生成的ReactElement和它比较</span></span><br><span class="line">  nextChildren, <span class="comment">//新生成的ReactElement 会以它为标准生成新的fiber节点</span></span><br><span class="line">  renderLanes <span class="comment">//本次渲染的优先级 最终会挂载到新fiber的lanes属性上</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><h2 id="Diff-的基本原则"><a href="#Diff-的基本原则" class="headerlink" title="Diff 的基本原则"></a>Diff 的基本原则</h2><p>场景有节点自身更新 节点增删 节点移动等三种情况</p><ul><li>即使两个元素的子树完全一样 但前后父级元素不同 按照规则 div 元素及其子树会完全销毁 并重建新的一个 p 元素及其子树 不会尝试复用子树</li><li>使用标签名（<code>tag</code>）和<code>key</code>识别节点 区分出前后的节点是否变化 以达到尽量复用无变化的节点（React 可以根据 <code>tag</code>和<code>key</code>来判断节点只是位置发生了变化来复用）</li></ul><blockquote><p>每轮循环都是自左向右进行查找比对的</p></blockquote><h2 id="Diff-使用场景"><a href="#Diff-使用场景" class="headerlink" title="Diff 使用场景"></a>Diff 使用场景</h2><h3 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h3><h4 id="单节点更新以及增删"><a href="#单节点更新以及增删" class="headerlink" title="单节点更新以及增删"></a>单节点更新以及增删</h4><p>即在<code>tag</code>和<code>key</code>相同的情况下 节点的属性发生了变化 就是节点更新 如果节点的<code>tag | key</code> 不同 则新旧节点没有关系</p><p>单节点指<code>newChildren</code>为单一节点 但是<code>oldFiber</code>的数量不一定</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="attr">old</span>: A <span class="attr">new</span>: A</span><br><span class="line"><span class="number">2.</span><span class="attr">old</span>: A - B - C <span class="attr">new</span>: B</span><br><span class="line"><span class="number">3.</span><span class="attr">old</span>: --  <span class="attr">new</span>: A</span><br></pre></td></tr></tbody></table></figure><p>对于单节点 其实只有更新操作 对 React 来说只有两种情况 即 oldFiber 是否为空</p><ul><li><p><code>oldFiber</code>不为空</p><p>遍历它们 找到<code>key和tag</code>相同的节点 然后删除剩下的<code>oldFiber</code>节点 再用匹配的<code>oldFiber</code>，<code>newChildren</code>中的新节点的<code>props</code>来生成新的<code>fiber</code>节点</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先删除剩下的oldFiber节点</span></span><br><span class="line"><span class="title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="property">sibling</span>);</span><br><span class="line"><span class="comment">// 基于oldFiber节点和新节点的props新建新的fiber节点</span></span><br><span class="line"><span class="keyword">const</span> existing = <span class="title function_">useFiber</span>(child, element.<span class="property">props</span>);</span><br><span class="line">existing.<span class="property">ref</span> = <span class="title function_">coerceRef</span>(returnFiber, child, element);</span><br><span class="line">existing.<span class="property">return</span> = returnFiber;</span><br><span class="line"><span class="keyword">return</span> existing;</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>oldFiber</code>为空</p><p>对于没有<code>oldFibe</code>节点的情况 只能新增 <code>newFiber</code>节点</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> created = <span class="title function_">createFiberFromElement</span>(element, returnFiber.<span class="property">mode</span>, lanes);</span><br><span class="line">created.<span class="property">ref</span> = <span class="title function_">coerceRef</span>(returnFiber, currentFirstChild, element);</span><br><span class="line">created.<span class="property">return</span> = returnFiber;</span><br><span class="line"><span class="keyword">return</span> created;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="多节点"><a href="#多节点" class="headerlink" title="多节点"></a>多节点</h3><p>多节点分为节点更新、新增节点、删除节点、节点移动四种情况 调用 <code>reconcileChildrenArray</code>进行<code>diff</code> 它会以<code>newChildren</code>为主体进行最多三轮遍历 即第一轮从头开始 之后每一轮都是上一轮结束的断点继续</p><blockquote><p>在平时的实践中 节点自身的更新是最频繁的 所以<code>diff</code>算法会优先处理更新的节点 所以第一轮是针对节点自身属性的更新 后面两轮依次处理节点的新增、移动</p></blockquote><h4 id="节点更新"><a href="#节点更新" class="headerlink" title="节点更新"></a>节点更新</h4><p>第一轮从头开始遍历 <code>newChildren</code> 逐个和 <code>oldFiber</code>链中的节点进行比较 判断节点的 <code>key |tag</code>是否有变化</p><ul><li>没变则从<code>oldFiber</code>节点<code>clone</code>一个<code>props</code>被更新的<code>fiber</code>节点 新的节点来自于<code>newChildren</code>中的新节点 实现节点更新</li><li>有变化则说明不满足复用条件 立即中断遍历进入下边的遍历 （diff 算法的复杂度也因为这个操作大幅降低）</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新节点，对于DOM节点来说，updateSlot内部会判断</span></span><br><span class="line"><span class="comment">// key 和 tag。任意一个不同，则返回null</span></span><br><span class="line"><span class="keyword">const</span> newFiber = <span class="title function_">updateSlot</span>( returnFiber,</span><br><span class="line">  oldFiber,</span><br><span class="line">  newChildren[newIdx],</span><br><span class="line">  lanes,</span><br><span class="line">);</span><br><span class="line"><span class="comment">// newFiber为null则说明当前的节点不是更新的场景，中止这一轮循环</span></span><br><span class="line"><span class="keyword">if</span> (newFiber === <span class="literal">null</span>) {</span><br><span class="line">  <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) {</span><br><span class="line">     oldFiber = nextOldFiber;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg： old: a -b-c-d newChildren: a-b-d-c</span></span><br><span class="line"><span class="number">1.</span>第一轮遍历中 ab都是一样的 可以复用 在d这里跳出第一轮循环 这里的最后一个可复用的节点 即b（lastPlacedIndex ）是下一轮循环的移动节点参照物</span><br><span class="line"><span class="comment">//跳出逻辑</span></span><br><span class="line">....</span><br><span class="line"><span class="comment">//如果不跳出 记录最新的固定节点的位置</span></span><br><span class="line">lastPlacedIndex = <span class="title function_">placedChild</span>(newFiber, lastPlacedIndex, newIndex)</span><br><span class="line"><span class="comment">//当节点无需移动的时候 会返回当前节点的位置 对于固定节点来说 就是返回自身的index</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h4><p>遍历 <code>newChildren</code> 当它遍历结束但是 <code>oldFiber</code>链还没遍历完 说明剩下的节点都要被删除 可以直接在<code>oldFiber</code>的节点上打上 <code>Delection</code>的删除标记理删除</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newIdx === newChildren.<span class="property">length</span>) {</span><br><span class="line">  <span class="comment">// 新子节点遍历完，说明剩下的oldFiber都是没用的了，可以删除</span></span><br><span class="line">  <span class="title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//删除不仅仅是标记了删除标记 而且还会将这个被删除的 fiber节点添加到父级的effectList中</span></span><br></pre></td></tr></tbody></table></figure><h4 id="节点新增"><a href="#节点新增" class="headerlink" title="节点新增"></a>节点新增</h4><p>当<code>oldFiber</code>链遍历完 但<code>newChildren</code>还没遍历完 那么余下的节点都属于新插入的节点 会新建<code>fiber</code>节点并以<code>sibling</code>为指针连成 <code>fiber</code>链</p><h4 id="节点移动"><a href="#节点移动" class="headerlink" title="节点移动"></a>节点移动</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//old: a-b-c-d-e-f new: a-b-d-c-e</span><br><span class="line">第一轮 发现固定节点为ab 此时oldFiber为CDEF newChildren为 DCE</span><br><span class="line">之后将oldFiber节点放入一个以key为键的map中 existingChildren</span><br><span class="line">newChildren中剩余的节点 都是不确定是否要移动的 所以遍历它们 每一个去看看这个节点在oldFiber中的旧位置 遍历到它在newChildren中的新位置</span><br><span class="line">如果旧位置在lastPlacedIndex的右边 说明这个节点不变</span><br><span class="line">如果旧节点在左边 而新节点在右边 说明位置没变化 更新新的lastPlacedIndex</span><br><span class="line">如果旧位置在右边 而新位置也在右边 说明位置不变 更新lasyPlacedIndex</span><br><span class="line">如果旧位置在lastPlacedIndex的左边，当前这个节点的位置要往右挪。</span><br><span class="line">原因是旧位置在lastPlacedIndex的左边，新位置却在lastPlacedIndex的右边，所以它要往右挪，但它不是固定节点。此时无需更新lastPlacedIndex</span><br><span class="line">//过程</span><br><span class="line"></span><br><span class="line">1. 最右侧固定节点为b lastPlacedIndex为1 existingChildren {c: '节点c' d: '节点d'， e: "节点e"， f： “节点f”}</span><br><span class="line">2. newchildren DCE继续遍历 首先遍历D D在oldFiber中为3 3&gt;1 oldFiber中D的位置在B的右边 newCHildren也是如此 所以D的位置不动 此时最新的节点变为D lasyPlacedIndex为3 并从existingChildren删除D</span><br><span class="line">3.再遍历到c c在oldFiber中的位置是2 2 &lt; 3 c原来在d的左边 而newChildren中的c在d的右边 所以要将它移动到右边 并从 existingChildren 中删除c</span><br><span class="line">4.再遍历到e e在oldFiber中的位置是4 4 &gt; 3 所以e的位置不懂 最新的固定点变成e 从 existingChildren中删除e</span><br><span class="line">5.newChildren中的节点都处理完了 针对移动节点的遍历结束 existingFiber中还有f节点 直接删除就好</span><br></pre></td></tr></tbody></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>第一轮遍历 一一对比<code>vdom</code>和<code>oldFiber</code> 如果可以复用就处理下一节点 否则就结束遍历<ul><li>​ 如果所有新的<code>vdom</code>都处理完了 就把剩下的<code>fiber</code>节点删除掉就行</li><li>如果还有<code>vdom</code>没有处理 就就行第二次遍历</li></ul></li><li>第二轮遍历 把<code>oldFiber</code>中的<code>lastPlacedIndex</code>之后的节点放入 <code>existingChildren</code>的 <code>map</code>中 遍历剩下的<code>vdom</code> 从<code>map</code>中查找 如果找到了 在判断是否需要移动 （是否需要移动都需要在查找后从<code>map</code>中删除该节点）</li><li>第二轮遍历后 就将剩余的<code>oldFiber</code>删除掉 剩余的<code>vdom</code>新增</li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildrenArray</span>(<span class="params"></span></span><br><span class="line"><span class="params">  returnFiber: Fiber,</span></span><br><span class="line"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  newChildren: <span class="built_in">Array</span>&lt;*&gt;,</span></span><br><span class="line"><span class="params">  lanes: Lanes</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> {</span><br><span class="line">  <span class="comment">/* * returnFiber：currentFirstChild的父级fiber节点</span></span><br><span class="line"><span class="comment">   * currentFirstChild：当前执行更新任务的WIP（fiber）节点</span></span><br><span class="line"><span class="comment">   * newChildren：组件的render方法渲染出的新的ReactElement节点</span></span><br><span class="line"><span class="comment">   * lanes：优先级相关</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// resultingFirstChild是diff之后的新fiber链表的第一个fiber。</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">resultingFirstChild</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// resultingFirstChild是新链表的第一个fiber。</span></span><br><span class="line">  <span class="comment">// previousNewFiber用来将后续的新fiber接到第一个fiber之后</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">previousNewFiber</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// oldFiber节点，新的child节点会和它进行比较</span></span><br><span class="line">  <span class="keyword">let</span> oldFiber = currentFirstChild;</span><br><span class="line">  <span class="comment">// 存储固定节点的位置</span></span><br><span class="line">  <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 存储遍历到的新节点的索引</span></span><br><span class="line">  <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 记录目前遍历到的oldFiber的下一个节点</span></span><br><span class="line">  <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该轮遍历来处理节点更新，依据节点是否可复用来决定是否中断遍历</span></span><br><span class="line">  <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) {</span><br><span class="line">    <span class="comment">// newChildren遍历完了，oldFiber链没有遍历完，此时需要中断遍历</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber.<span class="property">index</span> &gt; newIdx) {</span><br><span class="line">      nextOldFiber = oldFiber;</span><br><span class="line">      oldFiber = <span class="literal">null</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 用nextOldFiber存储当前遍历到的oldFiber的下一个节点</span></span><br><span class="line">      nextOldFiber = oldFiber.<span class="property">sibling</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 生成新的节点，判断key与tag是否相同就在updateSlot中</span></span><br><span class="line">    <span class="comment">// 对DOM类型的元素来说，key 和 tag都相同才会复用oldFiber</span></span><br><span class="line">    <span class="comment">// 并返回出去，否则返回null</span></span><br><span class="line">    <span class="keyword">const</span> newFiber = <span class="title function_">updateSlot</span>(</span><br><span class="line">      returnFiber,</span><br><span class="line">      oldFiber,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      lanes</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newFiber为 null说明 key 或 tag 不同，节点不可复用，中断遍历</span></span><br><span class="line">    <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// oldFiber 为null说明oldFiber此时也遍历完了</span></span><br><span class="line">        <span class="comment">// 是以下场景，D为新增节点</span></span><br><span class="line">        <span class="comment">// 旧 A - B - C</span></span><br><span class="line">        <span class="comment">// 新 A - B - C - D oldFiber = nextOldFiber;</span></span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) {</span><br><span class="line">      <span class="comment">// shouldTrackSideEffects 为true表示是更新过程</span></span><br><span class="line">      <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.<span class="property">alternate</span> === <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// newFiber.alternate 等同于 oldFiber.alternate</span></span><br><span class="line">        <span class="comment">// oldFiber为WIP节点，它的alternate 就是 current节点</span></span><br><span class="line">        <span class="comment">// oldFiber存在，并且经过更新后的新fiber节点它还没有current节点,</span></span><br><span class="line">        <span class="comment">// 说明更新后展现在屏幕上不会有current节点，而更新后WIP</span></span><br><span class="line">        <span class="comment">// 节点会称为current节点，所以需要删除已有的WIP节点</span></span><br><span class="line">        <span class="title function_">deleteChild</span>(returnFiber, oldFiber);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 记录固定节点的位置</span></span><br><span class="line">    lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">    <span class="comment">// 将新fiber连接成以sibling为指针的单向链表</span></span><br><span class="line">    <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) {</span><br><span class="line">      resultingFirstChild = newFiber;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      previousNewFiber.<span class="property">sibling</span> = newFiber;</span><br><span class="line">    }</span><br><span class="line">    previousNewFiber = newFiber;</span><br><span class="line">    <span class="comment">// 将oldFiber节点指向下一个，与newChildren的遍历同步移动</span></span><br><span class="line">    oldFiber = nextOldFiber;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理节点删除。新子节点遍历完，说明剩下的oldFiber都是没用的了，可以删除.</span></span><br><span class="line">  <span class="keyword">if</span> (newIdx === newChildren.<span class="property">length</span>) {</span><br><span class="line">    <span class="comment">// newChildren遍历结束，删除掉oldFiber链中的剩下的节点</span></span><br><span class="line">    <span class="title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理新增节点。旧的遍历完了，能复用的都复用了，所以意味着新的都是新插入的了</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) {</span><br><span class="line">      <span class="comment">// 基于新生成的ReactElement创建新的Fiber节点</span></span><br><span class="line">      <span class="keyword">const</span> newFiber = <span class="title function_">createChild</span>(returnFiber, newChildren[newIdx], lanes);</span><br><span class="line">      <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 记录固定节点的位置lastPlacedIndex</span></span><br><span class="line">      lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="comment">// 将新生成的fiber节点连接成以sibling为指针的单向链表</span></span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) {</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        previousNewFiber.<span class="property">sibling</span> = newFiber;</span><br><span class="line">      }</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 执行到这是都没遍历完的情况，把剩余的旧子节点放入一个以key为键,值为oldFiber节点的map中</span></span><br><span class="line">  <span class="comment">// 这样在基于oldFiber节点新建新的fiber节点时，可以通过key快速地找出oldFiber</span></span><br><span class="line">  <span class="keyword">const</span> existingChildren = <span class="title function_">mapRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 节点移动</span></span><br><span class="line">  <span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) {</span><br><span class="line">    <span class="comment">// 基于map中的oldFiber节点来创建新fiber</span></span><br><span class="line">    <span class="keyword">const</span> newFiber = <span class="title function_">updateFromMap</span>(</span><br><span class="line">      existingChildren,</span><br><span class="line">      returnFiber,</span><br><span class="line">      newIdx,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      lanes</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">if</span> (shouldTrackSideEffects) {</span><br><span class="line">        <span class="keyword">if</span> (newFiber.<span class="property">alternate</span> !== <span class="literal">null</span>) {</span><br><span class="line">          <span class="comment">// 因为newChildren中剩余的节点有可能和oldFiber节点一样,只是位置换了，</span></span><br><span class="line">          <span class="comment">// 但也有可能是是新增的.</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果newFiber的alternate不为空，则说明newFiber不是新增的。</span></span><br><span class="line">          <span class="comment">// 也就说明着它是基于map中的oldFiber节点新建的,意味着oldFiber已经被使用了,所以需</span></span><br><span class="line">          <span class="comment">// 要从map中删去oldFiber</span></span><br><span class="line">          existingChildren.<span class="title function_">delete</span>(</span><br><span class="line">            newFiber.<span class="property">key</span> === <span class="literal">null</span> ? newIdx : newFiber.<span class="property">key</span></span><br><span class="line">          );</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 移动节点，多节点diff的核心，这里真正会实现节点的移动</span></span><br><span class="line">      lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="comment">// 将新fiber连接成以sibling为指针的单向链表</span></span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) {</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        previousNewFiber.<span class="property">sibling</span> = newFiber;</span><br><span class="line">      }</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (shouldTrackSideEffects) {</span><br><span class="line">    <span class="comment">// 此时newChildren遍历完了，该移动的都移动了，那么删除剩下的oldFiber</span></span><br><span class="line">    existingChildren.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> <span class="title function_">deleteChild</span>(returnFiber, child));</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="vue2Diff-双端比较"><a href="#vue2Diff-双端比较" class="headerlink" title="vue2Diff 双端比较"></a>vue2Diff 双端比较</h2><p>即新列表和旧列表两个列表的头尾互相比对 在比对的过程中逐渐向内靠拢 知道某一个列表的所有节点全部遍历过 对比停止（即将复杂的变化情况留在中间位置）</p><h3 id="算法规则"><a href="#算法规则" class="headerlink" title="算法规则"></a>算法规则</h3><ol><li>如果新节点有子节点而老节点没有 则判断老节点是否有文本内容 如果有就清空老节点的文本内容 然后为其新增子节点</li><li>如果新节点没有子节点而老节点有子节点 则先删除老节点的子节点 然后设置文本内容</li><li>如果新节点没有子节点 而老节点也没有子节点 则进行文本的对比 然后设置其文本内容</li><li>如果新节点有子节点 老节点也有子节点 则进行新老子节点的比对 然后进行新增 移动 删除 修改等操作 也是<code>diff</code>算法操作的情况</li></ol><h3 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h3><p>在页面首次渲染时会调用一次<code>patch</code>并创建新的 <code>vdom</code> 但是这个时候不会使用<code>diff</code>算法进行更深层次的比较</p><p>之后在组件的状态数据发生改变时 会触发<code>setter</code>并通过 Notify 通知<code>Watcher</code> 对应的<code>Watcher</code>会通知更新并执行更新函数 会执行<code>render</code>函数获取新的<code>vDom</code> 然后执行<code>patch</code>对比上次渲染的结果和<code>oldVdom</code> 并计算出最小的变化 然后再更根据这个最小的变化去更新真实的<code>dom</code></p><h3 id="实现描述"><a href="#实现描述" class="headerlink" title="实现描述"></a>实现描述</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//vue/src/core/vdom/path.js</span><br><span class="line">let oldStartIdx, oldEndIdx, newStartIdx, newEndIdx ;//分别用来表示新旧vnode的首尾索引</span><br><span class="line">//当 oldStartIdx &gt; oldEndIdx 表示旧vdom已经遍历完成 接下来是新增vdom的操作</span><br><span class="line">//当 newStartIdx &gt; newEndIdx 表示新vdom已经遍历完成 直接对剩余的旧vdom进行删除操作就行</span><br></pre></td></tr></tbody></table></figure><p>先对以下四种情况做优化策略</p><ul><li><code>oldStartIdx / newStartIdx</code></li><li><code>oldEndIdx / newEndIdx</code></li><li><code>oldStartIdx / newEndIdx</code></li><li><code>oldEndIdx / newStartIdx</code></li></ul><p>如果以上的情况都没找到 则从新数组的第一个节点去老数组中查找 找到了就递归更新 没找到就创建新节点</p><p>最后循环结束后 需要对未处理的节点进行处理 如果是老节点列表先循环完毕 这个时候如果新节点列表还有剩余的节点 则说明这些节点直接创建并插入到<code>Dom</code>中就行了 如果新节点列表先循环完毕 而老节点列表还有剩余节点 则说明这些节点都是要被废弃的节点 直接批量删除就好了</p><h3 id="Diff-算法的优化"><a href="#Diff-算法的优化" class="headerlink" title="Diff 算法的优化"></a>Diff 算法的优化</h3><h5 id="1-只比较同一层级-不跨级比较"><a href="#1-只比较同一层级-不跨级比较" class="headerlink" title="1.只比较同一层级 不跨级比较"></a>1.只比较同一层级 不跨级比较</h5><p><code>Diff</code>过程只会对同一层级的<code>DOM</code>进行比较来简化比较次数</p><p><img src="https://pic.lxtlovely.top/XUXI/image-20221023210939892.png" alt="image-20221023210939892"></p><h5 id="2-通过-tag-以及-key"><a href="#2-通过-tag-以及-key" class="headerlink" title="2.通过 tag 以及 key"></a>2.通过 tag 以及 key</h5><h6 id="1-tag"><a href="#1-tag" class="headerlink" title="1.tag"></a>1.tag</h6><p>如果同一层的 tag 不同 则直接移除老的<code>DOM</code>对应的节点</p><h6 id="2-key"><a href="#2-key" class="headerlink" title="2.key"></a>2.key</h6><p>如果<code>tag &amp;&amp; key</code> 相同 则认为是相同的节点 不会继续按照这个树结构做深度比较</p><p><strong>key 的作用</strong></p><ul><li><code>key</code> 可以精确的找到相同的新旧虚拟节点 可以加快 patch 过程 更高效地更新虚拟<code>DOM</code></li><li>如果<code>patch</code>的时候发现<code>key</code>值不同 则会直接认为不是相同的节点 所以如果<code>key</code>值不唯一 可能会有一些隐藏的 bug 比如对列表数据进行增删 还有使用相同标签元素进行过度切换的时候 会导致只替换内部属性而不会触发过渡效果</li></ul><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) {</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode)) {</span><br><span class="line">    <span class="comment">//如果vnode不存在而旧的oldVnode存在 则直接删除旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode)) <span class="title function_">invokeDestroyHook</span>(oldVnode);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//初始化不是首次false</span></span><br><span class="line">  <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue = [];</span><br><span class="line">  <span class="comment">//如果旧虚拟dom不存在而新虚拟dom存在 则直接创建新虚拟dom并插入 比如第一次渲染</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode)) {</span><br><span class="line">    isInitialPatch = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">createElm</span>(vnode, insertedVnodeQueue);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">//如果新旧节点都存在的话</span></span><br><span class="line">    <span class="keyword">const</span> isRealElement = <span class="title function_">isDef</span>(oldVnode.<span class="property">nodeType</span>);</span><br><span class="line">    <span class="keyword">if</span> (!isRealElement &amp;&amp; <span class="title function_">sameVnode</span>(oldVnode, vnode)) {</span><br><span class="line">      <span class="comment">// patch existing root node</span></span><br><span class="line">      <span class="comment">//如果新旧节点是统一节点则通过patchVnode进行后续的比较</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (isRealElement) {</span><br><span class="line">        <span class="comment">//如果是元素节点且是服务端渲染的话（nodeType == 1表示服务端渲染）</span></span><br><span class="line">        <span class="keyword">if</span> (oldVnode.<span class="property">nodeType</span> === <span class="number">1</span> &amp;&amp; oldVnode.<span class="title function_">hasAttribute</span>(<span class="variable constant_">SSR_ATTR</span>)) {</span><br><span class="line">          oldVnode.<span class="title function_">removeAttribute</span>(<span class="variable constant_">SSR_ATTR</span>); <span class="comment">//删掉这个属性 并用hydrating表示服务端渲染</span></span><br><span class="line">          hydrating = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isTrue</span>(hydrating)) {</span><br><span class="line">          <span class="comment">//如果是服务端渲染 则使用hydrating将oldNode和realElement混合</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">hydrate</span>(oldVnode, vnode, insertedVnodeQueue)) {</span><br><span class="line">            <span class="title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> oldVnode;</span><br><span class="line">          } <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">"production"</span>) {</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">              <span class="string">"The client-side rendered virtual DOM tree is not matching "</span> +</span><br><span class="line">                <span class="string">"server-rendered content. This is likely caused by incorrect "</span> +</span><br><span class="line">                <span class="string">"HTML markup, for example nesting block-level elements inside "</span> +</span><br><span class="line">                <span class="string">"&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing "</span> +</span><br><span class="line">                <span class="string">"full client-side render."</span></span><br><span class="line">            );</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// either not server-rendered, or hydration failed.</span></span><br><span class="line">        <span class="comment">// create an empty node and replace it</span></span><br><span class="line">        <span class="comment">//如果不是服务端渲染或者混合失败 就创建一个空的注释节点替换oldVnode</span></span><br><span class="line">        oldVnode = <span class="title function_">emptyNodeAt</span>(oldVnode);</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">//获取oldVnode的父节点</span></span><br><span class="line">      <span class="comment">// replacing existing element</span></span><br><span class="line">      <span class="keyword">const</span> oldElm = oldVnode.<span class="property">elm</span>;</span><br><span class="line">      <span class="keyword">const</span> parentElm = nodeOps.<span class="title function_">parentNode</span>(oldElm);</span><br><span class="line">      <span class="comment">//根据新的vnode创建一个DOM节点 挂在到父节点上</span></span><br><span class="line">      <span class="comment">// create new node</span></span><br><span class="line">      <span class="title function_">createElm</span>(</span><br><span class="line">        vnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">        <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">        <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">        oldElm.<span class="property">_leaveCb</span> ? <span class="literal">null</span> : parentElm,</span><br><span class="line">        nodeOps.<span class="title function_">nextSibling</span>(oldElm)</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">//如果新的vnode的根节点存在 说明根节点被修改了 那么就要遍历更新父节点</span></span><br><span class="line">      <span class="comment">// update parent placeholder node element, recursively</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">parent</span>)) {</span><br><span class="line">        <span class="keyword">let</span> ancestor = vnode.<span class="property">parent</span>;</span><br><span class="line">        <span class="keyword">const</span> patchable = <span class="title function_">isPatchable</span>(vnode);</span><br><span class="line">        <span class="keyword">while</span> (ancestor) {</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.<span class="property">destroy</span>.<span class="property">length</span>; ++i) {</span><br><span class="line">            cbs.<span class="property">destroy</span>[i](ancestor);</span><br><span class="line">          }</span><br><span class="line">          ancestor.<span class="property">elm</span> = vnode.<span class="property">elm</span>;</span><br><span class="line">          <span class="keyword">if</span> (patchable) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.<span class="property">create</span>.<span class="property">length</span>; ++i) {</span><br><span class="line">              cbs.<span class="property">create</span>[i](emptyNode, ancestor);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// #6513</span></span><br><span class="line">            <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></span><br><span class="line">            <span class="comment">// e.g. for directives that uses the "inserted" hook.</span></span><br><span class="line">            <span class="keyword">const</span> insert = ancestor.<span class="property">data</span>.<span class="property">hook</span>.<span class="property">insert</span>;</span><br><span class="line">            <span class="keyword">if</span> (insert.<span class="property">merged</span>) {</span><br><span class="line">              <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.<span class="property">fns</span>.<span class="property">length</span>; i++) {</span><br><span class="line">                insert.<span class="property">fns</span>[i]();</span><br><span class="line">              }</span><br><span class="line">            }</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">            <span class="title function_">registerRef</span>(ancestor);</span><br><span class="line">          }</span><br><span class="line">          ancestor = ancestor.<span class="property">parent</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// destroy old node</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(parentElm)) {</span><br><span class="line">        <span class="title function_">removeVnodes</span>([oldVnode], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">tag</span>)) {</span><br><span class="line">        <span class="title function_">invokeDestroyHook</span>(oldVnode);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, isInitialPatch);</span><br><span class="line">  <span class="keyword">return</span> vnode.<span class="property">elm</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//sameVnode 用来判断是不是同一个节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span>(<span class="params">a, b</span>) {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    (a.<span class="property">key</span> === b.<span class="property">key</span> &amp;&amp;</span><br><span class="line">      (a.<span class="property">asyncFactory</span> == b.<span class="property">asyncFactory</span>) &amp; <span class="comment">//是不是异步组件</span></span><br><span class="line">        (a.<span class="property">tag</span> === b.<span class="property">tag</span> &amp;&amp;</span><br><span class="line">          a.<span class="property">isComment</span> == b.<span class="property">isComment</span> &amp;&amp;</span><br><span class="line">          <span class="title function_">isDef</span>(a.<span class="property">data</span>) == <span class="title function_">isDef</span>(b.<span class="property">data</span>) &amp;&amp; <span class="comment">//内容数据是不是一样</span></span><br><span class="line">          <span class="title function_">sameInputeType</span>(a, b))) || <span class="comment">//判断input的type是不是一样</span></span><br><span class="line">    (<span class="title function_">isTrue</span>(a.<span class="property">isAsyncPlaceholder</span>) &amp;&amp; <span class="title function_">isUndef</span>(b.<span class="property">isAsyncFactory</span>.<span class="property">error</span>))</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>patchVnode 方法的源码</strong></p><p>这是在新的 vnode 和 oldVnode 是同一节点的情况下 才会执行的函数 主要对比节点文本变化或子节点变化</p><ul><li>如果<code>oldVnode</code>和 <code>vnode</code>的引用地址是一样的 就表示节点没有变化 直接返回</li><li>如果 <code>oldVnode &amp;&amp; isAsyncPlaceholder</code> 则跳过异步组件的检查 直接返回</li><li>如果<code>oldVnode</code>和<code>vnode</code>都是静态节点且有唯一的<code>key</code> 并且<code>vnode</code>是克隆节点或者<code>v-once</code>控制节点时 将<code>oldVnode.elm</code>和 <code>oldVnode.child</code>都复制到<code>vnode</code>上 然后返回</li><li>如果<code>vnode</code>不是文本节点也不是注释的情况下<ul><li>如果<code>vnode</code>和 <code>oldVnode</code>都有子节点 并且子节点不一样 就使用 <code>updateChildren</code>更新节点</li><li>如果只有<code>vnode</code>有子节点 就直接使用<code>addVnodes</code>创建子节点</li><li>如果只有``oldVnode<code>有子节点 就调用</code>removeVnodes`删除子节点</li><li>如果<code>vnode</code>文本为<code>undefined</code>就删掉<code>vnode.elm</code></li></ul></li><li>如果<code>vnode</code>是文本节点但是和<code>oldVnode</code>文本的内容不一样 就更新文本</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span>(<span class="params"></span></span><br><span class="line"><span class="params">  oldVnode, <span class="comment">// 老的虚拟 DOM 节点</span></span></span><br><span class="line"><span class="params">  vnode, <span class="comment">// 新的虚拟 DOM 节点</span></span></span><br><span class="line"><span class="params">  insertedVnodeQueue, <span class="comment">// 插入节点的队列</span></span></span><br><span class="line"><span class="params">  ownerArray, <span class="comment">// 节点数组</span></span></span><br><span class="line"><span class="params">  index, <span class="comment">// 当前节点的下标</span></span></span><br><span class="line"><span class="params">  removeOnly <span class="comment">// 只有在</span></span></span><br><span class="line"><span class="params"></span>) {</span><br><span class="line">  <span class="comment">// 新老节点引用地址是一样的，直接返回</span></span><br><span class="line">  <span class="comment">// 比如 props 没有改变的时候，子组件就不做渲染，直接复用</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新的 vnode 真实的 DOM 元素</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">elm</span>) &amp;&amp; <span class="title function_">isDef</span>(ownerArray)) {</span><br><span class="line">    <span class="comment">// clone reused vnode</span></span><br><span class="line">    vnode = ownerArray[index] = <span class="title function_">cloneVNode</span>(vnode);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> elm = (vnode.<span class="property">elm</span> = oldVnode.<span class="property">elm</span>);</span><br><span class="line">  <span class="comment">// 如果当前节点是注释或 v-if 的，或者是异步函数，就跳过检查异步组件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(oldVnode.<span class="property">isAsyncPlaceholder</span>)) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">asyncFactory</span>.<span class="property">resolved</span>)) {</span><br><span class="line">      <span class="title function_">hydrate</span>(oldVnode.<span class="property">elm</span>, vnode, insertedVnodeQueue);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      vnode.<span class="property">isAsyncPlaceholder</span> = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 当前节点是静态节点的时候，key 也一样，或者有 v-once 的时候，就直接赋值返回</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="title function_">isTrue</span>(vnode.<span class="property">isStatic</span>) &amp;&amp;</span><br><span class="line">    <span class="title function_">isTrue</span>(oldVnode.<span class="property">isStatic</span>) &amp;&amp;</span><br><span class="line">    vnode.<span class="property">key</span> === oldVnode.<span class="property">key</span> &amp;&amp;</span><br><span class="line">    (<span class="title function_">isTrue</span>(vnode.<span class="property">isCloned</span>) || <span class="title function_">isTrue</span>(vnode.<span class="property">isOnce</span>))</span><br><span class="line">  ) {</span><br><span class="line">    vnode.<span class="property">componentInstance</span> = oldVnode.<span class="property">componentInstance</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// hook 相关的不用管</span></span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">const</span> data = vnode.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>((i = data.<span class="property">hook</span>)) &amp;&amp; <span class="title function_">isDef</span>((i = i.<span class="property">prepatch</span>))) {</span><br><span class="line">    <span class="title function_">i</span>(oldVnode, vnode);</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 获取子元素列表</span></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.<span class="property">children</span>;</span><br><span class="line">  <span class="keyword">const</span> ch = vnode.<span class="property">children</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isPatchable</span>(vnode)) {</span><br><span class="line">    <span class="comment">// 遍历调用 update 更新 oldVnode 所有属性，比如 class,style,attrs,domProps,events...</span></span><br><span class="line">    <span class="comment">// 这里的 update 钩子函数是 vnode 本身的钩子函数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.<span class="property">update</span>.<span class="property">length</span>; ++i) cbs.<span class="property">update</span>[i](oldVnode, vnode);</span><br><span class="line">    <span class="comment">// 这里的 update 钩子函数是我们传过来的函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>((i = data.<span class="property">hook</span>)) &amp;&amp; <span class="title function_">isDef</span>((i = i.<span class="property">update</span>))) <span class="title function_">i</span>(oldVnode, vnode);</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 如果新节点不是文本节点，也就是说有子节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode.<span class="property">text</span>)) {</span><br><span class="line">    <span class="comment">// 如果新老节点都有子节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh) &amp;&amp; <span class="title function_">isDef</span>(ch)) {</span><br><span class="line">      <span class="comment">// 如果新老节点的子节点不一样，就执行 updateChildren 函数，对比子节点</span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch)</span><br><span class="line">        <span class="title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(ch)) {</span><br><span class="line">      <span class="comment">// 如果新节点有子节点的话，就是说老节点没有子节点</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果老节点文本节点，就是说没有子节点，就清空</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">""</span>);</span><br><span class="line">      <span class="comment">// 添加子节点</span></span><br><span class="line">      <span class="title function_">addVnodes</span>(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.<span class="property">length</span> - <span class="number">1</span>, insertedVnodeQueue);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh)) {</span><br><span class="line">      <span class="comment">// 如果新节点没有子节点，老节点有子节点，就删除</span></span><br><span class="line">      <span class="title function_">removeVnodes</span>(oldCh, <span class="number">0</span>, oldCh.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) {</span><br><span class="line">      <span class="comment">// 如果老节点是文本节点，就清空</span></span><br><span class="line">      nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.<span class="property">text</span> !== vnode.<span class="property">text</span>) {</span><br><span class="line">    <span class="comment">// 新老节点都是文本节点，且文本不一样，就更新文本</span></span><br><span class="line">    nodeOps.<span class="title function_">setTextContent</span>(elm, vnode.<span class="property">text</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) {</span><br><span class="line">    <span class="comment">// 执行 postpatch 钩子</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>((i = data.<span class="property">hook</span>)) &amp;&amp; <span class="title function_">isDef</span>((i = i.<span class="property">postpatch</span>))) <span class="title function_">i</span>(oldVnode, vnode);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>updateChildren</strong> 新的<code>vnode</code>和<code>oldVnode</code>都有子节点并且子节点不一样的时候进行对比子节点的函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span>(<span class="params"></span></span><br><span class="line"><span class="params">  parentElm,</span></span><br><span class="line"><span class="params">  oldCh,</span></span><br><span class="line"><span class="params">  newCh,</span></span><br><span class="line"><span class="params">  insertedVnodeQueue,</span></span><br><span class="line"><span class="params">  removeOnly</span></span><br><span class="line"><span class="params"></span>) {</span><br><span class="line">  <span class="comment">//定义新旧vdom的首位索引以及首尾vdom</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line">  <span class="comment">//后续查找需要的变量</span></span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> canMove = !removeOnly;</span><br><span class="line">  <span class="comment">//当前环境的判断</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">"production"</span>) {</span><br><span class="line">    <span class="title function_">checkDuplicateKeys</span>(newCh);</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//当新vdom和旧vdom都没遍历结束</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) {</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]; <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) {</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]; <span class="comment">//上面两部是去掉在之前的对比中可能被删除的节点</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) {</span><br><span class="line">      <span class="comment">//新老首部对比</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(</span><br><span class="line">        oldStartVnode,</span><br><span class="line">        newStartVnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        newCh,</span><br><span class="line">        newStartIdx</span><br><span class="line">      );</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) {</span><br><span class="line">      <span class="comment">//旧尾部和新首部</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(</span><br><span class="line">        oldEndVnode,</span><br><span class="line">        newEndVnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        newCh,</span><br><span class="line">        newEndIdx</span><br><span class="line">      );</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) {</span><br><span class="line">      <span class="comment">// 旧首部和新尾部</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(</span><br><span class="line">        oldStartVnode,</span><br><span class="line">        newEndVnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        newCh,</span><br><span class="line">        newEndIdx</span><br><span class="line">      );</span><br><span class="line">      canMove &amp;&amp;</span><br><span class="line">        nodeOps.<span class="title function_">insertBefore</span>(</span><br><span class="line">          parentElm,</span><br><span class="line">          oldStartVnode.<span class="property">elm</span>,</span><br><span class="line">          nodeOps.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>)</span><br><span class="line">        );</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) {</span><br><span class="line">      <span class="comment">// 旧尾部和新尾部</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(</span><br><span class="line">        oldEndVnode,</span><br><span class="line">        newStartVnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        newCh,</span><br><span class="line">        newStartIdx</span><br><span class="line">      );</span><br><span class="line">      canMove &amp;&amp;</span><br><span class="line">        nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>);</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">//当前面四种情况都之后还没结束的时候 则进行循环遍历查找</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldKeyToIdx))</span><br><span class="line">        <span class="comment">//根据老vdom创建一个map 避免用数组重复遍历查询 属于时间换空间的算法</span></span><br><span class="line">        oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">      <span class="comment">//新vdom的第一个头结点（并不是初始的头结点 而是经过前面四种情况处理后的newStartIdx）</span></span><br><span class="line">      <span class="comment">//去旧vdom生成的map中查找</span></span><br><span class="line">      idxInOld = <span class="title function_">isDef</span>(newStartVnode.<span class="property">key</span>)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">        : <span class="title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(idxInOld)) {</span><br><span class="line">        <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">//如果找不到的话 则进行创建并插入未处理的旧节点的前面 (oldStartVnode.elem)的前面</span></span><br><span class="line">        <span class="title function_">createElm</span>(</span><br><span class="line">          newStartVnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          parentElm,</span><br><span class="line">          oldStartVnode.<span class="property">elm</span>,</span><br><span class="line">          <span class="literal">false</span>,</span><br><span class="line">          newCh,</span><br><span class="line">          newStartIdx</span><br><span class="line">        );</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">//如果找到了</span></span><br><span class="line">        vnodeToMove = oldCh[idxInOld];</span><br><span class="line">        <span class="comment">//判断是否时相同节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(vnodeToMove, newStartVnode)) {</span><br><span class="line">          <span class="comment">//如果是的话 则递归更新</span></span><br><span class="line">          <span class="title function_">patchVnode</span>(</span><br><span class="line">            vnodeToMove,</span><br><span class="line">            newStartVnode,</span><br><span class="line">            insertedVnodeQueue,</span><br><span class="line">            newCh,</span><br><span class="line">            newStartIdx</span><br><span class="line">          );</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">          canMove &amp;&amp;</span><br><span class="line">            nodeOps.<span class="title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="comment">//否则创建新的节点进行替换</span></span><br><span class="line">          <span class="title function_">createElm</span>(</span><br><span class="line">            newStartVnode,</span><br><span class="line">            insertedVnodeQueue,</span><br><span class="line">            parentElm,</span><br><span class="line">            oldStartVnode.<span class="property">elm</span>,</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            newCh,</span><br><span class="line">            newStartIdx</span><br><span class="line">          );</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//循环查找的过程结束</span></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) {</span><br><span class="line">    <span class="comment">//如果老的vdom结束 而新的vdom还在 则直接批量创建并插入</span></span><br><span class="line">    refElm = <span class="title function_">isUndef</span>(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].<span class="property">elm</span>;</span><br><span class="line">    <span class="title function_">addVnodes</span>(</span><br><span class="line">      parentElm,</span><br><span class="line">      refElm,</span><br><span class="line">      newCh,</span><br><span class="line">      newStartIdx,</span><br><span class="line">      newEndIdx,</span><br><span class="line">      insertedVnodeQueue</span><br><span class="line">    );</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) {</span><br><span class="line">    <span class="comment">//否则直接批量删除</span></span><br><span class="line">    <span class="title function_">removeVnodes</span>(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><h3 id="diff-的作用域"><a href="#diff-的作用域" class="headerlink" title="diff 的作用域"></a>diff 的作用域</h3><h4 id="存在-children-的-vnode-类型"><a href="#存在-children-的-vnode-类型" class="headerlink" title="存在 children 的 vnode 类型"></a>存在 children 的 vnode 类型</h4><h5 id="1-element-元素类型-vnode"><a href="#1-element-元素类型-vnode" class="headerlink" title="1.element 元素类型 vnode"></a>1.element 元素类型 vnode</h5><p><code>patchElement</code>用于处理<code>element</code>类型的<code>vnode</code></p><h5 id="2-fragment-碎片类型的-vnode"><a href="#2-fragment-碎片类型的-vnode" class="headerlink" title="2.fragment 碎片类型的 vnode"></a>2.fragment 碎片类型的 vnode</h5><p><code>fragment</code>是虚拟的 并不会在<code>DOM</code>树中呈现 这样我们就可以将组件的功能绑定到单一的元素中 而不需要创建一个多余的<code>DOM</code>节点 使用 <code>processFragment</code>处理<code>Fragment</code>类型的<code>vnode</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(patchFlag &amp;&amp; <span class="title class_">PatchFlag</span>.<span class="property">KEYD_FRAGMENT</span>) {</span><br><span class="line">...<span class="comment">//对于存在key的情况使用diff</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (patch &amp;&amp; <span class="title class_">PatchFlags</span>.<span class="property">UNKEYED_FRAGMENT</span>) {</span><br><span class="line"><span class="comment">//对于不存在key的情况 直接patch</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>patchChildren</code>根据是否存在<code>key</code>进行真正的 <code>diff</code>或者直接<code>patch</code></p></blockquote><h3 id="diff-算法具体操作"><a href="#diff-算法具体操作" class="headerlink" title="diff 算法具体操作"></a>diff 算法具体操作</h3><h4 id="不存在-key-的时候"><a href="#不存在-key-的时候" class="headerlink" title="不存在 key 的时候"></a>不存在 key 的时候</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> c1 = c1 || <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line">    c2 = c2 || <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line">    <span class="keyword">const</span> oldLength = c1.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> newLength = c2.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> commonLength = <span class="title class_">Math</span>.<span class="title function_">min</span>(oldLength, newLength) <span class="comment">//比较新旧children的最小值作为公共部分 进行新的patch工作</span></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; commonLength; i++) { <span class="comment">/* 依次遍历新老vnode进行patch */</span></span><br><span class="line">      <span class="keyword">const</span> nextChild = (c2[i] = optimized</span><br><span class="line">        ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">        : <span class="title function_">normalizeVNode</span>(c2[i]))</span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        c1[i],</span><br><span class="line">        nextChild,</span><br><span class="line">        container,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (oldLength &gt; newLength) { <span class="comment">/* 老vnode 数量大于新的vnode，删除多余的节点 */</span></span><br><span class="line">      <span class="title function_">unmountChildren</span>(c1, parentComponent, parentSuspense, <span class="literal">true</span>, commonLength)</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">/* /* 老vnode 数量小于于新的vnode，创造新的即诶安 */</span></span><br><span class="line">      <span class="title function_">mountChildren</span>(</span><br><span class="line">        c2,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized,</span><br><span class="line">        commonLength</span><br><span class="line">      )</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="存在-key-的情况"><a href="#存在-key-的情况" class="headerlink" title="存在 key 的情况"></a>存在 key 的情况</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">    /*  c1 老的vnode c2 新的vnode  */</span><br><span class="line">    let i = 0              /* 记录索引 */</span><br><span class="line">    const l2 = c2.length   /* 新vnode的数量 */</span><br><span class="line">    let e1 = c1.length - 1 /* 老vnode 最后一个节点的索引 */</span><br><span class="line">    let e2 = l2 - 1        /* 新节点最后一个节点的索引 */</span><br><span class="line">    //首先新旧children首首对比 发现不同立马跳出</span><br><span class="line">    while(i &lt;= e1 &amp;&amp; i &lt;= e2) {</span><br><span class="line">    .....</span><br><span class="line">    }</span><br><span class="line">    //从新旧children的尾部开始向前对比 发现不同立马退出</span><br><span class="line">    while( i &lt;= e1 &amp;&amp; i &lt;= e2) {</span><br><span class="line">    //.....</span><br><span class="line">    e1--;</span><br><span class="line">    e2--;</span><br><span class="line">    }</span><br><span class="line">    //如果老节点全部patch 新节点没有patch完 则创建新的vnode插入</span><br><span class="line">    if(i &gt; e1) {</span><br><span class="line">    if(i &lt;= e2)</span><br><span class="line">    while(i &lt;= e2) {</span><br><span class="line">    patch(...)</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">    //如果新的节点全部patch 而节点有剩余 则卸载所有老节点</span><br><span class="line">    else if(i &gt; e2) {</span><br><span class="line">    while(i &lt;= e1) {</span><br><span class="line">    unmount(...);</span><br><span class="line">    i++;</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">    //如果双端对比后 没有处理完 则需要继续处理 即diff的核心 最长连续稳定序列算法</span><br><span class="line">     const s1 = i  //第一步遍历到的index</span><br><span class="line">      const s2 = i</span><br><span class="line">      const keyToNewIndexMap: Map&lt;string | number, number&gt; = new Map()</span><br><span class="line">      /* 把没有比较过的新的vnode节点,通过map保存 */</span><br><span class="line">      for (i = s2; i &lt;= e2; i++) {</span><br><span class="line">        if (nextChild.key != null) {</span><br><span class="line">          keyToNewIndexMap.set(nextChild.key, i)</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      let j;//记录剩下新的节点的索引</span><br><span class="line">      let patched = 0 ;//记录这个过程patch的节点的数量</span><br><span class="line">      const toBePatched = e2 - s2 + 1 /* 没有经过 path 新的节点的数量 */</span><br><span class="line">      let moved = false /* 证明是否移动过 */</span><br><span class="line">      let maxNewIndexSoFar = 0</span><br><span class="line">      const newIndexToOldIndexMap = new Array(toBePatched);//用来存放新节点的索引和老节点的索引的数组</span><br><span class="line">       for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0</span><br><span class="line">      /* 建立一个数组，每个子元素都是0 [ 0, 0, 0, 0, 0, 0, ] */</span><br><span class="line">      ---------------------------------------</span><br><span class="line">      //接下来是diff算法的核心</span><br><span class="line">      //第一步 通过老节点的key找到对应新节点的index 开始遍历老的节点 判断有没有key 如果存在key通过新节点的keyToNewIndexMNap找到新节点index 如果不存在则会遍历生下来的新节点试图找到对应index</span><br><span class="line">      //如果存在index证明有对应的老节点 则直接复用老节点进行patch 如果没有找到老节点对应的新节点 则删除当前的老节点</span><br><span class="line">      //newIndexToOldIndexMap找到对应新老节点关系</span><br><span class="line"> for (i = s1; i &lt;= e1; i++) { /* 开始遍历老节点 */</span><br><span class="line">        const prevChild = c1[i]</span><br><span class="line">        if (patched &gt;= toBePatched) {</span><br><span class="line">          /* ①如果已经patch的大于等于需要patch的，说明新children已经处理完成，那么统一卸载老的节点 */</span><br><span class="line">          unmount(prevChild, parentComponent, parentSuspense, true)</span><br><span class="line">          continue</span><br><span class="line">        }</span><br><span class="line">        let newIndex</span><br><span class="line">         /* ② 如果,老节点的key存在 ，通过key找到对应的index */</span><br><span class="line">        if (prevChild.key != null) {</span><br><span class="line">          newIndex = keyToNewIndexMap.get(prevChild.key)</span><br><span class="line">        } else { /*  ③ 如果,老节点的key不存在 */</span><br><span class="line">          for (j = s2; j &lt;= e2; j++) { /* 遍历剩下的所有新节点 */</span><br><span class="line">            if (</span><br><span class="line">              newIndexToOldIndexMap[j - s2] === 0 &amp;&amp; /* newIndexToOldIndexMap[j - s2] === 0 新节点没有被patch */</span><br><span class="line">              isSameVNodeType(prevChild, c2[j] as VNode)</span><br><span class="line">            ) { /* 如果找到与当前老节点对应的新节点那么 ，将新节点的索引，赋值给newIndex  */</span><br><span class="line">              newIndex = j</span><br><span class="line">              break</span><br><span class="line">            }</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">        if (newIndex === undefined) { /* ①没有找到与老节点对应的新节点，删除当前节点，卸载所有的节点 */</span><br><span class="line">          unmount(prevChild, parentComponent, parentSuspense, true)</span><br><span class="line">        } else {</span><br><span class="line">          /* ②把老节点的索引，记录在存放新节点的数组中， */</span><br><span class="line">          newIndexToOldIndexMap[newIndex - s2] = i + 1</span><br><span class="line">          if (newIndex &gt;= maxNewIndexSoFar) {</span><br><span class="line">            maxNewIndexSoFar = newIndex</span><br><span class="line">          } else {</span><br><span class="line">            /* 证明有节点已经移动了   */</span><br><span class="line">            moved = true</span><br><span class="line">          }</span><br><span class="line">          /* 找到新的节点进行patch节点 */</span><br><span class="line">          patch(</span><br><span class="line">            prevChild,</span><br><span class="line">            c2[newIndex] as VNode,</span><br><span class="line">            container,</span><br><span class="line">            null,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized</span><br><span class="line">          )</span><br><span class="line">          patched++</span><br><span class="line">        }</span><br><span class="line"> }</span><br><span class="line">//虽然已经patch过所有的老节点 可是对于已经发生移动的节点 要怎么真正移动dom元素 以及对于新增的节点 要怎么处理</span><br><span class="line">      /*移动老节点创建新节点*/</span><br><span class="line">     /* 根据最长稳定序列移动相对应的节点 */</span><br><span class="line">      const increasingNewIndexSequence = moved</span><br><span class="line">        ? getSequence(newIndexToOldIndexMap)//通过getSequece获取一个最长稳定序列 对于index === 0的情况也就是新增节点 需要重新创建一个vnode 然后对于发生移动的节点进行统一的移动</span><br><span class="line"></span><br><span class="line">        : EMPTY_ARR</span><br><span class="line">      j = increasingNewIndexSequence.length - 1</span><br><span class="line">      for (i = toBePatched - 1; i &gt;= 0; i--) {</span><br><span class="line">        const nextIndex = s2 + i</span><br><span class="line">        const nextChild = c2[nextIndex] as VNode</span><br><span class="line">        const anchor =</span><br><span class="line">          nextIndex + 1 &lt; l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor</span><br><span class="line">        if (newIndexToOldIndexMap[i] === 0) { /* 没有老的节点与新的节点对应，则创建一个新的vnode */</span><br><span class="line">          patch(</span><br><span class="line">            null,</span><br><span class="line">            nextChild,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG</span><br><span class="line">          )</span><br><span class="line">        } else if (moved) {</span><br><span class="line">          if (j &lt; 0 || i !== increasingNewIndexSequence[j]) { /*如果没有在长*/</span><br><span class="line">            /* 需要移动的vnode */</span><br><span class="line">            move(nextChild, container, anchor, MoveType.REORDER)</span><br><span class="line">          } else {</span><br><span class="line">            j--</span><br><span class="line">          }</span><br></pre></td></tr></tbody></table></figure><p><strong>Q：</strong>为什么要得到最长稳定序列</p><p><strong>A：</strong>我们需要一个序列作为基础的参照序列 其他未在稳定序列的节点进行移动</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>新旧<code>children</code>首部开始对比 发现不同立马跳出</li><li>如果第一步没有<code>patch</code>完 立即从后往前开始<code>patch</code> 发现不同立马跳出循环</li><li>如果新的节点大于老的节点数 对于剩下的节点全部以新的 vnode 处理</li><li>对于老的节点大于新的节点 则将超出的节点卸载</li><li>前面四轮没有 patch 完的元素与 3，4 对立关系<ol><li>将没有比较过的新节点通过<code>map</code>保存 记录已经 patch 过的新节点的数量 <code>patched</code> 没有进过<code>patch</code>新的节点的数量<code>toBePatched</code> 进阿里一个数组 newIndexToOldIndexMap 来记录老节点的索引 数组的索引就是新节点的索引</li><li><strong>开始遍历老节点</strong><ol><li>如果<code>toBePatched</code>新的节点数量为 0 说明已经比较完成 可以统一卸载老节点</li><li>如果老节点的<code>key</code>存在 则通过<code>key</code>找到对应的新节点的<code>index</code></li><li>如果老节点的<code>key</code>不存在<ol><li>遍历剩下的所有新节点</li><li>如果找到与当前老节点对应的新节点 那么将新节点的索引 赋值给 newIndex</li></ol></li><li>如果没有找到与老节点对应的新节点 卸载当前老节点</li><li>如果找到与老节点对应的新节点 则将老节点的索引 记录在存放新节点的数组中<ol><li>如果节点发生移动 用<code>moved</code>记录移动了<ol><li>根据<code>newIndexOldIndexMap</code>新节点索引列表找到最长稳定序列</li><li>对于<code>newIndexToOldIndexMap - item == 0</code>证明不存在老节点 直接创建新的<code>vnode</code></li><li>对于发生移动的节点进行移动处理</li></ol></li><li><code>patch</code>新老节点 找到新的节点进行<code>patch</code></li></ol></li></ol></li></ol></li><li>遍历结束</li></ol><p><img src="https://img-blog.csdnimg.cn/20200607002918225.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psX0FsaWVu,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="vue3-相比-vue2-的优化"><a href="#vue3-相比-vue2-的优化" class="headerlink" title="vue3 相比 vue2 的优化"></a>vue3 相比 vue2 的优化</h2><h4 id="事件缓存"><a href="#事件缓存" class="headerlink" title="事件缓存"></a>事件缓存</h4><p>将事件进行缓存，这样如果多次用到相同的事件，就不用重复去创建以及绑定</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;button @click={toClickSec}&gt;clickSecondBtn&lt;/button&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) {</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(<span class="string">"div"</span>, _hoisted_1, [</span><br><span class="line">    <span class="title function_">_createElementVNode</span>(<span class="string">"button"</span>, {</span><br><span class="line">      <span class="attr">onClick</span>: _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = $event =&gt; ({<span class="attr">toClickSec</span>: _ctx.<span class="property">toClickSec</span>}))</span><br><span class="line">    }, <span class="string">"clickSecondBtn"</span>)</span><br><span class="line">  ]))</span><br></pre></td></tr></tbody></table></figure><h4 id="静态标记"><a href="#静态标记" class="headerlink" title="静态标记"></a>静态标记</h4><p>对于一些属性或者内容固定的节点，对其打上静态节点的标记，这样在后续的<code>diff</code>过程中，可以跳过这些不必要的比较来优化<code>diff</code>算法 ，同样的 还有类似于<code>class绑定、props</code>等，也是同样的道理，利用标记来避免不必要的比较</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;h2&gt;i am olddog&lt;/h2&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>i am div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">{style}</span>&gt;</span>i am class div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:pro</span>=<span class="string">"props"</span> <span class="attr">:class</span>=<span class="string">{style}</span>&gt;</span> i am props div <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   onst _hoisted_1 = { <span class="attr">id</span>: <span class="string">"app"</span> }</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(<span class="string">"h2"</span>, <span class="literal">null</span>, <span class="string">"i am olddog"</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"><span class="keyword">const</span> _hoisted_3 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="string">"i am div"</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"><span class="keyword">const</span> _hoisted_4 = [<span class="string">"pro"</span>]</span><br></pre></td></tr></tbody></table></figure><p>可以看到，这些标记其实就是一些位运算</p><blockquote><p>不仅 vue。react 使用的也是位运算来标记，除此之外，位运算还可以用于在权限系统中（例如一个系统拥有多个用户，而每个用户只有几个权限的情况下 但是需注意这种情况下的权限查找较不方便）</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> enum <span class="title class_">PatchFlags</span> {</span><br><span class="line"></span><br><span class="line">  <span class="variable constant_">TEXT</span> = <span class="number">1</span>,<span class="comment">// 表示具有动态textContent的元素</span></span><br><span class="line">  <span class="variable constant_">CLASS</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,  <span class="comment">// 表示有动态Class的元素</span></span><br><span class="line">  <span class="variable constant_">STYLE</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,  <span class="comment">// 表示动态样式（静态如style="color: red"，也会提升至动态）</span></span><br><span class="line">  <span class="variable constant_">PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,  <span class="comment">// 表示具有非类/样式动态道具的元素。</span></span><br><span class="line">  <span class="variable constant_">FULL_PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,  <span class="comment">// 表示带有动态键的道具的元素，与上面三种相斥</span></span><br><span class="line">  <span class="variable constant_">HYDRATE_EVENTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,  <span class="comment">// 表示带有事件监听器的元素</span></span><br><span class="line">  <span class="variable constant_">STABLE_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   <span class="comment">// 表示其子顺序不变的片段（没懂）。</span></span><br><span class="line">  <span class="variable constant_">KEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">// 表示带有键控或部分键控子元素的片段。</span></span><br><span class="line">  <span class="variable constant_">UNKEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">// 表示带有无key绑定的片段</span></span><br><span class="line">  <span class="variable constant_">NEED_PATCH</span> = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">// 表示只需要非属性补丁的元素，例如ref或hooks</span></span><br><span class="line">  <span class="variable constant_">DYNAMIC_SLOTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  <span class="comment">// 表示具有动态插槽的元素</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>vue2</code>是全量<code>Diff</code>（即不管任何节点都会进行<code>diff</code>） <code>vue3</code>是 静态标记 + 非全量<code>DIff</code>（即通过静态标记标记不同<code>Vdom</code>的类型，以此跳过不必要的比较来优化<code>diff</code>的效率）</p></blockquote><h4 id="静态提升"><a href="#静态提升" class="headerlink" title="静态提升"></a>静态提升</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;i am olddog&lt;/h2&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>i am div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">{style}</span>&gt;</span>i am class div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:pro</span>=<span class="string">"props"</span> <span class="attr">:class</span>=<span class="string">{style}</span>&gt;</span> i am props div <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   onst _hoisted_1 = { <span class="attr">id</span>: <span class="string">"app"</span> }</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(<span class="string">"h2"</span>, <span class="literal">null</span>, <span class="string">"i am olddog"</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"><span class="keyword">const</span> _hoisted_3 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="string">"i am div"</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"><span class="keyword">const</span> _hoisted_4 = [<span class="string">"pro"</span>]</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) {</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(<span class="string">"div"</span>, _hoisted_1, [</span><br><span class="line">    _hoisted_2,</span><br><span class="line">    _hoisted_3,</span><br><span class="line">    <span class="title function_">_createElementVNode</span>(<span class="string">"div"</span>, {</span><br><span class="line">      <span class="attr">class</span>: <span class="title function_">_normalizeClass</span>({<span class="attr">style</span>: _ctx.<span class="property">style</span>})</span><br><span class="line">    }, <span class="string">"i am class div"</span>, <span class="number">2</span> <span class="comment">/* CLASS */</span>),</span><br></pre></td></tr></tbody></table></figure><p>可以看到 对于一些内容或属性固定的静态节点 <code>vue3</code> 将它们定义在 <code>render</code> 函数外部来做到 <code>静态提升</code> 这样当多次用到这些节点的时候 可以直接引用而不是重复创建 大大提高了性能</p><h4 id="使用最长稳定子序列优化对比流程"><a href="#使用最长稳定子序列优化对比流程" class="headerlink" title="使用最长稳定子序列优化对比流程"></a>使用最长稳定子序列优化对比流程</h4><h5 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h5><ul><li>旧头和新头相比</li><li>旧头和新尾相比</li><li>旧尾和新头相比</li><li>旧尾和新尾相比</li><li>都没有命中的对比</li></ul><h5 id="vue3-1"><a href="#vue3-1" class="headerlink" title="vue3"></a>vue3</h5><ul><li>旧头和新头对比</li><li>旧尾和新尾对比</li><li>基于最长递增子序列进行移动/增加/删除 （使用最长递增子序列可以最大程度的减少<code>DOM</code>的移动 达到最少的<code>DOM</code>操作）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识系列一</title>
      <link href="/2022/10/11/ji-suan-ji-wang-luo-1/"/>
      <url>/2022/10/11/ji-suan-ji-wang-luo-1/</url>
      
        <content type="html"><![CDATA[<p>在网上冲浪的我们，无时无刻都在用着网络，而作为一名程序猿，我们更是每天都和网络打交道，但是和用户不同的是，用户只需要知道如何使用数据和 wifi 即可，而我们开发人员则需要知道网络背后的知识和秘密，无论学习还是求职，计网都是我们绕不开的知识点。本篇将讲解对于一个前端 er 我们应该知道/掌握的计算机网络的相关内容/面试题，让我们一起开始本文的学习吧！！！（<strong>tips</strong>：万字长文，建议点赞收藏反复观看！！！ ）</p><p><strong>适合读者</strong>：</p><ul><li>计网小白</li><li>准备面试的求职者</li></ul><p><strong>你将学到</strong>：</p><ul><li>前端日常接触到的计网知识</li><li>常见的热门面试题</li></ul><p>话不多说，让我们一起往下学习吧！！！</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa27071d33f443bca907dba3d372ace4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="1-OSI-7-层模型和-TCP-IP-四层模型"><a href="#1-OSI-7-层模型和-TCP-IP-四层模型" class="headerlink" title="1.OSI 7 层模型和 TCP/IP 四层模型"></a>1.OSI 7 层模型和 TCP/IP 四层模型</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d26b83396ff43f58f03a3c17d3edf8b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221009194652350"></p><p><strong>各层的基本功能：</strong></p><ul><li><p><code>应用层</code>：对应于 OSI 参考模型的高层，为用户提供所需要的各种服务，例如：<code>FTP、Telnet、DNS、SMTP</code>等</p></li><li><p><code>传输层</code>：传输层对应 OSI 模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包顺序传输和完整性，包含两个主要的协议：传输控制协议（<code>TCP</code>）以及用户数据报协议（<code>UDP</code>）</p></li><li><p><code>网络层</code>：对应 OSI 的网络层，主要用于解决主机到主机的通信问题。注重重新赋予主机一个 IP 地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网络协议（<code>IP</code>）、互联网组管理协议（<code>IGMP</code>）和互联网控制报文协议（<code>ICMP</code>）</p><blockquote><p><code>IP</code>协议是最重要的协议 提供了一个可靠、无连接的数据传递服务</p></blockquote></li><li><p><code>数据链路层</code>：对应 OSI 的数据链路层。它负责监视数据在主机和网络之间的交换。事实上，<code>TCP/IP</code>本身并未定义该层的协议，而由参与互连的各网络使用自己的<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%B1%82?fromModule=lemma_inlink">物理层</a>和<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82?fromModule=lemma_inlink">数据链路层</a>协议，然后与<code>TCP/IP</code>的网络接入层进行连接。<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE?fromModule=lemma_inlink">地址解析协议</a>（<code>ARP</code>）工作在此层，即 OSI 参考模型的数据链路层。</p></li></ul><h2 id="2-常见的请求方法"><a href="#2-常见的请求方法" class="headerlink" title="2.常见的请求方法"></a>2.常见的请求方法</h2><p>这里我们先解释一下啥叫<strong>幂等操作</strong>：无论操作多少次，产生的结果都是一样的（比如 <code>get、put</code>这些，<code>post</code>不是幂等操作）</p><h3 id="1-get"><a href="#1-get" class="headerlink" title="1.get"></a>1.get</h3><ul><li>用于向服务器请求资源</li><li>很多时候可以换成<code>get</code>请求的结果来达到减少网络请求的优化效果</li><li>通过将请求参数放入<code>url</code>中向服务器请求， 参数只允许是 <code>ASCII字符</code>（会在历史记录中保存，不安全）</li><li>由于浏览器对<code>url</code>长度有限制 所以有时候会影响到<code>get</code>请求发送数据时的长度（由<code>RFC</code>规定而不是浏览器）</li></ul><h3 id="2-post"><a href="#2-post" class="headerlink" title="2.post"></a>2.post</h3><ul><li><code>post</code>操作不是幂等操作，一般用于向服务器发送提交一些数据（比如登陆注册等）</li><li>请求参数放在请求体中，参数支持很多类型（字符串、文件等）</li><li>一般不对<code>post</code>请求的结果做缓存，比<code>get</code>安全</li></ul><h3 id="3-options"><a href="#3-options" class="headerlink" title="3.options"></a>3.options</h3><ul><li>请求 web 服务器告知其支持的功能</li><li>通常用于询问服务器支持的方法或者对于特殊资源支持的方法（可以使我们不用实际访问那些资源就可以判定用哪些方式去处理资源）</li></ul><blockquote><p>为什么<code>post</code>请求实际上需要发两次请求</p><ol><li><p>第一次是<code>options</code>的预检请求，返回 204 状态码</p><p>预检请求可以获取服务器是否支持该实际请求，同时可以检查该请求是否是跨域请求，服务器是否支持跨域</p></li><li><p>第二次才是实际的<code>post</code>请求</p></li></ol></blockquote><h3 id="4-put"><a href="#4-put" class="headerlink" title="4.put"></a>4.put</h3><ul><li>向服务器写入数据（类似于更新数据，所以操作多少次结果都是一样的，这一点和<code>post</code>方法不一样）</li></ul><h3 id="5-head"><a href="#5-head" class="headerlink" title="5.head"></a>5.head</h3><ul><li>只获取响应首部的内容 不会返回实体的内容（相当于<code>get</code>但是只获取响应首部的内容）</li><li>可以在未获取实际资源的适合对资源的首部进行检查（判断资源类型、状态码以及资源是否被修改）</li></ul><h3 id="6-delete"><a href="#6-delete" class="headerlink" title="6.delete"></a>6.delete</h3><ul><li>请求服务器删除请求<code>URL</code>所指定的资源</li><li>该操作不一定会被执行（<code>HTTP</code>允许服务器在不通知客户端的情况下撤销<code>DELETE</code>请求）</li></ul><h3 id="7-trace"><a href="#7-trace" class="headerlink" title="7.trace"></a>7.trace</h3><ul><li>允许客户端在最终将请求发送给服务器时查询最终的请求内容（因为请求内容可能在穿过防火墙、代理、网关和其他一些应用程序的适合被修改）</li><li>可用于查看代理和其他应用程序对请求产生的效果</li><li><code>TRACE</code>请求中不能带有实体的主题部分</li></ul><h3 id="8-connect"><a href="#8-connect" class="headerlink" title="8.connect"></a>8.connect</h3><ul><li>在与代理服务器通信时创建 <strong>管道</strong>， 使用管道去进行通信</li></ul><h3 id="9-patch"><a href="#9-patch" class="headerlink" title="9.patch"></a>9.patch</h3><ul><li>对资源进行部分修改而不是全部修改</li></ul><h2 id="3-HTTP-报文的结构"><a href="#3-HTTP-报文的结构" class="headerlink" title="3.HTTP 报文的结构"></a>3.HTTP 报文的结构</h2><p><code>http</code>报文是简单的格式化数据块，由起始行（说明这个请求/响应要做什么）、首部块（<code>header</code>）以及可选的包含数据的主体部分组成，而报文又能分成 <strong>请求报文</strong> 和 <strong>响应报文</strong>两种</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//请求报文</span><br><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt; // 方法 | 请求url | http版文</span><br><span class="line">&lt;headers&gt; // 首部</span><br><span class="line">&lt;entity-body&gt; //报文主体</span><br><span class="line">//响应报文</span><br><span class="line">&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt; //版本 | 状态码 | 处理该请求的原因</span><br><span class="line">&lt;headers&gt;</span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ada259850834a1a8d860c98cb83f089~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221009210018806"></p><p>起始行的组成较为简单</p><ul><li>请求行：包含方法、请求<code>URL</code>以及版本号</li><li>响应行：包含版本、状态码以及原因短语</li></ul><p>接下来我们重点讲下<code>header</code>，<code>header</code>分为请求头和响应头</p><h3 id="报文首部的结构"><a href="#报文首部的结构" class="headerlink" title="报文首部的结构"></a>报文首部的结构</h3><p>报文的首部分为：通用首部、请求首部、响应首部、实体首部以及扩展首部五大主要类。</p><p><strong>tips</strong>：关于本小节和缓存有关的知识后面的缓存小节集中细讲</p><h4 id="1-通用首部"><a href="#1-通用首部" class="headerlink" title="1.通用首部"></a>1.通用首部</h4><p>请求报文和响应报文都能使用</p><ul><li><code>Connection</code>： 允许客户端和服务器指定与请求/响应连接有关的选项（比如<code>http/1.0</code>使用 <code>Connection: keep-Alive</code>开启持久连接，使用 <code>Connection: close</code>来关闭连接）</li><li><code>Date</code>：说明报文的创建时间，可用来判断响应资源是来自于缓存还是源服务器（缓存一般不修改 <code>Date</code>数据）</li><li><code>MIME-Versioon</code>：发送端使用的 <code>MIME</code>版本</li><li><code>Trailer</code> ：如果报文采用了分块传输编码方式，就可 以用这个首部列出位于报文拖挂（trailer）部分的首部集合</li><li><code>Transfer-Encoding</code>：告知接收端报文的编码方式</li><li><code>Update</code>：发送端可能想要升级的版本或者协议</li><li><code>Via</code>：列出了与报文途径的节点的学习（代理、网关）</li><li><code>Cache-Control</code>：和缓存有关，后面细讲</li></ul><h4 id="2-请求首部"><a href="#2-请求首部" class="headerlink" title="2.请求首部"></a>2.请求首部</h4><ul><li><code>Client-Ip</code>：提供了客户端<code>IP</code>地址（较老的客户端或者代理使用的扩展首部 不安全）</li><li><code>Form</code>： 客户端的 E-mail 地址</li><li><code>Host</code>：接收请求的服务器的主机名和端口号</li><li><code>Referer</code>：提供了包含当前请求 URI 的文档的 URL</li><li><code>UA-Coloe|CPU|Disp|OS</code>: 提供客户端显示器的相关消息（显示颜色等）</li><li><code>User-Agent</code>：告知服务器发起请求的应用程序的名称（较老的网关或代理使用）</li><li><code>Accept</code>：告知服务器自己想要啥类型的资源<ul><li><code>Accept</code>：需要哪些媒体类型</li><li><code>Accept-Charset</code>：字符集</li><li><code>Accept-Encoding</code>：希望服务器使用的编码方式</li><li><code>Accept Language</code>：使用的语言</li><li><code>TE</code>：服务器可以使用的扩展传输编码</li></ul></li><li><code>Expect</code>：告知服务器它们需求的某种行为（和<code>100Continue</code>响应码紧密相关）</li><li><code>If-Math</code>：如果实体标记与文档当前的实体标记相匹配，就获取这份文档</li><li><code>If-Modified-Since</code>： 除非在某个指定的日期之后资源被修改过，否则就限制这个请求</li><li><code>If-None-Match</code>：如果提供的实体标记与当前文档的实体标记不相符，就获取文档</li><li><code>Range</code>：允许请求资源的部分内容（比如断连继续下载，只下载某部分）</li><li><code>If-Range</code>： 允许对文档的某个范围进行条件请求</li><li><code>If-Unmodified-Since</code>： 除非在某个指定日期之后资源没有被修改过，否则就限制这个请求</li><li><code>Authorization</code>:与身份认证有关</li><li><code>Cookie</code>： 与<code>cookie</code>有关（不安全）</li><li><code>Cookie2</code>： 说明请求端支持的<code>cookie</code>版本</li><li>代理请求首部<ul><li><code>Max-Forward</code> ：在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次 数——与 <code>TRACE</code> 方法一同使用</li><li><code>Proxy-Authorization</code> ：与 <code>Authorization</code> 首部相同，但这个首部是在与代理进行认证时使用的</li><li><code>Proxy-Connection</code>： 与 <code>Connection</code> 首部相同，但这个首部是在与代理建立连接时使用的</li></ul></li></ul><h4 id="3-响应首部"><a href="#3-响应首部" class="headerlink" title="3.响应首部"></a>3.响应首部</h4><ul><li><code>Age</code>：告知接收端响应已经产生多久时间了 （HTTP/1.1 规定每个响应中都必须包含一个<code>Age</code>首部）</li><li><code>Retry-After</code>：如果资源不可用的话，在此日期或事件重试（和 与 <code>503 Service Unavailable</code>（服务不可用）状态码配合使用，给出客户端 可以重试其请求的具体日期和时间（或者秒数））</li><li><code>Accept-Ranges</code>：告知客户端是否接收请求资源的某个范围（设置 <code>Accept-anges:none</code>客户端以后就不会发起范围请求了）</li><li><code>Vary</code>：列出了所有客户端的请求首部，服务器可以根据这些首部的内容挑选出最适合的资源版本发送给服务端</li><li><code>Proxy-Authenticate</code>：来自代理的客户端的质询列表（类似于 <code>WWW-Authenticate</code> 不过是代理使用）</li><li><code>Set-Cookie</code>：设置<code>cookie</code>（不安全）</li><li><code>WWW-Authenticate</code>：用于 <code>401 Unauthorized</code>响应 向客户端发布一个质询认证方案</li></ul><h4 id="4-实体首部"><a href="#4-实体首部" class="headerlink" title="4.实体首部"></a>4.实体首部</h4><ul><li><code>Allow</code>：允许的请求方法</li><li><code>Location</code>：告知客户端资源的实际位置（重定向相关）</li><li><code>Content-Base</code>：解析主体中的相对<code>URL</code>时使用的基础<code>URL</code></li><li><code>Content-Encoding</code>： 主体使用的编码方式</li><li><code>Content-Language</code>：主体使用的语言</li><li><code>Content-Length</code>：资源的长度</li><li><code>Content-Location</code>：资源的实际位置</li><li><code>Content-MD5</code>：服务器用来对报文主体进行报文完整性检查</li><li><code>Content-Range</code>：请求资源的某部分时 产生的结果由 <code>Content-Range</code>首部给出 （提供了请请求资源在请求内部的位置以及资源的长度）</li><li><code>Content-Type</code>：资源的对象类型</li><li><code>ETag</code>：根据资源内容生成的标记值（和缓存有关）</li><li><code>Expires</code>：缓存有效的时间，超过这个时间后就要重新获取资源</li><li><code>Last-Modified</code>：资源最后一次被修改的时间戳</li></ul><p><strong>总结</strong>：报文的首部和内容大概就讲完了，接下来贴一下掘金首页的请求和响应数据给大家对应着学习</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bd0feaa9f0a4b43a12d63ca3191acaf~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221009220614717"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6724d38a45f840a9af77549cc2674598~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221009220632618"></p><h2 id="4-常见的状态码"><a href="#4-常见的状态码" class="headerlink" title="4.常见的状态码"></a>4.常见的状态码</h2><table><thead><tr><th>100-101</th><th>处理信息</th></tr></thead><tbody><tr><td>200-206</td><td>请求成功</td></tr><tr><td>300-307</td><td>重定向</td></tr><tr><td>400-417</td><td>客户端错误</td></tr><tr><td>500-505</td><td>服务器错误</td></tr></tbody></table><ul><li><code>100</code>：收到了请求的起始部分，客户端应该继续</li><li><code>101</code>：服务器正切换成客户端<code>Update</code>列出的协议</li><li><code>200</code>：服务器成功处理请求</li><li><code>201</code>：用于创建服务器对象的请求（<code>PUT </code>），服务器已经有对应的资源了，响应主体中应该包含已创建的资源的 URL 以及 <code>Location</code>中的引用</li><li><code>202</code>：请求已经被接收但是服务器还未执行任何操作</li><li><code>203</code>：如果资源首部包含的信息来自于缓存或者其他节点的副本</li><li><code>204</code>：响应报文中不包含资源的主体部分（比如刷新一个表单页面时使用）</li><li><code>206</code>：成功执行那些只请求部分资源的请求 和<code>Range</code>首部配合使用</li><li><code>300</code>： 如果客户端求一个实际指向多个资源的 URL 时（比如查看某个文档网站想要查看中文文档）此时服务器应该在<code>Location</code>首部中包含首选的 <code>URL</code></li><li><code>301</code>：资源被永久转移到 <code>Location</code>指向的<code>URL</code></li><li><code>302</code>：与 301 相似 但是是临时资源，以后的请求还是使用老的 URL</li><li><code>303</code>：告知客户端应该使用另外一个 URL 获取资源（这个 URL 在<code>Location</code>中）</li><li><code>304</code>：客户端可以通过它们所包含的请求首部发起条件请 求。这个代码说明资源未发生过变化</li><li><code>305</code>：必须通过代理访问资源，代理的位置在<code>Location</code>中指出</li><li><code>307</code>：和 301 相似，但是也是临时定位</li></ul><blockquote><p>302、303、307 存在交叉主要是为了适配 http1.0 以及 http1.1（http1.1 中 303 的作用和 http1.0 的 302 作用一样，所以 http1.1 将 307 的作用和 http1.0 的 302 一样 这样可以将 302 留给 http1.0 使用）也就是用 http1.1 使用 307 来取代 302 进行临时重定向，而 http1.0 使用 302 啦临时重定向</p><p>服务器要选择适当的重定向状态码放入重定向响应中， 需要查看客户端的 http 版本</p></blockquote><ul><li><code>400</code>：客户端发送了一个错误的请求</li><li><code>401</code>：需要登录等认证方式</li><li><code>403</code>：服务器拒绝该请求（通常在服务器不想说明拒绝原因的时候使用）</li><li><code>404</code>：找不到资源</li><li><code>406</code>：客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器 没有与客户端可接受的 URL 相匹配的资源时，使用此代码</li><li><code>407</code>：和 <code>401</code>类似 但是是要求代理服务器进行认证</li><li><code>408</code>：请求超时</li><li><code>416</code>：请求报文所请求的是指定资源的某个范围 但是这个范围无效时使用</li><li><code>500</code>：服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码</li><li><code>501</code>：客户端发起的请求超出服务器的能力范围（比如，使用了服务器不 支持的请求方法）时，使用此状态码</li><li><code>502</code>：作为代理或网关使用的服务器从请求响应链的下一条链路上收到了 一条伪响应（比如，它无法连接到其父网关）时，使用此状态码</li><li><code>503</code>：用来说明服务器现在无法为请求提供服务，但将来可以。如果服务 器知道什么时候资源会变为可用的，可以在响应中包含一个 <code>Retry-After</code>首部</li></ul><h2 id="5-讲讲三次握手和四次挥手"><a href="#5-讲讲三次握手和四次挥手" class="headerlink" title="5.讲讲三次握手和四次挥手"></a>5.讲讲三次握手和四次挥手</h2><p>这个可以说是面试必问了，在讲这个之前我们先看一些前置知识</p><p>我们先来看下<code>TCP</code>头部</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/778624b80ef24eda9a9333ce762b46da~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221009223447438"></p><p>这里我们解释下上面几个比较关键的名词</p><ul><li><code>序列号</code>：建立连接时随机生成的初始值，用来解决数据包乱序的问题</li><li><code>确认号</code>：发送端接收到这个确认号可以认为在这个序号以前的数据已经被正常接收，用来解决数据丢包的问题</li><li><code>SYN</code>：希望建立连接时发送，设为 1</li><li><code>FIN</code>：希望断开连接时使用 设为 1</li><li><code>RST</code>：表示出现异常时强制断开连接 设为 1</li><li><code>ACK</code>:表示确认号有效 设为 1</li></ul><h4 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1.三次握手"></a>1.三次握手</h4><p>接下来我们就看看三次握手的流程图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/820fa9b6e809433bbbb4e5447f271581~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221010091540679"></p><p>我们照着上面的图讲解下这个过程（<strong>注意：一定要先弄明白上面<code>SYN/ACK/RST/FIN</code>这几个概念再继续看</strong>）</p><ol><li>开始时客户端处于<code>close</code>状态，为了建立连接，客户端发送了<code>SYN=1</code>表示想要建立连接，并将随机生成的<code>client_isn</code>(tcp 序列号)一起发送过去</li><li>客户端发送完想要连接的申请后就进入了 <code>SYN_SEND</code>状态等待服务端的回应</li><li>此时服务端处于<code>LiSTEN</code>状态，接收到客户端想要申请连接的请求后，将<code>ACK=client_isn + 1</code>(表明服务端接收到了正确的请求)，同时将自身随机产生的 <code>server_isn</code>以及 <code>SYN = 1</code>（确认收到了信息）一起发送过去</li><li>之后服务端就进入了 <code>SYN_RE</code>状态，等待客户端的回应</li><li>客户端接收到了服务端的<code>ACK</code>和<code>SYN</code>知道了服务端已经能够正确接收客户端的请求了，于是将服务端发的 <code>server_isn + 1</code>在<code>ACK</code>上带出去，表示自己也可以接收到服务器的响应</li><li>服务器接收到客户端的回应后，知道了客户端也可以正确接收自己发出的响应，到这里三次握手的流程就结束了</li></ol><p><strong>Q：</strong>为什么需要三次握手，两次握手不行吗？</p><p><strong>A</strong>：我们看下上面的流程，会发现，服务端第一次接收到客户端的<code>SYN</code>之后，知道了客户端想要建立连接，这个时候可以表明客户端是有发送请求的能力的，于是服务器将客户端的 <code>ack=client_isn+1</code>以及<code>SYN</code>和 <code>server_isn</code>发送过去，当客户端接收到服务器的<code>ack</code>时，它知道服务器接收到了自己正确的请求连接（到这里两次握手完成，但是这个时候只能保证服务端可以正常接收到客户端的请求，但是服务端还不知道客户端能否正常接收自己的响应，所以就需要第三次握手）第三次握手，客户端将自己收到的 <code>server_isn + 1</code>发送回去，服务端接收到数据后就明白客户端已经可以正确接收到自己的响应了，到这里双方确认互相的请求和响应都能被正常接收，第三次握手结束，整个流程也结束了</p><h4 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2.四次挥手"></a>2.四次挥手</h4><p>讲完三次握手，相信大家对于这个过程都有了一个新的认知，接下来我们趁热打铁学习一下四次挥手的过程。老规矩，我们还是先看下整个大概的流程</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7b68746de1a46db85087ae0656cb4e1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221010085417706"></p><p>接下来我们按照上图的流程来讲一下（四次挥手和三次握手不一样，因为三次握手只能客户端发送给服务端，但是四次挥手是双端都能发起，所以这里用发送端和接收端来区别！！！）</p><ol><li>发送端想要断开连接，于是发送 <code>FIN=1</code> 表示想要断开连接</li><li>发送完就进入了 <code>FIN_WAIT_1</code>状态，等待接收端的确认消息</li><li>接收端接收到了发送端的<code>FIN</code>，知道对方想要断开连接，于是先发送 <code>ACK</code>给对方，表示我收到了你的断开请求</li><li>如果接收端也想要断开连接，就会继续发送 <code>FIN=1</code>给发送端，表示:”嘿兄弟，我也想断开请求”</li><li>这个时候当发送端接收到了接收端陆续发来的 <code>ACK</code>和 <code>FIN</code>后，知道接收端可以知道自己的断开请求同时对方自己也想断开</li><li>这个时候发送端就会发送 <code>ACK=1</code>告诉接收端：“我知道你也想断开请求了，可以断开了”</li><li>接收端接收到服务端的确认 <code>ACK</code>后，便断开了连接，进入了<code>close</code>状态</li><li>发送端在进入<code>TIME_WAIT</code>等待<code>2MSL</code>的时间后也进入了 <code>close</code> 状态（为什么要等待<code>2MSL</code>呢？一个是为了保证接收端可以接收到自己最后一次发的<code>ACK</code> 因为如果对方接收不到<code>ACK</code>的话就会重发<code>FIN</code> 另一个作用是保证在新的连接前残余的数据都清除完毕）</li></ol><p><strong>Q</strong>:为什么需要四次挥手，三次挥手不行吗？</p><p><strong>A</strong>：如果我们可以理清楚每次挥手结束都代表啥，那自然可以理解这个问题。比如第一次握挥结束，接收端接收到了发送端的<code>FIN</code>，就知道了发送端想要断开连接，于是它回送了<code>ACK</code>过去，当发送端接收到了返回的<code>ACK</code>，它知道接收端已经接收到了自己断开连接的请求了，这个时候第二次挥手结束，这个时候如果接收端也想断开连接，他就会发送<code>FIN</code>给发送端，当发送端接收到<code>FIN</code>的时候，就明白原来你和我一样，都想断开连接，这个时候第三次挥手结束，但是这个时候还不能断开，因为接收端并不知道发送端能不能知道自己也想要断开连接（这也是为啥发送端要在<code>TIME_WAIT</code>等待的原因，因为接收端收不到<code>ACK</code>确认的时候就会重发<code>FIN</code>）所以需要第四次挥手，也就是发送端发送<code>ACK</code> 表示我已经知道你要断开连接了，可以断开了，当接收端接收到确认的<code>ACK</code>时 明白双方都确认完毕，于是断开连接，这里第四次挥手就结束了。</p><p><strong>总结</strong>：之所以要三次握手和四次握手，都是为了保证双方都能确认收到自己的请求信息，防止一方关闭了另一方还开着这种情况，其中的关键就是理解 <code>ACK/FIN/SYN/RST</code>的作用是啥，理解了自然就不难了</p><h2 id="6-讲讲缓存"><a href="#6-讲讲缓存" class="headerlink" title="6.讲讲缓存"></a>6.讲讲缓存</h2><p>我们前端说的本地缓存一般指的是浏览器的本地缓存（<code>webStorage</code>），而本地缓存是我们做性能优化时的一大关注点，接下来我就带大家一起学习下如何利用<strong>本地缓存</strong>来做<strong>性能优化</strong>！</p><h4 id="缓存分类："><a href="#缓存分类：" class="headerlink" title="缓存分类："></a><strong>缓存分类：</strong></h4><p>1.<strong>Memory Cache</strong>：再浏览器内存中的缓存，访问优先级最高，访问速度也是最快的（和渲染进程共存，进程关闭就清除缓存，所以有效期比较短）</p><p>2.<strong>service worker Cache</strong>：独立的 js 线程，可实现离线缓存、消息推送等功能</p><p>3.<strong>Disk Cache</strong>：磁盘中的缓存，容量较大，但是相对的访问速度较慢</p><p>4.<strong>push Cache</strong>：<code>HTTP2</code>的新特新，优先级最低（前面三种缓存无法命中后才会命中这个）</p><p>比如我们现在打开掘金首页的控制台，就可以看到哪些请求是用了缓存的</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17846fcabb5e46969ab746fdbdf0bda1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>（红色框里的就是用了<strong>memory cache</strong> 或<strong>disk cache</strong> 的）</p><h4 id="缓存策略："><a href="#缓存策略：" class="headerlink" title="缓存策略："></a><strong>缓存策略：</strong></h4><p>浏览器的缓存策略可以分为<strong>强缓存</strong> 和<strong>协商缓存</strong>两种</p><ul><li><strong>强缓存</strong>： 不用向服务器请求。可以通过设置 <code>HTTP Header</code>的 <code>expries</code>和 <code>cache-control</code>实现<ul><li><strong>expries</strong>： 服务器第一次响应时，会将过期的时间戳写在 <code>expries</code>的请求头中返回，当我们再次请求时，如果本地时间小于 <code>expries</code>的时间戳，就直接去缓存中读取资源<ul><li>缺点：如果跟改了本地时间，可能会导致缓存失效</li></ul></li><li><strong>cache-control</strong>： 通过 <code>max-age</code>控制本地资源的有效期，<code>s-maxage</code>控制代理服务器（<code>CDN缓存</code>）的有效期（<code>s-maxage</code>仅在代理服务器中生效，<code>max-age</code>仅在客户端生效），设置成<code>no-store </code>则表示拒绝一切形式的缓存<ul><li>缺点：如果更改了本地时间，同样会导致缓存失效，但是解决了 <code>expires</code>会因为客户端和服务器直接时差不一导致的缓存时间不一致的问题</li></ul></li></ul></li></ul><blockquote><p><code>cache-control</code>优先级高于 <code>expries</code></p></blockquote><ul><li><p><strong>协商缓存</strong>：浏览器需要先向服务器发起请求，在判断是否从本地获取缓存资源。可以通过设置 <code>HTTP Header</code>的 <code>Last-Modified</code>和 <code>ETag</code>实现</p><ul><li><strong>Last-Modified</strong>：首次响应时会返回 <code>Last-Modified</code>字段，之后客户端每次请求都会带上 <code>If-Modified-Since</code>的字段（上一次<code>response</code>中的 <code>Last-Modified</code>的值），服务器根据该时间戳和资源在服务器上最后的修改时间是否一致来判断是否使用缓存（返回 <code>304</code>表示使用本地缓存，返回新的 <code>Last-Modified</code>表示不使用缓存）<ul><li><strong>缺点</strong>：如果服务器没有及时感知到文件的变化（比如在毫秒级时间内完成了改动，但是因为 <code>Last-Modified</code>是秒级导致无法感知）</li></ul></li><li><strong>ETag</strong>：既然上面的 <code>Last-Modified</code>存在着缺点，那 <code>ETag</code>就是他的解决方案（服务器根据文件内容编码生成唯一标识符，可以精确感知文件的变化），首次响应会返回 <code>ETag</code>标识，下一次请求就带上 <code>If-None-Match</code>与服务端进行比较来判断是否使用缓存<ul><li><strong>缺点</strong>：服务端需要额外的开销来生成 <code>ETag</code>标识</li></ul></li></ul></li></ul><blockquote><p><strong>Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。</strong></p></blockquote><h4 id="HTTP-决策"><a href="#HTTP-决策" class="headerlink" title="HTTP 决策"></a><strong>HTTP 决策</strong></h4><p>关于 HTTP 请求的决策，这里我们通过<strong>Chrome</strong>给出的官方流程图来给大家讲解</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a976c759466647dc9d23636bbac9f81b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>接下来我给大家解释下上面的步骤</p><ol><li>考虑资源是否可复用<ol><li>如果不可以复用，则直接设置 <code>Cache-Control</code> 成 <code>no-store</code>表示拒绝一切形式的缓存</li><li>如果可以复用，考虑是否设置成每次都需要向浏览器进行缓存的有效确认<ol><li>如果需要，则设置 <code>Cache-Control</code>为 <code>no-cache</code></li><li>如果不需要，则考虑是否可以被代理服务器缓存<ol><li>如果可以，设置成 <code>public</code></li><li>如果不行，设置成 <code>private</code></li></ol></li></ol></li><li>考虑资源有效时长<ol><li>设置对应的 <code>max-age</code>和 <code>s-maxage</code>等值</li><li>最后再设置协商缓存需要用到的 <code>ETag</code>和 <code>Last-Modified</code></li></ol></li></ol></li></ol><p>以上便是对于一个<strong>HTTP 请求</strong>是否要用缓存以及如何使用缓存的决策过程，我们在考虑是否使用缓存的时候也可以按着这个思路来考虑。</p><h4 id="网页刷新对缓存的影响"><a href="#网页刷新对缓存的影响" class="headerlink" title="网页刷新对缓存的影响"></a>网页刷新对缓存的影响</h4><p>接下来我们看看网页刷新对各类缓存的影响，帮助大家更好地使用缓存</p><ul><li><strong>强制刷新</strong>： 直接从服务器请求，跳过强缓存和协商缓存（比如 <code>Ctrl + F5</code>）</li><li><strong>地址栏回车或正常刷新</strong>：跳出强缓存，检查协商缓存</li><li><strong>新窗口的 URL 访问</strong>： 按照正常的缓存策略，即先检查强缓存</li></ul><p>相信看到这里你对于如何使用缓存来优化性能应该有了更深入的了解，赶快动手试试吧！</p><h2 id="7-讲讲-DNS"><a href="#7-讲讲-DNS" class="headerlink" title="7.讲讲 DNS"></a>7.讲讲 DNS</h2><p><code>DNS</code>:域名系统，当客户端发送一个 URL 请求时，通过<code>DNS</code> 去解析这个<code>URL</code>对应的<code>IP</code>，这个就是<code>DNS</code>的作用。</p><ul><li>一个由分层的<code>DNS</code>服务器实现的<strong>分布式数据库</strong></li><li>一个使得主机能够查询分布式数据库的<strong>应用层协议</strong></li></ul><p>我们先看下<code>DNS</code>的层次结构</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23c4ddafd6f2402a8f3bb1fc9fb1473c~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221010092634078"></p><p>（图片来源于《计算机网络：自顶向下的方法》）</p><p>我们依次解释一下各层的<code>DNS</code>以及作用</p><p>我们就拿掘金的首页 <a href="https://juejin.cn/%E6%9D%A5%E8%AE%B2%E8%A7%A3%E5%90%A7">https://juejin.cn/来讲解吧</a></p><h4 id="1-根-DNS-服务器"><a href="#1-根-DNS-服务器" class="headerlink" title="1.根 DNS 服务器"></a>1.根 DNS 服务器</h4><p>根<code>DNS</code>服务器可以管理顶级域 DNS 服务器，也就是说我们可以通过询问根<code>DNS</code>服务器知道这个主机名对应的顶级域<code>DNS</code>服务器的 IP 是多少然后在下一阶段去向顶级域<code>DNS</code>服务器查询（如果有需要的话），像 <code>juejin.cn</code>这个<code>url</code>里的根域名其实是最后面的那个 <code>.</code></p><h4 id="2-顶级域-DNS-服务器"><a href="#2-顶级域-DNS-服务器" class="headerlink" title="2.顶级域 DNS 服务器"></a>2.顶级域 DNS 服务器</h4><p>管理下一级的权威<code>DNS</code>服务器，也就是说我们可以通过询问顶级域<code>DNS</code>服务器获知这个主机对应的权威<code>DNS</code>服务器的 ip 然后在下一阶段去查询。像 <code>juejin.cn</code>里面这个 <code>cn</code>就是顶级域名，其他常见的顶级域名还有 <code>com(最常见)、edu(教育机构 比如 gdut.edu)、org(适用于各类组织机构)</code></p><h4 id="3-权威-DNS-服务器"><a href="#3-权威-DNS-服务器" class="headerlink" title="3.权威 DNS 服务器"></a>3.权威 DNS 服务器</h4><p>查询权威<code>DNS</code>服务器就可以获取最终的 IP 地址了</p><h3 id="DNS-的查询过程"><a href="#DNS-的查询过程" class="headerlink" title="DNS 的查询过程"></a>DNS 的查询过程</h3><p>我们先来看下整个大概流程</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccc7dc0e47a04cc386ca06cd1bbdd780~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221010094615749"></p><p>先给大家解释下<strong>本地 DNS 服务器</strong>：本地<code>DNS</code>服务器可以说是整个过程的核心成员，你可以把本地服务器当成是代理（当主机发出<code>DNS</code>请求时，该请求会被发送到本地 DNS 服务器，由本地 DNS 服务器去进行后续的各个查询过程）可以理解为你们公司的 ISP、你们学校的 ISP 甚至小区的 ISP 都有属于自己的本地 DNS 服务器。本地 DNS 服务器在<strong>DNS 缓存</strong>中同样发挥着至关重要的作用</p><p>接下来我们解释下上面的流程</p><ol><li>首先我们请求 <code>juejin.cn</code>，将请求转发到<code>本地DNS服务器</code></li><li><code>本地DNS服务器</code>将该请求转发至 <code>根DNS服务器</code></li><li><code>根DNS服务器</code>接收到了请求，发现了 <code>.cn</code>,于是向<code>本地DNS服务器</code>返回 <code>cn</code> 对应的<code>顶级域DNS服务器</code>的 IP 列表（即我不知道这个的<code>ip</code>，但是<code>顶级DNS服务器</code>可能知道，你去问它们）</li><li><code>本地DNS服务器</code>于是向上一步返回的列表中的<code>顶级域DNS服务器</code>发送请求</li><li>该<code>顶级域DNS服务器</code>注意到了 <code>juejin.cn</code> 于是将对应的<code>权威DNS服务器</code>的 IP 列表发过去（我不知道这个，但是这些<code>权威DNS服务器</code>应该知道）</li><li><code>本地DNS服务器</code>于是向<code>权威DNS服务器</code>发送请求</li><li><code>权威DNS服务器</code>查询到了 <code>juejin.cn</code>对应的 ip 地址并返回</li><li><code>本地DNS服务器</code>将收到的 <code>juejin.cn</code>以及对应的 ip 返回给主机 主机开始真正请求对应的 ip 地址</li></ol><p>到这里流程就结束了。我们可以轻松发现，所有的请求都是由<code>本地DNS服务器</code>发出的，而对应的响应也是直接返回给<code>本地DNS服务器</code>（大家经常看到的说什么查询过程是 <code>递归+迭代</code>其实就是主机向本地 DNS 查询的过程是一个<code>递归</code>过程，而本地服务器向每个层次的 DNS 服务器请求的过程是一个<code>迭代</code>的过程）</p><p><strong>Q</strong>:什么是 DNS 缓存？</p><p><strong>A</strong>：在 DNS 的查询过程中，当一台 DNS 服务器接收到了一个 DNS 响应，就可以选择将映射缓存到本地，这样下次再请求就可以直接拿出本地缓存的内容，这就可以让我们更快的获取想要的 ip（当 DNS 缓存使用好之后，我们很少会去查询根 DNS 服务器，这大大加快我们的查询速度），同时也应该注意管理 DNS 缓存，在一定时间后清除掉对应的缓存（缓存不是永久存在的，有各自对应的有效时间）</p><h2 id="8-讲讲-http-的不同版本"><a href="#8-讲讲-http-的不同版本" class="headerlink" title="8.讲讲 http 的不同版本"></a>8.讲讲 http 的不同版本</h2><h3 id="1-HTTP-0-9"><a href="#1-HTTP-0-9" class="headerlink" title="1.HTTP/0.9"></a>1.HTTP/0.9</h3><p>HTTP/0.9 是最早的 HTTP 协议，即超文本传输协议，主要用于学术交流等简单功能</p><p><strong>特点：</strong></p><ul><li>只有一个请求行，没有请求头和请求体</li><li>服务器只返回数据，不返回响应头等信息</li><li>以 ASCII 字符流传输文件（因为传输的都是 HTML 格式的文件，使用 ASCII 字符流传输最合适）</li></ul><h3 id="2-HTTP-1-0"><a href="#2-HTTP-1-0" class="headerlink" title="2.HTTP/1.0"></a>2.HTTP/1.0</h3><ul><li>无状态、无连接的协议，默认使用非持久连接</li><li>每次请求都需要建立一个 TCP 连接</li><li>存在队头阻塞的问题（队头阻塞：下一个请求需要在前一个请求响应到达之后才能发送，如果前一个请求一直不响应到达，就会造成后面的请求阻塞）</li><li>不能请求资源的一部分，只能完整请求</li><li>使用 <code>If-Modified-Since | Expries</code>控制缓存</li></ul><h3 id="3-HTTP-1-1"><a href="#3-HTTP-1-1" class="headerlink" title="3.HTTP/1.1"></a>3.HTTP/1.1</h3><ul><li>默认使用持久连接（<code>Connect:keep-alive</code>）</li><li>通过多个 http 请求复用同一个 TCP 连接来避免每次建立连接的时延</li><li>同一个 host 下最多只能共存 6 个 TCP 连接</li><li>比起 HTTP/1.0 增加了 <code>ETag| If-Unmodified-Since | If-Match</code>等更多缓存头部字段，支持协商缓存和强缓存</li><li>新增了 <code>PUT | HEAD | OPTIONS</code>等请求方法</li><li>支持资源的部分请求和范围请求</li><li>支持请求管道化（在等待上一个请求响应的同时可以直接发送下一个请求，不需要像 http1.0 一样等待上一个请求响应结果的返回，但是服务器还是按照发送请求的顺序处理请求，所以并不是真正意义上的并行请求）</li><li>新增 Host 字段（一个服务器可以创建多个 web 站点）</li><li>引入了客户端 Cookie 机制和安全机制</li><li>使用 CDN 的实现域名分片机制</li><li>仍然存在队头阻塞问题</li><li>存在 TCP 慢启动（TCP 连接建立后，会采用一个非常慢的速度去发送数据，然后再慢慢调整至最合适的发送速度，这个过程就是慢启动）</li></ul><h3 id="4-HTTP-2-0"><a href="#4-HTTP-2-0" class="headerlink" title="4.HTTP/2.0"></a>4.HTTP/2.0</h3><ul><li>可以设置请求的优先级</li><li>服务器推送（http2 可以直接将数据提前推送到浏览器，这对首屏速度的优化起了很大的作用）</li><li>头部压缩。http/2.0 可以对请求头和响应头进行压缩，提高了请求的速度</li><li>引入了数据流。（HTTP/2.0 的数据包不是按序发送的，所以需要对数据包做标记，每个请求或者响应的所有数据包就是一个数据流）</li><li>二进制协议：HTTP2.0 中头信息和数据主体都是二进制，这给了我妹分帧的能力，从而实现多路复用</li><li>多路复用<ul><li>同一个域名只开启一条 TCP 连接，所有请求和响应都在上面完成</li><li>将数据流以消息的形式发送，消息可以拆分成帧，帧之间可以乱序发送（根据帧首部的流表示来保证接收端重组数据时的顺序）</li><li>单个连接可以流通双向数据（可以并行传输互不干扰的请求和响应信息）</li><li>解决了队头阻塞的问题，极大地加快了请求的速度和利用率</li></ul></li></ul><h3 id="5-HTTP-3-0（QUIC-协议）"><a href="#5-HTTP-3-0（QUIC-协议）" class="headerlink" title="5.HTTP/3.0（QUIC 协议）"></a>5.HTTP/3.0（QUIC 协议）</h3><p>基于 UDP 实现了类似于 TCP 的多路数据流，可靠传输等功能</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84b7d234ea8c4dfb99b9eeed05ab7804~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221010152412160"></p><ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能，提供了数据包重传、拥塞控制以及其他的一些 TCP 中存在的特性</li><li>集成了 TLS 加密功能，可以减少握手所花费的 RTT 个数（三次握手其实是个比较浪费时间的过程）</li><li>实现了 HTTP/2 中的多路复用功能，实现了数据流的单独传输，解决了 TCP 中队头阻塞的问题</li><li>实现了快速握手功能，这大大提升首页速度</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcdc0cc12b604e3290ffe505eddb7086~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>不知不觉已经写了近一万字了，但是却只写了不到一半的内容，限于篇幅的原因，剩下的内容将在下篇补全，感兴趣的同学可以关注一波持续学习！！！</p><p><strong>tips</strong>：创作不易，觉得作者写的还不错的可以点赞收藏支持一下呀</p><h3 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h3><ul><li><strong>CDN</strong></li><li><strong>cookie、token、jwt、session</strong></li><li><strong>前端安全（XSS | CSRF|SQL 注入 | DOS 攻击）</strong></li><li><strong>HTTP 和 HTTPS 的区别</strong></li><li><strong>加密算法</strong></li><li><strong>重定向</strong></li><li><strong>webSocket</strong></li><li><strong>跨域问题</strong></li></ul><h3 id="往期推荐"><a href="#往期推荐" class="headerlink" title="往期推荐"></a>往期推荐</h3><ul><li><a href="https://juejin.cn/post/7151202596961648671"> 谈谈浏览器关于渲染流程、缓存以及网络请求的原理</a></li><li><a href="https://juejin.cn/post/7140185024653066271">谈谈前端性能优化的常见手段及知识原理</a></li><li><a href="https://juejin.cn/post/7138203576098095112"> 一文带你读懂 webpack 的知识和原理，附带常见面试题！</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器原理系列（一）：关于架构、TCP/HTTP、缓存以及渲染流程的原理</title>
      <link href="/2022/10/05/liu-lan-qi-yuan-li-xi-lie-yi-guan-yu-jia-gou-tcp/http-huan-cun-yi-ji-xuan-ran-liu-cheng-de-yuan-li/"/>
      <url>/2022/10/05/liu-lan-qi-yuan-li-xi-lie-yi-guan-yu-jia-gou-tcp/http-huan-cun-yi-ji-xuan-ran-liu-cheng-de-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>我们都知道前端工程师每天都需要和浏览器打交道，浏览器对于我们的重要程度不言而喻。但是不知道各位在日常开发（摸鱼 bushi）中有没有和笔者有一些共同的疑惑，比如为什么我只是打开了一个标签页却开了好几个进程（可通过浏览器的任务管理器查看）、为什么大家都倾向于使用 <strong>chrome</strong>而不是其他浏览器、为什么同一个资源第二次、第三次访问往往会比第一次快很多、为什么资源可以完整安全地送达到浏览器、从输入一个 <code>URL</code>到看到渲染好地页面这中间到底发生了什么？如果你对于上面的问题都能回答上来，那你对于浏览器的知识储备应该比我强不少哈哈哈，如果你对于这些问题也有疑问，那我相信这篇文章或许可以解答你的疑惑！！！接下来我们就按照问题一个一个来解决大家的疑惑并学习背后的知识原理。（<code>ps：</code>先 <code>赞</code>后看，这是我创作的动力！！！</p><h3 id="你将学到："><a href="#你将学到：" class="headerlink" title="你将学到："></a>你将学到：</h3><ul><li>浏览器的工作原理</li><li><strong>chrome</strong>的进程、线程相关知识和架构</li><li>浏览器缓存</li><li>TCP/HTTP 相关知识</li><li>浏览器的导航过程（从输入 <code>URL</code>到渲染出完整的 <code>页面</code>）</li></ul><p>话不多说，让我们进入今天的学习吧！</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dbf2e06b3d1448c9ec3896bfe43be60~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="chrome-的进程、线程以及架构"><a href="#chrome-的进程、线程以及架构" class="headerlink" title="chrome 的进程、线程以及架构"></a>chrome 的进程、线程以及架构</h2><p>如果你现在打开浏览器的任务管理器，就会看到下面这样的图片</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81016709f03f47428393acacac0df3fd~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220928205430775"></p><p>你可能会产生疑惑，明明我只是打开了掘金，明明 <code>js</code>是单线程的，为什么会开了这么多的进程？为了解开这个疑惑，我们需要先看下 <code>线程</code>和 <code>进程</code>的基本概念</p><p><strong>进程</strong>：系统进行资源调度和分配的基本单位，实现了操作系统的并发</p><p><strong>线程</strong>：进程的子任务，是<code>CPU</code>调度和分派的基本单位，用于保证程序的实时性，实现 <code>进程</code>内部的并发</p><p>看完 <code>进程</code>和 <code>线程</code>的概念，接下来我们来看下 <code>chrome</code>的多进程架构图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5844b341a06f4fcd91b9dc7b2fbbad56~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220928210943153"></p><p>可以看到，<code>chrome</code>包含以下进程</p><ul><li><strong>插件进程</strong>：负责插件的运行（隔离插件进程和其他进程可以防止因为插件进程的奔溃或错误影响浏览器和其他页面，因为你不能保证你的插件是绝对安全稳定的）</li><li><strong>渲染进程</strong>：将 <code>HTML/CSS/JS</code>转换为交互的页面（排版引擎 <code>Blink</code>和 JavaScript 引擎 <code>V8</code>都是运行在这里），默认情况下 <code>chrome</code>会为每个 <code>Tab</code>开启一个渲染进程（渲染进程通过在沙箱中运行来保证安全）</li><li><strong>网络进程</strong>：负责网络资源的加载，比如请求和响应，浏览器缓存等功能</li><li><strong>浏览器主进程</strong>：负责显式、交互、子进程管理以及存储等功能</li><li><strong>GPU 进程</strong>：实现 <code>3DCSS</code>等效果以及 <code>UI界面</code>的绘制</li></ul><p>看完上面对各进程的知识讲解，你现在应该可以知道为啥我们打开一个网页会开启这么多进程了吧，关于这些进程一些实际应用场景将在后面的几个小节中穿插详解。</p><p><strong>Q</strong>：为什么 JS 是<code>单线程</code>的，为什么不适用多线程的并行能力？</p><p><strong>A</strong>：由于 JS 经常要操作 <code>DOM</code>以及和用户互动，如果是多线程的话，可能会出现 A 线程在修改 <code>DOMA</code>结果 B 线程删除了 <code>DOMA</code>这样的情况，这个时候就会出现线程冲突（<code>HTML5</code>提出了 <code>Web Worker</code>允许 js 创建多个子线程在后台进行并行操作，但是这些子线程并不能操作 <code>DOM</code> 所以这个标准并不能说让 js 变成多线程），而为了使 js 也能像其他语言那样拥有异步和并行的能力，浏览器通过 <code>事件队列、事件循环</code>来解决这个问题，推荐看这篇文章 <a href="https://juejin.cn/post/7097142990044889102">一文带你读懂浏览器的事件循环机制 - 掘金 (juejin.cn)</a></p><blockquote><p><code>Chorme</code>团队正在设计新的 <code>Chrome</code>架构，目的是构建一个 <code>更内聚、松耦合、易于维护和扩展的系统</code>，感兴趣的朋友可以去网上查找相关资料</p></blockquote><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>你在日常生活中是否有留意过这样一个现象，当我们第一次打开一个网站时，往往需要等待数秒的加载，而之后我们再打开这个网站时，就会比之前快很多，这其中其实是 <code>浏览器缓存</code>的功劳。</p><p><code>浏览器</code>是指浏览器根据 <code>url</code>第一次访问资源之后，根据缓存策略将 <code>html、css、js、图片等资源</code>保存在浏览器本地，之后你再访问这些资源时，便可以根据缓存策略决定是使用本地的缓存还是重新请求。</p><blockquote><p><code>浏览器缓存</code>是前端性能优化必不可少的重要一环！！！</p></blockquote><p>那如何查看自己的请求是使用缓存还是重新访问呢？我们直接打开掘金的首页并打开控制台</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17846fcabb5e46969ab746fdbdf0bda1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>（红色框里的就是用了<strong>memory cache</strong> 或<strong>disk cache</strong> 的 像这些就是使用了缓存的）</p><h4 id="缓存分类："><a href="#缓存分类：" class="headerlink" title="缓存分类："></a><strong>缓存分类：</strong></h4><p>1.<strong>Memory Cache</strong>：在浏览器内存中的缓存，访问优先级最高，访问速度也是最快的（和渲染进程共存，进程关闭就清除缓存，所以有效期比较短）</p><p>2.<strong>service worker Cache</strong>：独立的 js 线程，可实现离线缓存、消息推送等功能</p><p>3.<strong>Disk Cache</strong>：磁盘中的缓存，容量较大，但是相对的访问速度较慢</p><p>4.<strong>push Cache</strong>：<code>HTTP2</code>的新特新，优先级最低（前面三种缓存无法命中后才会命中这个）</p><h4 id="缓存策略："><a href="#缓存策略：" class="headerlink" title="缓存策略："></a><strong>缓存策略：</strong></h4><p>浏览器的缓存策略可以分为<strong>强缓存</strong> 和<strong>协商缓存</strong>两种</p><ul><li>强缓存： 不用向服务器请求。可以通过设置 <code>HTTP Header</code>的 <code>expries</code>和 <code>cache-control</code>实现<ul><li><code>expries</code>： 服务器第一次响应时，会将过期的时间戳写在 <code>expries</code>的请求头中返回，当我们再次请求时，如果本地时间小于 <code>expries</code>的时间戳，就直接去缓存中读取资源<ul><li>缺点：如果更改了本地时间，可能会导致缓存失效</li></ul></li><li><code>cache-control</code>： 通过 <code>max-age</code>控制本地资源的有效期，<code>s-maxage</code>控制代理服务器（<code>CDN缓存</code>）的有效期（<code>s-maxage</code>仅在代理服务器中生效，<code>max-age</code>仅在客户端生效），设置成<code>no-store</code> 则表示拒绝一切形式的缓存<ul><li>缺点：如果更改了本地时间，同样会导致缓存失效，但是解决了 <code>expires</code>会因为客户端和服务器直接时差不一导致的缓存时间不一致的问题</li></ul></li></ul></li></ul><blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`cache-control`优先级高于 `expries</span><br></pre></td></tr></tbody></table></figure></blockquote><ul><li><strong>协商缓存</strong>：浏览器需要先向服务器发起请求，在判断是否从本地获取缓存资源。可以通过设置 <code>HTTP Header</code>的 <code>Last-Modified</code>和 <code>ETag</code>实现<ul><li><code>Last-Modified</code>：首次响应时会返回 <code>Last-Modified</code>字段，之后客户端每次请求都会带上 <code>If-Modified-Since</code>的字段（上一次<code>response</code>中的 <code>Last-Modified</code>的值），服务器根据该时间戳和资源在服务器上最后的修改时间是否一致来判断是否使用缓存（返回 <code>304</code>表示使用本地缓存，返回新的 <code>Last-Modified</code>表示不使用缓存）<ul><li><strong>缺点</strong>：如果服务器没有及时感知到文件的变化（比如在毫秒级时间内完成了改动，但是因为 <code>Last-Modified</code>是秒级导致无法感知）</li></ul></li><li><code>ETag</code>：既然上面的 <code>Last-Modified</code>存在着缺点，那 <code>ETag</code>就是他的解决方案（服务器根据文件内容编码生成唯一标识符，可以精确感知文件的变化），首次响应会返回 <code>ETag</code>标识，下一次请求就带上 <code>If-None-Match</code>与服务端进行比较来判断是否使用缓存<ul><li><strong>缺点</strong>：服务端需要额外的开销来生成 <code>ETag</code>标识</li></ul></li></ul></li></ul><blockquote><p><strong>Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。</strong></p></blockquote><h4 id="HTTP-决策"><a href="#HTTP-决策" class="headerlink" title="HTTP 决策"></a><strong>HTTP 决策</strong></h4><p>关于 HTTP 请求的决策，这里我们通过<strong>Chrome</strong>给出的官方流程图来给大家讲解</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a976c759466647dc9d23636bbac9f81b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>接下来我给大家解释下上面的步骤</p><ol><li>考虑资源是否可复用<ol><li>如果不可以复用，则直接设置 <code>Cache-Control</code> 成 <code>no-store</code>表示拒绝一切形式的缓存</li><li>如果可以复用，考虑是否设置成每次都需要向浏览器进行缓存的有效确认<ol><li>如果需要，则设置 <code>Cache-Control</code>为 <code>no-cache</code></li><li>如果不需要，则考虑是否可以被代理服务器缓存<ol><li>如果可以，设置成 <code>public</code></li><li>如果不行，设置成 <code>private</code></li></ol></li></ol></li><li>考虑资源有效时长<ol><li>设置对应的 <code>max-age</code>和 <code>s-maxage</code>等值</li><li>最后再设置协商缓存需要用到的 <code>ETag</code>和 <code>Last-Modified</code></li></ol></li></ol></li></ol><p>以上便是对于一个<strong>HTTP 请求</strong>是否要用缓存以及如何使用缓存的决策过程，我们在考虑是否使用缓存的时候也可以按着这个思路来考虑。</p><h4 id="网页刷新对缓存的影响"><a href="#网页刷新对缓存的影响" class="headerlink" title="网页刷新对缓存的影响"></a>网页刷新对缓存的影响</h4><p>接下来我们看看网页刷新对各类缓存的影响，帮助大家更好地使用缓存</p><ul><li><strong>强制刷新</strong>： 直接从服务器请求，跳过强缓存和协商缓存（比如 <code>Ctrl + F5</code>）</li><li><strong>地址栏回车或正常刷新</strong>：跳出强缓存，检查协商缓存</li><li><strong>新窗口的 URL 访问</strong>： 按照正常的缓存策略，即先检查强缓存</li></ul><p>上面就是对于浏览器缓存的一些讲解了，相信看到这里你一定对于浏览器缓存有一些新的或者更深入的了解。</p><h2 id="TCP-HTTP-在浏览器中的使用"><a href="#TCP-HTTP-在浏览器中的使用" class="headerlink" title="TCP/HTTP 在浏览器中的使用"></a>TCP/HTTP 在浏览器中的使用</h2><p>首先我们先学一些前置知识</p><ul><li><code>IP</code>：计算机的地址（互联网协议地址）</li><li><code>UDP</code>：支持一个无连接的传输协议，为程序提供了一种无需建立连接就可以发送封装的 <code>IP</code>数据包的方法。不能保证数据的可靠性，但是传输速度非常快（可用于一些对完整性要求不高的场景，比如视频、互动游戏等）</li><li><code>TCP</code>：一种面向连接的、可靠的、基于字节流的传输层通信协议（连接到不同但互相连接的计算机通信网络的著计算机中的成对进程之间依靠 <code>TCP</code>提供的可靠的通信服务）</li><li><code>HTTP</code>:超文本传输协议，通常运行在 <code>TCP</code>之上，通过浏览器和服务器进行数据交互、进行超文本（文本、图片、视频等）传输的规定</li></ul><p>接下来我们讲一下 <code>TCP</code>连接的过程（包含 <code>建立连接 - 传输数据 - 断开连接</code>）</p><ol><li><strong>建立连接</strong>：通过三次握手来建立连接<ol><li>客户端向服务端发送 <code>SYN包</code>并等待服务器确认（客户端进入 <code>SYN-SENT</code>阶段）</li><li>服务端收到客户端的 <code>SYN包</code>后，对该包进行确认后结束 <code>LISTEN</code>阶段，并返回一段 <code>TCP</code>报文 随后进入 <code>SYN-RECV</code>阶段</li><li>客户端接受到服务端的 <code>SYN + ACK</code>包之后，确认连接是正常的 从而结束 <code>SYN-SENT</code>阶段并发送最后一段报文</li><li>服务端接收到客户端确认收到服务器数据的报文后，明确连接是正常的，三次握手的过程完成</li></ol></li><li><strong>传输数据</strong>：客户端需要对每个数据包进行确认操作（接收到数据之后要发送确认数据包给服务端）所以当服务端在规定事件内没有接受到客户端的确认消息，就判断丢包并重发 （一个大的文件在传输的过程中会被拆封成多个小的数据包并在客户端按照 TCP 头部的序号排序重组成完整的数据）</li><li><strong>断开连接</strong>：通过四次挥手来保证双方都断开连接</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e0964b551654633a79922e6c259417b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220928221859252"></p><p><strong>总结：</strong> <code>TCP</code>牺牲了数据包的传输数量（三次握手和数据包校验机制大大提高了数据包的数量）来保证了数据传输的可靠性</p><h3 id="浏览器中-HTTP-的请求流程"><a href="#浏览器中-HTTP-的请求流程" class="headerlink" title="浏览器中 HTTP 的请求流程"></a>浏览器中 HTTP 的请求流程</h3><p>先用一张图来看一下浏览器中的 HTTP 请求所经历的各个阶段</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96b26a25ab374bbda7025646c6a7a9ce~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>接下来我们按照图中的流程来解释下里面的各个过程</p><ol><li><p>构建请求（根据搜索框的信息构建请求 url）</p><ol><li>如果是符合 <code>url</code>的形式则根据对应的网络协议拼接成请求<code>url</code>（比如我们输入 <code>juejin.cn</code>会被自动拼接为 <code>https://juejin.cn/</code>）</li><li>如果是一些其他搜索内容，则根据对应的搜索引擎去拼接请求的 <code>url</code>（比如输入 <code>掘金</code>则会自动拼接为 <code>https://www.google.com/search?q=%E6%8E%98%E9%87%91&amp;oq=%E6%8E%98%E9%87%91&amp;aqs=chrome..69i57j0i13j69i59j0i13j0i30j0i13i30l4j0i10i13i15i30.1257j0j15&amp;sourceid=chrome&amp;ie=UTF-8</code>）</li></ol></li><li><p>查找缓存：根据缓存策略去判断是使用缓存还是重新请求资源</p><ol><li>使用缓存：直接使用缓存，整个请求过程结束</li><li>重新请求：进入网络请求过程</li></ol></li><li><p>查找 ip 地址和端口： 根据 <code>DNS（域名系统）</code>查找对应的<code>ip</code>，拿到<code>ip</code>后就需要获取对应的端口（<code>url</code>没有特别指明默认使用 <code>80端口</code>）</p></li><li><p>等待 tcp 队列：由于 <strong>chrome</strong>对于每个域名的 <code>TCP</code>连接数量有限制 （同个域名下最多只能建立 6 个连接）</p><ol><li>同一个域名下有大于 6 个请求同时发生，则需要等待</li><li>少于 6 个。则直接建立 TCP 连接</li></ol></li><li><p>建立 TCP 连接：进行三次握手进行 TCP 连接，连接成功则进入下一阶段</p></li><li><p>发送 HTTP 请求：</p><ol><li>浏览器向服务器发送 <strong>请求行</strong> ，包括 <strong>请求方法、请求 URI、HTTP 版本协议</strong>（如果是像 <code>post</code>这些方法，还需要在 <code>请求体</code>中将对应的数据发送过去）</li><li>发送<strong>请求头</strong>，包括所使用的操作系统、浏览器内核、域名信息、cookie 等信息</li></ol></li><li><p>服务器处理 HTTP 请求： 根据浏览器的请求信息返回相应的内容</p><ol><li>服务器返回的数据格式包括响应行（包括协议版本和 1 状态码等）、响应头（包括生成数据的时间戳、数据类型以及 cookie 等信息）、响应体（客户端实际想要的大部分内容）</li><li>断开连接<ol><li>正常情况下服务器返回了响应数据后就会请求端来 <code>TCP</code>连接</li><li>如果浏览器/服务器在头部信息加入了 <code>Connection:Keep-Alive</code> 则不会断开连接（可以省去下次请求时建立连接的时间从而加快资源加载速度）</li></ol></li><li>重定向：如果服务器返回了 <code>3xx</code>一般就是重定向 比如 <code>301</code> 这个时候会在响应头的 <code>location</code>中带上重定向的地址，浏览器接收到后就会自动再请求重定向的地址 (比如你输入 <code>baidu.com</code>会被重定向到 <code>https://www.baidu.com</code> )</li></ol><p><strong>总结</strong>：以上便是浏览器中 <code>HTTP</code>请求的全部过程了，经过了 <code>：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接</code>这八个阶段</p><h2 id="从输入-URL-到渲染完页面发生了什么"><a href="#从输入-URL-到渲染完页面发生了什么" class="headerlink" title="从输入 URL 到渲染完页面发生了什么"></a>从输入 URL 到渲染完页面发生了什么</h2><p><strong>面试官</strong>: 说一说从输入 url 到页面渲染完成这个过程发生了什么？</p><p><strong>我：</strong>。。。。。。</p><p>相信大家多多少少都看过上面这个问题，因为这是一道非常高频的经典面试题，面试官往往会从这道来考察你的基础知识（包括浏览器的进程架构、请求过程、渲染原理等等），接下来我们就一起来学习下这个过程，避免下次遇到的时候翻车！！</p><p>我们先回顾下第一小节的知识，浏览器中有 <code>浏览器主进程、网络进程、渲染进程</code>，这三个进程便是这个过程的三大主力军，我们再来回顾下第二小节的内容 <code>浏览器缓存</code>，这会决定是否跳过请求资源的阶段，我们再回顾下上一小节的 <code>HTTP在浏览器中的应用</code>，这将决定哪个进程负责请求中的那个阶段，这么一看是不是发现这道题可以把前面的知识都连接起来！！！</p><p>接下来进入我们的学习吧！</p><p>按照管理，我们先看一下这个过程的大致流程图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d7d7e94c24443749c9fc9f78fb28425~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220928232858665"></p><p>（作图使用的是<a href="https://www.iodraw.com/%EF%BC%89">https://www.iodraw.com/）</a></p></li></ol><p>我们先带大家回顾下三个进程的各自职责是干嘛的</p><ul><li>浏览器主进程：用户交互、主进程管理以及文件存储等功能</li><li>网络进程：面向渲染进程和浏览器主进程提供网络相关功能（包括浏览器缓存）</li><li>渲染进程：将 <code>HTML/CSS/JS/图片等资源</code>解析成页面（运行在沙箱内保证系统的安全）</li></ul><p>接下来我们按照图来讲解整个过程</p><ol><li><p>用户输入，浏览器根据用户输入生成请求的 url 并发起请求</p></li><li><p>判断是否使用缓存：</p><ol><li><p>如果有缓存资源，则直接将缓存资源返回给浏览器主进程</p></li><li><p>如果不使用缓存，则进入网络请求过程</p><ol><li>进行 DNS 解析 获取对应的 <code>ip</code>地址 （如果是 <code>HTPS</code> 还要建立 <code>TSL</code>连接）</li><li>建立 TCP 连接</li><li>构建请求头、请求行、请求体信息发起请求</li><li>服务器开始处理响应信息</li><li>浏览器接收到响应信息并分析请求头<ol><li>如果带有重定向等信息 则重新请求重定向 url 指向的资源</li><li>否则接受响应并提示浏览器主进程准备渲染进程</li></ol></li><li>判断响应信息的类型（<code>Content-Type</code>）<ol><li>如果是下载类型 则被提交到下载管理器 URL 请求的导航阶段结束</li><li>如果是 <code>HTML</code>类型 则继续导航流程</li></ol></li><li>接下来准备渲染流程</li></ol></li><li><p>准备渲染流程</p><ol><li>浏览器默认会为每个 tab 页创建一个渲染进程</li><li>如果是属于同一个站点（比如从一个页面打开另一个新的页面且两个页面是同一个站点）则新页面会复用父页面的渲染进程</li><li>准备好渲染进程后将进入提交文档阶段</li></ol></li><li><p>提交文档阶段：将网络进程接收到的 <code>HTML</code>数据提交给渲染进程</p><ol><li>浏览器进程接受到网络进程的响应头数据后 ，向浏览器进程发起 <code>提交文档</code>的信息</li><li>渲染进程接收到 <code>提交文档</code>的信息后 就会和网络进程建立起传输数据的 <code>管道</code></li><li>当文档数据传输完成后 渲染进程会返回 <code>确认提交</code>的信息给浏览器进程</li><li>浏览器进程收到 <code>确认提交</code>的信息后 会更新浏览器页面状态（包括安全状态、地址栏 url、历史状态以及 web 页面） 这就是为什么我们输入一个网址时浏览器并没有立马跳转而是过一会跳转的原因</li><li>之后就进入了渲染阶段</li></ol><p>5.渲染阶段：渲染阶段即将 <code>HTML/CSS/JS/图片</code>等资源渲染成我们看到的页面，这一部分的内容有点多，受限于篇幅，推荐大家直接看我的另一篇文章 <a href="https://juejin.cn/post/7098248836543414285">浏览器是如何将 HTML、CSS、JavaScript 变成可视的页面的 - 掘金 (juejin.cn)</a></p><p><strong>总结</strong>: 好的，讲到这里我们已经将从输入 <code>URL</code>到页面渲染的内容讲完了，相信大家都收获了一些东西</p><p><strong>结束语：</strong></p><p>不知不觉已经写了好多，无奈涉及的知识太多无法一篇讲完，后续将继续更新浏览器原理知识系列，感兴趣的小伙伴可以点个关注一起学习！！！</p><p><strong>往期推荐：</strong></p><p><a href="https://juejin.cn/post/7140185024653066271">谈谈前端性能优化的常见手段及知识原理 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7138203576098095112">一文带你读懂 webpack 的知识和原理，附带常见面试题！ - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7128965885057826846">谈谈前端中的设计模式和使用场景 - 掘金 (juejin.cn)</a></p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见性能优化方式及手段</title>
      <link href="/2022/09/27/tan-tan-qian-duan-chang-jian-xing-neng-you-hua-fang-shi/"/>
      <url>/2022/09/27/tan-tan-qian-duan-chang-jian-xing-neng-you-hua-fang-shi/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="theme-smartblue"><a href="#theme-smartblue" class="headerlink" title="theme: smartblue"></a>theme: smartblue</h2><p>在前端发展日新月异的今天，我们前端能做的事情越来越多，但随之而来的是我们的项目越来越大，功能越来越复杂，这个时候<strong>前端性能优化</strong>避免不了的话题。大家可能或多或少都有了解/学习过一些优化的知识，但是你是否系统去学过呢？或者你在有需求的时候是否可以去解决呢？今天这篇文章，我将带大家一起学习一些前端常见的性能优化手段以及对应的知识原理！！</p><p><strong>本文适合：</strong></p><ul><li>对性能优化感兴趣的同学</li><li>有面试需求的同学</li></ul><p><strong>本文将学到：</strong></p><p>-<strong>构建工具的优化</strong></p><p>-<strong>图片的优化</strong></p><p>-<strong>利用缓存做优化</strong></p><p>-<strong>利用CDN做优化</strong></p><p>话不多说，就让我们开始今天的学习吧！！！</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b99337d497f4e47a8d4ef78357f0844~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="1-构建工具方面的优化"><a href="#1-构建工具方面的优化" class="headerlink" title="1.构建工具方面的优化"></a>1.构建工具方面的优化</h2><p>现在市面上有很多成熟好用的构建工具，但是使用率最高的还得是功能强大齐全的<strong>webpack</strong> 以及这两年异军突起的<strong>vite</strong>，接下来我们就一起看看如何用这两个工具进行性能优化</p><h3 id="1-1-webpack"><a href="#1-1-webpack" class="headerlink" title="1.1 webpack"></a>1.1 webpack</h3><p>接下来我们一起看看<strong>webpack</strong>在性能优化相关的知识吧</p><ul><li>使用高版本的 <strong>webpack</strong> 和<strong>node</strong></li><li>多进程构建：使用<strong>thread-loader</strong>（<strong>HappyPack</strong>不维护了，这里不推荐）</li><li>使用<strong>Tree shaking</strong> 删除多余模块导出<ul><li>配置 <code>optimization.usedExports</code>为 <code>true</code> 启动标记功能</li><li>启动代码优化功能 可以通过如下方法实现<ul><li>配置 <code>mode = production</code></li><li>配置 <code>optimization.minimize = true</code></li><li>提供 <code>optimization.minimizer</code>数组</li></ul></li></ul></li><li>使用<strong>Scope Hoisting</strong>合并模块<ul><li><strong>Scope Hoisting</strong>用于 <strong>将符合条件的多个模块合并到同一个函数空间</strong> 中，从而减少产物体积，优化性能。</li><li>开启方法：<ul><li><code> mode = 'production'</code>开启生产模式</li><li>使用 <code>optimization.concatenateModules</code>配置项</li><li>使用 <code>ModuleConcatenationPlugin</code> 插件</li></ul></li></ul></li><li>开启模块热替换<ul><li>可以通过<code> devServer：{hot：true}</code>或者 使用 <code>HotModuleReplacementPlugin</code>开启模块热替换</li><li>忽略部分很少变化的大文件如<strong>node_modules</strong>提高构建效率</li></ul></li><li>监控产物体积<ul><li>监控产物体积可以帮助我们分析项目的性能，避免项目体积过大带来的资源消耗</li><li>通过 <strong>performance</strong> 配置项来自定义各种阈值或参数</li></ul></li></ul><blockquote><p>业内认为一般情况下应该保证关键路径的资源体积始终小于 <strong>170kb</strong>，如果超过这个大小，可能就需要考虑优化来减小体积</p></blockquote><ul><li><p>缩小文件的搜索范围</p><ul><li><p>优化loader配置：可以通过<code>test/ include / exclude</code>来指定文件的loader命中的文件范围，可以通过指定<code>include</code>来使 loader只处理那些需要被处理的模块</p></li><li><p>优化 <code>resolves.modules</code> 配置:用于指定<strong>webpack</strong>去哪些路径下寻找第三方模块</p><ul><li>例如当所有第三方模块都放在 <strong>node_modules</strong>时 可以配置<code>resolve: {modules: path.resolve(__dirname, 'node_modules')} </code></li></ul></li><li><p>优化resolve.mainFilelds配置：用于配置第三方模块使用哪个入口文件 -为了减少搜索范围，可以使用<code>resolve: {mainFields: ['main']}</code></p><p>-如果想优先使用ESModule版本的话，设置<code>resolve: {mainFields: ['jsnext:main', 'main']}         </code></p></li><li><p>配置<code>resolve.alias</code>:<code>resolve.alias</code>通过别名将原导入路径映射成一个新的导入路径</p></li><li><p>配置<code>resolve.extensions </code>: 引入文件时省略数组内的后缀名</p></li><li><p>配置<code>resolve.noParse </code>: 省略对指定文件的处理，如（<strong>JQuery</strong>等大型库）可以提高构建性能（被忽略的文件不能包含导入语句如<code>require / import / define</code>）</p></li></ul></li><li><p>设置环境</p><ul><li>设置<code>mode: production/development </code>可以开启对应的优化</li></ul></li><li><p>代码压缩</p><ul><li>使用 <code>terser-webpack-plugin</code>压缩ES6代码</li><li>使用<code>ParalleUglifyPlugin</code>多进程压缩代码</li><li>使用<code> css-minimize-webpack-plugin</code>对css代码进行压缩</li><li>使用<code>html-minimizer-webpack-plugin </code>压缩html代码</li></ul></li><li><p>使用<strong>CDN</strong>加速</p><ul><li><p>将静态资源存储在 </p><p>CDN</p><p>上可以加快对静态资源的访问速度，减少流量消耗</p><ul><li>通过<code>output.publicPath</code>设置JavaScript文件地址</li><li>通过<code>WebPlugin.stylePublicPath</code>设置CSS文件的地址</li><li>通过<code>css-loader.publicPath</code>设置被CSS导入的资源的地址</li></ul></li></ul></li><li><p>为不同的环境配置对应的配置文件</p><ul><li>使用<code>webpack-merge </code> 分别书写<strong>development/ production / test</strong>环境下的配置文件</li></ul></li><li><p>使用缓存构建</p><ul><li>配置<code>cache: {type: 'systemfile'} </code>开启构建缓存，可以大幅提高二次构建的速度</li></ul></li><li><p>使用DllPlugin：使用<strong>DllPlugin</strong>进行分包，使用 <code>DllReferencePlugin</code>引用<code>mainfext.json </code>, 通过将一些很少变动的代码先打包成静态资源，避免重复编译来提高构建性能</p></li><li><p>提取公共代码</p><ul><li>使用<code>splitChunkPlugin </code> 提取公共代码，减少代码体积 （webpack3通过<code>CommonsChunkPlugin</code>）</li></ul></li><li><p>动态Polyfill：使用<code>polyfill-service</code>只返回给用户需要的<strong>polyfill</strong></p></li><li><p>使用可视化工具来分析性能</p><ul><li>使用<strong>UnusedWebpackPlugin</strong>分析未被使用到的文件</li><li>使用<strong>Webpack Dashboard</strong> 以命令行的形式输出编译过程的各种信息</li><li>使用<strong>Webpack Bundle Analyzer</strong>分析重复的模块或者没被用到的模块</li><li>使用<code> --json=stats,json</code>将构建过程中的信息都输出到指定文件</li><li>使用<a href="https://link.juejin.cn/?target=https://webpack.github.io/analyse/">Webpack Analysis</a>：官方提供的可视化分析工具</li></ul></li></ul><p>以上就是使用<strong>webpack</strong>进行优化的常见手段了，对于<strong>webpack</strong> 感兴趣的同学可以看看这篇关于<strong>webpack</strong>的好文：<a href="https://juejin.cn/post/7138203576098095112">一文带你读懂webpack的知识和原理，附带常见面试题！ - 掘金 (juejin.cn)</a></p><h3 id="1-2-vite"><a href="#1-2-vite" class="headerlink" title="1.2 vite"></a>1.2 vite</h3><p>讲完<strong>webpack</strong>，接下来我们看看如何使用<strong>vite</strong>来做性能优化。关于<strong>vite</strong>的优化可以从以下几个方面入手。</p><h4 id="1-网络优化"><a href="#1-网络优化" class="headerlink" title="1.网络优化"></a>1.网络优化</h4><hr><h5 id="1-1-HTTP2"><a href="#1-1-HTTP2" class="headerlink" title="1.1 HTTP2"></a>1.1 HTTP2</h5><p><strong>http1的缺点</strong>：</p><ul><li><strong>队头阻塞</strong>：当前列的队头数据包受阻而导致整列数据包阻塞的现象</li><li><strong>请求排队</strong>：同一个TCP管道同一个时刻只能处理一个HTTP请求</li><li><strong>并发请求数量有限</strong>：同一个域名下的并发请求数量有限制</li></ul><p><strong>http2的改进</strong>：</p><ul><li><strong>多路复用</strong>：通过将数据分成多个二进制帧，使得多个请求和响应数据帧可以在同一个<strong>TCP</strong>通道进行传输 解决了队头阻塞的问题</li><li><strong>首部压缩</strong>：<code>http2</code>通过在客户端和服务端使用 “首部表”来跟踪和存储之前发送的请求头的键值对，对于相同的数据将不再每次请求都重复发送，达到节省流量和缩短请求时间的效果</li><li><strong>设置优先级</strong>：可以对请求设置优先级 来对一些比较紧急的请求优先处理</li><li><strong>Server Push</strong>： 通过服务端推送可以让某些资源提前到达浏览器</li></ul><p>在 <code>vite</code> 中可以通过 <code>vite-plugin-mkcert</code>在 <code>dev server</code>开启 <strong>HTTP2</strong></p><h5 id="1-2-DNS预解析"><a href="#1-2-DNS预解析" class="headerlink" title="1.2 DNS预解析"></a>1.2 DNS预解析</h5><p>可以通过 <code>dns-prefetch</code> 将<code>DNS</code>解析的过程提前，降低 <code>DNS</code> 解析的延迟时间</p><h5 id="1-3-preload"><a href="#1-3-preload" class="headerlink" title="1.3 preload"></a>1.3 preload</h5><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preload"</span> href=<span class="string">"important.js"</span> <span class="keyword">as</span>=<span class="string">"script"</span>&gt; ;<span class="comment">//href表示资源地址 as表示资源类型</span></span><br></pre></td></tr></tbody></table></figure><p>以上就是 <code>preload</code>的使用方式 即对于一些比较重要的资源 可以用过预加载的方式来使资源更早地到达浏览器，优化性能</p><p>在 <code>vite</code> 中可以<code>build.polyfillModulePrelad</code> 一键开启 <code>modulepreload</code>的 Polyfill 来让所有支持原生 ESM 的浏览器都可以兼容此特性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vite.congfig.ts</span></span><br><span class="line"><span class="attr">build</span>: {</span><br><span class="line"><span class="attr">polyfilModulePreload</span>: <span class="literal">true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="1-4-prefetch"><a href="#1-4-prefetch" class="headerlink" title="1.4 prefetch"></a>1.4 prefetch</h5><p>在浏览器空闲的时候去预加载其他页面的资源 （浏览器兼容性不太好 所以用的不是很多）</p><h5 id="1-5-预构建"><a href="#1-5-预构建" class="headerlink" title="1.5 预构建"></a>1.5 预构建</h5><p>将第三方依赖内部的文件合并为一个文件，减少HTTP请求数量</p><h4 id="2-资源优化"><a href="#2-资源优化" class="headerlink" title="2.资源优化"></a>2.资源优化</h4><h5 id="2-1-资源压缩"><a href="#2-1-资源压缩" class="headerlink" title="2.1 资源压缩"></a>2.1 资源压缩</h5><p>分为对 <code>javascript代码</code>、 <code>css代码</code>、<code>图片等其他资源</code>三大类</p><p>其中 <code>vite</code>默认对 <code>JavaScript代码</code>和 <code>css代码</code>都有开启压缩，一般不用我们自己去配置。而对于图片资源， 可以使用 <code>vite-plugin-imagemin</code>来压缩。</p><h5 id="2-2-产物拆包"><a href="#2-2-产物拆包" class="headerlink" title="2.2 产物拆包"></a>2.2 产物拆包</h5><p>为什么要进行产物拆包呢？如果不对产物拆包，会有下面几个问题</p><ol><li><strong>首屏性能下降</strong>：首屏加载所有代码，造成体积过大，首屏卡顿</li><li><strong>线上缓存效果差</strong>：只要有代码改动就会导致整个产物缓存失效，缓存复用率几乎为0</li></ol><p>那我们看看<code>vite</code>对于产物的拆包策略是啥</p><ol><li><strong>CSS代码分割</strong>：实现一个<code>chunk</code>对应一个CSS文件</li><li>将业务代码和第三方依赖的代码分开打包</li><li>对于动态<code>import</code>的模块单独打包成一个<code>chunk</code></li></ol><p>可以通过 <code>manualChunks</code>配置项自定义拆包策略（一般不用自己配置）</p><h5 id="2-3-构建产物分析"><a href="#2-3-构建产物分析" class="headerlink" title="2.3 构建产物分析"></a>2.3 构建产物分析</h5><p>分析构建产物可以帮助我们对项目的性能做优化，这里我推荐使用 <code>rollup-plugin-visualizer</code>进行产物分析</p><p>使用方式也很简单</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vite.config.ts</span></span><br><span class="line"><span class="keyword">import</span> { visualizer } <span class="keyword">from</span> <span class="string">"rollup-plugin-visualizer"</span>;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line"><span class="title function_">visualizer</span>({</span><br><span class="line"><span class="comment">//打包后自动打开浏览器的产物分析界面</span></span><br><span class="line"><span class="attr">open</span>: <span class="literal">true</span></span><br><span class="line">})</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h5 id="2-4-按需加载"><a href="#2-4-按需加载" class="headerlink" title="2.4 按需加载"></a>2.4 按需加载</h5><p><code>vite</code>会将动态 <code>import</code> 的模块单独打包成一个<code>chunk</code> 而不同的框架一般也会有自己的按需加载方案 这个根据时机情况自己选择就好 </p><h5 id="2-5-预渲染优化"><a href="#2-5-预渲染优化" class="headerlink" title="2.5 预渲染优化"></a>2.5 预渲染优化</h5><p>预渲染优化可分为 <strong>服务端渲染（SSR）</strong>和 <strong>静态站点生成（SSG）</strong></p><ul><li><strong>SSR</strong>： 服务端生成完整的 <strong>HTML</strong>内容，浏览器接收到后可以直接渲染出内容而不需要经过<strong>JS</strong>的加载，降低了浏览器的压力，同时有利于<strong>SEO</strong></li><li><strong>SSG</strong>：在构建阶段生成完整的<strong>HTML</strong>内容 （SSR是在服务器运行时生成） 适合做较为静态的站点（比如博客）</li></ul><p>关于<strong>vite</strong>的常用性能优化手段就讲完了，接下来我们来学习以下如何优化资源占比大头的<strong>图片资源</strong></p><h2 id="2-图片优化"><a href="#2-图片优化" class="headerlink" title="2.图片优化"></a>2.图片优化</h2><p>图片资源一直是各种资源占比很大的一种，所以我们想要优化前端性能，就不可避免地要在图片资源上面下功夫！</p><p><strong>常见的图片资源类型</strong></p><p>-<strong>JPG/JPEG</strong>: 可以通过<strong>有损压缩</strong>减小体积，常用于<code>banner、轮播图、背景图 </code>等色彩丰富但对对比度要求低的场景</p><p>-<strong>PNG</strong>：无损压缩但体积较大，常用于颜色简单对比度高的场景，如logo图</p><p>-<strong>svg</strong>：文本文件，体积小，压缩效率高，常用作矢量图或logo（掘金的logo就是svg格式）</p><p>-<strong>base64</strong>：文本文件，为小图标而生（<strong>webpack</strong>的<code>url-loader</code>可以根据文件大小判断是否采用<strong>base64</strong>格式转换）</p><p>-<strong>gif</strong>：无损压缩的动画格式</p><p>看完图片的类型及对应的特点，你应该知道如何根据使用场景来选择不同格式的图片了，接下来我们讲讲如何从代码层面来通过图片优化性能</p><p>-<strong>懒加载</strong>：如果一次性加载所有图片的话，会造成很大的性能浪费和卡顿，所以最好对图片进行懒加载，这可以极大地提高性能和使用体验（如何懒加载网上有很多资源，可以自行查阅）</p><p>-<strong>响应式图片</strong>：即根据屏幕大小自动加载合适的图片，可以通过<code>picture</code> 和<code> @media</code>实现</p><p>-<strong>使用CSS代替图片</strong>：对于一些背景（比如渐变）可以使用css来实现而不是图片</p><p>-<strong>压缩图片体积</strong>：比如<strong>webpack</strong>的<code>image-webpack-loader </code> 和<strong>vite</strong> 的<code> vite-plugin-imagemin</code>都是压缩图片的利器</p><p>关于图片方面的优化大概就是上面这么多了，接下来我们趁热打铁来学习下性能优化的重中之重-<strong>缓存</strong></p><h2 id="3-本地缓存"><a href="#3-本地缓存" class="headerlink" title="3.本地缓存"></a>3.本地缓存</h2><p>我们前端说的本地缓存一般指的是浏览器的本地缓存（<code>webStorage</code>），而本地缓存是我们做性能优化时的一大关注点，接下来我就带大家一起学习下如何利用<strong>本地缓存</strong>来做<strong>性能优化</strong>！</p><h4 id="缓存分类："><a href="#缓存分类：" class="headerlink" title="缓存分类："></a><strong>缓存分类：</strong></h4><p>1.<strong>Memory Cache</strong>：再浏览器内存中的缓存，访问优先级最高，访问速度也是最快的（和渲染进程共存，进程关闭就清除缓存，所以有效期比较短）</p><p>2.<strong>service worker Cache</strong>：独立的js线程，可实现离线缓存、消息推送等功能</p><p>3.<strong>Disk Cache</strong>：磁盘中的缓存，容量较大，但是相对的访问速度较慢</p><p> 4.<strong>push Cache</strong>：<code>HTTP2</code>的新特新，优先级最低（前面三种缓存无法命中后才会命中这个）</p><p> 比如我们现在打开掘金首页的控制台，就可以看到哪些请求是用了缓存的</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17846fcabb5e46969ab746fdbdf0bda1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>        （红色框里的就是用了<strong>memory cache</strong> 或<strong>disk cache</strong> 的）</p><h4 id="缓存策略："><a href="#缓存策略：" class="headerlink" title="缓存策略："></a><strong>缓存策略：</strong></h4><p>浏览器的缓存策略可以分为<strong>强缓存</strong> 和<strong>协商缓存</strong>两种</p><ul><li><strong>强缓存</strong>： 不用向服务器请求。可以通过设置 <code>HTTP Header</code>的 <code>expries</code>和 <code>cache-control</code>实现<ul><li><strong>expries</strong>： 服务器第一次响应时，会将过期的时间戳写在 <code>expries</code>的请求头中返回，当我们再次请求时，如果本地时间小于 <code>expries</code>的时间戳，就直接去缓存中读取资源<ul><li>缺点：如果跟改了本地时间，可能会导致缓存失效</li></ul></li><li><strong>cache-control</strong>： 通过 <code>max-age</code>控制本地资源的有效期，<code>s-maxage</code>控制代理服务器（<code>CDN缓存</code>）的有效期（<code>s-maxage</code>仅在代理服务器中生效，<code>max-age</code>仅在客户端生效），设置成<code>no-store </code>则表示拒绝一切形式的缓存<ul><li>缺点：如果更改了本地时间，同样会导致缓存失效，但是解决了 <code>expires</code>会因为客户端和服务器直接时差不一导致的缓存时间不一致的问题</li></ul></li></ul></li></ul><blockquote><p><code>cache-control</code>优先级高于 <code>expries</code></p></blockquote><ul><li><p><strong>协商缓存</strong>：浏览器需要先向服务器发起请求，在判断是否从本地获取缓存资源。可以通过设置 <code>HTTP Header</code>的 <code>Last-Modified</code>和 <code>ETag</code>实现</p><ul><li><strong>Last-Modified</strong>：首次响应时会返回 <code>Last-Modified</code>字段，之后客户端每次请求都会带上 <code>If-Modified-Since</code>的字段（上一次<code>response</code>中的 <code>Last-Modified</code>的值），服务器根据该时间戳和资源在服务器上最后的修改时间是否一致来判断是否使用缓存（返回 <code>304</code>表示使用本地缓存，返回新的 <code>Last-Modified</code>表示不使用缓存）<ul><li><strong>缺点</strong>：如果服务器没有及时感知到文件的变化（比如在毫秒级时间内完成了改动，但是因为 <code>Last-Modified</code>是秒级导致无法感知）</li></ul></li><li><strong>ETag</strong>：既然上面的 <code>Last-Modified</code>存在着缺点，那 <code>ETag</code>就是他的解决方案（服务器根据文件内容编码生成唯一标识符，可以精确感知文件的变化），首次响应会返回 <code>ETag</code>标识，下一次请求就带上 <code>If-None-Match</code>与服务端进行比较来判断是否使用缓存<ul><li><strong>缺点</strong>：服务端需要额外的开销来生成 <code>ETag</code>标识</li></ul></li></ul></li></ul><blockquote><p> <strong>Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。</strong></p></blockquote><h4 id="HTTP决策"><a href="#HTTP决策" class="headerlink" title="HTTP决策"></a><strong>HTTP决策</strong></h4><p>关于HTTP请求的决策，这里我们通过<strong>Chrome</strong>给出的官方流程图来给大家讲解</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a976c759466647dc9d23636bbac9f81b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>接下来我给大家解释下上面的步骤</p><ol><li>考虑资源是否可复用<ol><li>如果不可以复用，则直接设置 <code>Cache-Control</code> 成 <code>no-store</code>表示拒绝一切形式的缓存</li><li>如果可以复用，考虑是否设置成每次都需要向浏览器进行缓存的有效确认<ol><li>如果需要，则设置 <code>Cache-Control</code>为 <code>no-cache</code></li><li>如果不需要，则考虑是否可以被代理服务器缓存<ol><li>如果可以，设置成 <code>public</code></li><li>如果不行，设置成 <code>private</code></li></ol></li></ol></li><li>考虑资源有效时长<ol><li>设置对应的 <code>max-age</code>和 <code>s-maxage</code>等值</li><li>最后再设置协商缓存需要用到的 <code>ETag</code>和 <code>Last-Modified</code></li></ol></li></ol></li></ol><p>以上便是对于一个<strong>HTTP请求</strong>是否要用缓存以及如何使用缓存的决策过程，我们在考虑是否使用缓存的时候也可以按着这个思路来考虑。</p><h4 id="网页刷新对缓存的影响"><a href="#网页刷新对缓存的影响" class="headerlink" title="网页刷新对缓存的影响"></a>网页刷新对缓存的影响</h4><p>接下来我们看看网页刷新对各类缓存的影响，帮助大家更好地使用缓存</p><ul><li><strong>强制刷新</strong>： 直接从服务器请求，跳过强缓存和协商缓存（比如 <code>Ctrl + F5</code>）</li><li><strong>地址栏回车或正常刷新</strong>：跳出强缓存，检查协商缓存</li><li><strong>新窗口的URL访问</strong>： 按照正常的缓存策略，即先检查强缓存</li></ul><p>相信看到这里你对于如何使用缓存来优化性能应该有了更深入的了解，赶快动手试试吧！</p><h2 id="4-使用CDN"><a href="#4-使用CDN" class="headerlink" title="4.使用CDN"></a>4.使用CDN</h2><p>说完本地缓存，我们这一节来学一学<strong>CDN</strong>在前端性能优化上的作用</p><p><strong>Q</strong>：什么是<strong>CDN</strong>？</p><p><strong>A</strong>：<strong>CDN</strong>是一组分布在不同区域的服务器（内容分发网络），这些服务器上存储着数据的副本，用户访问资源时，可以工具距离来选择较近的服务器，从而达到节省流量，加快访问速度以及减轻网络拥塞的目的。</p><h3 id="CDN在前端的作用"><a href="#CDN在前端的作用" class="headerlink" title="CDN在前端的作用"></a><strong>CDN在前端的作用</strong></h3><p><strong>CDN</strong>在前端有三个核心的作用，即<strong>缓存</strong>、<strong>回源</strong>和 <strong>前端安全</strong>。</p><h4 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h4><p>前一节我们在学习本地缓存的时候学到，我们的强缓存可以控制我们的资源是否可以被代理服务器缓存（设置成<code>private </code>），这里的<strong>CDN</strong>就是常用的代理服务器。<br>我们经常将一些静态资源放在<strong>CDN</strong>上 ，比如<strong>图片、js资源、css资源等等</strong>。</p><p>（比如我们打开掘金，就可以看到掘金将很多静态资源都放在了<strong>CDN</strong> 服务器上来优化）</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0645c111acb444528efde0c3c8c455e7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>这里我们可以看到<strong>CDN</strong>服务器的域名和我们掘金主站的域名并不一样，这样可以解决浏览器对同一域名下的连接数量的限制，这也是使用<strong>CDN</strong>的一个小细节。</p><h4 id="2-回源"><a href="#2-回源" class="headerlink" title="2.回源"></a>2.回源</h4><p>故名思意，回源的作用就是当我们的<strong>CDN</strong>服务器上的资源失效时，向上级服务器请求有效资源的过程。可以配合我们的缓存一起优化性能</p><h4 id="3-前端安全"><a href="#3-前端安全" class="headerlink" title="3.前端安全"></a>3.前端安全</h4><p><strong>CDN</strong>还有一个比较少被提到的作用就是减少网站被攻。  <strong>CDN</strong>可以通过监控数据、隐藏源IP、过滤黑客入侵以及防止<strong>ddos/cc攻击</strong>来保护我们的网站</p><p>关于<strong>CDN</strong>的作用暂时就讲这么多，感兴趣的同学可以之后自行查阅</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e90b34d2edbe450090cab732697d47a4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>好了，今天的分享就到这里，这几天我会继续更新前端性能优化的其他手段和知识，感兴趣的同学可以点个赞和关注一起学习！！！</p><p><strong>下期预告：</strong></p><ul><li><strong>服务端渲染</strong></li><li><strong>浏览器底层渲染原理</strong></li><li><strong>性能监测</strong></li><li><strong>懒加载和首屏优化</strong></li><li><strong>防抖节流</strong></li><li><strong>CSS/JS资源的加载</strong></li><li><strong>权衡优化力度</strong></li></ul><p><strong>往期精彩文章：</strong></p><p><a href="https://juejin.cn/post/7138203576098095112">一文带你读懂webpack的知识和原理，附带常见面试题！ - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7128965885057826846">谈谈前端中的设计模式和使用场景 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack相关原理及使用</title>
      <link href="/2022/09/27/yi-wen-dai-ni-du-dong-webpack-xiang-guan-yuan-li-ji-ying-yong/"/>
      <url>/2022/09/27/yi-wen-dai-ni-du-dong-webpack-xiang-guan-yuan-li-ji-ying-yong/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="theme-channing-cyan"><a href="#theme-channing-cyan" class="headerlink" title="theme: channing-cyan"></a>theme: channing-cyan</h2><p>在前端技术发展日新月异的今天，前端工程化已经成了每个前端工作/学习者的必备知识，那说到工程化，不可避免地就会谈到 webpack（虽然市面上已经有了很多成熟好用的打包工具，如<a href="https://rollupjs.org/guide/en/">rollup</a>、<a href="https://vitejs.dev/">vite</a>，但是目前来看<strong>webpack</strong>龙头地位依旧不可撼动）但是我们都知道，<strong>webpack</strong>的内容之多难度之大劝退了很多想要入门的人，但是难归难，又不能不学，至少被问到的时候得能说上几句吧！接下来我就带大家一起来看看<strong>webpack</strong>有哪些常见的知识点/原理/面试题吧！！！</p><p><strong>温馨提示</strong>：本文近<strong>9000</strong>字，建议收藏反复学习！！！</p><p><strong>通过本文，你将学到：</strong></p><ol><li><strong>webpack</strong>的常见知识点以及对应的原理</li><li><strong>webpack</strong>常见面试题</li></ol><p>话不多说，接下来让我们一起进入今天的学习吧！！！</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7aec6d5cb5cd4f71862363fe97d2a7ce~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="1-webpack-是啥？有啥作用"><a href="#1-webpack-是啥？有啥作用" class="headerlink" title="1.webpack 是啥？有啥作用"></a>1.webpack 是啥？有啥作用</h2><p>概念：<strong>Webpack</strong> 是一种用于构建 JavaScript 应用程序的静态模块打包器，它能够以一种相对一致且开放的处理方式，加载应用中的所有资源文件（图片、CSS、视频、字体文件等），并将其合并打包成浏览器兼容的 Web 资源文件。</p><p>功能：</p><ul><li>模块的打包：通过打包整合不同的模块文件保证各模块之间的引用和执行</li><li>代码编译：通过丰富的<code>loader</code>可以将不同格式文件如<code>.sass/.vue/.jsx</code>转译为浏览器可以执行的文件</li><li>扩展功能：通过社区丰富的<code>plugin</code>可以实现多种强大的功能，例如<strong>代码分割、代码混淆、代码压缩、按需加载…..等等</strong></li></ul><h2 id="2-常见的-loader-及其作用？"><a href="#2-常见的-loader-及其作用？" class="headerlink" title="2.常见的 loader 及其作用？"></a>2.常见的 loader 及其作用？</h2><p>-<code>babel-loader</code>：将 es6 转译为 es5</p><p>-<code> file-loader</code>：可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存，并在代码中通过<strong>URL</strong>去引用输出的文件</p><p>-<code>url-loader</code>：和<code>file-loader</code>功能相似，但是可以通过指定阈值来根据文件大小使用不同的处理方式（小于阈值则返回 base64 格式编码并将文件的 <code>data-url</code>内联到<code>bundle</code>中）</p><p>-<code>raw-loader</code>：加载文件原始内容</p><blockquote><p>webpack5 自身内置了<code>file-loader/ url-loader/ raw-loader</code>等 loader，所以我们不需要再显示引入 loader 只需要指定对应的 type 即可实现相同的功能 如<code>file-loader</code>等价于 <code>type= "asset/resource"'</code></p><p>-<code>image-webpack-loader</code>： 加载并压缩图片资源</p></blockquote><p>-<code>awesome-typescirpt-loader</code>: 将 typescript 转换为 javaScript 并且性能由于<code>ts-loader</code></p><p>-<code>sass-loader</code>: 将 SCSS/SASS 代码转换为 CSS</p><p>-<code>css-loader</code>: 加载 CSS 代码 支持模块化、压缩、文件导入等功能特性</p><p>-<code>style-loader</code>: 把 CSS 代码注入到 js 中，通过<code>DOM</code> 操作去加载 CSS 代码</p><blockquote><p>当我们使用类似于 <code>less</code> 或者 <code>scss</code> 等预处理器的时候，通常需要多个 <strong>loader</strong> 的配合使用如<code>test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] </code></p><p>-<code>source-map-loader</code>: 加载额外的<code>Source Map</code>文件</p></blockquote><p>-<code>eslint-loader</code>: 通过 ESlint 检查 js 代码</p><p>-<code>cache-loader</code>: 可以在一些开销较大的<code>Loader</code>之前添加可以将结果缓存到磁盘中，提高构建的效率</p><p>-<code>thread-loader</code>: 多线程打包，加快打包速度</p><p>以上便是常用的 loader 以及作用，对 loader 感兴趣的小伙伴之后可以自行了解</p><h2 id="3-常见的-plugin-及作用"><a href="#3-常见的-plugin-及作用" class="headerlink" title="3.常见的 plugin 及作用"></a>3.常见的 plugin 及作用</h2><p>-<code>define-plugin</code>: 定义环境变量（webpack4 之后可以通过指定<code>mode：production/development</code>实现同样效果）</p><p>-<code>web-webpack-plugin</code>：为单页面应用输出 HTML 性能优于<code>html-webpack-plugin</code></p><p>-<code>clean-webpack-plugin</code>: 每次打包时删除上次打包的产物, 保证打包目录下的文件都是最新的</p><p>-<code>webpack-merge</code>： 用来合并公共配置文件,常用（例如分别配置<code>webpack.common.config.js/ webpack.dev.config.js/webpack.production.config.js</code>并将其合并）</p><p>-<code>ignore-plugin</code>: 忽略指定的文件，可以加快构建速度</p><p>-<code>terser-webpack-plugin</code>：压缩 ES6 的代码（tree-shaking）</p><p>-<code>uglifyjs-webpack-plugin</code>: 压缩 js 代码</p><p>-<code>mini-css-extract-plugin</code>: 将 CSS 提取为独立文件，支持按需加载</p><p>-<code>css-minimize-webpack-plugin</code>：压缩 CSS 代码</p><blockquote><p>css 文件的压缩需要<code>mini-css-extract-plugin</code>和<code>css-minimize-webpack-plugin </code>的配合使用 即先使用<code>mini-css-extract-plugin</code>将 css 代码抽离成单独文件，之后使用<code> css-minimize-webpack-plugin</code>对 css 代码进行压缩</p></blockquote><p>-<code>serviceworker-webpack-plugin</code>: 为离线应用增加离线缓存功能</p><p>-<code>ModuleconcatenationPlugin</code>: 开启<code>Scope Hositing</code> 用于合并提升作用域， 减小代码体积</p><p>-<code>copy-webpack-plugin</code>： 在构建的时候，复制静态资源到打包目录。</p><p>-<code>compression-webpack-plugin</code>: 生产环境采用<code>gzip</code>压缩 JS 和 CSS</p><p>-<code>ParalleUglifyPlugin</code>： 多进程并行压缩 js</p><p>-<code>webpack-bundle-analyzer</code>: 可视化 webpack 输出文件大小的根据</p><p>-<code>speed-measure-webpack-plugin</code>: 用于分析各个 loader 和 plugin 的耗时，可用于性能分析</p><p>-<code>webpack-dashboard</code>: 可以更友好地展示打包相关信息</p><p>以上便是常见的插件及其作用，接下来讲解我自己使用过的觉得好用的插件/工具</p><h2 id="4-有没有用过好用的工具-plugin"><a href="#4-有没有用过好用的工具-plugin" class="headerlink" title="4.有没有用过好用的工具/plugin"></a>4.有没有用过好用的工具/plugin</h2><p>-<code>splitChunkPlugin</code>：用于代码分割</p><p>-<code>webpack-merge</code>: 提取公共配置，用于分别编写不同环境的配置文件（ `` ）</p><p>-<code>HotModuleReplacementPlugin</code>:支持模块热替换</p><p>-<code>ignore-plugin</code>: 忽略指定文件，可以加快构建速度</p><p>-<code>clean-webpack-plugin</code>: 每次打包时删除上次打包的产物， 保证打包目录下的文件都是最新的</p><p>-<code>speed-measure-webpack-plugin</code>: 分析出 Webpack 打包过程中的 Loader 和 Plugin 的耗时，用于性能分析</p><p>-<code>mini-css-extract-plugin</code>: 将 CSS 代码抽离为独立文件，支持按需加载， 配合 <code>css-minimize-webpack-plugin</code>使用</p><p>-<code>terser-webpack-plugin</code>: 实现更精细的代码压缩功能</p><p>-<code>SourceMapDevtoolPlugin</code>:精细度配置<code>SourceMap</code>， 不能和<code>devtool</code>选项同时使用</p><p>-<code>UnusedWebpackPlugin</code>: 反向查找项目中没被用到的文件，日常工作经常用到，可在重构或者性能分析时使用</p><p>-<code>webpack-dashboard</code>: <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/webpack-dashboard" title="https://www.npmjs.com/package/webpack-dashboard">webpack-dashboard</a>&nbsp; 是一个命令行可视化工具，能够在编译过程中实时展示编译进度、模块分布、产物信息等相关信息，性能分析时很有用。</p><p>-<code> Webpack Analysis</code>：<a href="https://link.juejin.cn/?target=https://webpack.github.io/analyse/" title="https://webpack.github.io/analyse/">Webpack Analysis</a>&nbsp; 是 webpack 官方提供的可视化分析工具。</p><p>-<code>BundleAnalyzerPlugin</code>：性能分析插件，可以在运行后查看是否包含重复模块/不必要模块等</p><p>以上便是我日常学习中经常用到的一些工具/插件，有用过其他好用的工具/插件的同学欢迎在评论区推荐讨论！</p><h2 id="5-loader-和-plugin-有啥区别？"><a href="#5-loader-和-plugin-有啥区别？" class="headerlink" title="5.loader 和 plugin 有啥区别？"></a>5.loader 和 plugin 有啥区别？</h2><h4 id="Loader："><a href="#Loader：" class="headerlink" title="Loader："></a>Loader：</h4><p>Loader 本质上是一个函数，负责代码的转译，即对接收到的内容进行转换后将转换后的结果返回<br>配置 Loader 通过在<code> modules.rules</code>中以数组的形式配置</p><h4 id="Plugin："><a href="#Plugin：" class="headerlink" title="Plugin："></a>Plugin：</h4><p>Plugin 本质上是一个带有<code>apply(compiler)</code>的函数，基于<a href="https://www.npmjs.com/package/tapable">tapable</a>这个事件流框架来监听<strong>webpack</strong>构建/打包过程中发布的 hooks 来通过自定义的逻辑和功能来改变输出结果。<br>Plugin 通过<code>plugins</code> 以数组的形式配置</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><strong>Loader</strong>主要负责将代码转译为<strong>webpack</strong> 可以处理的 JavaScript 代码，而 <strong>Plugin</strong> 更多的是负责通过接入<strong>webpack</strong> 构建过程来影响构建过程以及产物的输出，<strong>Loader</strong>的职责相对比较<strong>单一</strong>简单，而<strong>Plugin</strong>更为丰富多样</p><h2 id="6-如何保证众多-Loader-按照想要的顺序执行？"><a href="#6-如何保证众多-Loader-按照想要的顺序执行？" class="headerlink" title="6.如何保证众多 Loader 按照想要的顺序执行？"></a>6.如何保证众多 Loader 按照想要的顺序执行？</h2><p>可以通过<code>enforce</code>来强制控制 Loader 的执行顺序 （<code>pre</code> 表示在所有正常的 loader 执行之前执行，<code>post</code>则表示在之后执行）</p><blockquote><p>Loader 的执行有以下两个阶段：</p><ol><li> <strong>Pitching</strong>&nbsp; 阶段: loader 上的 pitch 方法，按照 &nbsp;<code>后置(post)、行内(inline)、普通(normal)、前置(pre)</code>&nbsp; 的顺序调用。更多详细信息，请查看 &nbsp;<a href="https://webpack.docschina.org/api/loaders/#pitching-loader">Pitching Loader</a>。</li><li> <strong>Normal</strong>&nbsp; 阶段: loader 上的 常规方法，按照 &nbsp;<code>前置(pre)、普通(normal)、行内(inline)、后置(post)</code>&nbsp; 的顺序调用。模块源码的转换， 发生在这个阶段。</li></ol></blockquote><h2 id="7-如何编写-Loader"><a href="#7-如何编写-Loader" class="headerlink" title="7.如何编写 Loader"></a>7.如何编写 Loader</h2><p>这也是面试官喜欢问的问题，而我们大部分人别说写了，可能连用都没咋用过，所以问这个问题更多是为了了解你对 loader 这方面的知识掌握程度，毕竟只有当你足够了解 loader 的知识，你才有自己编写 loader 的可能，那接下来我们就按照从 loader 的特性来分析如何编写 loader 这个思路来讲解</p><ul><li><p>loader 支持链式调用，上一个 loader 的执行结果会作为下一个 loader 的入参。</p><ul><li>根据这个特性，我们知道我们的<strong>loader</strong>想要有返回值，并且这个返回值必须是标准的 JavaScript 字符串或者<code>AST</code>代码结构，这样才能保证下一个<strong>loader</strong>的正常调用。</li></ul></li><li><p>loader 的主要职责就是将代码转译为<strong>webpack</strong>可以理解的 js 代码。</p><ul><li>根据这个特性，loader 内部一般需要通过<code>return / this.callback</code>来返回转换后的结果</li></ul></li><li><p>单个 loader 一把只负责单一的功能。</p><ul><li>根据这个特性，我们的 loader 应该符合<strong>单一职责</strong>的原则，尽量别让单个 loader 执行太多职责</li></ul></li><li><p>善于利用开发工具</p><ul><li><strong>loader-utils</strong>： <a href="https://link.juejin.cn/?target=https://github.com/webpack/loader-utils" title="https://github.com/webpack/loader-utils">loader-utils</a>&nbsp; 是一个非常重要的 Loader 开发辅助工具，为开发中提供了诸如读取配置、<code>requestString</code>的序列化和反序列化、<code>getOptions/getCurrentRequest/parseQuery</code>等核心接口….等等功能，对于 loader 的开发十分有用</li><li><strong>schema–utils</strong>：<a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/schema-utils" title="https://www.npmjs.com/package/schema-utils">schema-utils</a>是用于校验用户传入 loader 的参数配置的校验工具，也是在开发中十分有用</li></ul></li><li><p>loader 是无状态的</p><ul><li>根据此特性，我们不应该在 loader 保存状态</li></ul></li><li><p>webpack 默认缓存 loader 的执行结果</p><ul><li><strong>webpack</strong>会默认<strong>缓存</strong>loader 的执行结果直到资源/所依赖的资源发生变化 如果想要 loader 不缓存 可以通过<code>this.cacheble</code> 显式声明不做缓存</li></ul></li><li><p>Loader 接收三个参数</p><ul><li><code>source</code>： 资源输入 对于第一个执行的 loader 为资源文件的内容 后续执行的 loader 则为前一个 loader 的执行结果 也可能是字符串 或者是代码的<code>AST</code>结构</li><li><code>sourceMap</code>： 可选参数 代码的<code>sourcemap</code>结构</li><li><code>data</code>： 可选参数 其他需要在<code>Loader</code>链中传递的信息</li></ul></li><li><p>正确上报 loader 的异常信息</p><ul><li>一般尽量使用<code>logger.error</code> 减少对用户的干扰</li><li>对于需要明确警示用户的错误 优先使用 <code>this.emitError</code></li><li>对于已经严重到不能继续往下编译的错误 使用 <code>callback</code></li></ul></li><li><p>loader 函数中的<code>this </code>由 webpack 提供 并且指向了<code>loader-runtime</code>的<code>loaderContext </code>对象</p><ul><li>可以通过<code>this</code>来获取 loader 需要的各种信息 <strong>Loader Context</strong>提供了许多实用的接口，我们不仅可以通过这些接口获取需要的信息，还可以通过这些接口改变 webpack 的运行状态（相当于产生 <strong>Side Effect</strong>）</li></ul></li><li><p>loader 由<code>pitch</code>和<code>normal</code>两个阶段</p><ul><li>根据此特性，我们可以在<code>pitch</code>阶段预处理一些操作</li></ul></li></ul><blockquote><p>webpack 会按照 <code>use</code> 定义的顺序从前往后执行<code>Pitch</code> Loader 从后往前执行<code>Normal</code> <code>Loader</code> 我们可以将一些预处理的逻辑放在<code>Pitch</code>中</p></blockquote><ul><li>正确处理日志 使用 <code>Loader Context``的getLogger接口（支持verbose/log/info/warn/error</code> 五种级别的日志 用户可以通过<a href="https://link.juejin.cn/?target=https://webpack.js.org/configuration/other-options/%23level">infrastructureLogging.level</a> 配置项筛选不同日志内容 ）</li><li>充分调试你编写的<strong>loader</strong><ul><li>创建出<strong>webpack</strong>实例 并运行<strong>laoder</strong></li><li>获取<strong>loader</strong>执行结果 对比、分析判断是否符合预期</li><li>判断执行过程中是否出错</li></ul></li></ul><p>以上便是开发 loader 需要的知识以及常规步骤，相信答出这些内容后，面试官变不会再为难你了！说完如何开发<strong>loader</strong>，接下来就趁热打铁讲解一下如何开发<strong>plugin</strong></p><h2 id="8-如何编写-Plugin"><a href="#8-如何编写-Plugin" class="headerlink" title="8.如何编写 Plugin"></a>8.如何编写 Plugin</h2><p>上面我们已经讲完了如何编写<strong>loader</strong>，接下来我们还是按照分析 plugin 特性来讲解如何开发 plugin，一起来看看吧！由于 plugin 比 loader 复杂不少，这里我们需要一些前置知识来作为支撑！</p><p>我们都知道<strong>Plugin</strong>是通过监听 webpack 构建过程中发布的 hooks 来实施对应的操作从而影响更改构建逻辑以及生成的产物，而在这个过程中<code>compiler</code>和<code>compilation</code>可以说是最核心的两个对象了，其中<code>compiler</code>可以暴露了整个构建流程的 200+个<code>hooks</code>，而<code>compilation</code>则暴露了更细粒度的<code>hooks</code>。</p><p><code>compiler</code>对象是一个全局单例，代表了 webpack 从开启到关闭的整个生命周期，负责启动编译和监听文件，而<code>compilation</code>是每次构建过程的上下文对象，包含当次构建所需要的信息</p><blockquote><p>每次热更新和重新编译都会创建一个新的<code>compilation</code>对象，<code>compilation</code>对象只代表当次编译</p></blockquote><p>我们都知道插件是通过监听 webpack 构建过程中发布的<code>hooks</code>从而在特定阶段去执行特定功能来达到改变构建逻辑以及产物的目的，而这些都离不开<a href="https://www.npmjs.com/package/tapable">tapable</a> （一个专门用于处理各种发布订阅的库 有同步异步、熔断、循环、瀑布流等钩子），关于了解<strong>tapable</strong>的使用，这里推荐这篇文章：<a href="https://juejin.cn/post/6844903895584473096#comment">Webpack tapable 使用研究 - 掘金 (juejin.cn)</a>。<br>讲完 plugin 的前置知识，接下来就让我们正式开始学习如何开发插件</p><ul><li><p>插件是通过监听 webpack 发布的 hooks 来工作的</p><ul><li>根据这个特性，我们的 plugin 一定是一个函数或者一个包含<code>apply（） </code>的对象，这样才可以监听<code>compiler </code>对象</li></ul></li><li><p>传递给插件的<code>compiler </code> 和<code>compilation</code> 都是同一个引用</p><ul><li>根据此特性，我们知道我们的插件是会影响到其他插件的，所以我们在编写插件的时候应该分析会对其他插件造成啥影响</li></ul></li><li><p>基于<strong>tapable</strong>来完成对<code>hooks</code>的复杂的订阅以及响应</p><ul><li>编译过程的特定节点会分发特定钩子，插件可以通过这些钩子来执行对应的操作</li><li>通过 <strong>tapable</strong>的回调机制以参数形式传递上下文信息</li><li>可以通过上下文的众多接口来影响构建流程</li></ul></li><li><p>监听一些具有特定意义的<code>hook</code>来影响构建</p><ul><li><code>compiler.hooks.compilation</code>:<strong>webpack</strong>刚启动完并创建<code>compilation</code>对象后触发</li><li><code>compiler.hooks.make</code>:<strong>webpack</strong>开始构建时触发</li><li><code>compiler.hooks.done</code>:<strong>webpack</strong> 完成编译时触发，此时可以通过<code>stats</code>对象得知编译过程中的各种信息</li></ul></li><li><p>善于使用开发工具</p><ul><li>使用<code>schema-utils</code>用于校验参数（关于<code>schema-utils</code>的使用方法读者可以自行查阅）</li></ul></li><li><p>正确处理插件日志信息以及插件信息</p><ul><li>使用 <code>stats</code>汇总插件的统计数据</li><li>使用 <code>ProgressPlugin</code>插件的 <code>reportProgress</code>接口上报执行进度</li><li>通过 <code>compilation.getLogger</code>获取分级日志管理器</li><li>使用 <code>compilation.errors/warining</code>处理异常信息（<strong>eslint-webpack-plugin</strong>的做法）</li></ul></li><li><p>测试插件</p><ul><li>通过分析<code>compilation.error/warn</code> 数组来判断 webpack 是否运行成功</li><li>分析构建产物判断插件功能是否符合预期</li></ul></li></ul><p>以上便是如何编写 plugin 所需的知识和常规流程，建议可以阅读一些插件例如<code>eslint-webpack-plugin / DefinePlugin </code>等插件的源码来更深入地学习插件开发的知识和流程</p><h2 id="9-什么是文件指纹？文件指纹有什么作用？怎么用？"><a href="#9-什么是文件指纹？文件指纹有什么作用？怎么用？" class="headerlink" title="9.什么是文件指纹？文件指纹有什么作用？怎么用？"></a>9.什么是文件指纹？文件指纹有什么作用？怎么用？</h2><p>概念：文件指纹是指文件打包后的一连串后缀</p><p>作用：</p><ul><li><strong>版本管理：</strong> &nbsp; 在发布版本时，通过文件指纹来区分 修改的文件 和 未修改的文件。</li><li><strong>使用缓存：</strong> &nbsp; 浏览器通过文件指纹是否改变来决定使用缓存文件还是请求新文件。</li></ul><p>种类：</p><ul><li><code>Hash</code>：和整个项目的构建相关，只要项目有修改（<code>compilation</code>实例改变），<code>Hash</code>就会更新</li><li><code> Contenthash</code>：和文件的内容有关，只有内容发生改变时才会修改</li><li><code> Chunkhash</code>：和<strong>webpack</strong>构架的 chunk 有关 不同的<strong>entry</strong>会构建出不同的<strong>chunk</strong> （不同 <code>ChunkHash</code>之间的变化互不影响）</li></ul><p>如何使用：</p><ul><li>JS 文件：使用<code>Chunkhash </code></li><li>CSS 文件：使用<code>Contenthash </code></li><li>图片等静态资源： 使用<code>hash </code></li></ul><blockquote><p>生产环境的<strong>output</strong>为了区分版本变动，通过<code>Contenthash</code>来达到清理缓存及时更新的效果，而开发环境中为了加快构建效率，一般不引入<code>Contenthash </code></p></blockquote><h2 id="10-Babel-的原理"><a href="#10-Babel-的原理" class="headerlink" title="10.Babel 的原理"></a>10.Babel 的原理</h2><p><strong>babel</strong> 可以将代码转译为想要的目标代码，并且对目标环境不支持的<strong>api</strong> 自动<code> polyfill</code>。而<strong>babel</strong>实现这些功能的流程是<code> 解析（parse）-转换（transfrom）-生产（generator）</code>，接下来我们就看看每个流程都做了啥工作</p><ul><li><code>解析</code>：根据代码生成对应的<code>AST</code>结构<ul><li>进行代码分析，将代码分割成<strong>token</strong>流（语法单元数组），再根据<strong>token</strong>流生成对应的<code>AST</code></li></ul></li><li><code> 转换</code>：遍历<code>AST</code>节点并生成新的<code>AST</code>节点</li><li><code>生成</code>：根据新的<code>AST</code>生成目标代码</li></ul><h2 id="11-文件监听的原理"><a href="#11-文件监听的原理" class="headerlink" title="11.文件监听的原理"></a>11.文件监听的原理</h2><p>开启文件监听后，webpack 会轮询访问文件的最后修改时间，当发现文件修改时间发生变化后，会先缓存起来等到<code>aggregateTimeout</code>再统一执行</p><p>开启文件监听方式：可以在构建时带上<code>--watch</code> 参数或者设置<code>watch：true</code>，而<code>watchOptions</code>则可以对监听的细节进行定制</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">watchOptions</span>: {</span><br><span class="line">    <span class="comment">//不监听的文件或者文件夹 忽略一些大型的不经常变化的文件可以提高构建速度</span></span><br><span class="line">    <span class="attr">ignored</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    <span class="comment">//监听到变化会等多少时间再执行</span></span><br><span class="line">    <span class="attr">aggregateTimeout</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="comment">//判断文件是否发生变化是通过不断轮询指定文件有没有变化实现的</span></span><br><span class="line">    <span class="attr">poll</span>: <span class="number">1000</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="12-什么是-Source-map？如何使用"><a href="#12-什么是-Source-map？如何使用" class="headerlink" title="12.什么是 Source map？如何使用"></a>12.什么是 Source map？如何使用</h2><p><strong>source map</strong>是将编译打包后的代码映射回源码<br>可以通过<strong>devtool</strong>配置项来设置，还可以通过<a href="https://webpack.docschina.org/plugins/source-map-dev-tool-plugin"><code>SourceMapDevToolPlugin</code></a>实现更加精细粒度的控制</p><blockquote><p><strong>devtool</strong>配置项和 <a href="https://webpack.docschina.org/plugins/source-map-dev-tool-plugin"><code>SourceMapDevToolPlugin</code></a>不能同时使用，因为<strong>devtool</strong>选项已经内置了这些插件，如果同时使用相当于应用了两次插件</p></blockquote><table><thead><tr><th>devtool</th><th>performance</th><th>production</th><th>quality</th><th>comment</th></tr></thead><tbody><tr><td>(none)</td><td><strong>build</strong>: fastest <strong>rebuild</strong>: fastest</td><td>yes</td><td>bundle</td><td>Recommended choice for production builds with maximum performance.</td></tr><tr><td><strong><code>eval</code></strong></td><td><strong>build</strong>: fast <strong>rebuild</strong>: fastest</td><td>no</td><td>generated</td><td>Recommended choice for development builds with maximum performance.</td></tr><tr><td><code>eval-cheap-source-map</code></td><td><strong>build</strong>: ok <strong>rebuild</strong>: fast</td><td>no</td><td>transformed</td><td>Tradeoff choice for development builds.</td></tr><tr><td><code>eval-cheap-module-source-map</code></td><td><strong>build</strong>: slow <strong>rebuild</strong>: fast</td><td>no</td><td>original lines</td><td>Tradeoff choice for development builds.</td></tr><tr><td><strong><code>eval-source-map</code></strong></td><td><strong>build</strong>: slowest <strong>rebuild</strong>: ok</td><td>no</td><td>original</td><td>Recommended choice for development builds with high quality SourceMaps.</td></tr><tr><td><code>cheap-source-map</code></td><td><strong>build</strong>: ok <strong>rebuild</strong>: slow</td><td>no</td><td>transformed</td><td></td></tr><tr><td><code>cheap-module-source-map</code></td><td><strong>build</strong>: slow <strong>rebuild</strong>: slow</td><td>no</td><td>original lines</td><td></td></tr><tr><td><strong><code>source-map</code></strong></td><td><strong>build</strong>: slowest <strong>rebuild</strong>: slowest</td><td>yes</td><td>original</td><td>Recommended choice for production builds with high quality SourceMaps.</td></tr><tr><td><code>inline-cheap-source-map</code></td><td><strong>build</strong>: ok <strong>rebuild</strong>: slow</td><td>no</td><td>transformed</td><td></td></tr><tr><td><code>inline-cheap-module-source-map</code></td><td><strong>build</strong>: slow <strong>rebuild</strong>: slow</td><td>no</td><td>original lines</td><td></td></tr><tr><td><code>inline-source-map</code></td><td><strong>build</strong>: slowest <strong>rebuild</strong>: slowest</td><td>no</td><td>original</td><td>Possible choice when publishing a single file</td></tr><tr><td><code>eval-nosources-cheap-source-map</code></td><td><strong>build</strong>: ok <strong>rebuild</strong>: fast</td><td>no</td><td>transformed</td><td>source code not included</td></tr><tr><td><code>eval-nosources-cheap-module-source-map</code></td><td><strong>build</strong>: slow <strong>rebuild</strong>: fast</td><td>no</td><td>original lines</td><td>source code not included</td></tr><tr><td><code>eval-nosources-source-map</code></td><td><strong>build</strong>: slowest <strong>rebuild</strong>: ok</td><td>no</td><td>original</td><td>source code not included</td></tr><tr><td><code>inline-nosources-cheap-source-map</code></td><td><strong>build</strong>: ok <strong>rebuild</strong>: slow</td><td>no</td><td>transformed</td><td>source code not included</td></tr><tr><td><code>inline-nosources-cheap-module-source-map</code></td><td><strong>build</strong>: slow <strong>rebuild</strong>: slow</td><td>no</td><td>original lines</td><td>source code not included</td></tr><tr><td><code>inline-nosources-source-map</code></td><td><strong>build</strong>: slowest <strong>rebuild</strong>: slowest</td><td>no</td><td>original</td><td>source code not included</td></tr><tr><td><code>nosources-cheap-source-map</code></td><td><strong>build</strong>: ok <strong>rebuild</strong>: slow</td><td>no</td><td>transformed</td><td>source code not included</td></tr><tr><td><code>nosources-cheap-module-source-map</code></td><td><strong>build</strong>: slow <strong>rebuild</strong>: slow</td><td>no</td><td>original lines</td><td>source code not included</td></tr><tr><td><code>nosources-source-map</code></td><td><strong>build</strong>: slowest <strong>rebuild</strong>: slowest</td><td>yes</td><td>original</td><td>source code not included</td></tr><tr><td><code>hidden-nosources-cheap-source-map</code></td><td><strong>build</strong>: ok <strong>rebuild</strong>: slow</td><td>no</td><td>transformed</td><td>no reference, source code not included</td></tr><tr><td><code>hidden-nosources-cheap-module-source-map</code></td><td><strong>build</strong>: slow <strong>rebuild</strong>: slow</td><td>no</td><td>original lines</td><td>no reference, source code not included</td></tr><tr><td><code>hidden-nosources-source-map</code></td><td><strong>build</strong>: slowest <strong>rebuild</strong>: slowest</td><td>yes</td><td>original</td><td>no reference, source code not included</td></tr><tr><td><code>hidden-cheap-source-map</code></td><td><strong>build</strong>: ok <strong>rebuild</strong>: slow</td><td>no</td><td>transformed</td><td>no reference</td></tr><tr><td><code>hidden-cheap-module-source-map</code></td><td><strong>build</strong>: slow <strong>rebuild</strong>: slow</td><td>no</td><td>original lines</td><td>no reference</td></tr><tr><td><code>hidden-source-map</code></td><td><strong>build</strong>: slowest <strong>rebuild</strong>: slowest</td><td>yes</td><td>original</td><td>no reference. Possible choice when using SourceMap only for error reporting purposes.</td></tr></tbody></table><p>这么多的选择，那么我们应该如何使用呢，根据我的实践，我觉得比较好的设置应该是下面这样</p><ul><li>开发环境：<code>cheap-eval-source-map</code>，生产这种<code>source map</code>速度最快，并且由于开发环境下没有代码压缩，所以不会影响断点调试</li><li>生产环境：<code>hidden-source-map</code>，由于进行了代码压缩，所以并不会占用多大的体积</li></ul><blockquote><p>避免在生产中使用 <code>inline-</code> 和 <code>eval-</code> 因为它们会增加 <strong>bundle</strong> 体积大小 并且降低整体性能</p></blockquote><h2 id="13-HMR（热更新）的原理"><a href="#13-HMR（热更新）的原理" class="headerlink" title="13.HMR（热更新）的原理"></a>13.HMR（热更新）的原理</h2><p>这个可以说是<strong>webpack</strong>的最高频考点之一了，同时也是<strong>webpack</strong>的难点，也是<strong>webpack</strong>的核心功能之一！接下来我将带大家先学习如何使用<strong>HMR</strong>再逐步分析<strong>HMR</strong>的原理。</p><p><strong>如何开启 HMR</strong>：<br>通过设置<code>devServer: {hot: true}</code> 开启 开启后便可以在发生改变后局部刷新改变的部分</p><p><strong>原理：</strong></p><ul><li>使用 <code>webpack-dev-server（WDS）</code> 托管静态资源 同时以<code>Runtime</code>方式注入<strong>HMR</strong>客户端代码</li><li>浏览器加载页面后 与<strong>WDS</strong>建立<code>WebSocket</code>连接</li><li>webpack 监听到文件变化后 增量构建发生变更的模块 并通过<strong>WebSocket</strong>发送<code>hash</code>事件</li><li>浏览器接收到 <code>hash</code>事件后 请求 <code>manifest</code>资源文件 确认增量变更范围</li><li>浏览器加载发生变更的增量模块</li><li><strong>webpack</strong>运行时触发变更模块的<code>module.hot.accept</code>回调 执行代码变更逻辑</li><li><code>done</code>：构建完成，更新变化</li></ul><p><strong>总结</strong>就是<strong>webpack</strong>将静态资源托管在 <strong>WDS</strong> 上，而 <strong>WDS</strong> 又和浏览器通过<code> webSocket</code> 建立联系，而当<strong>webpack</strong>监听到文件变化时，就会向浏览器推送更新并携带新的<code>hash </code>与之前的<code>hash</code>进行对比，浏览器接收到<code>hash</code>事件后变化加载变更的增量模块并触发变更模块的 <code>module.hot.accept</code>回调执行变更逻辑。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18e213aa683f4d06bff8bbe5974270ea~tplv-k3u1fbpfcp-zoom-1.image" alt="img"><br>（图片来自与范文杰大佬的<a href="https://juejin.cn/post/7021729340945596424">Webpack 原理系列十：HMR 原理全解析 - 掘金 (juejin.cn)</a>，这篇写的很不错，对 HMR 感兴趣的小伙伴推荐阅读）</p><h2 id="14-Tree-shaking-的原理"><a href="#14-Tree-shaking-的原理" class="headerlink" title="14.Tree shaking 的原理"></a>14.Tree shaking 的原理</h2><p>相信大家对于<strong>Tree shaking</strong>都不陌生吧，那你知道如何使用<strong>Tree shaking</strong>吗？你知道<strong>Tree shaking</strong>的原理吗？接下来就让我们一一学习</p><h4 id="什么是-Tree-shaking？"><a href="#什么是-Tree-shaking？" class="headerlink" title="什么是 Tree shaking？"></a>什么是 Tree shaking？</h4><p><strong>Tree-Shaking</strong> 是一种基于 ES Module 规范的 <strong>Dead Code Elimination</strong> 技术，它会在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾其它模块使用，并将其删除，以此实现打包产物的优化。</p><h4 id="使用-Tree-shaking"><a href="#使用-Tree-shaking" class="headerlink" title="使用 Tree shaking"></a>使用 Tree shaking</h4><p>使用 Tree shaking 的三个必要条件</p><ul><li><p>使用 ESM 规范编写模块代码</p></li><li><p>配置 <code>optimization.usedExports</code>为 <code>true</code> 启动标记功能</p></li><li><p>启动代码优化功能 可以通过如下方法实现</p><ul><li>配置 <code>mode = production</code></li><li>配置 <code>optimization.minimize = true</code></li><li>提供 <code>optimization.minimizer</code>数组</li></ul></li></ul><blockquote><p>对于使用了<code>babel-loader</code> loader 或者根据对代码进行转译的时候，注意应该关闭对于<strong>导入/导出</strong>语句的转译，因为这会影响到后续的 <strong>tree shaking</strong> 比如应该将<code> babel-loader</code> 的 <code>babel-preset-env</code>的<code>modules</code>配置为<code>false</code></p></blockquote><h4 id="必要条件："><a href="#必要条件：" class="headerlink" title="必要条件："></a>必要条件：</h4><p>所有导入导出语句只能在模块顶层 且导入导出的模块名必须为字符串常量 不能动态导入的（ESM 模块之间的依赖关系是高度确定的 与运行状态无关 编译工具只需要对 ESM 模块做静态分析就可以从代码字面量中推断出哪些模块值没被使用）</p><h4 id="Tree-shaking-的原理"><a href="#Tree-shaking-的原理" class="headerlink" title="Tree shaking 的原理"></a>Tree shaking 的原理</h4><p>Tree shaking 的工作流程可以分为</p><p>1.<strong>标记</strong>哪些导出值没有被使用； 2. 使用<strong>Terser</strong>将这些没用到的导出语句删除</p><p><strong>标记</strong>的流程如下：</p><ol><li><strong>make</strong>阶段：收集模块导出变量并记录到模块依赖关系图中</li><li><strong>seal</strong>阶段：遍历模块依赖关系图并标记那些导出变量有没有被使用</li><li><strong>构建</strong>阶段：利用<strong>Terser</strong>将没有被用到的导出语句删除</li></ol><h4 id="开发中如何利用-Tree-shaking？"><a href="#开发中如何利用-Tree-shaking？" class="headerlink" title="开发中如何利用 Tree shaking？"></a>开发中如何利用 Tree shaking？</h4><ul><li>避免无作用的重复赋值</li><li>使用<code> #pure</code>标记函数无副作用（这种做法在开源项目的源码中经常出现，如<strong>pinia、reactive….等</strong>）</li><li>禁止转译 <strong>导入/导出</strong>语句（使用了<code>babel-loader</code>需要将 <code>babel-preset-env</code>的<code>modules</code>配置为<code>false</code> ）</li><li>使用支持 <strong>Tree shaking</strong>的包</li><li>优化导出值的粒度</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确做法</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="string">"b"</span>;</span><br><span class="line"><span class="keyword">export</span> { a, b };</span><br><span class="line"><span class="comment">//错误做法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="attr">a</span>: <span class="string">"a"</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="string">"b"</span>,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>关于 tree shaking 的原理，这里同样推荐范文杰大佬写的<a href="https://juejin.cn/post/7019104818568364069">原理系列九：Tree-Shaking 实现原理</a></p><h2 id="15-如何用-webpack-来优化项目的性能"><a href="#15-如何用-webpack-来优化项目的性能" class="headerlink" title="15.如何用 webpack 来优化项目的性能"></a>15.如何用 webpack 来优化项目的性能</h2><p>说到优化，我们应该想到可以分为<strong>开发环境</strong>和<strong>生产环境</strong>的不同优化。</p><ul><li><p><strong>开发</strong>环境：开发环境我们需要的是更快的构建速度、模块热替换、更加友好的<strong>Source map</strong></p><ul><li><p>通过<code>cache： { type: 'systemfile'} </code> 开启缓存构建可以加快二次构建的效率</p></li><li><p>通过模块热替换可以做到局部更新变化，提高开发效率</p></li><li><p>根据设置 <code>devtool： cheap-eval-source-map</code> 在保证构建效率的同时又能进行代码调试</p></li><li><p>使用<a href="https://link.juejin.cn/?target=https://webpack.js.org/loaders/thread-loader/" title="https://webpack.js.org/loaders/thread-loader/">Thread-loader</a>以多进程的方式运行资源加载逻辑</p></li><li><p>通过 <strong>stats</strong> 来分析性能做优化</p></li></ul></li><li><p><strong>生产</strong>环境：生产环境我们需要的是更小的体积，更稳定又快的性能</p><ul><li>压缩代码：使用<code>UglifyJsPlugin</code>和<code>ParallelUglifyPlugin</code>来压缩代码 利用<code>cssnano(css-loader? minimize)</code>来压缩 css</li><li>利用<strong>CDN</strong>：可以使用<strong>CDN</strong>来加快对静态资源的访问，提高用户的使用体验</li><li><code>Tree Shaking</code>: 删除没用到的代码</li><li>提取公共第三方库： 使用<code>SplitChunksPlugin</code>插件来进行公共模块抽取</li><li>使用<a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/terser-webpack-plugin%23terseroptions" title="https://www.npmjs.com/package/terser-webpack-plugin#terseroptions">TerserWebpackPlugin</a>多进程执行代码压缩、uglify 功能</li></ul></li></ul><h2 id="16-webpack-构建流程是什么？"><a href="#16-webpack-构建流程是什么？" class="headerlink" title="16.webpack 构建流程是什么？"></a>16.webpack 构建流程是什么？</h2><p>相信经过上面的那么多讲解，大家对于 webpack 应该有一个不错的认识，接下来就让我们化零为整，从整体来看看 webpack 整个构建流程究竟发生了什么？话不多说，赶紧开始！</p><h4 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h4><ul><li><strong>初始化参数</strong>： 从配置文件和<code>Shell</code>语句中读取与合并并计算出最终的参数</li><li><strong>开始编译</strong>： 用上一步得到的初始化参数初始化<code>Complier</code>对象，加载所有配置的插件，执行<code>compiler</code>对象的<code>run</code>方法开始编译流程</li><li><strong>确定入口</strong>： 根据<code>entry</code>找出入口文件</li><li><strong>编译模块</strong>：从入口文件开始，根据配置的 <code>loader</code> 对模块进行转译，如果该模块还有依赖的模块，则<strong>递归</strong>对这些模块进行翻译，通过递归上述操作直到对所有模块都进行转译</li><li><strong>完成模块编译</strong>： 在经过<code>Loader</code>翻译完所有模块后，得到了每个模块转译后的内容以及模块之间的依赖关系图（<strong>ModuleGraph</strong>）</li><li><strong>输出资源</strong>： 根据入口和模块之间的依赖关系 生成一个个包含多个模块的<code>Chunk</code>， 再把每个<code>Chunk</code>转换成一个单独的文件加入到输出列表中</li><li><strong>输出完成</strong>： 根据输出项的配置，将文件内容写到文件系统</li></ul><h4 id="流程简化："><a href="#流程简化：" class="headerlink" title="流程简化："></a>流程简化：</h4><p><strong>初始化阶段</strong>： 合并计算配置参数，创建<code>Compiler</code>、<code>Compilation</code>等基础对象，并初始化<strong>Plugin</strong>，并最终根据<code>entry</code>配置，找到所有入口模块</p><p><strong>构建模块</strong>： 从<code>entry</code>开始，调用<code>loader</code>转译对应的模块，调用 <code>Acorn</code>将代码转换为<code>AST</code>结构， 遍历<code>AST</code>从中 构建出完整的模块依赖关系图（递归操作）</p><p><strong>生成阶段</strong>： 根据<code>entry</code>配置，根据模块生成一个个<code>chunk</code>对象，之后转译<code>Chunk</code>代码并封装为<code>Asset</code>， 最后写出到文件系统</p><blockquote><p>单次构建过程<strong>自上而下</strong>按顺序执行 如果启动了<code>watch</code> 则构建完成后不会退出 webpack 进程 而是持续监听文件内容 发生变化时回到构建阶段重新执行构建</p></blockquote><h4 id="从资源转换角度看"><a href="#从资源转换角度看" class="headerlink" title="从资源转换角度看"></a>从资源转换角度看</h4><ul><li><p><code>compiler.make</code>阶段</p><ul><li><code>entry</code> 文件以 <code>dependence</code> 对象形式加入 <code>compilation</code> 的依赖列表 ，<code>dependence</code> 对象记录了 <code>entry</code> 的相关信息</li><li>根据 <code>dependency</code> 创建 对应的<code>module</code> 对象，之后读入 <code>module</code> 对应的文件内容， 调用 <code>loader-runner</code>对内容做转化， 转化结果若有对其他依赖则继续读入依赖资源， 重复此过程直到所有的依赖均被转换为 <code>module</code></li></ul></li><li><p><code>compilation.seal</code> 阶段</p><ul><li>遍历 <code>module</code> 集合， 根据 <code>entry</code>配置以及引入资源的方式， 将 <code>module</code> 分配到不同的 <code>Chunk</code></li><li><code>Chunk</code>之间最终形成<code>ChunkGraph</code>结构</li><li>遍历<code>ChunkGraph</code> 调用 <code>compilation.emitAssets</code> 方法标记 <code>chunk</code> 的输出规则， 及转换为 <code>assets</code>集合</li></ul></li><li><p><code>compiler.emitAssets</code>阶段</p><ul><li>将 <code>assets</code>写入文件系统</li></ul></li></ul><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><p>以上便是<strong>webpack</strong>整个构建流程的学习，虽然一眼看过去很多也很复杂，但是相信经过重复学习，我们一定可以熟练掌握的，这是我们深入学习<strong>webpack</strong>的必经之路</p><h2 id="17-你知道哪些优化-webpack-构建的手段或者知识？"><a href="#17-你知道哪些优化-webpack-构建的手段或者知识？" class="headerlink" title="17.你知道哪些优化 webpack 构建的手段或者知识？"></a>17.你知道哪些优化 webpack 构建的手段或者知识？</h2><p>梳理完<strong>webpack</strong>的整体构建流程后，接下来让我们看看日常工作中如何优化<strong>webpack</strong>的配置来提高我们的性能！！！</p><ul><li><p>使用高版本的 <strong>webpack</strong> 和<strong>node</strong></p></li><li><p>多进程构建：使用<strong>thread-loader</strong>（<strong>HappyPack</strong>不维护了，这里不推荐）</p></li><li><p>使用<strong>Tree shaking</strong> 删除多余模块导出</p><ul><li>配置 &nbsp;<code>optimization.usedExports</code>为 &nbsp;<code>true</code>&nbsp; 启动标记功能</li><li>启动代码优化功能 可以通过如下方法实现<ul><li>配置 &nbsp;<code>mode = production</code></li><li>配置 &nbsp;<code>optimization.minimize = true</code></li><li>提供 &nbsp;<code>optimization.minimizer</code>数组</li></ul></li></ul></li><li><p>使用<strong>Scope Hoisting</strong>合并模块</p><ul><li><strong>Scope Hoisting</strong>用于 &nbsp;<strong>将符合条件的多个模块合并到同一个函数空间</strong>&nbsp; 中，从而减少产物体积，优化性能。</li><li>开启方法：<ul><li><code> mode = 'production'</code>开启生产模式</li><li>使用 <code>optimization.concatenateModules</code>配置项</li><li>使用 &nbsp;<code>ModuleConcatenationPlugin</code>&nbsp; 插件</li></ul></li></ul></li><li><p>开启模块热替换</p><ul><li>可以通过<code> devServer：{hot：true}</code>或者 使用 <code>HotModuleReplacementPlugin</code>开启模块热替换</li><li>忽略部分很少变化的大文件如<strong>node_modules</strong>提高构建效率</li></ul></li><li><p>监控产物体积</p><ul><li>监控产物体积可以帮助我们分析项目的性能，避免项目体积过大带来的资源消耗</li><li>通过 <strong>performance</strong> 配置项来自定义各种阈值或参数</li></ul></li></ul><blockquote><p>业内认为一般情况下应该保证关键路径的资源体积始终小于 <strong>170kb</strong>，如果超过这个大小，可能就需要考虑优化来减小体积</p></blockquote><ul><li><p>缩小文件的搜索范围</p><ul><li><p>优化 loader 配置：可以通过<code>test/ include / exclude</code>来指定文件的 loader 命中的文件范围，可以通过指定<code>include</code>来使 loader 只处理那些需要被处理的模块</p></li><li><p>优化 <code>resolves.modules</code> 配置:用于指定<strong>webpack</strong>去哪些路径下寻找第三方模块</p><ul><li>例如当所有第三方模块都放在 <strong>node_modules</strong>时 可以配置<code>resolve: {modules: path.resolve(__dirname, 'node_modules')} </code></li></ul></li><li><p>优化 resolve.mainFilelds 配置：用于配置第三方模块使用哪个入口文件 -为了减少搜索范围，可以使用<code>resolve: {mainFields: ['main']}</code><br>-如果想优先使用 ESModule 版本的话，设置<code>resolve: {mainFields: ['jsnext:main', 'main']} </code></p></li><li><p>配置<code>resolve.alias</code>:<code>resolve.alias</code>通过别名将原导入路径映射成一个新的导入路径</p></li><li><p>配置<code>resolve.extensions </code>: 引入文件时省略数组内的后缀名</p></li><li><p>配置<code>resolve.noParse </code>: 省略对指定文件的处理，如（<strong>JQuery</strong>等大型库）可以提高构建性能（被忽略的文件不能包含导入语句如<code>require / import / define</code>）</p></li></ul></li><li><p>设置环境</p><ul><li>设置<code>mode: production/development </code>可以开启对应的优化</li></ul></li><li><p>代码压缩</p><ul><li>使用 <code>terser-webpack-plugin</code>压缩 ES6 代码</li><li>使用<code>ParalleUglifyPlugin</code>多进程压缩代码</li><li>使用<code> css-minimize-webpack-plugin</code>对 css 代码进行压缩</li><li>使用<code>html-minimizer-webpack-plugin </code>压缩 html 代码</li></ul></li><li><p>使用<strong>CDN</strong>加速</p><ul><li>将静态资源存储在 <strong>CDN</strong>上可以加快对静态资源的访问速度，减少流量消耗<ul><li>通过<code>output.publicPath</code>设置 JavaScript 文件地址</li><li>通过<code>WebPlugin.stylePublicPath</code>设置 CSS 文件的地址</li><li>通过<code>css-loader.publicPath</code>设置被 CSS 导入的资源的地址</li></ul></li></ul></li><li><p>为不同的环境配置对应的配置文件</p><ul><li>使用<code>webpack-merge </code> 分别书写<strong>development/ production / test</strong>环境下的配置文件</li></ul></li><li><p>使用缓存构建</p><ul><li>配置<code>cache: {type: 'systemfile'} </code>开启构建缓存，可以大幅提高二次构建的速度</li></ul></li><li><p>使用 DllPlugin：使用<strong>DllPlugin</strong>进行分包，使用 <code>DllReferencePlugin</code>引用<code>mainfext.json </code>, 通过将一些很少变动的代码先打包成静态资源，避免重复编译来提高构建性能</p></li><li><p>提取公共代码</p><ul><li>使用<code>splitChunkPlugin </code> 提取公共代码，减少代码体积 （webpack3 通过<code>CommonsChunkPlugin</code>）</li></ul></li><li><p>动态 Polyfill：使用<code>polyfill-service</code>只返回给用户需要的<strong>polyfill</strong></p></li><li><p>使用可视化工具来分析性能</p><ul><li>使用<strong>UnusedWebpackPlugin</strong>分析未被使用到的文件</li><li>使用<strong>Webpack Dashboard</strong> 以命令行的形式输出编译过程的各种信息</li><li>使用<strong>Webpack Bundle Analyzer</strong>分析重复的模块或者没被用到的模块</li><li>使用<code> --json=stats,json</code>将构建过程中的信息都输出到指定文件</li><li>使用<a href="https://link.juejin.cn/?target=https://webpack.github.io/analyse/" title="https://webpack.github.io/analyse/">Webpack Analysis</a>：官方提供的可视化分析工具</li></ul></li></ul><p>以上便是我们开发中可以使用的用来优化 webpack 的配置和手段，已经可以满足大部分情况了，如果评论区有同学有其他好的建议，可以在评论区分享讨论！</p><h1 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h1><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55fbb2d4134b49a1b996a268aa6b234b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>好了，不知不觉已经写了接近 9000 个字了，笔者近期学习<strong>webpack</strong>，写这篇的目的也是为了复习和牢固自己的知识，同时帮助有需要的同学，<strong>webpack</strong>的学习是一个漫长困难的过程，希望我们可以坚持下来，文章中若有出现错误，请各位在评论区指出一起学习讨论，笔者后续将更新其他关于<strong>webpack</strong>和<strong>vite</strong>的文章，感兴趣的同学可以点个关注一起学习！！！</p><p><strong>ps</strong>：创作不易，请点赞支持哈哈哈！！！</p><p><strong>引用文章/ 资源</strong>：</p><p><a href="http://webpack.wuhaolin.cn/">深入浅出 webpack</a></p><p><a href="https://juejin.cn/book/7115598540721618944">webpack5 核心原理与应用实践</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端设计模式之发布-订阅模式</title>
      <link href="/2022/09/27/qian-duan-she-ji-mo-shi-zhi-fa-bu-ding-yue-zhe-mo-shi/"/>
      <url>/2022/09/27/qian-duan-she-ji-mo-shi-zhi-fa-bu-ding-yue-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第2天，<a href="https://juejin.cn/post/7123120819437322247" title="https://juejin.cn/post/7123120819437322247">点击查看活动详情</a>。</p><p>昨天我发布了一篇关于策略模式和代理模式的文章，收到的反响还不错，于是今天我们继续来学习前端中常用的设计模式之一：发布-订阅模式。说到发布订阅模式大家应该都不陌生，它在我们的日常学习和工作中出现的频率简直不要太高，常见的有<code>EventBus</code>、框架里的组件间通信、鉴权业务等等……话不多说，让我们一起进入今天的学习把!!!</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a1eafc44c85475d82d91f0c180ad46e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><strong>发布-订阅模式</strong>又叫观察者模式，它定义对象间的一种一对多的依赖关系 当一个对象的状态发生改变时，所有依赖它的订阅者都会接收到通知。发布-订阅模式在日常应用十分广泛（js中一般用事件模型来替代传统的发布订阅模式，如<code>addEventListener</code>）。那<strong>发布-订阅者模式</strong>有啥用呢？</p><p><strong>例子1：</strong></p><p>我们举个例子，小明是一个喜欢吃包子的人，于是他每天都去楼下询问有没有包子，如果运气不好今天没有包子，小明就得白跑一趟，但是啥时候有包子小明又不知道，这让他很是困扰。那如何解决这个问题呢，这个时候发布-订阅模式就派上用场了。假如老板把小明的电话记了下来，有包子就通知小明，这样小明就不会白白跑一趟了。看到这个例子你有没有觉得这种模式很眼熟，像我们的点击事件，<strong>ajax</strong>请求的<code>error</code>或者<code>success</code>事件其实都是用了这种模式，接下来我们就用代码来还原上面小明的场景</p><p><strong>version1：</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baoziShop = {};<span class="comment">//定义包子铺</span></span><br><span class="line">baoziShop.<span class="property">listenList</span> = [];<span class="comment">//缓存列表 存放订阅者的回调函数</span></span><br><span class="line"><span class="comment">//添加订阅者</span></span><br><span class="line">baoziShop.<span class="property">listen</span> = <span class="keyword">function</span> (<span class="params">fn</span>) {</span><br><span class="line">    baoziShop.<span class="property">listenList</span>.<span class="title function_">push</span>(fn)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//发布消息</span></span><br><span class="line">baoziShop.<span class="property">trigger</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, fn; fn = baoziShop.<span class="property">listenList</span>[i++]) {</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//接下来尝试添加监听者</span></span><br><span class="line">baoziShop.<span class="title function_">listen</span>( <span class="keyword">function</span> (<span class="params">price, baoziType</span>) { <span class="comment">//小明订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`种类：<span class="subst">${baoziType}</span>, 价格： <span class="subst">${price}</span>`</span>)</span><br><span class="line">})</span><br><span class="line">baoziShop.<span class="title function_">listen</span>( <span class="keyword">function</span> (<span class="params">price, baoziType</span>) { <span class="comment">//小王订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`种类：<span class="subst">${baoziType}</span>, 价格： <span class="subst">${price}</span>`</span>)</span><br><span class="line">})</span><br><span class="line"><span class="comment">//接下来我们尝试发布消息</span></span><br><span class="line">baoziShop.<span class="title function_">trigger</span>(<span class="number">2</span>, <span class="string">'豆沙包'</span>);<span class="comment">//输出:种类：豆沙包， 价格 2 </span></span><br><span class="line">baoziShop.<span class="title function_">trigger</span>(<span class="number">3</span>, <span class="string">'肉包'</span>);<span class="comment">//输出：种类：肉包，价格 3</span></span><br></pre></td></tr></tbody></table></figure><p>上面我们已经实现了一个简单的例子，但是上面的代码还存在着一些问题：比如订阅者无差别接收到发布者发布的所有消息，如果小明只喜欢吃菜包，那他不应该收到上架肉包子的通知，所以我们有必要增加一个<code>key</code>来让订阅者只订阅自己感兴趣的东西，接下来我们对代码进行一些改动：</p><p><strong>version2:</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baoziShop = {}; <span class="comment">//定义包子铺</span></span><br><span class="line">baoziShop.<span class="property">listenList</span> = {}; <span class="comment">//存放订阅者的回调函数 注意 这里从前面的数组改成了对象</span></span><br><span class="line"><span class="comment">//添加订阅者 key用来标识订阅者</span></span><br><span class="line">baoziShop.<span class="property">listen</span> = <span class="keyword">function</span>(<span class="params">key, fn</span>) {</span><br><span class="line">    <span class="keyword">if</span>( !<span class="variable language_">this</span>.<span class="property">listenList</span>[key]) {</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">listenList</span>[key] = [];<span class="comment">//如果没有订阅过此类消息 就给该消息创建订阅列表</span></span><br><span class="line">    }</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listenList</span>[key].<span class="title function_">push</span>(fn);<span class="comment">//将回调放入订阅列表</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//发布消息</span></span><br><span class="line">baoziShop.<span class="property">trigger</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>), <span class="comment">//取出消息类型</span></span><br><span class="line">fns = <span class="variable language_">this</span>.<span class="property">listenList</span>[key];<span class="comment">//取出该订阅对应的回调列表</span></span><br><span class="line">    <span class="keyword">if</span>(!fns || fns.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没有订阅则直接返回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, fn; fn = fns[i]; i++) {</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>) <span class="comment">//绑定this</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//接下来我们尝试下订阅不同的消息</span></span><br><span class="line">baoziShop.<span class="title function_">listen</span>(<span class="string">'菜包子'</span>, <span class="keyword">function</span>(<span class="params">price</span>) { <span class="comment">//小明订阅菜包子的消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'价格：'</span>, price)</span><br><span class="line">})</span><br><span class="line">baoziShop.<span class="title function_">listen</span>(<span class="string">'肉包子'</span>, <span class="keyword">function</span>(<span class="params">price</span>) { <span class="comment">//小王订阅肉包子</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'价格:'</span>, price)</span><br><span class="line">})</span><br><span class="line"><span class="comment">//接下来我们发布下消息</span></span><br><span class="line">baoziShop.<span class="title function_">trigger</span>(<span class="string">'菜包子'</span>， <span class="number">2</span>); <span class="comment">//只有订阅菜包子的小明能收到消息</span></span><br><span class="line">baoziShop.<span class="title function_">trigger</span>(<span class="string">'肉包子'</span>, <span class="number">3</span>); <span class="comment">//只有订阅肉包子的小王能收到通知</span></span><br></pre></td></tr></tbody></table></figure><p>好了，经过上面的改写，我们已经实现了只收到自己订阅的类型的消息的功能。那我们不妨想一下我们的代码还有啥可以完善的功能，比如如果小明楼下有两个包子铺，如果小明想要在另一个包子铺买v包子，那这段代码就必须在另一个包子铺的对象上复制粘贴一遍，如果只有两个包子铺还好，那万一有十个包子铺呢？是不是得写十遍？所以我们正确的做法应该是将发布-订阅的功能单独抽离出来封装在一个通用的对象内，这样避免重复写同样的代码，那我们按着这种思路开始改写我们的代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event = {</span><br><span class="line">    listenList : [], <span class="comment">//订阅列表</span></span><br><span class="line">    <span class="attr">listen</span>: <span class="keyword">function</span> (<span class="params">key, fn</span>) {</span><br><span class="line">        <span class="keyword">if</span>( !<span class="variable language_">this</span>.<span class="property">listenList</span>[key]) {</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">listenList</span>[key] = [];<span class="comment">//如果没有订阅过此类消息 就给该消息创建订阅列表</span></span><br><span class="line">    }</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listenList</span>[key].<span class="title function_">push</span>(fn);<span class="comment">//将回调放入订阅列表</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">trigger</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">const</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>), <span class="comment">//取出消息类型</span></span><br><span class="line">fns = <span class="variable language_">this</span>.<span class="property">listenList</span>[key];<span class="comment">//取出该订阅对应的回调列表</span></span><br><span class="line">    <span class="keyword">if</span>(!fns || fns.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没有订阅则直接返回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, fn; fn = fns[i]; i++) {</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>) <span class="comment">//绑定this</span></span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，我们将发布-订阅那部分的逻辑抽离到<code>event</code>对象上,后续我们就能通过<code>event.trigger()</code>这种形式调用，接下来我们封装一个可以给所有对象都动态安装发布-订阅功能的方法，避免重复操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> installEvent = <span class="keyword">function</span>(<span class="params">obj</span>) {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> event) {</span><br><span class="line">        obj[i] = event[i];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//接下来我们测试下我们的代码 </span></span><br><span class="line"><span class="keyword">const</span> baoziShop = {};<span class="comment">//定义包子铺</span></span><br><span class="line"><span class="title function_">installEvent</span>(baoziShop);</span><br><span class="line"><span class="comment">//接下来我们就可以订阅和发布消息了</span></span><br><span class="line">baoziShop.<span class="title function_">listen</span>(<span class="string">'菜包子'</span>, <span class="keyword">function</span>(<span class="params">price</span>) { <span class="comment">//小明订阅菜包子的消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'价格：'</span>, price)</span><br><span class="line">})</span><br><span class="line">baoziShop.<span class="title function_">listen</span>(<span class="string">'肉包子'</span>, <span class="keyword">function</span>(<span class="params">price</span>) { <span class="comment">//小王订阅肉包子</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'价格:'</span>, price)</span><br><span class="line">})</span><br><span class="line">baoziShop.<span class="title function_">trigger</span>(<span class="string">'菜包子'</span>， <span class="number">2</span>); <span class="comment">//只有订阅菜包子的小明能收到消息</span></span><br><span class="line">baoziShop.<span class="title function_">trigger</span>(<span class="string">'肉包子'</span>, <span class="number">3</span>); <span class="comment">//只有订阅肉包子的小王能收到通知</span></span><br></pre></td></tr></tbody></table></figure><p>有没有发现，经过上面的改写，我们已经可以轻松做到给每个对象都添加订阅和发布消息，再也不用重复写代码了。那趁热打铁，我们再思考一下，能否让我们的代码功能更多些，比如如果有一天，小明不想吃包子了，但是小明还是会继续收到包子铺的消息，这让他很烦恼，于是他想要取消之前在包子铺的订阅，这就引出了另一个需求，有订阅就应该有取消订阅的功能！接下来我们开始改写我们的代码吧</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们给我们的event对象增加一个remove的方法用来取消订阅</span></span><br><span class="line">event.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key, fn</span>) {</span><br><span class="line">    <span class="keyword">const</span> fns = <span class="variable language_">this</span>.<span class="property">listenList</span>[key];<span class="comment">//取出该key对应的列表</span></span><br><span class="line">    <span class="keyword">if</span>(!fns) { <span class="comment">//如果该key没被人订阅，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">if</span>(!fn) { <span class="comment">//如果传入了key但是没有对应的回调函数，则标识取消该key对应的所有订阅！！</span></span><br><span class="line">        fns &amp;&amp; (fns.<span class="property">length</span> == <span class="number">0</span>)</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> len = fns.<span class="property">length</span> - <span class="number">1</span>; len &gt;= <span class="number">0</span>; len --) { <span class="comment">//反向遍历订阅的回调列表</span></span><br><span class="line">            <span class="keyword">const</span> _fn = fns[len];</span><br><span class="line">            <span class="keyword">if</span>(_fn === fn) {</span><br><span class="line">                fns.<span class="title function_">splice</span>(len, <span class="number">1</span>) ;<span class="comment">//删除订阅者的回调函数</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//接下来我们照常给包子铺添加一些订阅</span></span><br><span class="line"><span class="keyword">const</span> baoziShop = {};</span><br><span class="line"><span class="title function_">installEvent</span>(baoziShop);</span><br><span class="line">baoziShop.<span class="title function_">listen</span>(<span class="string">'菜包子'</span>, fn1 = <span class="keyword">function</span>(<span class="params">price</span>) { <span class="comment">//小明订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'价格'</span>, price);</span><br><span class="line">})</span><br><span class="line">baoziShop.<span class="title function_">listen</span>(<span class="string">'菜包子'</span>, fn2 = <span class="keyword">function</span>(<span class="params">price</span>) { <span class="comment">//小王订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'价格'</span>, price)</span><br><span class="line">})</span><br><span class="line">baoziShop.<span class="title function_">trigger</span>(<span class="string">'菜包子'</span>, <span class="number">2</span>);<span class="comment">//小明和小王都收到消息</span></span><br><span class="line">baoziShop.<span class="title function_">remove</span>(<span class="string">'菜包子'</span>, fn1); <span class="comment">//删除小明的订阅</span></span><br><span class="line">baoziShop.<span class="title function_">trigger</span>(<span class="string">'菜包子'</span>, <span class="number">2</span>);<span class="comment">//只有小王会收到订阅</span></span><br></pre></td></tr></tbody></table></figure><p>至此，我们的系统已经可以添加不同的订阅，赋予对象订阅-发布功能，取消订阅等等。理论上，我们的代码已经可以实现简单的功能，但是还存在着下面几个问题：</p><ul><li>每个对象都必须添加<code>listen</code>和<code>trigger</code>的功能，以及分配一个<code>listenList</code>的订阅列表，这其实是资源的浪费</li><li>代码的耦合度太高，就像下面这样</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小明必须知道包子铺的名称才能开始订阅</span></span><br><span class="line">baoziShop.<span class="title function_">listen</span>(<span class="string">'菜包子'</span>, <span class="keyword">function</span>(<span class="params">price</span>) {</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">})</span><br><span class="line"><span class="comment">//如果小明要去另外的包子铺买 就必须订阅另一家包子铺</span></span><br><span class="line">baoziAnother.<span class="title function_">listen</span>(<span class="string">'菜包子'</span>, <span class="keyword">function</span>(<span class="params">price</span>) {</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>这样未免有点愚蠢，我们想下现实的例子，如果我们想买包子，我们需要一家一家去和老板说吗？不需要的，我们大可以打开美团，在美团上购买就可以了，这其中，美团就类似于中介，我们只需要告诉美团我想吃包子，并不用关心包子是从哪里来的，而卖家只需要将消息发布到美团上，不用关心谁是消费者（这里和现实有点差异，因为现实我们买东西还是要看商家评价啥的，这里只是举个例子),所以我们可以改写下我们的代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们尝试改写event对象 使其充当一个中介的角色 将发布者和订阅者连接起来</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Event</span> = ({</span><br><span class="line"><span class="keyword">const</span> listenList = {};<span class="comment">//订阅列表</span></span><br><span class="line">    <span class="comment">//添加订阅者</span></span><br><span class="line">    <span class="keyword">const</span> listen = <span class="keyword">function</span>(<span class="params">key, fn</span>) {</span><br><span class="line">    <span class="keyword">if</span>( !<span class="variable language_">this</span>.<span class="property">listenList</span>[key]) {</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">listenList</span>[key] = [];<span class="comment">//如果没有订阅过此类消息 就给该消息创建订阅列表</span></span><br><span class="line">    }</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listenList</span>[key].<span class="title function_">push</span>(fn);<span class="comment">//将回调放入订阅列表</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//发布消息</span></span><br><span class="line"><span class="keyword">const</span> trigger = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">         <span class="keyword">const</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>), <span class="comment">//取出消息类型</span></span><br><span class="line">fns = <span class="variable language_">this</span>.<span class="property">listenList</span>[key];<span class="comment">//取出该订阅对应的回调列表</span></span><br><span class="line">    <span class="keyword">if</span>(!fns || fns.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没有订阅则直接返回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, fn; fn = fns[i]; i++) {</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>) <span class="comment">//绑定this</span></span><br><span class="line">    }</span><br><span class="line">    };</span><br><span class="line"><span class="comment">//取消订阅</span></span><br><span class="line"><span class="keyword">const</span> remove = <span class="keyword">function</span>(<span class="params">key, fn</span>) {</span><br><span class="line">        <span class="keyword">const</span> fns = <span class="variable language_">this</span>.<span class="property">listenList</span>[key];<span class="comment">//取出该key对应的列表</span></span><br><span class="line">    <span class="keyword">if</span>(!fns) { <span class="comment">//如果该key没被人订阅，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">if</span>(!fn) { <span class="comment">//如果传入了key但是没有对应的回调函数，则标识取消该key对应的所有订阅！！</span></span><br><span class="line">        fns &amp;&amp; (fns.<span class="property">length</span> == <span class="number">0</span>)</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> len = fns.<span class="property">length</span> - <span class="number">1</span>; len &gt;= <span class="number">0</span>; len --) { <span class="comment">//反向遍历订阅的回调列表</span></span><br><span class="line">            <span class="keyword">const</span> _fn = fns[len];</span><br><span class="line">            <span class="keyword">if</span>(_fn === fn) {</span><br><span class="line">                fns.<span class="title function_">splice</span>(len, <span class="number">1</span>) ;<span class="comment">//删除订阅者的回调函数</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        listen,</span><br><span class="line">        trigger,</span><br><span class="line">        remove</span><br><span class="line">    }</span><br><span class="line">})();</span><br><span class="line"><span class="comment">//接下来我们就能用Event来实现发布-订阅功能而不需要创建那么多的对象了</span></span><br><span class="line"><span class="title class_">Event</span>.<span class="title function_">listen</span>(<span class="string">'菜包子'</span>, <span class="keyword">function</span>(<span class="params">price</span>) { <span class="comment">//小明订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'价格：'</span>, price)</span><br><span class="line">})</span><br><span class="line"><span class="title class_">Event</span>.<span class="title function_">listen</span>(<span class="string">'菜包子'</span>, <span class="number">2</span>);<span class="comment">//包子铺发布消息</span></span><br></pre></td></tr></tbody></table></figure><p>经过修改，我们现在订阅消息不再需要知道包子铺的名称，也不需要给每个包子铺都创建一个对象，只需要统一通过<code>Event</code>对象来订阅就好，而发布消息也是这样的流程，这样我们就巧妙地通过<code>Event</code>这个中介对象把发布者和订阅者联系起来了。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e2cba57ae9144e4a3dc969aa9046fc5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>我们的发布订阅模式不止可用于上面这种例子，比较常见的还有模块间的通信（学过<code>vue</code>或者<code>react</code>的小伙伴应该都对组件间的事件响应不陌生），接下来就看看怎么使用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如我们在a元素发布一个消息 b元素就可以监听到并实施对应的操作</span></span><br><span class="line">a.<span class="property">onclick</span> = <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="title class_">Event</span>.<span class="title function_">listen</span>(<span class="string">'onclickEvent'</span>, <span class="string">'this is data'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//b元素接收到消息</span></span><br><span class="line"><span class="keyword">const</span> b = (<span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="title class_">Event</span>.<span class="title function_">listen</span>(<span class="string">'onclikcEvent'</span>, <span class="keyword">function</span>(<span class="params">data</span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'这是接收到的数据'</span>, data);<span class="comment">//输出这是接收到的数据thisisdata</span></span><br><span class="line">    })</span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure><p>这种用法在我们日常开发中用到的非常多！</p><p>同样，我们也可以把它用在有关登录的业务上，想象这么一个需求，如果在用户登陆后，首页需要更新用户推荐内容，用户个人信息和好友列表等，那我们应该怎么做呢？由于我们并不知道用户啥时候会登录，所以我们可以在登录成功后发布登录成功的消息，然后在需要登录权限的地方去监听登录成功的消息并做相关操作，就像下面这样</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在登录成功后发布消息</span></span><br><span class="line"><span class="title function_">login</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">data:{code}</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span>(code === <span class="number">200</span>) {</span><br><span class="line">        <span class="title class_">Event</span>.<span class="title function_">trigger</span>(<span class="string">'success'</span>, code);<span class="comment">//登录成功后发布消息</span></span><br><span class="line">    }</span><br><span class="line">})</span><br><span class="line"><span class="comment">//用户信息模块监听并更新</span></span><br><span class="line"><span class="title class_">Event</span>.<span class="title function_">listen</span>(<span class="string">'success'</span>, <span class="keyword">function</span>(<span class="params">code</span>) =&gt; {</span><br><span class="line">             <span class="title function_">refleshUserInfo</span>();<span class="comment">//更新用户信息</span></span><br><span class="line">             })</span><br></pre></td></tr></tbody></table></figure><p>这样，即使后面有其他模块需要鉴权，也只需要添加对应的订阅者就可以了，不用去改动登录部分的代码和逻辑，这对于代码的健壮性是有很好的帮助的。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf825bd4b43417b951b61b1641de31e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><strong>总结</strong> ： 关于发布-订阅模式就讲这么多，可以看到这种设计模式还是用处非常大的，实现难度也不大，但是也要注意一些小细节，比如注意命名冲突（每个key都是唯一的，可用<strong>ES6</strong>的<code>Symbol</code>单独封装到专门文件），比如会消耗一定的内存和时间，因为你订阅一个消息后，除非手动取消，不然订阅者会一一直存在于内存中造成浪费等等，但是总的来说发布-订阅模式的用处和好处还是非常多的，希望大家都可以掌握并熟练使用这种模式！！后续我还会继续更新其他的设计模式，感兴趣的朋友可以<strong>点赞关注收藏</strong>三连走一波，这对我真的很重要！！！</p><p>往期文章：</p><p><a href="https://juejin.cn/post/7128965885057826846">前端常见的设计模式和使用场景</a></p><p><a href="https://juejin.cn/post/7098664328382906405">一文带你读懂作用域、作用链和this的原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈前端中的设计模式和使用场景</title>
      <link href="/2022/09/27/tan-tan-qian-duan-chang-yong-she-ji-mo-shi/"/>
      <url>/2022/09/27/tan-tan-qian-duan-chang-yong-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="theme-channing-cyan"><a href="#theme-channing-cyan" class="headerlink" title="theme: channing-cyan"></a>theme: channing-cyan</h2><p>携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第N天，<a href="https://juejin.cn/post/7123120819437322247" title="https://juejin.cn/post/7123120819437322247">点击查看活动详情</a>。<br>相信大家在日常学习和工作中都多多少少听说/了解/使用过 <strong>设计模式</strong>，我们都知道，使用恰当的设计模式可以优化我们的代码，那你是否知道对于前端开发哪些 <strong>设计模式</strong> 是日常工作经常用到或者必须掌握的呢？本文我将带大家一起学习下前端常见的设计模式以及它们的 <strong>使用场景</strong>!!!</p><p><strong>本文主讲：</strong></p><ul><li>策略模式</li><li>代理模式</li></ul><p><strong>适合人群：</strong></p><ul><li>前端人员</li><li>设计模式小白/想知道如何在项目中使用设计模式</li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p> 策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。从定义不难看出，策略模式是用来解决那些一个功能有多种方案、根据不同条件输出不同结果且条件很多的场景，而这些场景在我们工作中也经常遇到，接下来我将用几个例子来展示策略模式在哪里用以及如何用。</p><p><strong>1.绩效考核</strong></p><p>假如我们有这么一个需求，需要根据员工的绩效考核给员工发放年终奖（分为A/B/C/D四个等级 分别对应基础奖金的1/2/3/4倍），我们很容易就写出这样的代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//level 评级 basicBonus 基础奖金</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">computeBonus</span>(level, basicBonus) = <span class="function">() =&gt;</span> {</span><br><span class="line"><span class="keyword">if</span>(level === <span class="string">'A'</span>) {</span><br><span class="line">        <span class="keyword">return</span> basicBonus * <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(level === <span class="string">'B'</span>) {</span><br><span class="line">        <span class="keyword">return</span> basicBonus * <span class="number">2</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(level === <span class="string">'C'</span>) {</span><br><span class="line">        <span class="keyword">return</span> basicBonus * <span class="number">3</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(level === <span class="string">'D'</span>) {</span><br><span class="line">        <span class="keyword">return</span> basicBonus * <span class="number">4</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="title function_">computeBonus</span>(<span class="string">'A'</span>, <span class="number">1000</span>);<span class="comment">//1000</span></span><br></pre></td></tr></tbody></table></figure><p>我们发现，以上的代码可以轻松实现我们的需求，但是这些代码存在什么问题呢？</p><ul><li><code>computedBonus</code>方法十分臃肿，包含太多<code>if-else</code> </li><li>拓展性差，后续如果想要更改评级或者规则都需要进入该函数内部调整。</li><li>复用性差。</li></ul><p>那策略模式是怎么解决这些问题的呢？我们都知道，设计模式的核心之一就是将可变的和不可变的部分<strong>抽离分装</strong>，那我们根据这个原则来修改我们的代码，其中可变的就是如何使用这些算法（多少个评级），不变的是算法的内容（评级对应的奖金），下面就是改变后的代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义策略类</span></span><br><span class="line"><span class="keyword">const</span> strategies = {</span><br><span class="line">    <span class="string">'A'</span>: <span class="keyword">function</span>(<span class="params">basicBonus</span>) {</span><br><span class="line">        <span class="keyword">return</span> basicBonus * <span class="number">1</span>;</span><br><span class="line">    },</span><br><span class="line">    <span class="string">'B'</span>: <span class="keyword">function</span>(<span class="params">basicBonus</span>) {</span><br><span class="line">        <span class="keyword">return</span> basicBonus * <span class="number">2</span>;</span><br><span class="line">    },</span><br><span class="line">    <span class="string">'C'</span>: <span class="keyword">function</span>(<span class="params">basicBonus</span>) {</span><br><span class="line">        <span class="keyword">return</span> basicBonus * <span class="number">3</span>;</span><br><span class="line">    },</span><br><span class="line">    <span class="string">'D'</span>: <span class="keyword">function</span>(<span class="params">basicBonus</span>) {</span><br><span class="line">        <span class="keyword">return</span> basicBonus * <span class="number">4</span>;</span><br><span class="line">    },</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用策略类</span></span><br><span class="line"><span class="keyword">const</span> computeBonus = (level, basicBonus) {</span><br><span class="line">    <span class="keyword">return</span> strategies[level](basicBonus);</span><br><span class="line">}</span><br><span class="line"><span class="title function_">computeBouns</span>(<span class="string">'A'</span>, <span class="number">1000</span>);<span class="comment">//1000</span></span><br></pre></td></tr></tbody></table></figure><p>从上面可以看出，我们将每种情况都单独弄成一个策略，然后根据传入评级和奖金计算年终奖，这样我们的<code>computeBonus</code>方法代码量大大减少，也不用冗杂的<code>if-else</code>分支，同时，如果我们想要改变规则，只需要在<code>strategies</code>中添加对应的策略，增加了代码的健壮性</p><p><strong>2.表单验证</strong></p><p>我们日常的工作中，不可避免地需要做表单相关的业务，毕竟这是前端最初始的职能之一。而表单绕不开表单验证，那接下来我将带大家看看策略模式在表单中如何使用。</p><p><strong>需求</strong>: 假设我们有一个登录业务，提交表单前需要做验证，验证规则如下：1.用户名称不能为空，2.密码不能少于6位，3.手机格式要正确。</p><p>我们很容易写出以下代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">verifyForm</span> = (<span class="params">formData</span>) =&gt; {</span><br><span class="line">    <span class="keyword">if</span>(formData.<span class="property">userName</span> == <span class="string">''</span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'用户名不能为空'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">if</span>(formData.<span class="property">password</span>.<span class="property">length</span> &lt; <span class="number">6</span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'密码长度不能小于6位'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(( !<span class="regexp">/(^1[3|5|8][0-9]{9}$)/</span>.<span class="title function_">test</span>(formData.<span class="property">phone</span>)) {</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'手机格式错误'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>显然，这样也可以完成表单校验的功能，但是这样写同样存在着上面说的问题，接下来，我们看下用策略模式如何改写</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写策略对象</span></span><br><span class="line"><span class="keyword">const</span> strategies = {</span><br><span class="line"><span class="attr">isEmpty</span>: <span class="keyword">function</span>(<span class="params">value, error</span>) {</span><br><span class="line">        <span class="keyword">if</span>(value === <span class="string">''</span> {</span><br><span class="line">           <span class="keyword">return</span> error;</span><br><span class="line">           })</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">minLength</span>: <span class="keyword">function</span>(<span class="params">value, len, error</span>) {</span><br><span class="line">        <span class="keyword">if</span>(value.<span class="property">length</span> &lt; len {</span><br><span class="line">           <span class="keyword">return</span> error;</span><br><span class="line">           })</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">isPhone</span>: <span class="keyword">function</span>(<span class="params">value, error</span>) {</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="regexp">/(^1[3|5|8][0-9]{9}$)/</span>.<span class="title function_">test</span>( value ) ){ </span><br><span class="line"> <span class="keyword">return</span> errorMsg; </span><br><span class="line"> }</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"><span class="comment">//接下来我们编写实现类 用于生成对应的策略实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Validator</span> {</span><br><span class="line">    <span class="title function_">controustor</span>(<span class="params">cache</span>) {</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span> = cache || []; <span class="comment">//保存校验规则</span></span><br><span class="line">    };</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">dom, rule, error</span>) {</span><br><span class="line">        <span class="keyword">const</span> arr = rule.<span class="title function_">splt</span>(<span class="string">':'</span>);<span class="comment">//分离参数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">push</span>(<span class="keyword">function</span>(<span class="params"></span>){ <span class="comment">// 把校验的步骤用空函数包装起来，并且放入 cache </span></span><br><span class="line"> <span class="keyword">const</span> strategy = arr.<span class="title function_">shift</span>(); <span class="comment">// 用户挑选的 strategy </span></span><br><span class="line"> arr.<span class="title function_">unshift</span>( dom.<span class="property">value</span> ); <span class="comment">// 把 input 的 value 添加进参数列表</span></span><br><span class="line"> arr.<span class="title function_">push</span>( errorMsg ); <span class="comment">// 把 error 添加进参数列表</span></span><br><span class="line"> <span class="keyword">return</span> strategies[ strategy ].<span class="title function_">apply</span>( dom, ary ); </span><br><span class="line"> });</span><br><span class="line">    };</span><br><span class="line">    <span class="title function_">start</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>, validatorFunc; validatorFunc = <span class="variable language_">this</span>.<span class="property">cache</span>[ i++ ]; ){ </span><br><span class="line"> <span class="keyword">var</span> msg = <span class="title function_">validatorFunc</span>(); <span class="comment">// 开始校验，并取得校验后的返回信息</span></span><br><span class="line"> <span class="keyword">if</span> ( msg ){ <span class="comment">// 如果有确切的返回值，说明校验没有通过</span></span><br><span class="line"> <span class="keyword">return</span> msg; </span><br><span class="line"> } </span><br><span class="line"> }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//编写完策略对象和实例类后我们就可以看看如何使用了</span></span><br><span class="line"><span class="keyword">const</span> validataFunc = <span class="keyword">function</span>(<span class="params"></span>){ </span><br><span class="line"> <span class="keyword">let</span> validator = <span class="keyword">new</span> <span class="title class_">Validator</span>(); <span class="comment">// 创建一个 validator 对象</span></span><br><span class="line"> <span class="comment">/***************添加一些校验规则****************/</span> </span><br><span class="line"> validator.<span class="title function_">add</span>( registerForm.<span class="property">userName</span>, <span class="string">'isNonEmpty'</span>, <span class="string">'用户名不能为空'</span> ); </span><br><span class="line"> validator.<span class="title function_">add</span>( registerForm.<span class="property">password</span>, <span class="string">'minLength:6'</span>, <span class="string">'密码长度不能少于 6 位'</span> ); </span><br><span class="line"> validator.<span class="title function_">add</span>( registerForm.<span class="property">phoneNumber</span>, <span class="string">'isMobile'</span>, <span class="string">'手机号码格式不正确'</span> ); </span><br><span class="line"> <span class="keyword">var</span> errorMsg = validator.<span class="title function_">start</span>(); <span class="comment">// 获得校验结果</span></span><br><span class="line"> <span class="keyword">return</span> errorMsg; <span class="comment">// 返回校验结果</span></span><br><span class="line">} </span><br><span class="line"> <span class="keyword">var</span> registerForm = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>( <span class="string">'registerForm'</span> ); </span><br><span class="line"> registerForm.<span class="property">onsubmit</span> = <span class="keyword">function</span>(<span class="params"></span>){ </span><br><span class="line"> <span class="keyword">var</span> errorMsg = <span class="title function_">validataFunc</span>(); <span class="comment">// 如果 errorMsg 有确切的返回值，说明未通过校验</span></span><br><span class="line"> <span class="keyword">if</span> ( errorMsg ){ </span><br><span class="line"> alert ( errorMsg ); </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 阻止表单提交</span></span><br><span class="line"> } </span><br><span class="line">}; </span><br></pre></td></tr></tbody></table></figure><p>这样，我们就用策略模式将需求改好了，之后如果我们的校验规则改变了，修改起来也是很方便的，比如：</p><p><code>validator.add( registerForm.userName, 'isNonEmpty', '用户名不能为空' );  // 改成：</code> </p><p><code>validator.add( registerForm.userName, 'minLength:10', '用户名长度不能小于 10 位' );</code></p><p>而且，我们也可以给文本框添加多个校验规则，只需要修改下策略对象以及策略方法即可！大大地增强了代码地健壮性。</p><h4 id="策略模式的优缺点："><a href="#策略模式的优缺点：" class="headerlink" title="策略模式的优缺点："></a>策略模式的优缺点：</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>避免多重条件选择语句（<code>if-else</code>）</li><li>具有可拓展性，可独立抽离封装，避免重复复制粘贴</li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>增加很多策略类或者策略对象，但是这其实不算什么大缺点</li><li>比起直接编写业务代码需要思考策略对象以及其他细节</li></ul><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。代理模式应该是我们日常用到比较多的设计模式了（我们日常工作中不知不觉就会用到代理模式，可能你没发现而已）。</p><p>代理模式分为保护代理（用于控制不同权限的对象对目标对象的访问）和虚拟代理（把开销很大的对象或者操作延迟到真正需要的时候再去创建 类比引入时动态引入）两种，但是前端基本不用到保护代理，或者说很难实现保护代理，所以大部分情况下我们用的都是虚拟代理，接下来我主要也是讲虚拟代理！</p><p>举个例子，加入A想要给C送情书，但是A没有直接把情书交给C，而是让B代为传送情书，那么B就是代理，他的职责就是替A做事，这个就是最简单的代理模式，接下来我们还是老样子，边写需求边讲解</p><p><strong>1.图片懒加载：</strong></p><p>相信大家对于图片懒加载都不陌生吧，他可以在我们加载出目标图片前预加载占位图片，避免空白区域影响体验，那我们很容易就能写出下面的代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lazyImage = (<span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">let</span> imgNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">'img'</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(imgNode);</span><br><span class="line">    <span class="keyword">let</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>;</span><br><span class="line">    image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">        imgNode.<span class="property">src</span> = image.<span class="property">src</span>;<span class="comment">//在这里设置图片的真正路由</span></span><br><span class="line">    }；</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        <span class="attr">setSrc</span>: <span class="keyword">function</span>(<span class="params">src</span>) {</span><br><span class="line">            imgNode.<span class="property">src</span> = <span class="string">'....'</span><span class="comment">//预加载本地图片;</span></span><br><span class="line">            image.<span class="property">src</span> = src</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})()</span><br><span class="line">lazyImage.<span class="title function_">setSrc</span>(<span class="string">'https://olddog.jpg'</span>);<span class="comment">//加载真正的图片</span></span><br></pre></td></tr></tbody></table></figure><p>我们看上面的代码，也可以完成预加载的功能，但是这样的代码存在着什么样的问题呢</p><ul><li>违反了单一职责原则，而且耦合度太高，如果后期我们不需要懒加载了，或者需要根据判断条件判断是否懒加载，就不得不去动lazyImage的代码</li></ul><p>接下来，我们就用代理模式来改写一下这个例子</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lazyImage = (<span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">let</span> imageNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">'img'</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(imageNode);</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        <span class="attr">setSrc</span>: <span class="keyword">function</span>(<span class="params">src</span>) {</span><br><span class="line">            imageNode.<span class="property">src</span> = src;<span class="comment">//设置目标src</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})()</span><br><span class="line"><span class="comment">//代理函数</span></span><br><span class="line"><span class="keyword">const</span> proxyImage = (<span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">let</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>;</span><br><span class="line">    image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">        myImage.<span class="title function_">setSrc</span>(<span class="variable language_">this</span>.<span class="property">src</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        <span class="attr">setSrc</span>: <span class="keyword">function</span>(<span class="params">src</span>) {</span><br><span class="line">            myImage.<span class="title function_">setSrc</span>(<span class="string">'....'</span>)<span class="comment">//预加载本地图片</span></span><br><span class="line">            img.<span class="property">src</span> = src</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})()</span><br><span class="line">proxyImage.<span class="title function_">setSrc</span>(<span class="string">'https://olddog.jpg'</span>);<span class="comment">//使用代理加载</span></span><br></pre></td></tr></tbody></table></figure><p>我们观察用代理模式写的代码，发现我们将预加载的逻辑转移到了代理函数中，这样有啥好处呢</p><ul><li>如果后期不需要预加载了，只需要取消代理，即将<code>proxyImage.setSrc(...)</code>改成<code>lazyImage.setSrc(...)</code></li><li>代理函数的使用方式和原函数一模一样，使用者不需要知道代理的实现细节也能使用</li></ul><p>不知道大家有没有发现，代理函数和原函数有一部分相似的逻辑和操作，只是代理函数的功能更多，这其实也是代理模式的特征之一，代理函数在保证实现原函数的基本功能的前提下实现更多功能，这样即使使用者不清楚逻辑也能直接使用，而且后期改动成本很低，只需要改回原函数的使用即可!!</p><p><strong>2.缓存代理</strong></p><p>设想一下，如果现在要你写一个简单的求积函数，你会怎么写</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mult = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line"><span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="variable language_">arguments</span>.<span class="property">length</span>; i &lt; len; i++) {</span><br><span class="line">        result *= <span class="variable language_">arguments</span>[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">}</span><br><span class="line"><span class="title function_">mult</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">//6</span></span><br></pre></td></tr></tbody></table></figure><p>我们来看一下上面的代码有啥缺点，上面的代码虽然实现了求积，但是如果我们<code>mult(1,2,3)</code>之后再去<code>mult(1,2,3)</code>,那么系统还是会再计算一遍，这样无疑是性能浪费，那么我们就能用代理模式来改写：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxyMult = (<span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line"><span class="keyword">let</span> cache = {};<span class="comment">//缓存计算结果</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line"><span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>( <span class="variable language_">arguments</span>, <span class="string">','</span>);</span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">in</span> cache) {</span><br><span class="line">            <span class="keyword">return</span> cache[args]</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cache[args] = mult.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">arguments</span>)</span><br><span class="line">}</span><br><span class="line">})();</span><br><span class="line"><span class="title function_">proxyMult</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//6</span></span><br><span class="line"><span class="title function_">proxyMult</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">//输出6 但是不会重新计算</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，我们用代理模式改写后避免了重复运算的浪费，这只是一种情景，还有其他相似情景，比如我们分页请求数据，可以使用相似的思路，避免对同页的数据重复请求，这在工作中非常有用！！</p><p><strong>总结：</strong></p><p>我们日常工作中还有很多地方用到代理，比如代理合并请求（间断性合并而不是全部合并，减少服务器压力）、惰性加载或创建申请资源等等，而什么时候使用代理其实不需要提前花很多精力去思考，当我们写着写着发现可以抽离使用代理模式的时候再去使用也不迟。由于文章篇幅有限，本文就先讲解策略模式和代理模式，后续将继续更新其他实用的设计模式，喜欢的小伙伴可以点个赞和关注一下，有啥问题可以评论区一起学习交流！</p><p><strong>相关文章：</strong></p><p><a href="https://juejin.cn/post/7129350321327112206">前端设计模式之发布-订阅模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析浏览器事件循环机制</title>
      <link href="/2022/09/27/shen-ru-jie-xi-liu-lan-qi-shi-jian-xun-huan-ji-zhi/"/>
      <url>/2022/09/27/shen-ru-jie-xi-liu-lan-qi-shi-jian-xun-huan-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器事件循环"><a href="#浏览器事件循环" class="headerlink" title="浏览器事件循环"></a>浏览器事件循环</h1><ol><li><code>js</code>是单线程的 非阻塞的<ol><li>如果是多线程 会面临很多问题 比如一个<code>DOM</code>元素被同时操作带来的问题 （H5 提出<code>Web Worker</code>标准 有很多限制 受主线程的控制 是主线程的子线程</li><li>通过<code>event Loop</code>实现<strong>非阻塞</strong></li></ol></li><li>浏览器的事件循环<ol><li><strong>执行栈</strong>和<strong>事件队列</strong></li><li><strong>宏任务</strong>和<strong>微任务</strong></li></ol></li></ol><h2 id="浏览器的事件循环"><a href="#浏览器的事件循环" class="headerlink" title="浏览器的事件循环"></a>浏览器的事件循环</h2><h3 id="执行栈和事件队列"><a href="#执行栈和事件队列" class="headerlink" title="执行栈和事件队列"></a>执行栈和事件队列</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97472917f9464c3a9ec232c06695a6ed~tplv-k3u1fbpfcp-zoom-1.image" alt="preview"></p><p>事件队列：异步代码的执行 并不会等待它返回的结果 而是直接将这个事件挂起 继续执行栈中的其他任务 当异步事件返回结果 将它放到事件队列中（被放入的事件不会立即执行回调 而是继续等待当前执行栈中的任务都执行完毕）主线程空闲 就回去事件队列查找是否有任务 如果有 则取出排在前面的<strong>事件对应的回调</strong>到执行栈中 然后执行其同步代码</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95b35f0fec064132909c253116cb46b4~tplv-k3u1fbpfcp-zoom-1.image" alt="2402010291-b9a57af85eebdab7"></p><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p><strong>Q：为什么需要有微任务？</strong></p><p><strong>A</strong>: 为了准确控制事件被添加到事件队列中的位置并加快执行高优先级的事件 （如果没有微任务 那么像<code>IO</code>事件和浏览器渲染事件就会被任意添加到事件队列中 难以控制）</p><p><strong>宏任务</strong></p><ul><li><code>script</code></li><li><code>setTimeOut（）</code></li><li><code>setInterval()</code></li><li><code>postMessage</code></li><li><code>I/O</code></li><li><code>setImmediate</code></li><li><code>UI RENDER</code></li></ul><p><strong>微任务</strong></p><ul><li><code>Promise(async await)</code></li><li><code>MutationObserver(html5回调)</code></li><li><code>process.nextTick</code>(和普通微任务有区别 在微任务执行之前执行)</li></ul><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>异步任务的返回结果会被放到任务队列中 根据事件类型决定放到微任务还是宏任务队列</p><p>当前执行栈为空时 会先查看微任务队列是否有待执行的事件</p><ul><li>有 依次执行微任务队列的回调直到队列为空 然后取出宏任务队列最前面的事件 将其回调添加到执行栈</li><li>无 取出宏队列最前面事件对应的回调并放入执行栈中</li></ul><p>当前执行栈执行完毕后时会立刻处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2f53462a66b49f2a0cabedac102235b~tplv-k3u1fbpfcp-zoom-1.image" alt="1100815376-96173ef6295d6c1f"></p><p>总结：先执行宏任务 然后执行该宏任务产生的微任务 若微任务执行中产生了其他任务（微任务则继续执行微任务 宏任务则放入下一轮宏任务中） 微任务执行完毕 再回到宏任务中进行下一轮循环</p><h3 id="小练"><a href="#小练" class="headerlink" title="小练"></a>小练</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"p2"</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">})</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"pro time"</span>);</span><br><span class="line">    }, <span class="number">0</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"after pro time"</span>);</span><br><span class="line">  })</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"second then"</span>);</span><br><span class="line">  });</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"t1"</span>);</span><br><span class="line">}, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"end"</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>第一轮事件循环</strong></p><ol><li>全局代码压入执行栈 执行<code>console.log('1')</code> 然后出栈</li><li><code>new Promise()</code>入执行栈 执行<code>console.log(p2)</code> 并将<code>then（）</code>放入微任务队列 <code>new Promise()</code>出栈</li><li><code>setTimeout（）</code>入执行栈 将对应事件放入宏任务队列 <code>setTimeout</code>出栈</li><li><code>console.log('end')</code> 入栈 执行<code>console.log('end')</code> 然后出栈</li><li>至此第一轮事件循环结束 此时微任务有<code>promise.then()</code> 宏任务有<code>setTimeout()</code> 输出 1-p2-3</li></ol><p><strong>第二轮事件循环</strong></p><ol><li>取出微任务队列第一个事件的回调至任务栈 及第一个<code>then</code> 执行<code>console.log(result)</code> 遇到<code>setTimeout</code> 将其翻入宏任务 继续执行下面的代码 即<code>console.log('after pro time')</code> 遇到<code>then</code> 属于微任务 则继续执行 <code>console.log('second then')</code> 微任务队列清空 前往宏任务队列</li><li>取出宏任务队列第一个事件并将回调放入执行栈 即<code>console.log(t1)</code></li><li>至此第二轮事件循环结束 宏任务队列还有一个<code>setTimeout</code>（刚才<code>promise</code>产生的） 微任务无事件 输出”after pro time” - “second then” - “t1”</li></ol><p><strong>第三轮事件循环</strong></p><ol><li>检查微任务队列 无待处理事件 前往宏任务队列</li><li>取出宏任务队列第一个事件 执行<code>console.log('pro time')</code></li><li>宏任务和微任务队列均清空 第三轮事件循环结束 输出 “pro time”</li></ol><p><strong>至此 所有事件执行完毕 输出依次为:</strong>“1” - “p2” - “end” - 3 - “after pro time” - “second then” - “t1” - “pro time”</p><p>相信看到这里，大家对于事件循环应该有了深刻的认识，本文错误之处，请各位在评论区指出</p><p><strong>文章参考</strong><a href="https://segmentfault.com/a/1190000022805523#comment-area">：<em>JS 中的事件循环机制</em></a></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器原理 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文带你读懂this、作用域和原型链</title>
      <link href="/2022/09/27/yi-wen-dai-ni-du-dong-this-zuo-yong-yu-he-yuan-xing/"/>
      <url>/2022/09/27/yi-wen-dai-ni-du-dong-this-zuo-yong-yu-he-yuan-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="变量提升的原理：JavaScript的执行顺序"><a href="#变量提升的原理：JavaScript的执行顺序" class="headerlink" title="变量提升的原理：JavaScript的执行顺序"></a>变量提升的原理：JavaScript的执行顺序</h2><p>变量提升：<code>JavaScript</code>代码执行过程中 <strong>JavaScript引擎</strong>把<strong>变量</strong>的声明部分和<strong>函数</strong>的声明部分提升到代码开头的行为 （变量提升后以<code>undefined</code>设为默认值）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">callName</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'callName Done!'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName);</span><br><span class="line"><span class="keyword">var</span> personName = <span class="string">'james'</span>;</span><br><span class="line"><span class="comment">//变量提升后 类似以下代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'callName Done!'</span>);</span><br><span class="line">};</span><br><span class="line"><span class="keyword">var</span> personName = <span class="literal">undefined</span>;</span><br><span class="line"><span class="title function_">callName</span>();<span class="comment">//callName已声明 所以正常输出calName Done!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName);<span class="comment">//undefined</span></span><br><span class="line">personName = <span class="string">'james'</span>;</span><br><span class="line"><span class="comment">//代码所作改变：</span></span><br><span class="line"><span class="number">1.</span>将声明的变量和函数移到了代码顶部</span><br><span class="line"><span class="number">2.</span>去除变量的<span class="keyword">var</span> 声明</span><br></pre></td></tr></tbody></table></figure><p><strong>JavaScript代码的执行流程：</strong>有些人认为 变量提升就是将声明部分提升到了最前面的位置 其实这种说法是错的 <strong>因为变量和函数声明在代码中的位置是不会变的 之所以会变量提升是因为在编译阶段被JavaScript引擎放入内存中</strong>（换句话来说 js代码在执行前会先被JavaScript引擎<strong>编译</strong>   然后才会进入<strong>执行</strong>阶段）流程大致如下图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dfcd86ca68d4b3abb12e5b8cac36ff8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517150046749"></p><p>那么编译阶段究竟是如何做到变量提升的呢 接下来我们一起来看看 我们还是以上面的那段代码作为例子</p><h5 id="第一部分：变量提升部分的代码"><a href="#第一部分：变量提升部分的代码" class="headerlink" title="第一部分：变量提升部分的代码"></a>第一部分：变量提升部分的代码</h5><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'callName Done!'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> personName = <span class="literal">undefined</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="第二部分：代码执行部分"><a href="#第二部分：代码执行部分" class="headerlink" title="第二部分：代码执行部分"></a>第二部分：代码执行部分</h5><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">callName</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName);</span><br><span class="line">personName = <span class="string">'james'</span></span><br></pre></td></tr></tbody></table></figure><p>执行图如下</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23c1d27f19e74543949aa485ff0000bf~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517151048844"></p><p>可以看到 结果编译后 会在生成<strong>执行上下文</strong>和<strong>可执行代码</strong>两部分内容</p><p>执行上下文：JavaScript代码执行时的运行环境（比如调用一个函数 就会进入这个函数的执行上下文 确定函数执行期间的<code>this</code>、<strong>变量</strong>、<strong>对象</strong>等）在<strong>执行上下文</strong>中包含着<strong>变量环境</strong>（Viriable Environment）以及<strong>词法环境</strong>（Lexicol Environment） 变量环境保存着变量提升的内容 例如上面的<code>myName</code> 以及<code>callName</code></p><p>那既然变量环境保存着这些变量提升 那变量环境对象时怎么生成的呢 我们还是用上面的代码来举例子</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">callName</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'callName Done!'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName);</span><br><span class="line"><span class="keyword">var</span> personName = <span class="string">'james'</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>第一、三行不是变量声明 JavaScript引擎不做任何处理</li><li>第二行 发现了function定义的函数 将函数定义储存在堆中 并在变量环境中创建一个<code>callName</code>的属性 然后将该属性指向<strong>堆</strong>中函数的位置</li><li>第四行 发现<code>var</code>定义 于是在变量环境中创建一个<code>personName</code>的属性 并使用<code>undefined</code>初始化</li></ul><p>经过上面的步骤后 变量环境对象就生成了 现在已经有了执行上下文和可执行代码了 接下来就是代码执行阶段了</p><h3 id="代码执行阶段"><a href="#代码执行阶段" class="headerlink" title="代码执行阶段"></a>代码执行阶段</h3><p>总所周知 js执行代码是按照顺序一行一行从上往下执行的 接下来还是使用上面的例子来分析</p><ul><li>执行到<code>callName()</code>是 JavaScript引擎便在变量环境中寻找该函数 由于变量环境中存在该函数的引用 于是引擎变开始执行该函数 并输出<code>"callName Done!"</code></li><li>接下来执行到<code>console.log(personName)</code>; 引擎在变量环境中找到<code>personName</code>变量 但是这时候它的值是<code>undefined</code> 于是输出<code>undefined</code></li><li>接下来执行到了<code>var personName = 'james'</code>这一行 在变量环境中找到<code>personName</code> 并将其值改成<code>james</code></li></ul><p>以上便是一段代码的编译和执行流程了 相信看到这里你对JavaScript引擎是如何执行代码的应该有了更深的了解</p><p><strong>Q</strong>：如果代码中出现了相同的变量或者函数怎么办？</p><p><strong>A</strong>：首先是编译阶段 如果遇到同名变量或者函数 在变量环境中后面的同名变量或者函数会将之前的覆盖掉 所以最后只会剩下一个定义</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'我是第一个定义的'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'我是将你覆盖掉的'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line"><span class="comment">//输出两次"我是将你覆盖掉的"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="调用栈：栈溢出的原理"><a href="#调用栈：栈溢出的原理" class="headerlink" title="调用栈：栈溢出的原理"></a>调用栈：栈溢出的原理</h2><p>你在日常开发中有没有遇到过这样的报错</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c69b9c0c05942ba9999a99c8fe5a635~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517152840833"></p><p>根据报错我们可以知道是出现了栈溢出的问题 那什么是栈溢出呢？为什么会栈溢出呢？</p><p><strong>Q1</strong>：什么是栈呢？</p><p><strong>A1</strong>：一种后进先出的数据结构队列</p><p><strong>Q2</strong>：什么是调用栈？</p><p><strong>A2</strong>：代码中通常会有很多函数 也有函数中调用另一个函数的情况 调用栈就是用来管理调用关系的一种数据结构</p><p>当我们在函数中调用另一个函数（如调用自身的递归）然后处理不当的话 就很容易产生栈溢出 比如下面这段代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">stackOverflow</span>(<span class="params">n</span>) {</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">stackOverflow</span>(n - <span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="title function_">stackOverflow</span>(<span class="number">10000</span>);<span class="comment">//栈溢出</span></span><br></pre></td></tr></tbody></table></figure><p>既然知道了什么是调用栈和栈溢出 那代码执行过程中调用栈又是如何工作的呢？我们用下面这个例子来举例</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> personName = <span class="string">'james'</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findName</span>(<span class="params">name, address</span>) {</span><br><span class="line"><span class="keyword">return</span> name + address;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findOneDetail</span> (name, adress) {</span><br><span class="line"><span class="keyword">var</span> tel = <span class="string">'110'</span>;</span><br><span class="line">detail = <span class="title function_">findName</span>(name, address);</span><br><span class="line"><span class="keyword">return</span> personName + detail + tel</span><br><span class="line">};</span><br><span class="line"><span class="title function_">findOneDetail</span>(<span class="string">'james'</span>, <span class="string">'Lakers'</span>)</span><br></pre></td></tr></tbody></table></figure><p>可以看到 我们在<code>findOneDetail</code>中调用了<code>findName</code>函数 那么调用栈是怎么变化的</p><p><strong>第一步</strong>：创建全局上下文 并将其压入栈底</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/246d36298c0c4bf98c0b181ca5099b3a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517154455415"></p><p>接下来开始执行<code>personName = 'james'</code>的操作 将变量环境中的<code>personName</code>设置为<code>james</code> </p><p><strong>第二步</strong>：执行<code>findOneDetail</code>函数 这个时候<code>JavaScript</code>会为其创建一个执行上下文 最后将其函数的执行上下文压入栈中 </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a3981e2d84841cb9181d1bfbec6da9d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517155137696"></p><p>接下来执行完<code>tel = ‘110'</code>后 将变量环境中的<code>tel</code>设置为<code>110</code></p><p><strong>第三步</strong>：当执行<code>detail = findName（）</code>时 会为<code>findName</code>创建执行上下文并压入栈中</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a015be5b8de4073ac991a63308ba125~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517155425992"></p><p>接下来执行完<code>findName</code>函数后 将其执行上下文弹出调用栈 接下来再弹出<code>findOneDetail</code>的执行上下文以及全局执行上下文 至此整个<code>JavaScript</code>的执行流程结束</p><p><strong>所以调用栈是JavaScript引擎追踪函数执行的一个机制 当一次有多个函数被调用时 通过调用栈就能追踪到哪个函数正在被执行以及各函数之间的调用关系</strong></p><h3 id="如何利用调用栈"><a href="#如何利用调用栈" class="headerlink" title="如何利用调用栈"></a>如何利用调用栈</h3><h4 id="1-使用浏览器查看调用栈的信息"><a href="#1-使用浏览器查看调用栈的信息" class="headerlink" title="1.使用浏览器查看调用栈的信息"></a>1.使用浏览器查看调用栈的信息</h4><p>点击source并打上断点刷新后就可以再Call Stack查到调用栈的信息（也可以通过代码中输入<code>console.track()</code>查看）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94d5cf96bc0c4442824f1795edf7f026~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517155835891"></p><h4 id="2-小心栈溢出"><a href="#2-小心栈溢出" class="headerlink" title="2.小心栈溢出"></a>2.小心栈溢出</h4><p>当我们在写递归的时候 很容易发生栈溢出 可以通过<strong>尾调用优化</strong>来避免栈溢出</p><h2 id="块级作用域：var、let以及const"><a href="#块级作用域：var、let以及const" class="headerlink" title="块级作用域：var、let以及const"></a>块级作用域：var、let以及const</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><strong>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期</strong></p><p>我们都知道 使用var会产生变量提升 而变量提升会引发很多问题 比如变量覆盖 本应被销毁的变量依旧存在等等问题 而ES6引入了let 和const两种声明方式 让js有了块级作用域 那let和const时如何实现块级作用域的呢 其实很简单 原来还是从理解执行上下文开始</p><p>我们都知道 JavaScript引擎在编译阶段 会将使用var定义的变量以及function定义的函数声明在对应的执行上下文中的变量环境中创建对应的属性 当时我们发现执行上下文中还有一个词法环境对象没有用到 其实 词法环境对象便是关键之处 我们还是通过举例子来说明一下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">    }</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b) </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(d)</span><br><span class="line">}   </span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>第一步：执行并创建上下文</strong></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7767853e8e834b4595359ddf04d16a7a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517161310897"></p><ul><li>函数内部通过var声明的变量  在编译阶段全都被存放到变量环境里面了</li><li>通过let声明的变量  在编译阶段会被存放到词法环境（Lexical Environment）中</li><li>在函数的作用域内部  通过let声明的变量并没有被存放到词法环境中</li><li>接下来  第二步继续执行代码  当执行到代码块里面时  变量环境中a的值已经被设置成了1  词法环境中b的值已经被设置成了2</li></ul><p>这时候函数的执行上下文就如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a3dd940ab3c4fe681eccb9ad2140e27~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517161335971"></p><p>可以看到 当进入函数的作用域块是 作用域块中通过let声明的变量 会被放到词法环境中的一个单独的区域中 这个区域并不邮箱作用域块外面的变量 （比如声明了<code>b = undefined </code>但是不影响外面的<code>b = 2</code>）</p><p>其实 在词法作用域内部 维护了一个小型的栈结构 栈底是函数最外层的变量 进入一个作用域块后 便会将过海作用域内部耳朵变量压到栈顶 当作用域执行完之后 就会弹出（通过<code>let</code>和<code>const</code>声明的变量）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1899d826927b4199ae65156b312ff6ad~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517161748842"></p><p>当作用域块执行完之后 其内部定义的变量就会从词法作用域的栈顶弹出</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb41ac6510b44ce0bf3bbd422b2a3065~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517161843353"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>块级作用域就是通过词法环境的栈结构来实现的 而变量提升是通过变量环境来实现 通过这两者的结合 JavaScript引擎也就同时支持了变量提升和块级作用域了。</strong></p><h2 id="作用域链和闭包"><a href="#作用域链和闭包" class="headerlink" title="作用域链和闭包"></a>作用域链和闭包</h2><p>在开始作用域链和闭包的学习之前 我们先来看下这部分代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findName</span>(<span class="params"></span>) {</span><br><span class="line"><span class="keyword">var</span> personName = <span class="string">'james'</span>;</span><br><span class="line"><span class="title function_">callName</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> personName = <span class="string">'curry'</span>;</span><br><span class="line"><span class="title function_">findName</span>();<span class="comment">//curry</span></span><br><span class="line"><span class="comment">//你是否以为输出james 猜想callName不是在findName中调用的吗 那findName中已经定义了personName = 'james' 那为什么是输出外面的curry呢 这其实是和作用域链有关的</span></span><br></pre></td></tr></tbody></table></figure><p><strong>在每个执行上下文的变量环境中 都包含了一个外部引用 用来执行外部的执行上下文 称之为outer</strong></p><p>当代码使用一个变量时 会先从当前执行上下文中寻找该变量 如果找不到 就会向outer指向的执行上下文查找</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/085a8dc8679745c3aef4729030746536~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517163149167"></p><p>可以看到<code>callName</code>和<code>findName</code>的outer都是指向全局上下文的 所以当在<code>callName</code>中找不到<code>personName</code>的时候 会去全局找 而不是调用<code>callName</code>的<code>findName</code>中找 所以输出的是<code>curry</code>而不是<code>james</code></p><p><strong>作用域链是由词法作用域决定的</strong></p><blockquote><p>词法作用域就是指作用域是由代码中函数声明的位置来决定的 所以词法作用域是静态的作用域 通过它就能够预测代码在执行过程中如何查找表示符</p></blockquote><p><strong>所以词法作用域是代码阶段就决定好的 和函数怎么调用的没有关系</strong></p><h3 id="块级作用域中的变量查找"><a href="#块级作用域中的变量查找" class="headerlink" title="块级作用域中的变量查找"></a>块级作用域中的变量查找</h3><p>我们来看下下面这个例子</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">" 极客世界 "</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">let</span> myName = <span class="string">"Chrome 浏览器 "</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(test)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">" 极客邦 "</span></span><br><span class="line">    <span class="keyword">let</span> test = <span class="number">2</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">let</span> test = <span class="number">3</span></span><br><span class="line">        <span class="title function_">bar</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">" 极客时间 "</span></span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="number">1</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></tbody></table></figure><p>我们知道 如果是<code>let</code>或者<code>const</code>定义的 就会储存在词法环境中 所以寻找也是从该执行上下文的词法环境找 如果找不到 就去变量环境 还是找不到则去outer指向的执行上下文寻找 如下图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e16d18de8274687ae2a0f846810b129~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517163831591"></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p> JavaScript 中 根据词法作用域的规则 内部函数总是可以访问其外部函数中声明的变量 当通过调用一个外部函数返回一个内部函数后 即使该外部函数已经执行结束了 但是内部函数引用外部函数的变量依然保存在内存中 我们就把这些变量的集合称为闭包</p><p>举个例子</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">" 极客时间 "</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = {</span><br><span class="line">        <span class="attr">getName</span>:<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">setName</span>:<span class="keyword">function</span>(<span class="params">newName</span>){</span><br><span class="line">            myName = newName</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">foo</span>()</span><br><span class="line">bar.<span class="title function_">setName</span>(<span class="string">" 极客邦 "</span>)</span><br><span class="line">bar.<span class="title function_">getName</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">getName</span>())</span><br></pre></td></tr></tbody></table></figure><p>首先我们看看当执行到 <code>foo </code>函数内部的<code>return innerBar</code>这行代码时调用栈的情况 你可以参考下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2783d4751c24f68a5acee2d84b15b40~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517164204469"></p><p>从上面的代码可以看出 <code>innerBar</code> 是一个对象 包含了 <code>getName</code> 和<code>setName</code>的两个方法 这两个方法都是内部定义的 且都引用了函数内部的变量</p><p>根据词法作用域的规则<code> getName</code>和<code>setName</code>总是可以访问到外部函数<code>foo</code>中的变量 所以当<code>foo</code>执行结束时 <code>getName</code>和<code>setName</code>依然可以以后使用变量<code>myName</code>和<code>test</code> 如下图所示</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/748119073d1643a0912112583978ed15~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517164450416"></p><p>可以看出 虽然<code>foo</code>从栈顶弹出 但是变量依然存在内存中 这个时候 除了<code>setName</code>和<code>getName</code> 其他任何地方都不能访问到这两个变量 所以形成了闭包</p><p>那如何使用这些闭包呢 可以通过bar来使用 当调用了<code>bar.seyName</code>时 如下图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54070dc6a2714ef2b6e3ff15b326cf24~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220517164641086"></p><p>可以使用chrome的Clourse查看闭包情况</p><h3 id="闭包怎么回收"><a href="#闭包怎么回收" class="headerlink" title="闭包怎么回收"></a>闭包怎么回收</h3><p>通常 如果引用闭包的函数是一个全局变量 那么闭包会一直存在直到页面关闭 但如果这个闭包以后不再使用的话 就会造成内存泄漏</p><p>如果引用闭包的函数是各局部变量 等函数销毁后 在下次JavaScript引擎执行垃圾回收的时候 判断闭包这块内容不再被使用了 就会回收</p><p>所以在使用闭包的时候 请记住一个原则：<strong>如果该闭包一直使用 可以作为全局变量而存在 如果使用频率不高且占内存 考虑改成局部变量</strong></p><h4 id="小练"><a href="#小练" class="headerlink" title="小练"></a>小练</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> per = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'curry'</span>;</span><br><span class="line"><span class="attr">callName</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">askName</span>(<span class="params"></span>){</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'davic'</span>;</span><br><span class="line"><span class="keyword">return</span> per.<span class="property">callName</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'james'</span>;</span><br><span class="line"><span class="keyword">let</span> _callName = <span class="title function_">askName</span>()</span><br><span class="line"><span class="title function_">_callName</span>();</span><br><span class="line">per.<span class="title function_">callName</span>();</span><br><span class="line"><span class="comment">//打印两次james</span></span><br><span class="line"><span class="comment">//只需要确定好调用栈就好 调用了askName（）后 返回的是per.callName 后续就和askName没关系了（出栈） 所以结果就是调用了两次per.callName 根据词法作用域规则 结果都是james 也不会形成闭包</span></span><br></pre></td></tr></tbody></table></figure><h2 id="this：从执行上下文分析this"><a href="#this：从执行上下文分析this" class="headerlink" title="this：从执行上下文分析this"></a>this：从执行上下文分析this</h2><p>相信大家都有被<code>this</code>折磨的时候 而this确实也是比较难理解和令人头疼的问题 接下来我将从执行上下文的角度来分析JavaScript中的<code>this</code> 这里先抛出结论：<strong>this是和执行上下文绑定的 每个执行上下文都有一个this</strong></p><p>接下来 我将带大家一起理清全局执行上下文的<code>this</code>和函数执行上下文的<code>this</code>、</p><h4 id="全局执行上下文的this"><a href="#全局执行上下文的this" class="headerlink" title="全局执行上下文的this"></a>全局执行上下文的this</h4><p>全局执行上下文的<code>this</code>和作用域链的最底端一样 都是指向<code>window</code>对象</p><h3 id="函数执行上下文的this"><a href="#函数执行上下文的this" class="headerlink" title="函数执行上下文的this"></a>函数执行上下文的this</h3><p>我们通过一个例子来看一下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">//window对象</span></span><br><span class="line">}</span><br><span class="line"><span class="title function_">func</span>();</span><br></pre></td></tr></tbody></table></figure><blockquote><p>默认情况下调用一个函数 其执行上下文的this也是指向window对象</p></blockquote><p>那如何改变执行上下文的<code>this</code>值呢 可以通过<code>apply call 和bind</code>实现 这里讲下如何使用<code>call</code>来改变</p><h4 id="1-通过call"><a href="#1-通过call" class="headerlink" title="1.通过call"></a>1.通过call</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> per = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'james'</span>,</span><br><span class="line"><span class="attr">address</span>: <span class="string">'Lakers'</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">'curry'</span></span><br><span class="line">}</span><br><span class="line">callName.<span class="title function_">call</span>(per);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per)<span class="comment">//name: 'curry', address: 'Lakers'</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到这里<code>this</code>的指向已经改变了</p><h4 id="2-通过对象调用"><a href="#2-通过对象调用" class="headerlink" title="2.通过对象调用"></a>2.通过对象调用</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'james'</span>;</span><br><span class="line"><span class="attr">callName</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">person.<span class="title function_">callName</span>();<span class="comment">//james </span></span><br></pre></td></tr></tbody></table></figure><p><strong>使用对象来调用其内部方法 该方法的this指向对象本身的</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.<span class="title function_">callName</span>() === person.<span class="property">callName</span>.<span class="title function_">call</span>(person)</span><br></pre></td></tr></tbody></table></figure><p>这个时候我们如果讲对象赋给另一个全局变量<code> this</code>又会怎样变化呢</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = {</span><br><span class="line">name: 'james';</span><br><span class="line">callName: function() {</span><br><span class="line">this.name = 'curry';</span><br><span class="line">console.log(this.name);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">var per1 = person;//this又指向window</span><br></pre></td></tr></tbody></table></figure><ul><li>在全局环境中调用一个函数 函数内部的<code>this</code>指向全局变量<code>window</code></li><li>通过一个对象调用内部的方法 该方法的<code>this</code>指向对象本身</li></ul><h4 id="3-通过构造函数设置"><a href="#3-通过构造函数设置" class="headerlink" title="3.通过构造函数设置"></a>3.通过构造函数设置</h4><p>当使用<code>new</code>关键字构建好了一个新的对象 构造函数的<code>this</code>其实就是对象本身</p><h3 id="this的缺陷以及应对方案"><a href="#this的缺陷以及应对方案" class="headerlink" title="this的缺陷以及应对方案"></a>this的缺陷以及应对方案</h3><h4 id="1-嵌套函数的this不会从外层函数中继承"><a href="#1-嵌套函数的this不会从外层函数中继承" class="headerlink" title="1.嵌套函数的this不会从外层函数中继承"></a>1.嵌套函数的this不会从外层函数中继承</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'james'</span>,</span><br><span class="line"><span class="attr">callName</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">//指向person</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">innerFunc</span>(<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">//指向window</span></span><br><span class="line">}</span><br><span class="line"><span class="title function_">innerFunc</span>()</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">person.<span class="title function_">callName</span>();</span><br><span class="line"><span class="comment">//如何解决</span></span><br><span class="line"><span class="number">1.</span>使用一个变量保存</span><br><span class="line"><span class="keyword">let</span> _this = <span class="variable language_">this</span> <span class="comment">//保存指向person的this</span></span><br><span class="line"><span class="number">2.</span>使用箭头函数</span><br><span class="line">() =&gt; {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">//箭头函数不会创建其自身的执行上下文 所以箭头函数中的this指向外部函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-普通函数中的this指向全局对象window"><a href="#2-普通函数中的this指向全局对象window" class="headerlink" title="2.普通函数中的this指向全局对象window"></a>2.普通函数中的this指向全局对象window</h4><p>在默认情况下调用一个函数 其指向上下文的<code>this</code>默认就是指向全局对象<code>window</code></p><p><strong>总结：</strong>相信看到这里 大家对于作用域 作用域链 执行上下文和this都有了更深的理解 笔者后期还会更新更多关于浏览器的原理和实践 感兴趣的小伙伴可以点波关注一起学习 文中错误之处请在评论区指出！</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器是如何将HTML、CSS、JavaScript变成可视的页面的</title>
      <link href="/2022/09/27/liu-lan-qi-di-ceng-xuan-ran-yuan-li/"/>
      <url>/2022/09/27/liu-lan-qi-di-ceng-xuan-ran-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器是如何将-HTML、CSS、JavaScript-变成可视的页面的"><a href="#浏览器是如何将-HTML、CSS、JavaScript-变成可视的页面的" class="headerlink" title="浏览器是如何将 HTML、CSS、JavaScript 变成可视的页面的"></a>浏览器是如何将 HTML、CSS、JavaScript 变成可视的页面的</h1><h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p>渲染模块在执行过程中会被划分为很多子阶段 输入的<code>HTML、CSS、JavaScript</code>经过这些子阶段处理输出像素 这个处理流程叫做<strong>渲染流水线</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f34a58986965474fa2632167ef562910~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516110029139"></p><p>流水线分为以下几个阶段</p><ul><li>构建<code>DOM</code>树</li><li>样式计算</li><li>布局阶段</li><li>分层</li><li>绘制</li><li>分块</li><li>栅格化</li><li>合成</li></ul><p>那既然流程这么复杂 如何避免搞混呢？ 其实只需要理解以下三个部分就行 即</p><ul><li>开始时每个子阶段都有其输入的内容</li><li>然后每个子阶段都有其处理过程</li><li>最终每个子阶段会生成输出内容</li></ul><h3 id="1-构建-DOM-树"><a href="#1-构建-DOM-树" class="headerlink" title="1.构建 DOM 树"></a>1.构建 DOM 树</h3><p><strong>Q</strong>: 为什么要构建<code>DOM</code>树呢</p><p><strong>A</strong>: 因为浏览器无法直接理解和使用<code>HTML</code> 所以需要将<code>HTML</code>转换成浏览器能够理解的<code>DOM</code>树</p><p>接下来我们看一下<code>DOM</code>树的构建过程</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82529d307842404b86b4084f1fe29c38~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516111753024"></p><p>从图中可以看出 构建<code>DOM</code>树的输入内容是一个简单的<code>HTML</code>文件 经过<code>HTML</code>解析器解析 最终输出<strong>树状结构</strong>的<code>DOM</code>树</p><p>至此构建<code>DOM</code>树的阶段已经完成 接下来便是让<code>DOM</code>节点拥有正确的样式 这一阶段便是样式计算</p><h3 id="2-样式计算"><a href="#2-样式计算" class="headerlink" title="2.样式计算"></a>2.样式计算</h3><p>样式计算的目的是计算出<code>DOM</code>树节点中每个元素的具体样式 可分为三步完成</p><ol><li><p>把<code>css</code>转换成浏览器能够理解的结构（<code>styleSheets</code>）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/080c689fa8c24478993963b6e852d71a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516113214615"></p><p>可以看出 <code>CSS</code>的来源主要有三种</p><ul><li>通过<code>link</code>引入的外部<code>CSS</code>文件</li><li><code>&lt;style&gt;</code>标记内的<code>CSS</code></li><li>元素的 style 属性内嵌的<code>CSS</code></li></ul><p>当浏览器接收到<code>CSS</code>文本时 会执行转换操作 将其转换成浏览器可以理解的<code>styleSheets</code>结构 该结构同时具有<strong>查询</strong>和<strong>修改</strong>功能</p><p>可以在 chrome 浏览器控制台输入<code>document.styleSheets</code>查看</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcbc3af0afc2410fb6483bbc120b3284~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516113650127"></p></li><li><p>转换样式表中的属性值 使其标准化</p><p>第一步我们已经将<code>CSS</code>文本转换成可以理解的<code>styleSheets</code>结构了 接下来便是对属性值的表转化操作</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8081232db7c64061b6677eff6531e602~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516114304703"></p><p>从图中看出 <code>aqua</code>被解析为<code>rgb(0, 255, 255)</code>……这就是标准化过程</p></li><li><p>计算出<code>DOM</code>树中每个节点的具体样式</p></li></ol><p>计算具体属性涉及到<code>CSS</code>的<strong>继承规则</strong>和<strong>层叠规则</strong></p><ul><li>继承：<code>dom</code>节点可以继承父节点的一些属性值</li><li>层叠：定义了如何合并来自多个原的属性值的算法</li></ul><p>一句话概括 样式计算阶段实在遵循<code>CSS</code>的<strong>继承</strong>和<strong>层叠</strong>规则下 计算输出每个<code>DOM</code>节点的样式并保存在<code>ComputedStyle</code>的结构内（可通过 Chrome 的 Computed 查看）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28be32e6ec4447eaab0ff642c76f39e5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516114737531"></p><h3 id="3-布局阶段"><a href="#3-布局阶段" class="headerlink" title="3.布局阶段"></a>3.布局阶段</h3><p>布局阶段主要有两个任务</p><ol><li><strong>创建布局树</strong><ol><li>遍历<code>DOM</code>树中的所有可见节点 并把这些节点添加到布局中</li><li>不可见的节点会被布局树忽略掉</li></ol></li><li><strong>布局计算</strong></li></ol><h3 id="4-分层"><a href="#4-分层" class="headerlink" title="4.分层"></a>4.分层</h3><p>在完成布局阶段后 依旧不能着手绘制页面 因为为了更加方便地实现一些复杂的效果（比如 3D 变换 页面滚动等）渲染引擎为特定的节点生成专用的图层 并生成一颗对应的图层树 由这些图层叠加在一起构成了最终的页面图像 （可以使用 chrome 的 Layers 功能查看页面的图层构成以及调试图层渲染过程）</p><p><strong>元素可以被单独提升为一个图层的情况：</strong></p><ol><li>拥有层叠上下文属性的元素 如定位属性 透明属性 <code>CSS</code>滤镜等</li></ol><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1627ba55268b454db6c8a886577a6cad~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516153448835" style="zoom:50%;"><p>2.需要剪裁的地方也会创建图层</p><p>例如<code>div</code>里面的文字较多且超出了显示区域 这个时候就产生了裁剪 渲染引擎会将裁剪文字内容的一部分用于显示在<code>div</code>区域 出现这种裁剪情况的时候 渲染引擎就会为文字部分单独创建一个层 如果出现滚动条 滚动条也会提升为单独的层</p><h3 id="5-图层绘制"><a href="#5-图层绘制" class="headerlink" title="5.图层绘制"></a>5.图层绘制</h3><p>完成图层树的构建后 渲染引擎会对图层树中的每个图层进行绘制。</p><p><strong>举个例子：</strong> 如果我们要画一副五星红旗 我们会怎么操作？通常 我们会进行这样的步骤</p><ul><li>绘制红色背景</li><li>画一个大五角星</li><li>画剩余的四个五角星</li></ul><p>其实图层绘制的步骤和这个差不多 渲染引擎会将一个图层的绘制拆分成很多绘制指令 再将这些绘制指令按照顺序组成一个待绘制列表 如下图（可以通过 chrome 的 Layers 中的 document 层查看调试）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03186a109bff45379a16adbe3e40138a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516154230624"></p><h3 id="6-栅格化操作"><a href="#6-栅格化操作" class="headerlink" title="6.栅格化操作"></a>6.栅格化操作</h3><p>绘制列表只是用来记录绘制顺序和绘制指令的列表 而实际上操作是由绘制引擎中的合成线程来完成的（类似于待办事项里的代办只是用来记录的列表 而执行这些事项的是你自己） 那合成线程和渲染主线程之间有啥关系呢</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70370f1ded2245ff97124cee3bee3fbd~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516154601954"></p><p>实际上 当图层的绘制列表准备好之后 主线程会将该列表<code>commit</code>给合成线程 而合成线程会将图层切割成多个图块 按照视口（简单理解为屏幕可视区域）附加的图块来优先生成位图 实际生成位图的操作是由栅格化来执行的。</p><p><strong>Q</strong>: 为什么要优先将可视区附加的图块生成位图？</p><p><strong>A</strong>: 当图层很长很大的时候 用户不一定会查看所有区域 如果一次性绘制所有图层的话 会产生太大的开销 也没有必要</p><p><strong>Q</strong>: 什么是栅格化?</p><p><strong>A</strong>: 将图块转化为位图（图块是栅格化的最小单位）</p><p>渲染进程维护了一个栅格化的线程池 所有图块栅格化都是在线程池内执行的</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbdaea2e0029434898f1cc4199baf374~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516155206479"></p><p><strong>栅格化通常会使用 GPU 来加速生成 使用 GPU 生成位图的过程称为快速栅格化 生成的位图被保存在 GPU 内存中</strong></p><h3 id="7-合成和显示"><a href="#7-合成和显示" class="headerlink" title="7.合成和显示"></a>7.合成和显示</h3><p>一旦所有图块被栅格化 合成线程就会生成一个绘制图块的命令——“<strong>DrawQuad”</strong> 然后提交该命令给浏览器进程</p><p>浏览器进程中的<strong>viz</strong>组件 根据<strong>DrawQuad</strong>命令 将页面内容绘制到<strong>内存</strong>中 然后将内存显示在屏幕上</p><p><strong>到这里 经过一系列操作 HTML CSS JavaScript 文件就会变成屏幕可视的页面了。</strong></p><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h3><p>一个完整的渲染流程简述如下</p><ol><li>渲染进程将<code>HTML</code>内容转换为能够读懂的<code>DOM</code>树结构</li><li>渲染引擎将<code>CSS</code>样式表转换为<code>styleSheets</code> 并计算出<code>DOM</code>节点的具体样式</li><li>创建布局树 计算元素的布局信息</li><li>对布局树进行分层 生成分层树</li><li>为每个图层生成绘制列表 并将其提交到合成进程</li><li>合成进程将图层分成图块 并在栅格化线程池将其转换为位图</li><li>合成线程发送绘制图块命令<strong>DrawQuad</strong>给浏览器进程</li><li>浏览器根据<strong>DrawQuad</strong>生成页面并显示到显示器上</li></ol><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="1-重排"><a href="#1-重排" class="headerlink" title="1.重排"></a>1.重排</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05786d73b8204421a80dcccd0ea45f18~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516160105558"></p><p>当修改了元素的几何属性（宽度 高度等）会使浏览器重新布局 解析之后的一系列子阶段 就叫重排 重排后需要更新完整的渲染流水线 所以开销是最大的</p><blockquote><p>重排一定会导致重绘</p></blockquote><h3 id="2-重绘"><a href="#2-重绘" class="headerlink" title="2.重绘"></a>2.重绘</h3><p>更改元素的背景色等 （不会触发布局阶段 没有引起集合位置的变化 ）直接进入了绘制阶段 然后执行之后的一系列子操作 就叫重绘</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1b7bd635a9f4d3d9381d912b5490e4a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516160545832"></p><p><strong>Q：</strong>重排快还是重绘快？</p><p><strong>A：</strong>重绘省去了布局和分层阶段 所以执行效率更快</p><blockquote><p>重绘不一定导致重排</p></blockquote><h3 id="3-直接合成阶段"><a href="#3-直接合成阶段" class="headerlink" title="3.直接合成阶段"></a>3.直接合成阶段</h3><p>当做了既不导致重排 也不导致重绘的操作 就跳过布局和绘制 只执行后续操作 称为直接合成</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57669f99a6824879b8cc4603e7a38211~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220516160821428"></p><p>例如 <code>transform</code>可以避免重排和重回 直接在非主线程上执行合成动画操作（这也是效率最高的 因为没有占用主线程的资源 也没有重排和重绘）</p><p><strong>Q</strong>: 如何减少重排和重绘？</p><p><strong>A</strong>: 触发重排和重绘的操作尽量放在一起（如修改高度或者边距） 通过虚拟<strong>dom 层</strong>计算出操作总得差异 一起提交给浏览器（例如使用<strong>createdocumentfragment</strong>来汇总<strong>append</strong>的<code>dom</code> 来减少触发重排重绘次数）</p><p><strong>结语</strong>：相信看了上面的文章 大家对于浏览器是如何将 HTML CSS JavaScript 文件处理并生成我们看到的页面这个过程有了更深的理解 文章若有错误之处 请大家在评论区指出指正！笔者最近正在学习浏览器的工作原理及实践的相关内容 感兴趣的小伙伴可以点波关注一起学习 后续会继续更新相关系列内容！</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 浏览器原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学ES6 1.0</title>
      <link href="/2022/05/06/chong-xue-es61.0/"/>
      <url>/2022/05/06/chong-xue-es61.0/</url>
      
        <content type="html"><![CDATA[<h1 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h1><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a= [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">a [ i] = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">a[6J ();<span class="comment">// 6</span></span><br><span class="line"> <span class="comment">//每轮的i都是重新声明的 因为js引擎内部会记住上一轮循环的值 另外 设置循环变量的那部分是一个父作用域 而循环体内部是一个单独的子作用域</span></span><br></pre></td></tr></tbody></table></figure><p>暂时性死区的本质就是只要进入当前作用域 所要使用的变量就已经存在 但是不可获取 只有等到声明变量的那一行代码出现 才可以获取和使用变量。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>ES6 允许块级作用域声明函数</p><ul><li>函数声明类似于<code>var</code> 即会提升到全局作用域或者函数作用域的头部</li><li>函数声明还会提升到所在块级作用域的头部</li></ul><h3 id="do-表达式"><a href="#do-表达式" class="headerlink" title="do 表达式"></a>do 表达式</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> {</span><br><span class="line">  <span class="keyword">let</span> t = <span class="title function_">f</span>();</span><br><span class="line">  t * t + <span class="number">1</span>;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//变量x会得到块级作用域的返回值</span></span><br></pre></td></tr></tbody></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p><code>const</code>实际上保证的并不是变量的值不得改动 而是变量指向的那个<strong>内存地址</strong>不得改动（对于一个复合类型的数据 变量指向的内存地址保存的只是一个指针 const 只能保证这个指针是固定的 不能保证它指向的数据结构是不可变的）</p><h1 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h1><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><blockquote><p>ES6 内部使用严格相等运算符判断一个位置是否有值 所以 如果一个数组成员不严格等于<code>undefined</code> 默认值是不会生效的</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x=<span class="number">1</span>] = [<span class="literal">undefined</span>]; <span class="comment">// x = 1</span></span><br><span class="line"><span class="keyword">let</span> [x=<span class="number">1</span>] = [<span class="literal">null</span>];<span class="comment">// x = null</span></span><br><span class="line"><span class="comment">//如果默认值是一个表达式 那么这个表达式是惰性求值的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) {....};</span><br><span class="line"><span class="keyword">let</span> [x = <span class="title function_">f</span>()] = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">//默认值可以引用解构赋值的其他变量 但是该变量必须已经声明</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];<span class="comment">//ReferenceError</span></span><br></pre></td></tr></tbody></table></figure><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><blockquote><p>数组的元素是按次序排列的 变量的取值是由他的位置决定的 而对象的属性没有次序 变量必须与属性同名才能取到正确的值 0</p></blockquote><p>默认值生效的条件是对象的属性值严格等于<code>undefined</code> 如果解构失败 那么变量的值等于<code>undefined</code></p><p>如果解构的是嵌套的对象 而且子对象所在的父属性不存在 那么就会报错</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> {</span><br><span class="line">  <span class="attr">foo</span>: { bar },</span><br><span class="line">} = { <span class="attr">baz</span>: <span class="string">"baz"</span> }; <span class="comment">//foo = undefined 所以取其子元素就会报错</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> { <span class="number">0</span>: first, [arr.<span class="property">length</span> - <span class="number">1</span>]: last } = arr; <span class="comment">//first: 1, last: 3</span></span><br></pre></td></tr></tbody></table></figure><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p><strong>解构赋值时 只要等号右边的值不是对象或数组 就会将其转为对象 由于<code>undefined</code>和<code>null</code>无法转为对象 所以对他们进行解构赋值时都会报错</strong></p><h2 id="解构的用途"><a href="#解构的用途" class="headerlink" title="解构的用途"></a>解构的用途</h2><ul><li>交换变量的值</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></tbody></table></figure><ul><li>从函数返回多个值</li><li>函数参数的命名</li><li>提取<code>JSON</code>数据</li><li>函数参数的默认值</li><li>遍历<code>Map</code>结构</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) {</span><br><span class="line">....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>输入模块的指定方法</li></ul><h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h2 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes() startsWith() endsWith()"></a><code>includes() startsWith() endsWith()</code></h2><ul><li><code>includes()</code>: 返回布尔值 表示是否找到了字符串</li><li><code>startsWith()</code>: 返回布尔值 表示参数字符串是否在源字符串的头部</li><li><code>endsWith():</code> 返回布尔值 表示参数字符串是否在源字符串的头部</li></ul><h2 id="repeat（）"><a href="#repeat（）" class="headerlink" title="repeat（）"></a><code>repeat（）</code></h2><p>返回一个新字符串 将原来的字符串重复几次</p><h2 id="padStart-padEnd"><a href="#padStart-padEnd" class="headerlink" title="padStart() padEnd()"></a><code>padStart() padEnd()</code></h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">'ab'</span>)<span class="comment">//'ababx' 最小长度以及补全的字符串</span></span><br><span class="line"><span class="comment">//如果字符串的长度大于或等于指定的最小长度 则返回原字符串 如果省略第二个参数 则用空格来补全</span></span><br><span class="line"><span class="comment">//padStart常用来胃数值补全指定位</span></span><br><span class="line">’ <span class="number">1</span> ’ . <span class="title function_">padStart</span>(l <span class="number">0</span>,’<span class="number">0</span> ’ ) <span class="comment">// ” 0 00000000 1 ”</span></span><br><span class="line"><span class="comment">//也可以用来提示字符串格式</span></span><br><span class="line"><span class="string">'12'</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>)<span class="comment">//'YYYY-MM-12'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串默认会将其他字符串转移 导致无法嵌入其他语言</p><h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h2><p>充当模板字符串的处理函数（返回一个连反斜线都被转转义的字符串）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property">raw</span><span class="string">`Hi\n<span class="subst">${<span class="number">5</span>+<span class="number">3</span>}</span>`</span>;<span class="comment">///  Hi \\nS !</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property">raw</span> <span class="title class_">Hi</span>\\n ;<span class="comment">// ” Hi \\n” 如果原字符串中的反斜线已经转移 则不会处理</span></span><br></pre></td></tr></tbody></table></figure><h1 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h1><h2 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h2><p><img src="https://s2.loli.net/2022/05/04/KwiHW6oR3PxnXGh.png" alt="image.png"></p><h1 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h1><h3 id="Number-isFinite-判断一个数是不是有限的"><a href="#Number-isFinite-判断一个数是不是有限的" class="headerlink" title="Number.isFinite():判断一个数是不是有限的"></a>Number.isFinite():判断一个数是不是有限的</h3><h4 id="Number-isNaN-判断一个数是不是-NaN"><a href="#Number-isNaN-判断一个数是不是-NaN" class="headerlink" title="Number.isNaN():判断一个数是不是 NaN"></a>Number.isNaN():判断一个数是不是 NaN</h4><p>只对数值有效 对非数值一律返回 f<code>alse</code></p><h2 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h2><p>极小的常量 实质是一个可以接受的误差范围</p><p>可用于为浮点数设置一个误差范围</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withinErrorMargin</span>(<span class="params">left, right</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(left - right) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span>;</span><br><span class="line">}</span><br><span class="line"><span class="title function_">withinErrorMargin</span>(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">withinErrorMargin</span>(<span class="number">0.2</span> + <span class="number">0.2</span>, <span class="number">0.3</span>); <span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Math-对象的新增"><a href="#Math-对象的新增" class="headerlink" title="Math 对象的新增"></a>Math 对象的新增</h2><h3 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h3><p>用于取出一个数的小数部分 返回整数部分（先内部使用 Number 再转为数值 对于空值或者无法截取整数的值 返回 NaN）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">trunc</span> = <span class="title class_">Math</span>.<span class="property">trunc</span> || <span class="function">(<span class="params">x</span>) =&gt;</span> x &lt; <span class="number">0</span>? <span class="title class_">Math</span>.<span class="title function_">ceil</span>(x): <span class="title class_">Math</span>.<span class="title function_">floor</span>(x)</span><br></pre></td></tr></tbody></table></figure><h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h3><p>判断一个数到底是正数负数还是零 先转为数值</p><h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>参数默认值不是传值的 而是每次都重新计算默认表达式的值 也就是默认表达式其实是惰性求值的</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params">p = x + <span class="number">1</span></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">//100</span></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">//101</span></span><br></pre></td></tr></tbody></table></figure><p>函数的<code>length</code>返回没有设置<strong>默认值</strong>的参数个数</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了默认值 函数进行声明式初始化 参会会形成一个单独的作用域 等到初始化结束 这个作用域就会消失 这和不设置参数的默认行为不一样</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params">y = x</span>) =&gt; {</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">};</span><br><span class="line"><span class="title function_">f</span>();<span class="comment">//1 参数y = x形成一个单独的作用域 在这个作用域里面 x还未定义 所以指向外层的全局变量x 函数体内部的局部变量x影响不到默认值变量x 如果全局x不存在 就会报错</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> =(<span class="params">x = x</span>) =&gt; {...};</span><br><span class="line"><span class="title function_">foo</span>();<span class="comment">//ReferenceError : x is not defined x = x会形成一个单独的作用域 实际上就是let x = x 由于暂时性死区 执行这行代码会产生定义错误</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() {x = <span class="number">2</span>}</span>) {<span class="comment">//定义了x</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="title function_">y</span>();<span class="comment">//改变的是参数定义的x</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">//输出var定义的x</span></span><br><span class="line">}</span><br><span class="line"><span class="title function_">foo</span>();<span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);<span class="comment">//1</span></span><br><span class="line">---------------------------</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (x , y = <span class="keyword">function</span> (<span class="params"></span>) { x = <span class="number">2</span> ; } ) {</span><br><span class="line">x = <span class="number">3</span>; <span class="comment">//改变参数的x</span></span><br><span class="line"><span class="title function_">y</span>(); <span class="comment">//改变定义的x</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">}</span><br><span class="line">foo () <span class="comment">// 2</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ol><li>函数体内的<code>this</code>就是定义时所在的对象 而不是使用时所在的对象<ol><li><code>this</code>指向的固定化并不是因为箭头函数内部由绑定 this 的机制 而是因为箭头函数根本没有自己的<code>this</code> 导致内部的<code>this</code>就是外层代码块的<code>this</code></li></ol></li><li>不可以当作构造函数<ol><li>因为它没有<code>this</code> 所以不能用作构造函数</li></ol></li><li>不可以使用<code>arguments</code>对象 可以用<code>rest</code>参数代替</li><li>不可以使用<code>yield</code>命令 因此箭头函数不能也能做<code>Generator</code>函数</li></ol><h3 id="绑定-this"><a href="#绑定-this" class="headerlink" title="绑定 this"></a>绑定 this</h3><p>使用<code>（::）</code>会自动将左边的对象作为上下文环境（即<code>this</code>对象）绑定到右边的函数上</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">foo</span>::bar; <span class="comment">// bar.bind(foo);</span></span><br></pre></td></tr></tbody></table></figure><p><strong>可以链式调用</strong></p><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>函数调用会在内部形成一个<strong>调用记录</strong>（<strong>调用帧</strong>）保存调用位置和内部变量等信息 所有调用帧就形成一个调用栈 尾调用由于是函数的最后一步操作 所以不需要保留外层函数的调用栈 因为调用位置 内部变量等信息都不会再用到 所以直接用内层函数的调用帧取代外层函数的即可。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">g</span>(m + n); <span class="comment">//需要保存m n 和g的调用位置</span></span><br><span class="line">}</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">g</span>(<span class="number">3</span>); <span class="comment">//只保留g3的调用帧</span></span><br><span class="line">}</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="comment">//等同于</span></span><br></pre></td></tr></tbody></table></figure><p>尾调用优化即指保留内层函数的调用帧 如果函数都是尾调用 那么可以做到每次执行时调用帧只有一项 可以大大节省内存</p><blockquote><p>只有不再用到外层函数的内部变量 内层函数的调用帧才可以取代外层函数的调用帧 否则无法进行尾调用优化</p></blockquote><h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span> (n) {</span><br><span class="line"><span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> n * <span class="title function_">factorial</span>(n - <span class="number">1</span>) ;</span><br><span class="line"><span class="title function_">factorial</span>(S) <span class="comment">// 120 容易栈溢出 复杂度On</span></span><br><span class="line"><span class="comment">//用尾调用优化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span> (n , total) {</span><br><span class="line"><span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total ;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span> , n *total);</span><br><span class="line"><span class="title function_">factorial</span>(S, <span class="number">1</span>) <span class="comment">// 120 复杂的O1</span></span><br><span class="line">----------------</span><br><span class="line"><span class="keyword">function</span> <span class="title class_">Fibonacc</span> 工（ {</span><br><span class="line"><span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) {<span class="keyword">return</span> <span class="number">1</span>};</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>) + <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>) ;</span><br><span class="line"><span class="title class_">Fibonacci</span> (lO) <span class="comment">// 89</span></span><br><span class="line"><span class="title class_">Fibonacci</span>(lOO) ／／ 堆裁溢出</span><br><span class="line"><span class="comment">//尾调用优化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fibonacci2</span> (n , acl = <span class="number">1</span> , ac2 = <span class="number">1</span>) {</span><br><span class="line"><span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) {<span class="keyword">return</span> ac2} ;</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Fibonacci2</span> (n - <span class="number">1</span> , ac2, acl + ac2);</span><br><span class="line"><span class="title class_">Fibonacc</span> i2 (<span class="number">100</span>) <span class="comment">// 573147844013817200000</span></span><br><span class="line"><span class="title class_">Fibonacci2</span> (<span class="number">1</span> <span class="number">000</span>) <span class="comment">// 7. 0330367711422765e+208</span></span><br><span class="line"><span class="title class_">Fibonacci2</span>(<span class="number">10000</span>) <span class="comment">//Infinit</span></span><br></pre></td></tr></tbody></table></figure><h3 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h3><ul><li>在尾递归函数之外再提供一个正常形式的函数</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tailFactorial</span>(<span class="params">n, total</span>) {</span><br><span class="line">......</span><br><span class="line">}</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">tailFactorial</span>(n, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 ES6 的函数默认值</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) {</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">}</span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>); <span class="comment">//120</span></span><br></pre></td></tr></tbody></table></figure><p><strong>一旦使用递归 则最好使用尾递归</strong></p><p>ES2017 提议可以在最后一个参数后面加逗号 减少后期更改时的提交信息的冗余</p><h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = []; <span class="comment">//first:undefined ; rest: []</span></span><br></pre></td></tr></tbody></table></figure><p><strong>如果将扩展运算符用于数组赋值 则只能将其作为参数的最后一位</strong></p><p>任何<code>Iterator</code>接口的对象 都可以使用扩展运算符来转为真正的数组</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">var</span> array = [...nodeList];</span><br></pre></td></tr></tbody></table></figure><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>将两类对象转为真正的数组：类似数组的对象（<code>array-like object</code>）和可遍历(<code>iterable</code>)对象</p><p><code>Array.from</code>的第二个参数类似于<code>map</code>方法 将每个元素处理后放入返回的数组</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr)); <span class="comment">//数组去重</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(string).<span class="property">length</span>; <span class="comment">//将字符串转换为数组并返回字符串的长度 避免特殊字符算作两个字符的bug</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>将一组值转换为数组</p><h2 id="copyWithin（）"><a href="#copyWithin（）" class="headerlink" title="copyWithin（）"></a>copyWithin（）</h2><p>在当前数组内部将指定位置的成员复制到其他位置（会覆盖原有裁员） 然后返回数组 即这个方法会修改当前数组</p><p><code>Array.prototype.copyWithin(target, start = 0, end = this.length)</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将3号位复制到0号位</span></span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span>, <span class="number">5</span>) . copyWi thin ( <span class="number">0</span> , <span class="number">3</span> , <span class="number">4</span>) <span class="comment">//[4,2,3,4,5]</span></span><br></pre></td></tr></tbody></table></figure><h2 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find()和 findIndex()"></a>find()和 findIndex()</h2><p>找到符合条件值以及对应的索引</p><h2 id="fill（）"><a href="#fill（）" class="headerlink" title="fill（）"></a>fill（）</h2><p>使用一个定制填充一个数组</p><h2 id="entries（）、keys（）、values（）"><a href="#entries（）、keys（）、values（）" class="headerlink" title="entries（）、keys（）、values（）"></a>entries（）、keys（）、values（）</h2><h2 id="includes（）"><a href="#includes（）" class="headerlink" title="includes（）"></a>includes（）</h2><ul><li><code>Map</code>结构的<code>has</code>方法是用来查找键名的</li><li><code>Set</code>结构的<code>has</code>方法是用来查找值的</li></ul><h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><blockquote><p>空位不是 undefined 一个位置的值等于 undefined 依然是有值的 空位是没有任何值的 in 运算符可以说明这点</p></blockquote><p>ES6 规定将空位转为<code>undefined</code></p><h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>与全等运算符差不多 但是<code>NaN</code>等于<code>NaN +0 ！= -0</code></p><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>将源对象的所有可枚举属性复制到目标对象</p><blockquote><p>如果目标对象和源对象有同名属性或者多个源有同名属性 则后面的属性会覆盖前面的属性</p></blockquote><p>如果只有一个参数 则<code>Object.assign</code>直接返回参数 如果该参数不是对象 则先转成<strong>对象</strong>再返回 如果是<code>null</code>或者 undefined 则报错</p><p>源对象（非首参数）位置的参数会先转成对象 不能则跳过 粗了字符串会以数组的形式复制到目标对象 其他值不会产生效果</p><p><strong><code>Object.assign</code>复制的属性是有限的 只复制源对象的自身属性（不复制继承属性） 也不复制不可枚举的属性</strong></p><p><strong><code>Object.assign</code>是浅复制 不是深复制</strong></p><p>对于嵌套的对象 一旦遇到同名属性 <code>Object.assign</code>的处理方法是<strong>替换</strong>而不是添加</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = { <span class="attr">a</span>: { <span class="attr">b</span>: <span class="string">"c"</span>, <span class="attr">d</span>: <span class="string">"e"</span> } };</span><br><span class="line"><span class="keyword">var</span> source = { <span class="attr">a</span>: { <span class="attr">b</span>: <span class="string">"hello"</span> } };</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source); <span class="comment">//{a: {b: 'hello'}}</span></span><br></pre></td></tr></tbody></table></figure><p>Object.assign 可以用来处理数组 但是会把数组当作对象来处理</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>为对象添加属性</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">x, y</span>) {</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, {x, y) );</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>为对象添加方法</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span> . assign (<span class="title class_">SomeClass</span> . prototype , {</span><br><span class="line">someMethod (argl , arg2) {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>克隆对象</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>({} , origin);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将原始对象赋值到一个新的对象 只能克隆自身的值 不能克隆继承的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) {</span><br><span class="line"><span class="keyword">let</span> originProto = <span class="title class_">Object</span> . getPrototypeOf（ ori gin );</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Object</span> . <span class="title function_">create</span>(originProto) , origin );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>合并多个对象</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> = (<span class="params">target, ...source</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...source)</span><br><span class="line"><span class="comment">//如果希望合并后返回一个新对象 可以对一个空对象合并</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> = (<span class="params">...source</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>({}, ...source);</span><br><span class="line"><span class="keyword">const</span> data1 = {<span class="attr">name</span>: <span class="string">'james'</span>};</span><br><span class="line"><span class="keyword">const</span> data2 = <span class="title function_">merge</span>(data1);</span><br><span class="line">data2.<span class="property">name</span> = <span class="string">'curry'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data1.<span class="property">name</span>):<span class="comment">//'james';//深复制</span></span><br></pre></td></tr></tbody></table></figure><ul><li>为属性指定默认值</li></ul><blockquote><p>由于存在深复制的问题 DEFAULTS 对象和 options 对象的所有属性都只能是简单类型 而不能指向另一个对象 否则将导致 DEFAULTS 对象该属性不起作用</p></blockquote><h2 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h2><ul><li><p><code>for...in</code></p><ul><li>遍历对象自身和继承的可枚举属性（不含<code>Symbol</code>属性）</li></ul></li><li><p><code>Object.keys(obj)</code></p><ul><li>返回一个包含自身（不包含<code>Symbo</code>l 以及继承）的可枚举属性</li></ul></li><li><p><code>Object.getOwnPropertyNames(obj)</code></p><ul><li>包含自身（不包含<code>Symbol</code>但是包含不可枚举属性）的数组</li></ul></li><li><p><code>Object.getOwnPropertySymbols(obj)</code></p><ul><li>包含自身的所有<code>Symbol</code>属性</li></ul></li><li><p><code>Reflect.ownKeys(obj)</code></p><ul><li>包含自身的所有属性</li></ul></li></ul><p>遍历规则</p><ul><li>首先遍历所有属性名为数值的属性 按照数字排序</li><li>其次遍历所有属性名为字符串的属性 按照生成时间遍历</li><li>最后遍历所有属性名为<code>Symbo</code>l 的属性 按照生成时间排序</li></ul><h2 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h2><p>设置一个对象的<code>prototype</code>对象 返回参数本身</p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p>读取一个对象的<code>prototype</code>对象</p><p>如果参数不是对象 则自动转换为对象 如果是<code>undefined</code>或<code>null</code> 则直接报错</p><h2 id="Objecr-keys-Object-values-Object-entries"><a href="#Objecr-keys-Object-values-Object-entries" class="headerlink" title="Objecr.keys() Object.values() Object.entries()"></a>Objecr.keys() Object.values() Object.entries()</h2><ul><li><p>O<code>bject.keys()</code>:包含自身（不包含继承）的所有可遍历属性</p></li><li><p><code>Object.values()</code>:如果参数不是对象 则会先将其转为对象 对于数值或者布尔值则返回空数组</p></li><li><p><code>Object.entries()</code>:输出非<code>Symbol</code>值的属性</p><ul><li>‘可以将对象转为真正的<code>Map</code>结构</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = { <span class="attr">foo</span>: <span class="string">"bar"</span>, <span class="attr">baz</span>: <span class="number">40</span> };</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br><span class="line">map; <span class="comment">//{foo: 'bar', baz: 40}</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h2><blockquote><p>解构赋值的复制是浅复制 即如果一个键的值是复合类型的值（数组、对象、函数） 那么解构赋值复制的是这个值的引用 而不是这个值的副本</p></blockquote><p>解构赋值不会复制继承自原型对象的属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//克隆完整对象</span></span><br><span class="line"><span class="keyword">const</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj)), obj);</span><br><span class="line"><span class="comment">//修改现有对象</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>Object.assign</code>总是复制一个属性的值 而不会复制它背后的赋值方法或取值方法</p></blockquote><p><code>Object.getOwnPropertyDescriptions</code>配合<code>Object.defineProperties</code>可以实现正确复制</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = {</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">value</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> target2 = {};</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(target2, <span class="title class_">Objecxt</span>.<span class="title function_">getOwnPropertyDescriptions</span>(source));</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptiontor</span>(target2, <span class="string">"fpp"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="Null-传到运算符（？"><a href="#Null-传到运算符（？" class="headerlink" title="Null 传到运算符（？.)"></a>Null 传到运算符（<code>？.</code>)</h2><p>相当于判空操作</p><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><blockquote><p><code>Symbol</code>函数不能使用 new 命令 否则会报错 因为<code>Symbol</code>是一个原始类型的值 不是对象 所以不能添加属性 是一种类似于字符串的数据类型</p><p><code>Symbol</code>函数的参数只表示对当前<code>Symbol</code>值的描述 因此相同参数的<code>Symbol</code>函数的返回值是不相等的</p></blockquote><p><code>Symbol</code>值不能与其他值进行比较 否则会报错 <code>Symbol</code>值可以转为字符串或者布尔值 但是不能转为数值</p><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><p><code>Symbol</code>值可以作为标识符用于对象的属性名 复制某一个键不小心被重写或者覆盖</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> data = {</span><br><span class="line">  [mySymbol]: <span class="string">"james"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="comment">//Symbol作为对象属性名时不能使用点运算符 因为点运算符后面总是字符串 所以不会读取mySymbol作为标识名所指代的值 导致a的属性名实际上时一个字符串 而不是一个Symbol值</span></span><br><span class="line">data.<span class="property">mySymbol</span>; <span class="comment">//undefined</span></span><br><span class="line">data[mySymbol]; <span class="comment">//james</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>Symbol</code>值作为属性名时 该属性还是<strong>公开</strong>属性 不是<strong>私有</strong>属性</p></blockquote><p>常量使用 Symbol 值的最大好处就是其他任何值不可能有相同的值了 因此可以保证 switch 语句按设计的方式工作</p><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><h3 id="消除魔法字符串"><a href="#消除魔法字符串" class="headerlink" title="消除魔法字符串"></a>消除魔法字符串</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = {</span><br><span class="line">  <span class="attr">triangle</span>: <span class="title class_">Symbol</span>(),</span><br><span class="line">};</span><br><span class="line"><span class="comment">//将多次出现的和代码耦合度高的字符串设置成Symbol降低耦合度</span></span><br></pre></td></tr></tbody></table></figure><h3 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h3><p><code>Symbol</code>作为属性名 不会被<code>for...in for...of</code> 以及<code>Object.keys() Object.getOwnPropertyNames()</code>返回 但是<strong>不是私有属性</strong> 可以使用<code>Object.getOwnPropertySymbols</code>获取对象的所有<code>Symbol</code>属性名</p><p><code>Reflect.owbKeys()</code>可以返回所有的类型的键名 包括常规键名和 Symbol 键名</p><blockquote><p>以<code>Symbol</code>值作为名称的属性不会被常规方法遍历得到 可以用这个特性为对象定义一些非私有但又希望只用于内部的方法</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> size = <span class="title class_">Symbol</span>(<span class="string">"size"</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">this</span>[size] = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">item</span>) {</span><br><span class="line">    <span class="variable language_">this</span>[<span class="variable language_">this</span>[size]] = item;</span><br><span class="line">    <span class="variable language_">this</span>[size]++;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sizeOf</span>(<span class="params">instance</span>) {</span><br><span class="line">    <span class="keyword">return</span> instance[size];</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Collection</span>();</span><br><span class="line"><span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x); <span class="comment">//0</span></span><br><span class="line">x.<span class="title function_">add</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x); <span class="comment">//1</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(x); <span class="comment">//['0']</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(x); <span class="comment">//['0']</span></span><br><span class="line"><span class="comment">//size属性是一个Symbol值 所以Objct.keys(x)都无法获取它 这就造成了一种非私有的内部方法的效果</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Symbol-for-Symbol-keyFor"><a href="#Symbol-for-Symbol-keyFor" class="headerlink" title="Symbol.for() Symbol.keyFor()"></a>Symbol.for() Symbol.keyFor()</h2><p>接收一个字符串作为参数 然后搜索有没有以该参数作为名称的<code>Symbol</code> 有就返回这个<code>Symbol</code>值 没有就新建一个以该字符串为名称的<code>Symbol</code>值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">"foo"</span>);</span><br><span class="line">s1 === s2; <span class="comment">//true</span></span><br><span class="line"><span class="comment">//Symbol.for()与Symbol（）这两种方法都会生成新的Symbol 前者会被登记在全局环境中供搜索 后者不会</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s1); <span class="comment">//foo</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="title class_">Symobl</span>.<span class="title function_">keyFor</span>(s2); <span class="comment">//undefined</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>Symbol.for</code>为<code>Symbol</code>值登记的名字是全局环境的 可以在不同的<code>iframe</code>或<code>service worker</code>中取到同一个值</p></blockquote><h3 id="模块的-Singleton-模式"><a href="#模块的-Singleton-模式" class="headerlink" title="模块的 Singleton 模式"></a>模块的 Singleton 模式</h3><p>Singleton 模式指的是 调用一个类并且在任何时候都返回同一个实例</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mod.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FOO_KEY</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">"hello"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>]) {</span><br><span class="line">  <span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>] = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">}</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>];</span><br><span class="line"><span class="comment">//可以保证globl[FOO_KEY]不会被无意间覆盖 但是还可以被改写</span></span><br></pre></td></tr></tbody></table></figure><h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><ul><li><code>Symbol.hasInstance</code></li></ul><p>使用<code>instanceof</code>运算符时会调用这个方法 判断该对象是否为某个构造函数的实例</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo <span class="keyword">instanceof</span> <span class="title class_">Foo</span> 实际上调用了<span class="title class_">Foo</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](foo)</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Symbol.isConcatSpreadable</code></li><li><code>Symbol.species</code></li><li><code>Symbol.match</code></li><li><code>Symbol.replace</code></li><li><code>Symbol.search</code></li><li><code>Symbol.split</code></li><li><code>Symbol.iterator</code></li><li><code>Symbol.toPrimitive</code></li><li><code>Symbol.toStringTag</code></li><li><code>Symbol.unscopables</code></li></ul><h1 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>Set</code>：一组不会重复的数组</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]; <span class="comment">//数组去重</span></span><br></pre></td></tr></tbody></table></figure><p>向<code>Set</code>加入值时不会发生类型转换 <code>Set</code>内部判断两个值是否相等时使用的算法类似于精确运算符 但是<code>NaN</code>等于自身 （<strong>两个对象总是不相等的</strong>）</p><blockquote><p><code>Set</code>的<strong>遍历顺序就是插入顺序</strong> 这个特性非常有用 比如使用<code>Set</code>保存一个回调函数列表 调用时能保证按照添加顺序调用</p></blockquote><h3 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h3><p>扩展运算符<code>(...)</code>内部使用<code>for...of</code>循环 也可以使用<code>Set</code>结构</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">"red"</span>, <span class="string">"blue"</span>]);</span><br><span class="line"><span class="keyword">let</span> arr = [...set];</span><br><span class="line"><span class="comment">//扩展运算符和Set结构相结合就能去除数组的重复裁员</span></span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"><span class="comment">//数组的map和fillter方法也可以用于Set</span></span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">fillter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line"><span class="comment">//所以set很用以实现并集、焦急和差集</span></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">fillter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="keyword">let</span> defference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">fillter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> !b.<span class="title function_">has</span>(x)));</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无法直接在遍历操作中同步改变Set结构 一种是利用原Set映射出一个新的结构 然后赋值给原来的Set结构 另一种是利用Array.from方法</span></span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(set, <span class="function">(<span class="params">val</span>) =&gt;</span> val * <span class="number">2</span>));</span><br></pre></td></tr></tbody></table></figure><h3 id="WaekSet"><a href="#WaekSet" class="headerlink" title="WaekSet"></a>WaekSet</h3><ul><li><code>WeakSet</code>的成员只能是对象 而不能是其他类型的值</li><li><code>WeakSet</code>中的对象都是弱引用 即垃圾回收机制不考虑<code>WeakSet</code>对该对象的引用（如果其他对象不再引用该对象 那么垃圾回收机制就会自动回收该对象所占用的内存 不考虑是否还存在于<code>WeakSet</code>中）</li><li><code>WeakSet</code>不能<strong>遍历</strong> 因为成员都是弱引用 随时可能消失 遍历机制无法保证成员存在 很可能刚刚遍历结束 成员就获取不到了</li></ul><blockquote><p><code>WeakSet</code>的一个用处是储存 DOM 节点 而不用担心这些节点从文档移除时会语法内存泄漏</p></blockquote><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><code>Map</code>的键可以是任何数据类型</li><li><code>Map</code>的键实际上适合内存绑定的 只要内存不一样 就视为两个键 这就解决了同名属性的问题 我们扩展别人的库是 如果使用对象作为键名 不 i 用担心自己的属性和原作者的属性同名</li></ul><blockquote><p>只有对<strong>同一对象的引用</strong> <code>Map</code>结构才将其视为同一个键</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>([<span class="string">"a"</span>], <span class="number">555</span>);</span><br><span class="line">map.<span class="title function_">get</span>([<span class="string">"a"</span>]); <span class="comment">//undefined</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果Map的键是一个简单类型的值（数字、字符串、布尔值） 只要两个值严格相等 Map就将其视为一个键 将NaN视为一个键</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="title class_">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="title class_">NaN</span>); <span class="comment">//123</span></span><br></pre></td></tr></tbody></table></figure><p><strong><code>Map</code>的遍历顺序就是插入顺序</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map转为JSON</span></span><br><span class="line"><span class="comment">//键名都是字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToJson</span>(<span class="params">strMap</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">strMapToJson</span>(strMap));</span><br><span class="line">}</span><br><span class="line"><span class="comment">//Map键名有非字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapToArrayJson</span>(<span class="params">map</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...map]);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//JSON转为Map</span></span><br><span class="line"><span class="comment">//正常情况下 所有键名都是字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToStrMap</span>(<span class="params">jsonStr</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">objToStrMap</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">}</span><br><span class="line"><span class="comment">//JSON就是一个数组 且每个成员本身又是一个具有两个成员的数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToMap</span>(<span class="params">jsonStr</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>如果想要往对象中添加数据又不想干扰垃圾回收机制 便可以使用<code>WeakMap</code> 比如在网页的<code>DOM</code>元素上添加数据时就可以用<code>WeakMap</code>结构 当该<code>DOM</code>元素被清除时 其对应的<code>WeakMap</code>记录就会自动清除</p><blockquote><p><code>WeakMap</code>弱引用的只是键名而不是键值 键值依然是正常引用的</p></blockquote><p>将监听函数反正该<code>WeakMap</code>里面 一旦<code>DOM</code>对象消失 与它绑定的函数也会自动消失</p><p><code>WeakMap</code>也可以用来部署私有属性</p><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><blockquote><p>要使<code>Proxy</code>起作用 必须针对<code>Proxy</code>实例进行操作 而不是针对目标对象进行操作</p></blockquote><p><code>Proxy</code>实例也可以作为其他对象的原型对象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">  {},</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, property</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line">);</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line">obj.<span class="property">time</span>; <span class="comment">//35</span></span><br><span class="line"><span class="comment">//proxy对象是obj对象的原型 obj对象本身没有time属性 所以根据原型链会在proxy对象上读取该属性 导致被拦截</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>get(target, propKey, receiver):</code>拦截对象属性的读取</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get方法可以继承</span></span><br><span class="line"><span class="keyword">let</span> proto = <span class="keyword">new</span> <span class="title class_">Proxy</span> ( { } , {</span><br><span class="line"><span class="title function_">get</span>(<span class="params">target, propertyKey , receiver</span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span> ( ’ <span class="variable constant_">GET</span> ’+propertyKey);</span><br><span class="line"><span class="keyword">return</span> target[propertyKey] ;</span><br><span class="line">.</span><br><span class="line">, } )</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto) ;</span><br><span class="line">obj.<span class="property">xxx</span> <span class="variable constant_">II</span> ” <span class="variable constant_">GET</span> xxx ”</span><br><span class="line"><span class="comment">//拦截操作定义在Propertype对象上 所以如果读取obj对象继承的属性 拦截会生效</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>set(target, propKey, value, receiver</code>):拦截的对象属性的设置</li></ul><p>如果一个属性不可配置或不可写 则该属性不能被代理 通过<code>Proxy</code>对象访问该属性将会报错</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有时候 我们会在对象上设置内部属性 属性名的第一个字符使用下划线开头 表示这些属性不应该被外部使用 结合get和set方法可以防止这些内部属性被外部读/写</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">invariant</span> = (<span class="params">key, action</span>) =&gt; {</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">"_"</span>) {</span><br><span class="line">    <span class="comment">//读取属性的第一个字符判断是否为内部属性</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">${action}</span>的属性<span class="subst">${key}</span>是内部的`</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) {</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">"get"</span>);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) {</span><br><span class="line">    <span class="title function_">invariant</span>(prop, <span class="string">"set"</span>);</span><br><span class="line">    target[prop] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果目标对象自身的某个属性不可写也不可配置 那么 set 不得改变这个属性的值 只能返回同样的值 否则报错</p></blockquote><ul><li><code>has(target, propKey):</code>拦截<code>propKey in proxy</code>的操作</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用has方法隐藏了某些属性 使其不被in运算符发现</span></span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"><span class="title function_">has</span>(<span class="params">target, key</span>) {</span><br><span class="line"><span class="keyword">if</span>(key[<span class="number">0</span>] === <span class="string">'_'</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> key <span class="keyword">in</span> target</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> target = { prop : ’ foo ’, prop :’foo ’ };</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target , handler);</span><br><span class="line">’ _prop ’ <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p>如果原对象不可配置或禁止扩展 那么<code>has</code>拦截会报错</p><blockquote><p><code>has</code> 方法拦截的是 <code>Has Property</code> 操作，而不是 <code>HasOwnProperty</code> 操作，即 <code>has</code> 方法 不判断一个属性是对象自身的属性还是继承的属性 对<code>for...in</code>不生效</p></blockquote><ul><li><code>deleteProperty(target, propKey)</code>:拦截<code>delete proxy[propKey</code>]的操作</li><li><code>ownKeys(target)</code>:拦截<code>Object.getOwnPropertyNames(proxy) Object.getOwnPropertySymbols(proxy) Object.keys(proxy)</code> 返回一个数组 该方法返回目标对象自身属性的属性名 而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性</li><li><code>getOwnPropertyDescriptor(target, propKey)</code>:拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code></li><li><code>defineProperty(target, propKey, propDesc):</code>拦截 <code>Object defineProperty(proxy propKey,</code> <code>propDesc 〕、 Object define Properties(proxy, propDescs)</code></li><li><code>preventExtensions(target):</code>拦截 <code>Object preventExtensions proxy</code></li><li><code>getPrototypeOf(target)</code></li><li><code>isExtensible(target)</code></li><li><code>setPrototypeOf(target, proto)</code> :拦截 <code>Object setPrototypeOf proxy proto ）</code>， 返回一个布尔值。 果目标对象是 函数 那么还有两 操作可以拦截。</li><li><code>apply(target, object, args)</code></li></ul><p><code>apply</code>方法拦截函数的调用<code>/call/apply</code>操作(直接调用<code>Reflect.apply</code>方法也会被拦截)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个参数 目标对象 目标对象的上下文对象 目标对象的参数数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">target</span> = (<span class="params"></span>) =&gt; {</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"i am the target"</span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"i am the proxy"</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="title function_">p</span>(); <span class="comment">// i am the proxy</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>construct( target, args)</code>:拦截 <code>Proxy</code> 实例作为构造函数调用的操作 ，比 <code>ηew proxy ( . . . arg)</code></li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target：目标对象 args：构建函数的参数对象</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params"></span>) {}, {</span><br><span class="line">    <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'call'</span> + args.<span class="title function_">join</span>(<span class="string">','</span>));</span><br><span class="line">        <span class="keyword">return</span> {<span class="attr">value</span>: args[<span class="number">0</span>]*<span class="number">10</span>}</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line">(<span class="keyword">new</span> <span class="title function_">p</span>(<span class="number">1</span>)).<span class="property">value</span>;<span class="comment">//10</span></span><br><span class="line"><span class="comment">//construct方法返回的必须是一个对象 否则会报错</span></span><br></pre></td></tr></tbody></table></figure><h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>在<code>Proxy</code>代理的情况下 目标对象内部的<code>this</code>关键字会指向<code>Proxy</code>代理</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === proxy);</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">target.<span class="title function_">m</span>(); <span class="comment">//false</span></span><br><span class="line">proxy.<span class="title function_">m</span>(); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//target内部的this也指向proxy 而不是target</span></span><br></pre></td></tr></tbody></table></figure><p>有些元素对象的内部属性只有通过正确的<code>this</code>才能获取 所以<code>Proxy</code>也无法代理这些原生对象的属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="title function_">getDate</span>();<span class="comment">//TypeError: this is not a Data object</span></span><br><span class="line"><span class="comment">//这个时候绑定bind就能解决问题</span></span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span> (’ <span class="number">2015</span>-<span class="number">01</span>-<span class="number">0</span> <span class="number">1</span> ’) ;</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"><span class="title function_">get</span>(<span class="params">target, prop</span>) {</span><br><span class="line"><span class="keyword">if</span> (p rop === ’ get <span class="title class_">Date</span> ’) {</span><br><span class="line"><span class="keyword">return</span> target . getDate .<span class="title function_">bind</span>(target) ;</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Reflect</span> . <span class="title function_">get</span>(target, prop);</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="title function_">getDate</span>()<span class="comment">//1</span></span><br></pre></td></tr></tbody></table></figure><h3 id="实例：web-服务的客户端"><a href="#实例：web-服务的客户端" class="headerlink" title="实例：web 服务的客户端"></a>实例：web 服务的客户端</h3><p><code>Proxy</code>对象可以拦截目标对象的任意属性 所以它很适合编写 Web 服务的客户端</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> service = createWebSer rice (’ <span class="attr">http</span>:<span class="comment">//example . com/data ’);</span></span><br><span class="line">service . <span class="title function_">employees</span>() . <span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> {</span><br><span class="line"><span class="keyword">const</span> employees= <span class="title class_">JSON</span> . <span class="title function_">parse</span>(json) ;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">}) ;</span><br><span class="line"><span class="comment">//proxy可以拦截这个对象的任意属性 所以不用为每一种数据写一个适配方法 只要写一个proxy拦截即可</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWebService</span>(<span class="params">baseurl</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>({}, {</span><br><span class="line"><span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">httpGet</span>(baseUrl + <span class="string">'/'</span> + propKey)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Proxy</code>还可以用来实现数据库的<strong>ORM</strong>层</p><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><ul><li>将<code>Object</code>对象的一些明显属于语言内部的方法（<code>Object.defineProperty</code>）放到<code>Reflect</code>对象上</li><li>修改某些<code>Object</code>方法的返回结果 让其变得合理</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧写法</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, property, attributes);</span><br><span class="line">} <span class="keyword">catch</span> (e) {</span><br><span class="line">  <span class="comment">//failure</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, property, attributes)) {</span><br><span class="line">  <span class="comment">//success</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">//failure</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>让<code>object</code>操作编程函数行为</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧写法</span></span><br><span class="line"><span class="string">"assign"</span> <span class="keyword">in</span> <span class="title class_">Object</span>; <span class="comment">//true</span></span><br><span class="line"><span class="comment">//新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(<span class="title class_">Object</span>, <span class="string">"assign"</span>); <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就 能在 <code>Reflect</code> 对象上找到对应的方法。这就使 <code>Proxy</code> 对象可以方便地调用对应的 <code>Reflect</code> 方法来完成默认行为，作为修改行为的基础。也就是说，无论 <code>Proxy</code> 怎么修改默认行为，我们 总可以在 <code>Reflect</code> 上获取默认行为。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Proxy</span>(target, {</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, name, value, receiver</span>) {</span><br><span class="line">    <span class="keyword">const</span> success = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, name, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (success) {</span><br><span class="line">      <span class="comment">//;;;;;;;</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="comment">//Proxy拦截了target对象的属性赋值方法 他采用Reflect.set方法将之际赋给对象的属性 保证原有的行为 然后再部署额外的功能</span></span><br><span class="line"><span class="keyword">var</span> loggedobj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, name</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"get"</span>, target, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, name);</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, name</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"delete"</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, name);</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, name</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"has"</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, name);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="comment">//每个proxy对象的拦截操作都内部调用了Reflect对应的方法 保证原生行为能够正常运行 添加的工作就是将每一个操作输出一行日志</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.lxtlovely.top/XUXI/image-20220505222048711.png" alt="image-20220505222048711"></p><h2 id="使用-Proxy-实现观察者模式"><a href="#使用-Proxy-实现观察者模式" class="headerlink" title="使用 Proxy 实现观察者模式"></a>使用 Proxy 实现观察者模式</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="title class_">Set</span>(); <span class="comment">//观察者函数容器</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">set</span> = (<span class="params">target, key, value, receiver</span>) =&gt; {</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver); <span class="comment">//执行正常set操作</span></span><br><span class="line">  queuedObservers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> <span class="title function_">observer</span>()); <span class="comment">//执行观察者容器里所有观察者</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observe</span> = (<span class="params">fn</span>) =&gt; queuedObservers.<span class="title function_">add</span>(fn); <span class="comment">//加入观察者容器</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observable</span> = (<span class="params">obj</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, { set }); <span class="comment">//设置拦截器</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="title function_">observable</span>({</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">print</span> = (<span class="params"></span>) =&gt; {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"dsqdqdqdsqd"</span>);</span><br><span class="line">};</span><br><span class="line"><span class="title function_">observe</span>(print);</span><br><span class="line">person.<span class="property">name</span> = <span class="string">"curry"</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul><li>对象的状态不受外界影响</li><li>一旦状态改变就不会再变 任何时候都可以得到这个结果</li><li>无法取消<code>Promise</code> 一旦新建就会立即执行 无法中途取消</li><li>如果不设置回调函数 <code>Promise</code>内部抛出的错误不会反映到外部</li><li>处于<code>Pendding</code>状态时 无法得知目前进展到哪一阶段</li><li>如果某些事件不断重复发生 使用<code>Stream</code>模式更好</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise新建后会立即执行</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Promise"</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">});</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Resolved"</span>);</span><br><span class="line">});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"HI"</span>); <span class="comment">//Promise HI Resolved</span></span><br><span class="line"><span class="comment">//Promise新建后立即执行 然后then指定的回调函数会在当前脚本所有同步任务执行完成后才执行 所以resolved最后输出</span></span><br></pre></td></tr></tbody></table></figure><p>调用<code>resolve</code>或<code>reject</code>并不会终结<code>Promise</code>的参数函数的执行</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">}).<span class="title function_">then</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(r)); <span class="comment">//2 --&gt; 1</span></span><br><span class="line"><span class="comment">//立即resolved的Promise是在本轮事件循环的末尾执行 总是晚于本轮循环的同步任务 一般应该再resolve和reject前面加上return 防止后续还有操作</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve , reject</span>) {</span><br><span class="line">resolve (’ ok ’) ;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span> ( ’ test ’);</span><br><span class="line">.</span><br><span class="line">, } )</span><br><span class="line">promise</span><br><span class="line">.<span class="property">then</span> (<span class="keyword">function</span>(<span class="params">value</span>) { <span class="variable language_">console</span>.<span class="title function_">log</span>(value) })</span><br><span class="line">. <span class="keyword">catch</span> (<span class="keyword">function</span> (<span class="params">error</span>) { <span class="variable language_">console</span> . log (error) } ) ;</span><br><span class="line"><span class="number">11</span> ok</span><br><span class="line"><span class="comment">//Promise再resolve语句后面再抛出错误 并不会被捕获 等于没有抛出 因为Promise的状态一旦改变 就会永久保持该状态 不会再改变了</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>Promise</code>对象的错误具有<strong>冒泡</strong>性质 会一直向后传递知道被捕获为止 即错误总会被下一个<code>catch</code>捕获</p><p>不要再 then 中定义<code>reject</code>状态的回调函数 而应该总是使用<code>catch</code>方法</p><p><strong>如果没有指定 catch 方法指定错误处理的回调函数 Promise 对象抛出的错误不会被传递到外层代码 即不会有任何反应</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学JS第二天</title>
      <link href="/2022/04/25/chong-xue-js-di-er-tian/"/>
      <url>/2022/04/25/chong-xue-js-di-er-tian/</url>
      
        <content type="html"><![CDATA[<h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p><code>Object.assign()</code>接收一个目标对象和一个或多个元对象作为参数 然后将每个原对象中可枚举（<code>Object.propertyIsEnumerable()</code>返回 true）和自有（<code>Object.hasOwnProperty()</code>返回 true）属性复制到目标对象以字符串和符号为键的属性 会被复制。对每个符合条件的属性，这个方法会使用源对象上的<code>[[Get]]</code>取得属性的值，然后使用目标 对象上的<code>[[Set]]</code>设置属性的值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = { <span class="attr">id</span>: <span class="string">"src"</span> };</span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// Object.assign 修改目标对象</span></span><br><span class="line"><span class="comment">// 也会返回修改后的目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest === result); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest !== src); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// { id: src }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { id: src }</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dest = {</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">val</span>) {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Invoked dest setter with param <span class="subst">${val}</span>`</span>);</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">src = {</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">a</span>() {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Invoked src getter'</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 调用 src 的获取方法</span></span><br><span class="line"><span class="comment">// 调用 dest 的设置方法并传入参数"foo"</span></span><br><span class="line"><span class="comment">// 因为这里的设置函数不执行赋值操作</span></span><br><span class="line"><span class="comment">// 所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// Invoked src getter"</span></span><br><span class="line"><span class="string">"Invoked dest setter with param foo"</span> {}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = { <span class="attr">a</span>: {} };</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { a :{} }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest.<span class="property">a</span> === src.<span class="property">a</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest == src)<span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>assign()</code>是浅复制 意味着只会复制对象的引用</p></blockquote><p>如果赋值期间出错 操作会中止并退出 同时抛出错误 因此可能只完成部分复制</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = {</span><br><span class="line">  <span class="attr">a</span>: <span class="string">"foo"</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">b</span>() {</span><br><span class="line">    <span class="comment">// Object.assign()在调用这个获取函数时会抛出错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">c</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line">} <span class="keyword">catch</span> (e) {}</span><br><span class="line"><span class="comment">// Object.assign()没办法回滚已经完成的修改</span></span><br><span class="line"><span class="comment">// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { a: foo }</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>可计算属性表达式中抛出任何错误都会中断对象创建 如果计算属性的表达式有副作用就要小心 因为如果表达式抛出错误 那么之前完成的计算是不能回滚的</p></blockquote><p>解构并不要求变量必须在解构表达式中说明 不过 如果是事先声明的变量 则赋值表达式必须包含在一对括号中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personName, personAge;</span><br><span class="line"><span class="keyword">let</span> person = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"Matt"</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line">};</span><br><span class="line">({ <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge } = person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName, personAge); <span class="comment">// Matt, 27</span></span><br><span class="line"><span class="comment">//vue的写法</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>({</span><br><span class="line">  <span class="attr">name</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">0</span>,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> response = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"olddog"</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">}(({ <span class="attr">name</span>: data.<span class="property">name</span>, <span class="attr">age</span>: data.<span class="property">age</span> } = response)); <span class="comment">//data:{name: 'olddog', age: 23}</span></span><br></pre></td></tr></tbody></table></figure><h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><p>可以通过解构来复制对象属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = {</span><br><span class="line"> <span class="attr">name</span>: <span class="string">'Matt'</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line"> <span class="attr">job</span>: {</span><br><span class="line"> <span class="attr">title</span>: <span class="string">'Software engineer'</span></span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> personCopy = {};</span><br><span class="line">({</span><br><span class="line"> <span class="attr">name</span>: personCopy.<span class="property">name</span>,</span><br><span class="line"> <span class="attr">age</span>: personCopy.<span class="property">age</span>,</span><br><span class="line"> <span class="attr">job</span>: personCopy.<span class="property">job</span></span><br><span class="line">} = person);</span><br><span class="line"><span class="comment">// 因为一个对象的引用被赋值给 personCopy，所以修改</span></span><br><span class="line"><span class="comment">// person.job 对象的属性也会影响 personCopy</span></span><br><span class="line">person.<span class="property">job</span>.<span class="property">title</span> = <span class="string">'Hacker'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line"><span class="comment">// { name: 'Matt', age: 27, job: { title: 'Hacker' } }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personCopy);</span><br><span class="line"><span class="comment">// { name: 'Matt', age: 27, job: { title: 'Hacker' } }</span></span><br><span class="line">--------------------------------</span><br><span class="line">vue的写法</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>({</span><br><span class="line"><span class="attr">name</span>: <span class="string">''</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">address</span>:{</span><br><span class="line">  <span class="attr">home</span>:<span class="string">""</span></span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"><span class="keyword">const</span> response = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'olddogewqeeqwweq'</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="attr">address</span>:{</span><br><span class="line">    <span class="attr">home</span>: <span class="string">'huilaieqw1341343'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  ({<span class="attr">name</span>: data.<span class="property">name</span>, <span class="attr">age</span>: data.<span class="property">age</span>, <span class="attr">address</span>:{<span class="attr">home</span>: data.<span class="property">address</span>.<span class="property">home</span>}} = response)<span class="comment">//data:{name: 'olddog', age: 23}</span></span><br><span class="line">  response.<span class="property">name</span> = <span class="string">"wdqdw"</span></span><br><span class="line">  response.<span class="property">address</span>.<span class="property">home</span> = <span class="string">'2132'</span></span><br><span class="line">  data.<span class="property">address</span>.<span class="property">home</span> = <span class="string">'qdewqdeqsw'</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="comment">//改变response不会影响data</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><blockquote><p>涉及到多个属性的解构赋值是一个无关输出的顺序化操作 如果一个解构表达式涉及多个赋值 如果开始的赋值成功而后面的赋值出错 则整个赋值表达式只会完成一部分</p></blockquote><p><strong>Object.setPrototypeof()可能会严重影响代码性能</strong></p><p><code>hasOwnProprtty()</code>用于确定某个属性是实例上还是原型对象上（实例上返回<code>true</code>）</p><h5 id="原型和-in-操作符"><a href="#原型和-in-操作符" class="headerlink" title="原型和 in 操作符"></a>原型和 in 操作符</h5><p>单独使用<code>in</code>只要可以访问到对象指定属性时返回<code>true</code> 无论是在实例上还是在原型上</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以同时使用hasOwnProperty()和in()操作符来确定某个属性是否存在于原型上</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasPrototypePrototy</span>(<span class="params">object, name</span>) {</span><br><span class="line">  <span class="keyword">return</span> !object.<span class="title function_">hasOwnProprtty</span>(name) &amp;&amp; name <span class="keyword">in</span> object;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) {}</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">"Software Engineer"</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(person, <span class="string">"name"</span>)); <span class="comment">// true --对象在原型上</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">"Greg"</span>; <span class="comment">//重写name属性后 实例上也有这个属性了 即使原型上还有name属性 但是会被实例上的属性遮蔽 所以不会被用到</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(person, <span class="string">"name"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p><code>for-in</code>只要能通过对象访问到并且可以被枚举的属性都会返回 包括实例属性和原型属性（遮蔽原型中不可枚举的实例属性也会被返回 因为默认情况下开发者定义的属性都是可枚举的）</p><p>如果要获得对象上的所有可枚举实例属性 可以使用<code>Object.keys()</code> (返回包含该对象所有可枚举属性名称的字符串数组)</p><blockquote><p><code>Object.keys()</code> 和 <code>Object.getOwnPropertyNames()</code> 在适当的时候都可以用来代替<code>for- in</code> 循环</p></blockquote><h5 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h5><p><code>for-in、Object.keys()</code>的枚举顺序是不确定的 <code>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign()</code> 的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中 定义的键以它们逗号分隔的顺序插入。</p><h4 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h4><p><code>Object.values()</code>返回对象值的数组 <code>Object.entries()</code>返回键值对的数组</p><blockquote><p>这两个方法执行对象浅复制</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"james"</span>,</span><br><span class="line">  <span class="attr">address</span>: {</span><br><span class="line">    <span class="attr">home</span>: <span class="string">"sga"</span>,</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> per1 = <span class="title class_">Object</span>.<span class="title function_">values</span>(data)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> per2 = <span class="title class_">Object</span>.<span class="title function_">values</span>(data)[<span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1); <span class="comment">//james</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per2);</span><br><span class="line">{</span><br><span class="line">  <span class="attr">home</span>: <span class="string">"sga"</span>;</span><br><span class="line">}</span><br><span class="line">data.<span class="property">name</span> = <span class="string">"curry"</span>;</span><br><span class="line">data.<span class="property">address</span>.<span class="property">home</span> = <span class="string">"school"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1); <span class="comment">//james</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per2); <span class="comment">//school</span></span><br></pre></td></tr></tbody></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>使用<code>new</code>调用类的构造函数会执行以下操作</p><ol><li>在内存中创建一个新对象</li><li>在这个新对象内部的<code>[[Prototype]]</code>指针被复制为构造函数的<code>prototype</code>属性</li><li>构造函数内部的 this 被赋值为这个新对象（即<code>this</code>指向新对象）</li><li>执行构造函数内部的代码（给新对象添加属性）</li><li>如果构造函数返回非空对象 则返回该对象 否则 返回刚创建的新对象</li></ol><h1 id="代理和反射"><a href="#代理和反射" class="headerlink" title="代理和反射"></a>代理和反射</h1><p>在代理对象上执行的任何操作实际上都会应用到目标对象 唯一可以感知的不同就是代码中操作的是代理对象那个</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line"><span class="attr">id</span>: <span class="string">'target'</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> handler = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span> == proxy.<span class="property">id</span>)<span class="comment">//true; id属性会访问同一个值</span></span><br><span class="line">target.<span class="property">id</span> = <span class="string">'foo'</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span> == proxy.<span class="property">id</span>);<span class="comment">//true 给目标属性赋值会反映在两个对象上 因为两个对象访问的是同一个值</span></span><br><span class="line">proxy.<span class="property">id</span> = <span class="string">'bar'</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( target.<span class="property">id</span> == proxy.<span class="property">id</span>);<span class="comment">//true 给代理属性赋值会反映到两个对象上 因为这个赋值会转移到目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>);<span class="comment">//TypeError: Function has non-object prototype</span></span><br><span class="line"><span class="string">'undefined'</span> <span class="keyword">in</span> <span class="keyword">instanceof</span> check <span class="title class_">Proxy</span>.<span class="property"><span class="keyword">prototype</span></span>是<span class="literal">undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target == proxy)<span class="comment">//false 严格相等可以用来区分代理和目标</span></span><br></pre></td></tr></tbody></table></figure><h3 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h3><p>使用代理的主要目的是可以定义捕获器(trap)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个get捕获器 在调用get（）时触发</span></span><br><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="comment">//捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"handler override"</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></tbody></table></figure><h5 id="捕获器参数和反射-API"><a href="#捕获器参数和反射-API" class="headerlink" title="捕获器参数和反射 API"></a>捕获器参数和反射 API</h5><p>所有捕获器都可以访问相应的参数 基于这些参数可以重建被捕获方法的原始行为</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) {</span><br><span class="line">    <span class="keyword">return</span> trapTarget[property];</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></tbody></table></figure><p>可以调用全局<code>Reflect</code>对象上（封装了原始行为）的同名方法来轻松重建</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">'bar'</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"> <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"> }</span><br><span class="line"> <span class="comment">//简洁写法</span></span><br><span class="line"> <span class="attr">get</span>: <span class="title class_">Reflect</span>.<span class="property">get</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="comment">//反射API为开发者准备好了样板代码 在此基础上可以用最少的代码修改捕获的方法</span></span><br><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">'bar'</span>,</span><br><span class="line"> <span class="attr">baz</span>: <span class="string">'qux'</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"> <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) {</span><br><span class="line"> <span class="keyword">let</span> decoration = <span class="string">''</span>;</span><br><span class="line"> <span class="keyword">if</span> (property === <span class="string">'foo'</span>) {</span><br><span class="line"> decoration = <span class="string">'!!!'</span>;</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>) + decoration;</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar!!!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">baz</span>); <span class="comment">// qux</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">baz</span>); <span class="comment">// qux</span></span><br></pre></td></tr></tbody></table></figure><h4 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h4><p>捕获器应该遵守某些规范而不是出现过于反常的行为</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的</span><br><span class="line">值时，会抛出 <span class="title class_">TypeError</span>：</span><br><span class="line"><span class="keyword">const</span> target = {};</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">'foo'</span>, {</span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">value</span>: <span class="string">'bar'</span></span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line"> <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line"> <span class="keyword">return</span> <span class="string">'qux'</span>;</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">//TypeError</span></span><br></pre></td></tr></tbody></table></figure><h5 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h5><p>使用<code>new Proxy()</code>创建的普通代理的联系在代理的生命周期内会一直持续纯在 可以使用<code>revocable()</code>来撤销代理对象和目标对象的联系 撤销时不可逆和幂等的（调用多少次都一样） 撤销后再调用代理就会抛出<code>TypeError</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//撤销函数和代理对象是在实例化时同时生成的</span></span><br><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> handler = {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"intercepted"</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> { proxy, revoke } = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// intercepted</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// TypeError</span></span><br></pre></td></tr></tbody></table></figure><h4 id="使用反射-API"><a href="#使用反射-API" class="headerlink" title="使用反射 API"></a>使用反射 API</h4><p>优先使用反射 API 的情况</p><p>Object 上的方法适用于通用程序 而反射方法适用于细粒度的对象控制与操作</p><h5 id="状态标记"><a href="#状态标记" class="headerlink" title="状态标记"></a>状态标记</h5><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始代码</span></span><br><span class="line"><span class="keyword">const</span> o = {};</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"success"</span>);</span><br><span class="line">} <span class="keyword">catch</span> (e) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"failure"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用反射方法重构</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(o, <span class="string">"foo"</span>, { <span class="attr">value</span>: <span class="string">"bar"</span> })) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"success"</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"failure"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以下反射方法都会提供状态标记：</p><ul><li><code>Reflect.defineProperty()</code></li><li><code>Reflect.preventExtensions()</code></li><li><code>Reflect.setPrototypeOf()</code></li><li><code>Reflect.set()</code></li><li><code>Reflect.deleteProperty(</code></li></ul><p>以下反射方法提供只有通过操作符才能完成的操作。</p><ul><li><code>Reflect.get()：</code>可以替代对象属性访问操作符</li><li><code>Reflect.set()</code>：可以替代=赋值操作符</li><li><code>Reflect.has()</code>：可以替代 in 操作符或 with()</li><li><code>Reflect.deleteProperty()</code>：可以替代 delete 操作符</li><li><code>Reflect.construct()</code>：可以替代 new 操作符</li></ul><p><strong>可以创建一个代理去代理另一个代理 这样就能在一个目标对象上构建多层拦截网</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> firstProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"first proxy"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> secondProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(firstProxy, {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"second proxy"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondProxy.<span class="property">foo</span>); <span class="comment">//second first bar</span></span><br></pre></td></tr></tbody></table></figure><h3 id="代理的问题与不足"><a href="#代理的问题与不足" class="headerlink" title="代理的问题与不足"></a>代理的问题与不足</h3><h5 id="代理中的-this"><a href="#代理中的-this" class="headerlink" title="代理中的 this"></a>代理中的 this</h5><p>如果目标对象依赖于对象标识 那么就可能出现问题</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入有一个weakMap</span></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">userId</span>) {</span><br><span class="line"> wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, userId);</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">id</span>(<span class="params">userId</span>) {</span><br><span class="line"> wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, userId);</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">id</span>() {</span><br><span class="line"> <span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">id</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">const</span> userInstanceProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, {});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInstanceProxy.<span class="property">id</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">//这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实</span></span><br><span class="line">例。要解决这个问题，就需要重新配置代理，把代理 <span class="title class_">User</span> 实例改为代理 <span class="title class_">User</span> 类本身。之后再创建代</span><br><span class="line">理的实例就会以代理实例作为 <span class="title class_">WeakMap</span> 的键了：</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserClassProxy</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, {});</span><br><span class="line"><span class="keyword">const</span> proxyUser = <span class="keyword">new</span> <span class="title class_">UserClassProxy</span>(<span class="number">456</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyUser.<span class="property">id</span>);</span><br></pre></td></tr></tbody></table></figure><h5 id="代理与内部槽位"><a href="#代理与内部槽位" class="headerlink" title="代理与内部槽位"></a>代理与内部槽位</h5><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//，Date 类型方法的执行依赖 this 值上的</span></span><br><span class="line">内部槽位[[<span class="title class_">NumberDate</span>]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通</span><br><span class="line">的 <span class="title function_">get</span>()和 <span class="title function_">set</span>()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 <span class="title class_">TypeError</span></span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, {});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy <span class="keyword">instanceof</span> <span class="title class_">Date</span>); <span class="comment">// true</span></span><br><span class="line">proxy.<span class="title function_">getDate</span>(); <span class="comment">// TypeError: 'this' is not a Date object</span></span><br></pre></td></tr></tbody></table></figure><h2 id="代理捕获器和反射方法"><a href="#代理捕获器和反射方法" class="headerlink" title="代理捕获器和反射方法"></a>代理捕获器和反射方法</h2><blockquote><p>对于代理对象上执行的任何一种操作 只会有一个捕获程序会被调用 不存在重复捕获的情况</p></blockquote><h3 id="get（）方法"><a href="#get（）方法" class="headerlink" title="get（）方法"></a>get（）方法</h3><p><code>get()</code>捕获器会在获取属性值的操作中被调用 对应的反射 API 为<code>Reflect.get()</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, {</span><br><span class="line"> <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'get()'</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line">proxy.<span class="property">foo</span>;</span><br><span class="line"><span class="comment">//拦截的操作</span></span><br><span class="line">proxy.<span class="property">property</span></span><br><span class="line">proxy[property]</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(proxy)[property]</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(proxy, property, receiver)</span><br><span class="line"><span class="comment">//捕获不变式</span></span><br><span class="line">如果target.<span class="property">property</span>不可写且不可配置 则处理程序返回的值必须与target.<span class="property">property</span>匹配</span><br><span class="line">如果target.<span class="property">property</span>不可配置且[[<span class="title class_">Get</span>]]特性为<span class="literal">undefined</span> 处理程序的返回值也必须是<span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><h3 id="set（）"><a href="#set（）" class="headerlink" title="set（）"></a>set（）</h3><p><code>set()</code>捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 <code>Reflect.set()。</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, {</span><br><span class="line"> <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'set()'</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">'bar'</span>;</span><br><span class="line"><span class="comment">// set()</span></span><br><span class="line"><span class="comment">//返回值：true 表示成功 false 表示失败</span></span><br><span class="line"><span class="comment">//拦截的操作</span></span><br><span class="line">proxy.<span class="property">property</span> = value;</span><br><span class="line">proxy[peoperty] = value;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(proxy)[property] = value</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(proxy, property, value, receiver)</span><br><span class="line"><span class="comment">//捕获器处理程序参数</span></span><br><span class="line"><span class="attr">target</span>: 目标对象</span><br><span class="line"><span class="attr">property</span>: 引用的目标对象上的字符串键属性</span><br><span class="line">value：要赋给属性的值</span><br><span class="line">receiver：接收最初赋值的对象</span><br><span class="line"><span class="comment">//捕获器不变式</span></span><br><span class="line">如果target.<span class="property">property</span>不可写且不可配置 则不修改目标属性的值</span><br><span class="line">如果target.<span class="property">property</span>不可配置且[[<span class="title class_">Set</span>]]特性为<span class="literal">undefined</span> 则不能修改目标属性的值</span><br><span class="line">在严格模式下 处理程序中返回<span class="literal">false</span>会抛出<span class="title class_">TypeError</span></span><br></pre></td></tr></tbody></table></figure><h3 id="has（）"><a href="#has（）" class="headerlink" title="has（）"></a>has（）</h3><p><code>has()</code>捕获器会在 in 操作符中被调用。对应的反射 API 方法为 <code>Reflect.has()。</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, {</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, property</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"has()"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="string">"foo"</span> <span class="keyword">in</span> proxy;</span><br><span class="line"><span class="comment">//返回值 必须返回布尔值 表示属性是否存在 返回非布尔值会被转型为布尔值</span></span><br><span class="line"><span class="comment">//捕获不变式：</span></span><br><span class="line"><span class="comment">//如果 target.property 存在且不可配置，则处理程序必须返回 true。</span></span><br><span class="line"><span class="comment">//如果 target.property 存在且目标对象不可扩展，则处理程序必须返回 true。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>apply()捕获器会在调用函数时被调用 对应的反射 api 方法为 Reflect.apply()</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myTarget</span> = (<span class="params"></span>) =&gt; {};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, {</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">target, thisArg, ...argumentsList</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"apply()"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// apply()</span></span><br></pre></td></tr></tbody></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h4 id="跟踪属性访问（很重要）"><a href="#跟踪属性访问（很重要）" class="headerlink" title="跟踪属性访问（很重要）"></a><strong>跟踪属性访问</strong>（很重要）</h4><p>通过捕获<code>get set 和has</code>等操作 可以知道对象属性说明时候被使用 查询的那个 把实现相应捕获器的某个对象代理放到应用中 就可以检测这个对象何时在何处被访问过</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'Jack'</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, {</span><br><span class="line"><span class="title function_">get</span>(<span class="params">target, property, receiver</span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Getting ${property}'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">}</span><br><span class="line"><span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Setting ${property} = ${value}'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// Getting name</span></span><br><span class="line">proxy.<span class="property">age</span> = <span class="number">27</span>; <span class="comment">// Setting age=27</span></span><br></pre></td></tr></tbody></table></figure><h4 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h4><p>代理的内部实现对外部代码是不可见的 因此可以用来隐藏目标对象上的属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">"foo"</span>, <span class="string">"bar"</span>];</span><br><span class="line"><span class="keyword">const</span> targetObject = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="number">3</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targetObject, {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property</span>) {</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, property</span>) {</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="comment">// get()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">bar</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">baz</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// has()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"foo"</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"bar"</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"baz"</span> <span class="keyword">in</span> proxy); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h4 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h4><p>因为所有的赋值操作都会触发<code>set（）</code>捕获器 所以可以根据所赋的值决定是允许还是拒绝赋值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">onlyNumbersGoHere</span>: <span class="number">0</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, {</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value</span>) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">"number"</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="string">"2"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><h4 id="函数与构造函数参数验证"><a href="#函数与构造函数参数验证" class="headerlink" title="函数与构造函数参数验证"></a>函数与构造函数参数验证</h4><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种 类型的值：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">median</span>(<span class="params">...nums</span>) {</span><br><span class="line"> <span class="keyword">return</span> nums.<span class="title function_">sort</span>()[<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>)];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(median, {</span><br><span class="line"> <span class="title function_">apply</span>(<span class="params">target, thisArg, argumentsList</span>) {</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> arg <span class="keyword">of</span> argumentsList) {</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'number'</span>) {</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">'Non-number argument provided'</span>;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">4</span>, <span class="string">'7'</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// Error: Non-number argument provided</span></span><br><span class="line">类似地，可以要求实例化时必须给构造函数传参：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">id</span>) {</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">id_</span> = id;</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, {</span><br><span class="line"> <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) {</span><br><span class="line"> <span class="keyword">if</span> (argumentsList[<span class="number">0</span>] === <span class="literal">undefined</span>) {</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">'User cannot be instantiated without id'</span>;</span><br><span class="line"> } <span class="keyword">else</span> {</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// Error: User cannot be instantiated without id</span></span><br></pre></td></tr></tbody></table></figure><h4 id="数据绑定和可观察对象"><a href="#数据绑定和可观察对象" class="headerlink" title="数据绑定和可观察对象"></a>数据绑定和可观察对象</h4><p>通过代理把运行中原本不相关的部分联系在一起 可以实现各种模式 从而让不同的代码互操作 比如 可以将代理的类绑定到一个全局实例集合 让所有创建的实例都被添加到这个集合中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name_</span> = name;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, {</span><br><span class="line">  <span class="title function_">construct</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> newUser = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    userList.<span class="title function_">push</span>(nreUser);</span><br><span class="line">    <span class="keyword">return</span> newUser;</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="string">"John"</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="string">"Jacob"</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="string">"Jingqdqdk"</span>);</span><br></pre></td></tr></tbody></table></figure><p>另外 还可以将集合绑定到一个事件分派程序 每次插入新实例都会发送消息</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">emit</span>(<span class="params">newValue</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(userList, {</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) {</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">      <span class="title function_">emit</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="string">"John"</span>);</span><br><span class="line"><span class="comment">// John</span></span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="string">"Jacob"</span>);</span><br><span class="line"><span class="comment">// Jacob</span></span><br></pre></td></tr></tbody></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote><p>ECMAScript 中的所有参数都按值传递 不可能按引用传递 如果把对象作为参数重载 那么传递的值就是这个对象的引用</p></blockquote><p>JavaScript 引擎在任何代码执行之前 会先读取函数声明 并在执行上下文中生成函数定义 而函数表达式必须等到代码执行到它的那一行 才会在执行上下文中生成函数定义。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) {</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//函数声明提升：函数声明会在任何代码执行之前被读取并添加到上下文中</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span> (<span class="params">num1, num2</span>) {</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//提升的是sum变量 而不是函数</span></span><br></pre></td></tr></tbody></table></figure><p><strong>从一个函数内部返回另一个函数也是可以的 而且非常重要</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">object1, object2</span>) {</span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) {</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">"Zachary"</span>, <span class="attr">age</span>: <span class="number">28</span> },</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">age</span>: <span class="number">29</span> },</span><br><span class="line">];</span><br><span class="line"><span class="comment">//可以根据不同的属性来进行不同的比较规则</span></span><br><span class="line">data.<span class="title function_">sort</span>(<span class="title function_">createComparisonFunction</span>(<span class="string">"name"</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="number">0</span>].<span class="property">name</span>); <span class="comment">// Nicholas</span></span><br><span class="line">data.<span class="title function_">sort</span>(<span class="title function_">createComparisonFunction</span>(<span class="string">"age"</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="number">0</span>].<span class="property">name</span>); <span class="comment">// Zachary</span></span><br></pre></td></tr></tbody></table></figure><p><strong>箭头函数中的<code>this</code>引用的是定义箭头函数的上下文</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">let</span> o = {</span><br><span class="line">  <span class="attr">color</span>: <span class="string">"blue"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sayColor</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">//red</span></span><br><span class="line">o.<span class="property">sayColor</span> = sayColor;</span><br><span class="line">o.<span class="title function_">sayColor</span>(); <span class="comment">//red</span></span><br><span class="line"><span class="comment">//因为this是在window上下文中定义的 所以引用的都是window对象</span></span><br><span class="line"><span class="comment">//函数名只是保存指针的变量 因此全局定义的sayColor和o.sayColor是同一个函数 只不过执行的上下文不同</span></span><br></pre></td></tr></tbody></table></figure><p>ES6 新增：<code>new.target</code>如果是使用<code>new</code>关键字调用的 则 n<code>ew.target</code>将引用被调用的构造函数 否则值是<code>undefined</code> 可以用来规定某个函数只能通过<code>new</code>来构建</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">King</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'King must be instantiated using "new"'</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'King instantiated using "new"'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">King</span>(); <span class="comment">// King instantiated using "new"</span></span><br><span class="line"><span class="title class_">King</span>(); <span class="comment">// Error: King must be instantiated using "new"</span></span><br></pre></td></tr></tbody></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>可以使用命名表达式来完成递归</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num) {</span><br><span class="line"> if (num &lt;= 1) {</span><br><span class="line"> return 1;</span><br><span class="line"> } else {</span><br><span class="line"> return num * factorial(num - 1);</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">let anotherFactorial = factorial; //将函数保存在anthorPactorial中</span><br><span class="line">factorial = null;</span><br><span class="line">console.log(anotherFactorial(4)); // 报错 递归调用factorial 但是factoprial已经不是函数了</span><br><span class="line">//可以使用命名函数来解决</span><br><span class="line">const factorial = (function f(num) {</span><br><span class="line"> if (num &lt;= 1) {</span><br><span class="line"> return 1;</span><br><span class="line"> } else {</span><br><span class="line"> return num * f(num - 1);</span><br><span class="line"> }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>ES6 新增了一想内存管理优化机制 让 js 引擎在满足条件时可以重用栈帧 非常适合尾调用（外部函数的返回值时一个内部函数的返回值）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">innerFunction</span>();<span class="comment">//尾调用</span></span><br><span class="line">}</span><br><span class="line"><span class="title class_">ES6</span>优化之前：</span><br><span class="line">(<span class="number">1</span>) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。</span><br><span class="line">(<span class="number">2</span>) 执行 outerFunction 函数体，到 <span class="keyword">return</span> 语句。计算返回值必须先计算 innerFunction。</span><br><span class="line">(<span class="number">3</span>) 执行到 innerFunction 函数体，第二个栈帧被推到栈上。</span><br><span class="line">(<span class="number">4</span>) 执行 innerFunction 函数体，计算其返回值。</span><br><span class="line">(<span class="number">5</span>) 将返回值传回 outerFunction，然后 outerFunction 再返回值。</span><br><span class="line">(<span class="number">6</span>) 将栈帧弹出栈外。</span><br><span class="line">在 <span class="title class_">ES6</span> 优化之后，执行这个例子会在内存中发生如下操作。</span><br><span class="line">(<span class="number">1</span>) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。</span><br><span class="line">(<span class="number">2</span>) 执行 outerFunction 函数体，到达 <span class="keyword">return</span> 语句。为求值返回语句，必须先求值 innerFunction。</span><br><span class="line">(<span class="number">3</span>) 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction</span><br><span class="line">的返回值。</span><br><span class="line">(<span class="number">4</span>) 弹出 outerFunction 的栈帧。</span><br><span class="line">(<span class="number">5</span>) 执行到 innerFunction 函数体，栈帧被推到栈上。</span><br><span class="line">(<span class="number">6</span>) 执行 innerFunction 函数体，计算其返回值。</span><br><span class="line">(<span class="number">7</span>) 将 innerFunction 的栈帧弹出栈外</span><br><span class="line">很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多</span><br><span class="line">少次嵌套函数，都只有一个栈帧。这就是 <span class="title class_">ES6</span> 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其</span><br><span class="line">销毁，则引擎就会那么做。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个常见的递归尾调用优化的例子</span></span><br><span class="line"><span class="comment">// 基础框架</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fibImpl</span>(<span class="number">0</span>, <span class="number">1</span>, n);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 执行递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibImpl</span>(<span class="params">a, b, n</span>) {</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fibImpl</span>(b, a + b, n - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包指的是那些引用了另一个函数作用域中变量的函数 通常是在嵌套函数中实现的</p><blockquote><p>在调用一个函数的时候 会为这个函数调用创建一个执行上下文 并创建一个作用域链 然后用 arguments 和其他命名参数来初始化这个函数的所有活动对象 外部函数的活动对象是内部函数作用域链上的第二个对象 这个作用域链一直向外串起了所有包含函数的活动对象 知道全局执行上下文才终止</p></blockquote><h2 id="理解调用的函数表达式"><a href="#理解调用的函数表达式" class="headerlink" title="理解调用的函数表达式"></a>理解调用的函数表达式</h2><p>立即调用的匿名函数又称作立即调用的函数表达式（IIFE）ES6 之后没有使用的必要了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IIFE可以模拟块级作用域 即在一个函数表达式内部声明变量然后立即调用这个函数 这样位于函数作用域的变量就相当于在块级作用域中一样</span></span><br><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  }</span><br><span class="line">})();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>使用闭包和私有变量会导致作用域链变长 作用域链越长 则找到变量所需的时间就越多</p></blockquote><h1 id="Promise-和异步函数"><a href="#Promise-和异步函数" class="headerlink" title="Promise 和异步函数"></a>Promise 和异步函数</h1><p><code>promise</code>的状态是私有的 不能直接通过 js 检测到 这是为了避免读取到的<code>promise</code>的状态以同步方式处理 同时 <code>promise</code>的状态也不能被外部 js 代码修改 要是为了隔离外部的同步代码</p><p><code>Promise.resolved()</code>是幂等状态</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> {});</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><code>Promise.reject()</code>会将传给他的作为错误信息返回 包括<code>promise.resloved()</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>()));</span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: Promise &lt;resolved&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><code>Finally</code>用于给<code>promise</code>添加<code>onFinally</code>处理程序 可以避免 <code>onResolved</code> 和 <code>onRejected</code> 处理程序中出 现冗余代码 主要用于添加清理代码</p><blockquote><p>明天再看</p></blockquote><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="窗口关系"><a href="#窗口关系" class="headerlink" title="窗口关系"></a>窗口关系</h2><p><code>outerWidth 和 outerHeight</code> 返回浏 览器窗口自身的大小（不管是在最外层 window 上使用，还是在窗格中使用）。<code>innerWidth 和 innerHeight</code> 返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）</p><p><code>document.documentElement.clientWidth 和 document.documentElement.clientHeight</code> 返回页面视口的宽度和高度。</p><h3 id="视口位置"><a href="#视口位置" class="headerlink" title="视口位置"></a>视口位置</h3><p>度量文档相对于视口滚动距离的属性有两对，返回相等的值<code>：window.pageXoffset/window. scrollX 和 window.pageYoffset/window.scrollY</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对于当前视口向下滚动 100 像素</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollBy</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 相对于当前视口向右滚动 40 像素</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollBy</span>(<span class="number">40</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 滚动到页面左上角</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 滚动到距离屏幕左边及顶边各 100 像素的位置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></tbody></table></figure><p>除了偏移值之外 还能通过<code>behavior</code>属性告诉浏览器是否平滑滚动</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常滚动</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>({</span><br><span class="line">  <span class="attr">left</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">top</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">behavior</span>: <span class="string">"auto"</span>,</span><br><span class="line">  <span class="comment">//behavior: 'smooth'//平滑滚动</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h2><p><code>URL</code>包含当前页面的完整 URL（地址栏中的 URL） <code>domain</code>包含页面的域名 <code>referrer</code>包含连接到当前页面的那个页面的 URL（如果当前页面无来源 则尾空字符串）<strong>只有 domain 的值是可以设置的</strong></p><p><code>getElementsByName()</code>方法最常用于单选按钮，因为同 一字段的单选按钮必须具有相同的 <code>name</code> 属性才能确保把正确的值发送给服务器</p><h2 id="ScrollIntoView（）"><a href="#ScrollIntoView（）" class="headerlink" title="ScrollIntoView（）"></a>ScrollIntoView（）</h2><p><code>scrollIntoView()</code>方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元 素进入视口</p><ul><li>alignToTop：boolean default：true<ul><li>true：窗口滚动后元素的顶部与视口顶部对齐</li><li>false：窗口滚动后元素的底部与视口底部对齐</li></ul></li><li>false：窗口滚动后元素的底部与视口底部对齐<ul><li>false：窗口滚动后元素的底部与视口底部对齐</li><li>block：定义垂直方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默 认为 “start”。</li><li>inline：定义水平方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默 认为 “nearest”。</li></ul></li></ul><p>这个方法可以用来在页面上发生某个事件时引起用户关注。把焦点设置到一个元素上也会导致浏览 器将元素滚动到可见位置。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="DOM-事件对象"><a href="#DOM-事件对象" class="headerlink" title="DOM 事件对象"></a>DOM 事件对象</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bubbles 布尔值 只读 表示事件是否冒泡</span><br><span class="line">cancelable 布尔值 只读 表示是否可以取消事件的默认行为</span><br><span class="line">currentTarget 元素 只读 当前事件处理程序所在的元素</span><br><span class="line">defaultPrevented 布尔值 只读 true 表示已经调用 preventDefault()方法（DOM3</span><br><span class="line">Events 中新增）</span><br><span class="line">detail 整数 只读 事件相关的其他信息</span><br><span class="line">eventPhase 整数 只读 表示调用事件处理程序的阶段：1 代表捕获阶段，2 代表</span><br><span class="line">到达目标，3 代表冒泡阶段</span><br><span class="line">preventDefault() 函数 只读 用于取消事件的默认行为。只有 cancelable 为 true 才</span><br><span class="line">可以调用这个方法</span><br><span class="line">stopImmediatePropagation() 函数 只读 用于取消所有后续事件捕获或事件冒泡，并阻止调用任</span><br><span class="line">何后续事件处理程序（DOM3 Events 中新增）</span><br><span class="line">stopPropagation() 函数 只读 用于取消所有后续事件捕获或事件冒泡。只有 bubbles</span><br><span class="line">为 true 才可以调用这个方法</span><br><span class="line">target 元素 只读 事件目标</span><br><span class="line">trusted 布尔值 只读 true 表示事件是由浏览器生成的。false 表示事件是开</span><br><span class="line">发者通过 JavaScript 创建的（DOM3 Events 中新增）</span><br><span class="line">type 字符串 只读 被触发的事件类型</span><br><span class="line">View AbstractView 只读 与事件相关的抽象视图。等于事件所发生的 window 对象</span><br></pre></td></tr></tbody></table></figure><p>在事件处理程序内部 <code>this</code>对象始终等于<code>currentTatget</code>的值 而<code>target</code>只包含事件的实际目标</p><p><code>type</code>属性在一个对象处理多个程序的时候很有用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span> (<span class="params">event</span>) {</span><br><span class="line">  <span class="keyword">switch</span> (event.<span class="property">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Clicked"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">      event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">"red"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">      event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">btn.<span class="property">onclick</span> = handler;</span><br><span class="line">btn.<span class="property">onmouseover</span> = handler;</span><br><span class="line">btn.<span class="property">onmouseout</span> = handler;</span><br></pre></td></tr></tbody></table></figure><p><code>preventDefault()</code>方法用于阻止特定事件的默认动作</p><p><code>stopPropagation()</code>方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件<code>捕获</code>或<code>冒泡</code></p><p><code>eventPhase</code> 属性可用于确定事件流当前所处的阶段</p><blockquote><p>event 对象只在事件处理程序执行期间存在 一旦执行完毕 就会被销毁</p></blockquote><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><ul><li><p>用户界面事件（<code>UIEvent</code>）：涉及与 BOM 交互的通用浏览器事件</p><ul><li>resize：在 window 或窗格上当窗口或窗格被缩放时触发（浏览器窗口在最大化或最小化的时候也会触发这个事件）</li><li>scroll：当用户滚动包含滚动条上的元素时在元素上触发</li><li>abort：在<code>&lt;object&gt;</code>元素上当相应对象加载完成前被用户提前终止下载时触发</li></ul></li><li><p>焦点事件（<code>FocusEvent</code>）：在元素获得和失去焦点时触发</p><ul><li>blur：失去焦点时触发</li><li>focus：用户获得焦点时触发 不冒泡</li><li>focusin：当元素获得焦点时触发。这个事件是 focus 的冒泡版</li><li>focusout：当元素失去焦点时触发。这个事件是 blur 的通用版</li></ul></li><li><p>鼠标事件（<code>MouseEvent</code>）：使用鼠标在页面上执行某些操作时触发</p></li><li><p>dblclick：在用户双击鼠标主键（通常是左键）时触发</p></li><li><p>mousedown：在用户按下任意鼠标键时触发。这个事件不能通过键盘触发</p></li><li><p>mouseenter：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在 光标经过后代元素时触发</p></li><li><p>mouseleave：在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在 光标经过后代元素时触发</p></li><li><p>mousemove：在鼠标光标在元素上移动时反复触发</p></li><li><p>mouseout：在用户把鼠标光标从一个元素移到另一个元素上时触发</p></li><li><p>mouseover：在用户把鼠标光标从元素外部移到元素内部时触发</p></li><li><p>mouseup：在用户释放鼠标键时触发</p></li></ul><p>除了 mouseenter 和 mouseleave，所有鼠标事件都会冒泡， 都可以被取消，而这会影响浏览器的默认行为</p><ul><li><p>滚轮事件（<code>WheelEvent</code>）：使用鼠标滚轮（或类似设备）时触发</p></li><li><p>输入事件（<code>InputEvent</code>）：向文档中输入文本时触发</p></li><li><p>键盘事件（<code>KeyboardEvent</code>）：使用键盘在页面上执行某些操作时触发</p><ul><li>textInput：输入事件 当 会在文本被插入到文本框之前触发(只在可编辑区域触发 只有新字符被插入时才会触发)</li><li>keydown 和 keypress 会在文本框变化前触发（按住不放则重复触发） keyUp 会在发生后触发</li><li>key 属性用于替代 keyCode，且包含字符串。在按下字符键时，key 的值等于文本字符（如 “k”或“M”）；在按下非字符键时，key 的值是键名（如“Shift”或“ArrowDown”）。char 属性在按 下字符键时与 key 类似，在按下非字符键时为 null</li></ul></li><li><p>合成事件（<code>CompositionEvent</code>）：在使用某种 IME（Input Method Editor，输入法编辑器）输入 字符时触发。</p></li></ul><h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托利用事件冒泡 可以只使用一个事件处理程序来处理一种类型事件</p><p><strong>所有使用按钮的事件（大多数鼠标事件和键盘事件）都适用于这个解决方案</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"myLinks"</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"goSomewhere"</span>&gt;</span>Go somewhere<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"sayHi"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;;</span><br><span class="line"><span class="comment">//如果对三个li都像这样指定3个事件处理程序</span></span><br><span class="line"><span class="keyword">let</span> item1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"goSomewhere"</span>);</span><br><span class="line"><span class="keyword">let</span> item2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"doSomething"</span>);</span><br><span class="line"><span class="keyword">let</span> item3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"sayHi"</span>);</span><br><span class="line">item1.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  location.<span class="property">href</span> = <span class="string">"http:// www.wrox.com"</span>;</span><br><span class="line">});</span><br><span class="line">item2.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">"I changed the document's title"</span>;</span><br><span class="line">});</span><br><span class="line">item3.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"hi"</span>);</span><br><span class="line">});</span><br><span class="line"><span class="comment">//使用事件委托 只要给所有元素沟通的祖先节点添加一个事件处理程序 可以解决问题</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myLinks"</span>);</span><br><span class="line">list.<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> target = event.<span class="property">target</span>;</span><br><span class="line">  <span class="keyword">switch</span> (target.<span class="property">id</span>) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"doSomething"</span>:</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">"I changed the document's title"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"goSomewhere"</span>:</span><br><span class="line">      location.<span class="property">href</span> = <span class="string">"http:// www.wrox.com"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"sayHi"</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"hi"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>事件委托的好处</p><ul><li><code>document</code> 对象随时可用，任何时候都可以给它添加事件处理程序（不用等待 DOMContentLoaded 或 load 事件）。这意味着只要页面渲染出可点击的元素，就可以无延迟地起作用。</li><li>节省花在设置页面事件处理程序上的时间。只指定一个事件处理程序既可以节省 DOM 引用，也 可以节省时间</li><li>减少整个页面所需的内存，提升整体性能</li></ul><p>最适合使用事件委托的事件包括：<code>click、mousedown、mouseup、keydown 和 keypress</code></p><h1 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h1><h2 id="跨上下文消息"><a href="#跨上下文消息" class="headerlink" title="跨上下文消息"></a>跨上下文消息</h2><p>跨文档消息（XDM）是一种在不同执行上下文（如不同工作线程或不同源的页面能力）间传递消息的能力</p><blockquote><p>跨上下文消息用于窗口之间通信或工作线程之间通信</p></blockquote><p><code>postMessage()</code>方法接收三个参数：消息、表示目标接收源的字符串和可选的可传输对象的数组（只与工作线程相关）第二个参数对于安全非常重要 可以限制浏览器交付数据的目标</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iframeWindow = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myframe"</span>).<span class="property">contentWIndow</span>;</span><br><span class="line">iframeWindow.<span class="title function_">postMessage</span>(<span class="string">"a message"</span>, <span class="string">"http://www.wrox.com"</span>);</span><br><span class="line"><span class="comment">//如果源匹配 就将消息交付到内嵌彪哥 否则啥都不错 可以保护信息不会因地址改变而泄漏</span></span><br></pre></td></tr></tbody></table></figure><p>接收到 XDM 消息后 window 对象上会触发<code>message</code>事件（<code>异步</code>触发 从发出到接收消息可能会有延迟）传给<code>message</code>的<code>event</code>对象包含以下三方面重要信息</p><ul><li><code>data</code>：作为第一个参数传递给<code>postMessage（）</code>的字符串数据</li><li><code>origin</code>：发送消息的文档源</li><li><code>source</code>：发送消息的文档中<code>window</code>对象的代理 这个代理对象主要用于发送上一条消息的窗口中执行<code>postMessage()</code>方法 如果发送窗口有相同的源 那么对象就是 window 对象</li></ul><p><code>onmessage</code> 事件处理程序中检查发送窗口的源可以保证数据来自正确的 地方</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">"message"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 确保来自预期发送者</span></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">origin</span> == <span class="string">"http://www.wrox.com"</span>) {</span><br><span class="line">    <span class="comment">// 对数据进行一些处理</span></span><br><span class="line">    <span class="title function_">processMessage</span>(event.<span class="property">data</span>);</span><br><span class="line">    <span class="comment">// 可选：向来源窗口发送一条消息</span></span><br><span class="line">    event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">"Received!"</span>, <span class="string">"http://p2p.wrox.com"</span>);</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>大多数情况下，<code>event.source</code> 是某个 <code>window</code> 对象的代理，而非实际的 window 对象。因此不能 通过它访问所有窗口下的信息。最好只使用 <code>postMessage()</code>，这个方法永远存在而且可以调用</p><p><strong>tips：</strong>最好就是只 通 过 <code>postMessage()</code> 发送字符串。如果需要传递结构化数据，那么最好先对该数据调用 <code>JSON.stringify()，</code>通过 postMessage()传过去之后，再在 <code>onmessage</code> 事件处理程序中调用 <code>JSON.parse()</code></p><p>在通过内嵌窗格加载不同域时，使用 XDM 是非常方便的。这种方法在混搭（mashup）和<code>社交应用</code> 中非常常用。通过使用 XDM 与内嵌窗格中的网页通信，可以保证包含页面的安全。XDM 也可以用于 <code>同源页面</code>之间通信</p><h2 id="Encoding-API"><a href="#Encoding-API" class="headerlink" title="Encoding API"></a>Encoding API</h2><p>用于实现字符串和定型数组之间的转换 <code>TextEncoder、TextEncoderStream、TextDecoder 和 TextDecoderStream。</code></p><h3 id="批量编码"><a href="#批量编码" class="headerlink" title="批量编码"></a>批量编码</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextEncoder、TextEncoderStream、TextDecoder 和 TextDecoderStream。</span></span><br><span class="line"><span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>();</span><br><span class="line"><span class="keyword">const</span> decodedText = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">const</span> encodedTRext = textEncoder.<span class="title function_">encode</span>(docodedText);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encodedText); <span class="comment">// Uint8Array(3) [102, 111, 111]</span></span><br><span class="line"><span class="comment">//编码器是用于处理字符的，有些字符（如表情符号）在最终返回的数组中可能会占多个索引</span></span><br><span class="line"><span class="comment">//encodeInto()方法，该方法接收一个字符串和目标 Unit8Array，返回一个</span></span><br><span class="line">字典，该字典包含 read 和 written 属性，分别表示成功从源字符串读取了多少字符和向目标数组写</span><br><span class="line">入了多少字符。如果定型数组的空间不够，编码就会提前终止，</span><br><span class="line"><span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>();</span><br><span class="line"><span class="keyword">const</span> fooArr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> barArr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> fooResult = textEncoder.<span class="title function_">encodeInto</span>(<span class="string">'foo'</span>, fooArr);</span><br><span class="line"><span class="keyword">const</span> barResult = textEncoder.<span class="title function_">encodeInto</span>(<span class="string">'bar'</span>, barArr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooArr); <span class="comment">// Uint8Array(3) [102, 111, 111]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooResult); <span class="comment">// { read: 3, written: 3 }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(barArr); <span class="comment">// Uint8Array(2) [98, 97]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(barResult); <span class="comment">// { read: 2, written: 2 }</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>文本编码会始终使用 UTF-8 格式，而且必须写入 Unit8Array 实例。使用其他类 型数组会导致 encodeInto()抛出错误</p></blockquote><h2 id="File-API-与-Blob-API"><a href="#File-API-与-Blob-API" class="headerlink" title="File API 与 Blob API"></a>File API 与 Blob API</h2><h3 id="File-类型"><a href="#File-类型" class="headerlink" title="File 类型"></a>File 类型</h3><p>每个 File 对象都有一些只读属性</p><ul><li>name：本地系统中的文件名</li><li>size：以字节计的文件大小</li><li>type：包含文件 MIME 类型的字符串</li><li>lastModifiedDate：表示文件最后修改的时间的字符串 只有 chome 实现了</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">通过监听 change 事件然后遍历 files 集合可以取得每个选中文件的信息</span><br><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"files-list"</span>);</span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">"change"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"> <span class="keyword">let</span> files = event.<span class="property">target</span>.<span class="property">files</span>,</span><br><span class="line"> i = <span class="number">0</span>,</span><br><span class="line"> len = files.<span class="property">length</span>;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; len) {</span><br><span class="line"> <span class="keyword">const</span> f = files[i];</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">${f.name}</span> (<span class="subst">${f.type}</span>, <span class="subst">${f.size}</span> bytes)`</span>);</span><br><span class="line"> i++;</span><br><span class="line"> }</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="FileReader-类型"><a href="#FileReader-类型" class="headerlink" title="FileReader 类型"></a>FileReader 类型</h3><p><code>FileReader</code>类型表示一种<code>异步</code>文件读取机制</p><ul><li><code>readAsText(file, encoding)</code>：从文件中读取纯文本内容并保存在 result 属性中。第二个 参数表示编码，是可选的</li><li><code>readAsDataURL(file)</code>：读取文件并将内容的数据 URI 保存在 result 属性中</li><li><code>readAsBinaryString(file)</code>：读取文件并将每个字符的二进制数据保存在 result 属性中</li><li><code>readAsArrayBuffer(file)</code>：读取文件并将文件内容以 <code>ArrayBuffer</code> 形式保存在 result 属性</li></ul><p>因为这些读取方法是异步的，所以每个 FileReader 会发布几个事件，其中 3 个最有用的事件是 <code>progress、error 和 load</code>，分别表示还有更多数据、发生了错误和读取完成</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从表单字段读取一个文件并将其内容显示在网页上</span></span><br><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"files-list"</span>);</span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">"change"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> info = <span class="string">""</span>,</span><br><span class="line">    output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"output"</span>);</span><br><span class="line">  (progress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"progress"</span>)),</span><br><span class="line">    (files = event.<span class="property">target</span>.<span class="property">files</span>),</span><br><span class="line">    (type = <span class="string">"default"</span>),</span><br><span class="line">    (reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>());</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/image/</span>.<span class="title function_">test</span>(files[<span class="number">0</span>].<span class="property">type</span>)) {</span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(files[<span class="number">0</span>]);</span><br><span class="line">    type = <span class="string">"image"</span>; <span class="comment">//如果是图片 则将其读取后保存为URL</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    reader.<span class="title function_">readAsText</span>(files[<span class="number">0</span>]); <span class="comment">//如果是文字则保存为文字</span></span><br><span class="line">    type = <span class="string">"text"</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//用于监控错误</span></span><br><span class="line">  reader.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    output.<span class="property">innerHTML</span> =</span><br><span class="line">      <span class="string">"Could not read file, error code is "</span> + reader.<span class="property">error</span>.<span class="property">code</span>;</span><br><span class="line">  };</span><br><span class="line">  <span class="comment">//用于跟踪和显示读取文件的进度</span></span><br><span class="line">  reader.<span class="property">onprogress</span> = <span class="keyword">function</span> (<span class="params">event</span>) {</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) {</span><br><span class="line">      progress.<span class="property">innerHTML</span> = <span class="string">`<span class="subst">${event.loaded}</span>/<span class="subst">${event.total}</span>`</span>; <span class="comment">//读取文件的进度</span></span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">  <span class="comment">//读取成功后</span></span><br><span class="line">  reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">let</span> html = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) {</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"image"</span>:</span><br><span class="line">        html = <span class="string">`&lt;img src="<span class="subst">${reader.result}</span>"&gt;`</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"text"</span>:</span><br><span class="line">        html = reader.<span class="property">result</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    output.<span class="property">innerHTML</span> = html;</span><br><span class="line">  };</span><br><span class="line">});</span><br><span class="line"><span class="comment">//如果想提前结束文件的读取 可以在过程中调用abort()方法 在load error和 abort事件触发后 还会触发loadend事件 loadend事件表示上述三种情况下所有读取操作都已经结束</span></span><br></pre></td></tr></tbody></table></figure><h3 id="FileReaderSync-类型"><a href="#FileReaderSync-类型" class="headerlink" title="FileReaderSync 类型"></a>FileReaderSync 类型</h3><p><code>FileReader</code>的同步版本 只有整个文件都加载到内存之后才能继续进行 只在工作线程中可用 因为如果读取整个文件的耗时过长则会影响全局</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line">self.<span class="property">omessage</span> = <span class="function">(<span class="params">messageEvent</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> syncReader = <span class="keyword">new</span> <span class="title class_">FileReaderSync</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(syncReader); <span class="comment">// FileReaderSync {}</span></span><br><span class="line">  <span class="comment">// 读取文件时阻塞工作线程</span></span><br><span class="line">  <span class="keyword">const</span> result = syncReader.<span class="title function_">readAsDataUrl</span>(messageEvent.<span class="property">data</span>);</span><br><span class="line">  <span class="comment">// PDF 文件的示例响应</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// data:application/pdf;base64,JVBERi0xLjQK...</span></span><br><span class="line">  <span class="comment">// 把 URL 发回去</span></span><br><span class="line">  self.<span class="title function_">postMessage</span>(result);</span><br><span class="line">};</span><br><span class="line"><span class="comment">//假设通过 postMessage()向工作线程发送了一个 File 对象。以下代码会让工作线程同步将文件</span></span><br><span class="line"><span class="comment">//读取到内存中，然后将文件的数据 URL 发回来</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Blob-与部分读取"><a href="#Blob-与部分读取" class="headerlink" title="Blob 与部分读取"></a>Blob 与部分读取</h3><p><code>File</code>对象提供了一个名为<code>slice()</code>的方法 （接收两个参数 其实字节和读取的字节数 返回一个 Blob 实例 ）Blob 实际上是 File 的<strong>超类</strong></p><p>Blob 对象有一个 <code>size</code> 属性和一个 <code>type</code> 属性，还有一个 <code>slice()</code>方法用于进一步切分数据。另 外也可以使用 <code>FileReader</code> 从 Blob 中读取数据</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文件的前32字节</span></span><br><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'files-list'</span>);</span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">"change"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">""</span>,</span><br><span class="line">output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'output'</span>);</span><br><span class="line">progress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'progress'</span>),</span><br><span class="line">files = event.<span class="property">target</span>.<span class="property">files</span>,</span><br><span class="line">reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(),</span><br><span class="line">blob = <span class="title function_">blobSlice</span>(files[<span class="number">0</span>], <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">if</span>(blob) [</span><br><span class="line">reader.<span class="title function_">readAsText</span>(blob);</span><br><span class="line">reader.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">output.<span class="property">innerHTML</span> = <span class="string">"Could not read file, error code is"</span> +</span><br><span class="line">reader.<span class="property">error</span>.<span class="property">code</span>;</span><br><span class="line">};</span><br><span class="line">reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">output.<span class="property">innerHTML</span> = reader.<span class="property">result</span>;</span><br><span class="line">}</span><br><span class="line">]<span class="keyword">else</span> {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'error'</span>)</span><br><span class="line">}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><blockquote><p>只读取部分文件可以节约时间 特别是在只需要特定部分比如文件头的时候</p></blockquote><h3 id="对象-URL-与-Blob"><a href="#对象-URL-与-Blob" class="headerlink" title="对象 URL 与 Blob"></a>对象 URL 与 Blob</h3><p>引用储存在<code>File</code>或<code>Blob</code>中数据的<code>URL</code></p><p>**优点:**不用把文件内容读取到 JavaScript 也可以使用文件 只要在适当的位置提供对象 URL 即可</p><p>使用 <code>window.URL.createObjectURL()</code>方法并传入 <code>File</code> 或 <code>Blob</code> 对象 返回一个指向内存中<strong>地址</strong>的字符串 在<code>DOM</code>中可以直接使用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用对象URL在页面中显示一张图片</span></span><br><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"files-list"</span>);</span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">'change'</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">''</span>,</span><br><span class="line">output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"output"</span>),</span><br><span class="line"> progress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"progress"</span>),</span><br><span class="line"> files = event.<span class="property">target</span>.<span class="property">files</span>,</span><br><span class="line"> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(),</span><br><span class="line"> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(files[<span class="number">0</span>]);</span><br><span class="line"> <span class="keyword">if</span>(url) {</span><br><span class="line"> <span class="keyword">if</span>(<span class="regexp">/image/</span>.<span class="title function_">test</span>(files[<span class="number">0</span>].<span class="property">type</span>)) {</span><br><span class="line"> output.<span class="property">innerHTML</span> = <span class="string">`&lt;img src="<span class="subst">${url}</span>"&gt;`</span>;</span><br><span class="line"></span><br><span class="line"> }esle {</span><br><span class="line"> output.<span class="property">innerHTML</span> = <span class="string">"Not an image."</span>;</span><br><span class="line"> }</span><br><span class="line"> }<span class="keyword">else</span> {</span><br><span class="line">  output.<span class="property">innerHTML</span> = <span class="string">"Your browser doesn't support object URLs."</span>;</span><br><span class="line"> }</span><br><span class="line">})</span><br><span class="line"><span class="comment">//如果把对象 URL 直接放到&lt;img&gt;标签，就不需要把数据先读到 JavaScript 中了。&lt;img&gt;标签可以直</span></span><br><span class="line"><span class="comment">//接从相应的内存位置把数据读取到页面上。</span></span><br></pre></td></tr></tbody></table></figure><p>使用完数据之后，最好能释放与之关联的内存。只要对象 URL 在使用中，就不能释放内存。如果 想表明不再使用某个对象 URL，则可以把它传给 window.URL.revokeObjectURL()。页面卸载时， 所有对象 URL 占用的内存都会被释放。不过，最好在不使用时就立即释放内存，以便尽可能保持页面 占用最少资源</p><h3 id="读取拖放文件"><a href="#读取拖放文件" class="headerlink" title="读取拖放文件"></a>读取拖放文件</h3><p>拖放文件可以像拖放图片或连接一样触发<code>drop</code>事件 被放置的文件可以通过事件的<code>event.dataTransfer.files</code>属性读到 这个属性保存着一组 File 对象 就像文本输入字段一样</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> droptarget = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"droptarget"</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleEvent</span>(<span class="params">event</span>) {</span><br><span class="line">  <span class="keyword">let</span> info = <span class="string">""</span>,</span><br><span class="line">    output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"output"</span>),</span><br><span class="line">    files,</span><br><span class="line">    i,</span><br><span class="line">    len;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">type</span> == <span class="string">"drop"</span>) {</span><br><span class="line">    files = event.<span class="property">dataTransfer</span>.<span class="property">files</span>;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    len = files.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) {</span><br><span class="line">      info += <span class="string">`<span class="subst">${files[i].name}</span> (<span class="subst">${files[i].type}</span>, <span class="subst">${files[i].size}</span> bytes)&lt;br&gt;`</span>;</span><br><span class="line">      i++;</span><br><span class="line">    }</span><br><span class="line">    output.<span class="property">innerHTML</span> = info;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">"dragenter"</span>, handleEvent);</span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">"dragover"</span>, handleEvent);</span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">"drop"</span>, handleEvent);</span><br><span class="line"><span class="comment">//必须取消dragenter、dragover和drop的默认行为 在drop事件处理程序中 可以通过event.dataTransfer.files 读到文件，此时可以获取文件的相关信息</span></span><br></pre></td></tr></tbody></table></figure><h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/24/595504b72117d4fb.png"></p><p><img src="https://i.bmp.ovh/imgs/2022/04/24/539327ac86e98fdd.png"></p><p><img src="https://i.bmp.ovh/imgs/2022/04/24/afd2eed69d58a3dd.png"></p><h3 id="检测编解码器"><a href="#检测编解码器" class="headerlink" title="检测编解码器"></a>检测编解码器</h3><p>有一个<code>canPlayType()</code>的方法 接收一个格式/编解码器字符串 返回一个”probably”、”maybe”或””</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (audio.<span class="title function_">canPlayType</span>(<span class="string">"audio/mpeg"</span>)) {</span><br><span class="line"> <span class="comment">// 执行某些操作</span></span><br><span class="line">}</span><br><span class="line"><span class="string">"probably"</span>和<span class="string">"maybe"</span>都是真值，在 <span class="keyword">if</span> 语句的上下文中可以转型为 <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Notifications-API"><a href="#Notifications-API" class="headerlink" title="Notifications API"></a>Notifications API</h2><p>用于向用户显示通知</p><ul><li>通知只能运行再安全上下文的代码中被触发</li><li>通知必须按照每个源的原则明确得到用户允许</li></ul><p>浏览器会记住用户的选择 如果被拒绝则无法重来</p><h3 id="通知授权"><a href="#通知授权" class="headerlink" title="通知授权"></a>通知授权</h3><p>页面可以使用全局对象<code>Notification</code> 向用户请求通知权限 这个对象会有一个<code>requestPermission()</code> 返回一个<code>promise</code>对象 用户在授权对话框上执行操作后这个<code>promise</code>会被解决</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Notification</span>.<span class="title function_">requestPermission</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">permission</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"User responded to permission request:"</span>, permission);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p><code>"granted"</code>值意味着用户明确授权了显示通知的权限。除此之外的其他值意味着显示通知会静默失 败。如果用户拒绝授权，这个值就是<code>"denied"</code>。一旦拒绝，就无法通过编程方式挽回，因为不可能再 触发授权提示。</p><h3 id="显示和隐藏通知"><a href="#显示和隐藏通知" class="headerlink" title="显示和隐藏通知"></a>显示和隐藏通知</h3><p>Notification 构造函数用于创建和显示通知</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">"Title text!"</span>, {</span><br><span class="line">  <span class="attr">body</span>: <span class="string">"Body text!"</span>,</span><br><span class="line">  <span class="attr">image</span>: <span class="string">"path/to/image.png"</span>,</span><br><span class="line">  <span class="attr">vibrate</span>: <span class="literal">true</span>,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> n = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">"I will close in 1000ms"</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> n.<span class="title function_">close</span>(), <span class="number">1000</span>); <span class="comment">//调用close关闭通知</span></span><br></pre></td></tr></tbody></table></figure><h3 id="通知生命周期"><a href="#通知生命周期" class="headerlink" title="通知生命周期"></a>通知生命周期</h3><ul><li><code>onshow</code> 在通知显示时触发</li><li><code>onshow</code> 在通知显示时触发</li><li><code>onclose</code> 在通知消失或通过 close()关闭时触发</li><li><code>onclose</code> 在通知消失或通过 close()关闭时触发</li></ul><h2 id="Page-Visibility-API"><a href="#Page-Visibility-API" class="headerlink" title="Page Visibility API"></a>Page Visibility API</h2><p>为开发者提供页面对用户是否可见的信息</p><ul><li><code>document.visibilityState</code> 值，表示下面 4 种状态之一<ul><li>页面在后台标签页或浏览器中最小化了。</li><li>页面在前台标签页中</li><li>实际页面隐藏了，但对页面的预览是可见的（例如在 Windows 7 上，用户鼠标移到任务栏图标 上会显示网页预览）。</li><li>页面在屏外预渲染</li></ul></li><li><code>visibilitychange</code> 事件，该事件会在文档从隐藏变可见（或反之）时触发</li><li><code>document.hidden</code> 布尔值，表示页面是否隐藏。这可能意味着页面在后台标签页或浏览器中被最小 化了。这个值是为了向后兼容才继续被浏览器支持的，应该优先使用 <code>document.visibilityState</code> 检测页面可见性</li></ul><h2 id="计时-API"><a href="#计时-API" class="headerlink" title="计时 API"></a>计时 API</h2><h3 id="High-Resolution-Time-API"><a href="#High-Resolution-Time-API" class="headerlink" title="High Resolution Time API"></a>High Resolution Time API</h3><p><code>Date.now()</code>不精确</p><p><code>performance.now()</code>:相对度量 计时器在执行上下文创建时从 0 开始</p><p><code>performance.timeOrigin</code> 属性返回计时器初始化时全局系统时钟的值</p><p><code>performance.getEntries()</code>：性能时间线（performance timeline）。每个 PerformanceEntry 对象 都有 name、entryType、startTime 和 duration 属性</p><h1 id="错误处理和调试"><a href="#错误处理和调试" class="headerlink" title="错误处理和调试"></a>错误处理和调试</h1><p>为了保证浏览器兼容 最好只使用<code>message</code></p><blockquote><p>只要代码中包含了<code>finally</code>子块 <code>try</code> 块或 <code>catch</code> 块中的 <code>return</code> 语句就会被忽 略</p></blockquote><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ul><li>Error</li><li>InternalError ：底层 JavaScript 引擎发出异常时由浏览器抛出 如递归过多导致栈移除 发生这种错误一般是出了问题</li><li><code>EvalError</code> ：使用<code>eval()</code>函数发生异常时抛出</li><li><code>RangeError</code> ：数值越界</li><li><code>ReferenceError</code> ：找不到对象时发生或者变量</li><li><code>SyntaxErro</code>：r 经常在给 <code>eval()</code>传入的字符串包含 JavaScript 语法错误时发生</li><li><code>TypeError</code> 主要发生在变量不是预期类型，或者访问不存在的方法时</li><li>``URIError<code>使用 </code>encodeURI()<code>或 </code>decodeURI()`但传入了格式错误的 URI 时发</li></ul><p>可以在 try/vatch 中使用 instance of 操作符确定错误的类型</p><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>使用 <code>throw</code> 操作符时，代码立即停止执行，除非 <code>try/catch</code> 语句捕获了抛出的值。</p><p>可以通过继承 ERROR 来创建自定义的类型错误 创建自定义类型错误需要提供<code>name</code>以及<code>message</code>属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message</span>) {</span><br><span class="line">    <span class="variable language_">super</span>(message);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">"CustomError"</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">message</span> = message;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomError</span>(<span class="string">"My message"</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>使用自定义错误有助于捕获错误时更准确地区分错误</strong></p><h3 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h3><p>任何没有被<code>try/catch</code>处理的错误都会在<code>window</code>对象上触发<code>error</code>事件</p><h3 id="错误处理策略"><a href="#错误处理策略" class="headerlink" title="错误处理策略"></a>错误处理策略</h3><p>最好使用(===)来避免比较时发生类型转换</p><p>在流控制语句中使用非布尔值作为条件时很常见的错误来源 为避免这种错误 需要始终坚持使用布尔值作为条件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不好的写法</span></span><br><span class="line"> <span class="keyword">if</span> (str3) { <span class="comment">// 不要！</span></span><br><span class="line"> <span class="comment">//好的写法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str3 === <span class="string">"string"</span>) { <span class="comment">// 恰当的比</span></span><br></pre></td></tr></tbody></table></figure><p>如果知道预期的确切类型 最好使用<code>instanceof</code>来确定值的正确类型</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (values) { // 不要</span><br><span class="line">if (values) { // 不要</span><br><span class="line"> if (typeof values.sort === "function") { // 不要</span><br><span class="line">  if (values instanceof Array) { // 修复</span><br></pre></td></tr></tbody></table></figure><blockquote><p>一般来说 原始类型的值应该使用 typeof 检测 而对象值应该使用 instanceof 检测</p></blockquote><h4 id="抛出错误-1"><a href="#抛出错误-1" class="headerlink" title="抛出错误"></a>抛出错误</h4><p>在大型应用程序中，自定义错误通常使用 <code>assert()</code>函数抛出错误。这个函数接收一个应该为 <code>true</code> 的条件，并在条件为 false 时抛出错误</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">condition, message</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!condition) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//这个 assert()函数可用于代替多个 if 语句，同时也是记录错误的好地方</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">num1, num2</span>) {</span><br><span class="line">  <span class="title function_">assert</span>(</span><br><span class="line">    <span class="keyword">typeof</span> num1 == <span class="string">"number"</span> &amp;&amp; <span class="keyword">typeof</span> num2 == <span class="string">"number"</span>,</span><br><span class="line">    <span class="string">"divide(): Both arguments must be numbers."</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> num1 / num2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="网络请求与远程资源"><a href="#网络请求与远程资源" class="headerlink" title="网络请求与远程资源"></a>网络请求与远程资源</h1><h2 id="跨源资源共享"><a href="#跨源资源共享" class="headerlink" title="跨源资源共享"></a>跨源资源共享</h2><p><code>CORS:</code>定义了浏览器和服务器如何实现跨源通信（背后的基本思路就是使用自定义的 HTTP 头部允许浏览器服务器相互了解 以确定请求或响应应该成功还是失败）</p><p>对于简单的请求（<code>get/post</code>）没有自定义头部 而且请求体是<code>text/plain</code>类型 这样的请求在发送时会有一个额外的头部教<code>Origin</code> <code>Origin</code>头部包含发送请求的页面的源（协议、域名和端口）以便服务器确定是否为其提供响应</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://www.nczonline.net</span><br><span class="line">如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源；</span><br><span class="line">或者如果资源是公开的，那么就包含"*"。</span><br><span class="line">如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个</span><br><span class="line">请求。注意，无论请求还是响应都不会包含 cookie 信息</span><br></pre></td></tr></tbody></table></figure><blockquote><p>因为无论同域还是跨域请求都使用同一个接口 所以最好在访问本地资源时使用相对 URL 在访问远程资源时使用绝对 URL 这样可以更明确区分使用场景 同时避免出现访问本地资源时出现头部或 cookie 信息访问受限的问题</p></blockquote><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p><code>CORS</code>通过一种教预检请求的服务器验证机制 允许自定义头部、除<code>GET和POST</code>之外的方法 以及不同请求体内容类型 预检请求使用<code>OPTIONS</code>发送包含以下头部</p><ul><li><code>origin</code>：与简单请求相同</li><li><code>Access-Control-Request-Method</code>：请求希望使用的方法。</li><li><code>Access-Control-Request-Headers</code>：（可选）要使用的逗号分隔的自定义头部列表</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">下面假设一个post请求 包含自定义的NCZ头部：</span><br><span class="line">Origin: http://www.nczonline.net</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: NCZ</span><br><span class="line">在这个请求发送后 服务器可以确定是否允许这种类型的请求 服务器会通过响应中发送以下头部与浏览器沟通这些信息</span><br><span class="line">Access-Control-Allow-Origin：与简单请求相同</span><br><span class="line">Access-Control-Allow-Methods：允许的方法（逗号分隔的列表</span><br><span class="line">Access-Control-Allow-Headers：服务器允许的头部（逗号分隔的列表）</span><br><span class="line">Access-Control-Max-Age：缓存预检请求的秒数</span><br><span class="line">例如：</span><br><span class="line">Access-Control-Allow-Origin: http://www.nczonline.net</span><br><span class="line">Access-Control-Allow-Methods: POST, GET</span><br><span class="line">Access-Control-Allow-Headers: NCZ</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></tbody></table></figure><p><strong>预检请求返回后 结果会按响应指定的时间缓存一段时间 换句话说 只有第一次发送这种类型的请求时才会多发送一次额外的 http 请求</strong></p><h3 id="凭据请求"><a href="#凭据请求" class="headerlink" title="凭据请求"></a>凭据请求</h3><p>默认情况下 跨源请求不提供凭据（cookie、HTTP 认证和客户端 SSL 证书） 可以通过将<code>withCredentials</code>属性设置为 true 来表明请求会发送凭据 如果服务器允许携带凭据的话 可以包含<code>Access-Control-Allow-Credentials: true</code></p><h3 id="Headers-对象"><a href="#Headers-对象" class="headerlink" title="Headers 对象"></a>Headers 对象</h3><p><strong>Headers 对象是所有外发请求和入站响应头部的容器</strong></p><h1 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h1><h3 id="cookie：服务器在响应-http-请求时-通过发送-Set-CookieHTTP-头部会话信息"><a href="#cookie：服务器在响应-http-请求时-通过发送-Set-CookieHTTP-头部会话信息" class="headerlink" title="cookie：服务器在响应 http 请求时 通过发送 Set-CookieHTTP 头部会话信息"></a>cookie：服务器在响应 http 请求时 通过发送 Set-CookieHTTP 头部会话信息</h3><p>cookie 是与特定域绑定的 设置 cookie 后 他会与请求一起发送到创建它的域 这个限制能保证 cookie 中存储的信息只对被认可的接收者开放 不被其他域访问</p><p>cookie 的构成</p><ul><li>名称：唯一表示 cookie 的名称 不区分大小写 必须经过 URL 编码</li><li>值：存储在 cookie 中的字符串 这个值必须经过 URL 编码</li><li>域：cookie 有效的域 发送到这个域的所有请求都会包含到对应的 cookie</li><li>路径：请求 URL 中包含这个路径才会把 cookie 发送到服务器</li><li>过期时间：合适删除 cookie 的时间戳（什么时间之后就不发送到服务器了）</li><li>安全标志：设置之后 只有在使用 SSL 安全连接的情况下才会把 cookie 发送到服务器</li></ul><h4 id="JavaScript-中的-cookie"><a href="#JavaScript-中的-cookie" class="headerlink" title="JavaScript 中的 cookie"></a>JavaScript 中的 cookie</h4><p><code>document.cookie</code>返回包含页面中所有有效 cookie 的字符串（根据域、路径、过期时间和安全设置）</p><p>根据域、路径、过期时间和安全设置</p><p>所有名和值都是 URL 编码 因此必须通过<code>decodeURIComponent()</code>解码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(decodeURIComponent(document.cookie));</span><br><span class="line">//_octo=GH1.1.1592692317.1629286532; tz=Asia/Shanghai</span><br></pre></td></tr></tbody></table></figure><p>在设置值是 可以通过<code>document.cookie</code>设置新的 cookie 字符串 这个字符串在被解析之后会添加到原有的<code>cookie</code>中 设置<code>document.cookie</code>不会覆盖之前任何的<code>cookie</code> 除非设置了已有的 cookie</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = "name=Nicholas";</span><br></pre></td></tr></tbody></table></figure><p><code>CookieUtil.get()</code>方法用于取得给定名称的 cookie 值</p><p><code>CookieUtil.set()</code>方法用于设置页面上的 cookie</p><h4 id="子-cookie：为了绕过浏览器对每个域-cookie-数的限制"><a href="#子-cookie：为了绕过浏览器对每个域-cookie-数的限制" class="headerlink" title="子 cookie：为了绕过浏览器对每个域 cookie 数的限制"></a>子 cookie：为了绕过浏览器对每个域 cookie 数的限制</h4><p>在单个 cookie 存储的小块数据 本质上是使用 cookie 的值在单个 cookie 中存储多个名/值对 如</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5</span><br></pre></td></tr></tbody></table></figure><p>子 cookie 的格式类似于查询字符串 这些值可以储存单个 cookie 而不用单独存储为自己的名/值对 结果就是网站或者 Web 应用程序能够在单域 cookie 数限制下存储更多的结构化数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//要取得某个子cookie 必须先取得cookie 然后在解码值之前需要先像下面这样找到子cookie</span><br><span class="line">class SubCookieUtil {</span><br><span class="line"> static get(name, subName) {</span><br><span class="line"> let subCookies = SubCookieUtil.getAll(name); //getAll用于取得所有子cookie的值 get用于取得一个子cookie</span><br><span class="line"> return subCookies ? subCookies[subName] : null;</span><br><span class="line"> }</span><br><span class="line"> static getAll(name) {</span><br><span class="line"> let cookieName = encodeURIComponent(name) + "=",</span><br><span class="line"> cookieStart = document.cookie.indexOf(cookieName),</span><br><span class="line"> cookieValue = null,</span><br><span class="line"> cookieEnd,</span><br><span class="line"> subCookies,</span><br><span class="line"> parts,</span><br><span class="line"> result = {};</span><br><span class="line"> if (cookieStart &gt; -1) {</span><br><span class="line"> cookieEnd = document.cookie.indexOf(";", cookieStart);</span><br><span class="line"> if (cookieEnd == -1) {</span><br><span class="line"> cookieEnd = document.cookie.length;</span><br><span class="line"> }</span><br><span class="line"> cookieValue = document.cookie.substring(cookieStart +</span><br><span class="line"> cookieName.length, cookieEnd);</span><br><span class="line"> if (cookieValue.length &gt; 0) {</span><br><span class="line"> subCookies = cookieValue.split("&amp;");</span><br><span class="line"> for (let i = 0, len = subCookies.length; i &lt; len; i++) {</span><br><span class="line"> parts = subCookies[i].split("=");</span><br><span class="line"> result[decodeURIComponent(parts[0])] =</span><br><span class="line"> decodeURIComponent(parts[1]);</span><br><span class="line"> }</span><br><span class="line"> return result;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> return null;</span><br><span class="line"> }</span><br><span class="line"> // 省略其他代码</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-cookie-的注意事项"><a href="#使用-cookie-的注意事项" class="headerlink" title="使用 cookie 的注意事项"></a>使用 cookie 的注意事项</h4><p><code>HTTP-only</code>可在浏览器设置 也可以在服务器设置 但是只能在服务器上读取 这是因为 JavaScript 无法取得这种 cookie 的值</p><p><code>**http-only</code>的作用**</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果cookie中设置了http-only属性 那么通过js脚本无法读取cookie信息 这样能有效防止XSS攻击 窃取cookie内容 这样增加了cookie1的安全性</span><br><span class="line">XSS攻击：跨站脚本攻击 属于被动式且客户端的攻击方式 原理是攻击者向有XSS漏洞的网站中输入恶意HTML代码 当其他用户浏览该网站时 这段HTML代码会自动执行 从而达到攻击的目的 通常用来盗取用户Cookie 破坏页面结构 重定向到其他网站等</span><br></pre></td></tr></tbody></table></figure><p>因为所有 cookie 都会作为请求头部由浏览器发送给服务器，所以在 cookie 中保存大量信息可能会影 响特定域浏览器请求的性能。保存的 cookie 越大，请求完成的时间就越长。即使浏览器对 cookie 大小有 限制，最好还是尽可能只通过 cookie 保存必要信息，以避免性能问题。 对 cookie 的限制及其特性决定了 cookie 并不是存储大量数据的理想方式。因此，其他客户端存储技 术出现</p><blockquote><p>不要在 cookie 中存储重要或敏感的信息。cookie 数据不是保存在安全的环境中，因 此任何人都可能获得。应该避免把信用卡号或个人地址等信息保存在 cookie 中</p></blockquote><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p>解决通过客户端储存不需要频繁发送回服务器的数据时使用 cookie 的问题</p><ul><li>提供在 cookie 之外的储存会话数据的途径</li><li>提供跨会话持久化储存大量数据的机制</li></ul><p><code>localStorage</code> 是 永久存储机制，<code>sessionStorage</code> 是跨会话的存储机制</p><h4 id="Storage-类型"><a href="#Storage-类型" class="headerlink" title="Storage 类型"></a>Storage 类型</h4><p>用于保存名/值对数据</p><ul><li><code>clear（）</code>：删除所有值</li><li><code>getItem(name)</code>:取得给定 name 的值</li><li><code>key(index):</code>取得给定数值位置名称</li><li><code>removeItem(name):</code>删除给定的 name 的名/值对</li><li><code>setItem(name, value)</code>:设置给定 name 的值</li></ul><h4 id="sessionStorage-对象"><a href="#sessionStorage-对象" class="headerlink" title="sessionStorage 对象"></a>sessionStorage 对象</h4><p><code>sessionStorage</code> 对象只存储会话数据，这意味着数据只会存储到浏览器关闭</p><p>因为 <code>sessionStorag</code>e 对象与服务器会话紧密相关，所以在运行本地文件时不能使用。存储在 <code>sessionStorage</code> 对象中的数据只能由最初存储数据的页面使用，在多页应用程序中的用处有限</p><p><strong>浏览器在实现存储的时候使用同步阻塞方式 因此数据会立即被提交到储存</strong></p><p><strong>通过 webStorage 写入的任何数据都能被立即读取</strong></p><p>可以使用 for-in 循环迭代<code>sessionStorage</code>的值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> sessionStorage) {</span><br><span class="line">  <span class="comment">//每次循环 key都会被赋予sessionStorage中的一个名称 这里不会返回内置方法或length属性</span></span><br><span class="line">  <span class="keyword">let</span> value = sessionStorage.<span class="title function_">getItem</span>(key);</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">${key}</span>=<span class="subst">${value}</span>`</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以使用<code>delete</code>或<code>removeItem</code>删除<code>sessionStorage</code>的数据</p><h4 id="localStorage-对象"><a href="#localStorage-对象" class="headerlink" title="localStorage 对象"></a>localStorage 对象</h4><p><strong>要想访问同一个 localStorage 对象 页面必须来自同一个域（子域不可以</strong>） <strong>在相同的端口上使用相同的协议</strong></p><p>两种存储方法的区别在于，存储在 localStorage 中的数据会保留到通过 JavaScript 删除或者用户 清除浏览器缓存。localStorage 数据不受页面刷新影响，也不会因关闭窗口、标签页或重新启动浏览 器而丢失。</p><h4 id="储存事件"><a href="#储存事件" class="headerlink" title="储存事件"></a>储存事件</h4><p>每当 Storage 对象发生变化时 都会在文档上触发 storage 事件</p><ul><li><code>domain</code>：存储变化对应的域。</li><li><code>key：</code>被设置或删除的键。。</li><li><code>newValue</code>：键被设置的新值，若键被删除则为 null。</li><li><code>oldValue</code>：键变化之前的值。</li></ul><p>对于 <code>sessionStorage</code> 和 <code>localStorage</code> 上的任何更改都会触发 storage 事件，但 storage 事 件不会区分这两者</p><h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><p><code>indexedDB</code>的请求几乎都是<strong>异步</strong>的 添加<code>onerror</code>和<code>onsuccess</code> 事件处理程序来确定输出</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>使用对象储存</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db,</span><br><span class="line">  request,</span><br><span class="line">  version = <span class="number">1</span>;</span><br><span class="line">request = indexedDB.<span class="title function_">open</span>(<span class="string">"admin"</span>, version); <span class="comment">//如果存在数据库就打开 否则发送创建并打开这个数据库的请求</span></span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  event <span class="comment">//失败事件</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">`Failed to open: <span class="subst">${event.target.errorCode}</span>`</span>);</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">//成功事件</span></span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>简历好数据库连接后就是使用对象储存了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设插入一条user记录</span></span><br><span class="line"><span class="keyword">let</span> user = {</span><br><span class="line">  <span class="attr">username</span>: <span class="string">"007"</span>,</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">"James"</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">"Bond"</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">"foo"</span>,</span><br><span class="line">}; <span class="comment">//用户名必须全局唯一 因为创建储存时必须指定一个键</span></span><br><span class="line"><span class="comment">//open操作触发了upgradeneeded事件 因此可以在事件处理程序中更新数据库模式</span></span><br><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="comment">// 如果存在则删除当前 objectStore。测试的时候可以这样做</span></span><br><span class="line">  <span class="comment">// 但这样会在每次执行事件处理程序时删除已有数据</span></span><br><span class="line">  <span class="keyword">if</span> (db.<span class="property">objectStoreNames</span>.<span class="title function_">contains</span>(<span class="string">"users"</span>)) {</span><br><span class="line">    db.<span class="title function_">deleteObjectStore</span>(<span class="string">"users"</span>);</span><br><span class="line">  }</span><br><span class="line">  db.<span class="title function_">createObjectStore</span>(<span class="string">"users"</span>, { <span class="attr">keyPath</span>: <span class="string">"username"</span> }); <span class="comment">//这里第二个参数的 keyPath 属性表示应该用作键的存储对象的属性名。</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务通过调用数据库对象的<code>transaction</code>方法创建</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> transaction = db.<span class="property">transaction</span>; <span class="comment">//如果不指定参数 则对数据库中所有对象储存有只读权限</span></span><br><span class="line"><span class="comment">//可以指定一个或多个要访问的对象存储的名称（传入名称数组）</span></span><br><span class="line"><span class="keyword">let</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">"users"</span>, <span class="string">"readwrite"</span>); <span class="comment">//"readonly"、"readwrite"或"versionchange"权限问题</span></span><br></pre></td></tr></tbody></table></figure><p>有了事务的引用，就可以使用 <code>objectStore()</code>方法并传入对象存储的名称以访问特定的对象存储。 然后，可以使用 <code>add()</code>和 <code>put()</code>方法添加和更新对象，使用 <code>get()</code>取得对象，使用 <code>delete(</code>)删除对象， 使用 <code>clear()</code>删除所有对象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">"users"</span>),</span><br><span class="line">  store = transaction.<span class="title function_">objectStore</span>(<span class="string">"users"</span>),</span><br><span class="line">  request = store.<span class="title function_">get</span>(<span class="string">"007"</span>);</span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">"Did not get the object!"</span>);</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">result</span>.<span class="property">firstName</span>);</span><br><span class="line">transaction.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 整个事务被取消</span></span><br><span class="line">};</span><br><span class="line">transaction.<span class="property">oncomplete</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 整个事务成功完成</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>不能通过<code>oncomplete</code>事件处理程序的<code>event</code>对象访问<code>get（）</code>请求返回的任何数据 因此 仍然需要通过请求的<code>onsuccess</code>事件处理程序来获取数据</p><h4 id="插入对象"><a href="#插入对象" class="headerlink" title="插入对象"></a>插入对象</h4><p>使用<code>add()</code>或<code>put()</code>写入数据 <code>add（）</code>是插入新值 而<code>put</code>是更新值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users 是一个用户数据的数组</span></span><br><span class="line"><span class="keyword">let</span> request,</span><br><span class="line">  requests = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> users) {</span><br><span class="line">  request = store.<span class="title function_">add</span>(user); <span class="comment">//将请求对象保存到一个变量 然后为它添加onerror和onSuccess事件</span></span><br><span class="line">  request.<span class="property">onerror</span> = <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  };</span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// 处理成功</span></span><br><span class="line">  };</span><br><span class="line">  requests.<span class="title function_">push</span>(request);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="通过游标查询"><a href="#通过游标查询" class="headerlink" title="通过游标查询"></a>通过游标查询</h4><p>如果想要取得多条数据 则需要在事务中创建一个游标（指向结果集的指针）使用<code>openCursor()</code>创建</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onst transaction = db.<span class="title function_">transaction</span>(<span class="string">"users"</span>),</span><br><span class="line"> store = transaction.<span class="title function_">objectStore</span>(<span class="string">"users"</span>),</span><br><span class="line"> request = store.<span class="title function_">openCursor</span>();</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"> <span class="comment">// 处理成功</span></span><br><span class="line">    <span class="comment">//可以通过event.target.result访问对象储存中的下一条记录 包含着IDBCursor实例</span></span><br><span class="line">    <span class="comment">//包括属性：direction、 key、 value：实际的对象（需要用JSON编码） primaryKey：游标使用的键</span></span><br><span class="line">};</span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"> <span class="comment">// 处理错误</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>游标可用于更新个别记录 <code>update（）</code>方法指定使用的对象更新当前游标对应的值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"> <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"> <span class="keyword">let</span> value,</span><br><span class="line"> updateRequest;</span><br><span class="line"> <span class="keyword">if</span> (cursor) { <span class="comment">// 永远要检查</span></span><br><span class="line"> <span class="keyword">if</span> (cursor.<span class="property">key</span> == <span class="string">"foo"</span>) {</span><br><span class="line"> value = cursor.<span class="property">value</span>; <span class="comment">// 取得当前对象</span></span><br><span class="line"> value.<span class="property">password</span> = <span class="string">"magic!"</span>; <span class="comment">// 更新密码</span></span><br><span class="line"> updateRequest = cursor.<span class="title function_">update</span>(value); <span class="comment">// 请求保存更新后的对象</span></span><br><span class="line"> updateRequest.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> {</span><br><span class="line"> <span class="comment">// 处理成功</span></span><br><span class="line"> };</span><br><span class="line"> updateRequest.<span class="property">onerror</span> = <span class="function">() =&gt;</span> {</span><br><span class="line"> <span class="comment">// 处理错误</span></span><br><span class="line"> };</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> <span class="comment">//也可以调用delete（）删除游标位置的记录</span></span><br></pre></td></tr></tbody></table></figure><p>如果事务没有修改对象储存的权限 <code>uodate（）和delete（）</code>都会抛出错误</p><p>默认情况下 每个游标只会创建一个请求 如果想要创建另一个请求 必须调用以下方法</p><ul><li><code>continue（key）</code>：移动到结果集中的下一条记录 如果没有指定 key 则移动到下一条 否则移动到指定的</li><li><code>advance（count）</code>：向前移动指定 count 条记录</li></ul><p>这两个方法都会让游标重用相同的请求 因此也会重用<code>onsuccess和onerror</code>处理程序 知道不需要</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">if</span> (cursor) {</span><br><span class="line">    <span class="comment">// 永远要检查</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Key: <span class="subst">${cursor.key}</span>, Value: <span class="subst">${<span class="built_in">JSON</span>.stringify(cursor.value)}</span>`</span>);</span><br><span class="line">    cursor.<span class="title function_">continue</span>(); <span class="comment">// 移动到下一条记录</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Done!"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="comment">//调用cursor.continue()会触发另一个请求并再次调用onsuccess事件处理程序 在没有更多记录时 onsuccess最后一次被调用 此时event.target.result = null</span></span><br></pre></td></tr></tbody></table></figure><h4 id="键范围"><a href="#键范围" class="headerlink" title="键范围"></a>键范围</h4><p>使用键范围可以让游标更容易管理 键范围对应 IDBKeyRange 的实例</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onlyRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">only</span>(<span class="string">"007"</span>);</span><br><span class="line">这个范围保证只获取键为<span class="string">"007"</span>的值。使用这个范围创建的游标类似于直接访问对象存储并调用</span><br><span class="line"><span class="title function_">get</span>(<span class="string">"007"</span>)。</span><br><span class="line">第二种键范围可以定义结果集的下限。下限表示游标开始的位置。例如，下面的键范围保证游标从</span><br><span class="line"><span class="string">"007"</span>这个键开始，直到最后：</span><br><span class="line"><span class="comment">// 从"007"记录开始，直到最后</span></span><br><span class="line"><span class="keyword">const</span> lowerRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">lowerBound</span>(<span class="string">"007"</span>); <span class="comment">//如果想要从后面的记录开始 则传入true</span></span><br><span class="line">第二种键范围可以定义结果集的下限。下限表示游标开始的位置。例如，下面的键范围保证游标从</span><br><span class="line"><span class="string">"007"</span>这个键开始，直到最后：</span><br><span class="line"><span class="comment">// 从"007"记录开始，直到最后</span></span><br><span class="line"><span class="keyword">const</span> lowerRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">lowerBound</span>(<span class="string">"007"</span>);<span class="comment">//不想包含指定的键 则传入true</span></span><br><span class="line">要同时指定下限和上限，可以使用 <span class="title function_">bound</span>()方法。这个方法接收四个参数：下限的键、上限的键、</span><br><span class="line">可选的布尔值表示是否跳过下限和可选的布尔值表示是否跳过上限</span><br><span class="line">要同时指定下限和上限，可以使用 <span class="title function_">bound</span>()方法。这个方法接收四个参数：下限的键、上限的键、</span><br><span class="line">可选的布尔值表示是否跳过下限和可选的布尔值表示是否跳过上限</span><br><span class="line">定义了范围之后，把它传给 <span class="title function_">openCursor</span>()方法，就可以得到位于该范围内的游标：</span><br><span class="line"><span class="keyword">const</span> store = db.<span class="title function_">transaction</span>(<span class="string">"users"</span>).<span class="title function_">objectStore</span>(<span class="string">"users"</span>),</span><br><span class="line"> range = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">"007"</span>, <span class="string">"ace"</span>);</span><br><span class="line"> request = store.<span class="title function_">openCursor</span>(range);</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params">event</span>){</span><br><span class="line"> <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"> <span class="keyword">if</span> (cursor) { <span class="comment">// 永远要检查</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Key: <span class="subst">${cursor.key}</span>, Value: <span class="subst">${<span class="built_in">JSON</span>.stringify(cursor.value)}</span>`</span>);</span><br><span class="line"> cursor.<span class="title function_">continue</span>(); <span class="comment">// 移动到下一条记录</span></span><br><span class="line"> } <span class="keyword">else</span> {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Done!"</span>);</span><br><span class="line"> }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p>如果两个不同的浏览器标签同时打开了同一个网页 可能出现一个网页尝试升级数据库而另一个网页尚未就绪的情形</p><p>应该在每次成功打开数据库后都指定 onversionchange 事件处理程序。记住，onversionchange 有可能会被其他标签页触发。</p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>无论一个模块在 require（）中被引用多少次 模块永远时单例（无论请求多少次 module 只会被加载一次）</p><p>模块第一次被加载后会被缓存 后续加载会取得缓存的模块 模块加载顺序由依赖图决定</p><p>在 CommonJS 中 模块加载是模块系统的同步操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"moduleA"</span>);</span><br><span class="line"><span class="keyword">if</span> (loadCondition) {</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">"./moduleA"</span>); <span class="comment">//moduleA会在loadCondition为true是才会加载 这个加载是同步的 因此if之前的任何代码都会在加载moduleA之前执行 而if之后的任何代码都会在module执行之后执行 如果moduleA已经在前面某个地方加载过 这个条件的require意味着只暴露moduleA这个命名空间而已</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="异步模块定义（AMD）"><a href="#异步模块定义（AMD）" class="headerlink" title="异步模块定义（AMD）"></a>异步模块定义（AMD）</h3><p><code>COmmonJS</code>以服务器为目标环境 能够一次性将所有的模块都加载到内存中 而异步模块定义（<code>AMD</code>）的模块定义系统则以浏览器为目标执行环境 这需要考虑网络延迟的问题。</p><p><code>AMD</code>的一般策略是让模块<strong>声明</strong>自己的依赖 而运行在浏览器中的模块系统会<strong>按需获取依赖</strong> 并在依赖<strong>加载完成后</strong>立即执行依赖他们的模块</p><p><code>AMD</code>模块实现的核心是用<strong>函数包装</strong>模块定义 这样可以防止声明<strong>全局变量</strong> 并允许加载器控制何时加载模块</p><p><code>AMD</code>模块可以使用字符串标识符指定自己的依赖 而<code>AMD加载器</code>会在所有依赖模块加载完毕后立即调用模块工厂函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ID 为'moduleA'的模块定义。moduleA 依赖 moduleB，</span></span><br><span class="line"><span class="comment">// moduleB 会异步加载</span></span><br><span class="line"><span class="title function_">define</span>(<span class="string">'moduleA'</span>, [<span class="string">'moduleB'</span>], <span class="keyword">function</span>(<span class="params">moduleB</span>) {</span><br><span class="line"> <span class="keyword">return</span> {</span><br><span class="line"> <span class="attr">stuff</span>: moduleB.<span class="title function_">doStuff</span>();</span><br><span class="line"> };</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>AMD 也支持<code>require和exports</code>对象 通过他们可以在 AMD 模块工厂函数内部定义 CommonJS 风格的模块</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="string">'moduleA'</span>, [<span class="string">'require'</span>, <span class="string">'exports'</span>], <span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span></span>) {</span><br><span class="line"> <span class="keyword">var</span> moduleB = <span class="built_in">require</span>(<span class="string">'moduleB'</span>);</span><br><span class="line"> <span class="built_in">exports</span>.<span class="property">stuff</span> = moduleB.<span class="title function_">doStuff</span>();</span><br><span class="line">});</span><br><span class="line">动态依赖也是通过这种方式支持的：</span><br><span class="line"><span class="title function_">define</span>(<span class="string">'moduleA'</span>, [<span class="string">'require'</span>], <span class="keyword">function</span>(<span class="params"><span class="built_in">require</span></span>) {</span><br><span class="line"> <span class="keyword">if</span> (condition) {</span><br><span class="line"> <span class="keyword">var</span> moduleB = <span class="built_in">require</span>(<span class="string">'moduleB'</span>);</span><br><span class="line"> }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h4><p><code>UMD</code>用于创建两个系统都可以使用的模块代码 本质上 UMD 定义的模块会在启动时检测到要使用那个模块系统 然后进行适当配置 并把所有逻辑包装在一个立即调用的函数表达式中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) {</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.<span class="property">amd</span>) {</span><br><span class="line">    <span class="comment">// AMD。注册为匿名模块</span></span><br><span class="line">    <span class="title function_">define</span>([<span class="string">"moduleB"</span>], factory);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="variable language_">module</span>.<span class="property">exports</span>) {</span><br><span class="line">    <span class="comment">// Node。不支持严格 CommonJS</span></span><br><span class="line">    <span class="comment">// 但可以在 Node 这样支持 module.exports 的</span></span><br><span class="line">    <span class="comment">// 类 CommonJS 环境下使用</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">" moduleB "</span>));</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 浏览器全局上下文（root 是 window）</span></span><br><span class="line">    root.<span class="property">returnExports</span> = <span class="title function_">factory</span>(root.<span class="property">moduleB</span>);</span><br><span class="line">  }</span><br><span class="line">})(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">moduleB</span>) {</span><br><span class="line">  <span class="comment">// 以某种方式使用 moduleB</span></span><br><span class="line">  <span class="comment">// 将返回值作为模块的导出</span></span><br><span class="line">  <span class="comment">// 这个例子返回了一个对象</span></span><br><span class="line">  <span class="comment">// 但是模块也可以返回函数作为导出值</span></span><br><span class="line">  <span class="keyword">return</span> {};</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h1 id="工作者线程"><a href="#工作者线程" class="headerlink" title="工作者线程"></a>工作者线程</h1><p>使用工作者线程 浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境 这个子环境不能与依赖单线程交互的 API 互操作 但可以与父环境并行执行代码</p><h3 id="工作者线程和线程"><a href="#工作者线程和线程" class="headerlink" title="工作者线程和线程"></a>工作者线程和线程</h3><ul><li>工作者线程是以实际线程实现的</li><li>工作者线程并行执行 虽然页面和工作者线程都是单线程 JavaScript 环境 每个环境中的指令可以并行执行</li><li>工作者线程可以共享某些内存 使用<code>SharedArrayBuffer</code> 在多个环境间共享 内容 JavaScript 使用 <code>Atomics</code> 接口实现并发控制</li><li>工作者线程不共享全部内存</li><li>工作者线程不一定再同一个进程里</li><li>创建工作者线程的开销更大 工作者线程有自己独立的<strong>事件循环</strong> <strong>全局对象</strong> <strong>事件处理程序</strong>和其他 js<strong>环境</strong>必须的特性</li></ul><p><strong>工作者线程相对比较重 不建议大量使用 工作者线程应该是长期运行的 启动成本比较高 每个实例占用的内存耶比较大</strong></p><h3 id="工作者线程的类型"><a href="#工作者线程的类型" class="headerlink" title="工作者线程的类型"></a>工作者线程的类型</h3><p>专用工作者线程、共享工作者线程和服务工作者线程</p><h4 id="专用工作者线程"><a href="#专用工作者线程" class="headerlink" title="专用工作者线程"></a>专用工作者线程</h4><p>可以让脚本单独创建一个 js 线程 只能被创建它的页面使用</p><h4 id="共享工作者线程"><a href="#共享工作者线程" class="headerlink" title="共享工作者线程"></a>共享工作者线程</h4><p>可以被多个不同的上下文使用 任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送 消息或从中接收消息</p><h4 id="服务工作者线程"><a href="#服务工作者线程" class="headerlink" title="服务工作者线程"></a>服务工作者线程</h4><p>主要用于拦截、重定向和修改页面发出的请求 充当网络请求的仲裁者</p><h1 id="ES2018-与-ES2019"><a href="#ES2018-与-ES2019" class="headerlink" title="ES2018 与 ES2019"></a>ES2018 与 ES2019</h1><p>剩余运算符再对象间执行前复制 因此只会复制对象的引用而不会克隆整个对象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = { <span class="attr">name</span>: <span class="string">"Matt"</span>, <span class="attr">age</span>: <span class="number">27</span>, <span class="attr">job</span>: { <span class="attr">title</span>: <span class="string">"Engineer"</span>, <span class="attr">level</span>: <span class="number">10</span> } };</span><br><span class="line"><span class="keyword">const</span> { ...remainingData } = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person === remainingData); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">job</span> === remainingData.<span class="property">job</span>); <span class="comment">// true</span></span><br><span class="line">remainingData.<span class="property">name</span> = <span class="string">"olddog"</span>;</span><br><span class="line">person.<span class="property">name</span> = <span class="string">"wqdq"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(remainingData.<span class="property">name</span>); <span class="comment">//olddog</span></span><br><span class="line">person.<span class="property">name</span>; <span class="comment">//wqdq</span></span><br><span class="line">person.<span class="property">job</span>.<span class="property">title</span> = <span class="string">"123"</span>;</span><br><span class="line">remainingData.<span class="property">job</span>, title; <span class="comment">//123</span></span><br></pre></td></tr></tbody></table></figure><p>剩余运算符会复制所有自有可枚举属性 包括括号</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> foo = { <span class="attr">a</span>: <span class="number">1</span>, [s]: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> };</span><br><span class="line"><span class="keyword">const</span> { a, ...remainingData } = foo;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(remainingData);</span><br></pre></td></tr></tbody></table></figure><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符会像拼接数组一样合并两个对象 应用到内部对象的扩展运算符会对所有自有可枚举属性执行浅复制到外部对象 包括符号</p><ul><li>对象跟踪插入顺序 从扩展对象复制的属性按照他们在对象字面量中列出的顺序插入</li><li>对象会覆盖重名属性 出现重名属性时会使用后续出现的值</li><li>与剩余操作符一样 所有复制都是浅复制</li></ul><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p>有了<code>Promise.prototype.finally</code>可以统一共享的处理程序 <code>finally（）</code>不传递任何参数 也不知道自己处理的<code>promise</code>是什么状态</p><p>每个<code>finally（）</code>都会创建一个新的<code>promise</code>实例 而这个新<code>promise</code>会被添加到浏览器的微任务队列 只有前面的处理程序执行完成才会解决</p><h3 id="数组打平方法"><a href="#数组打平方法" class="headerlink" title="数组打平方法"></a>数组打平方法</h3><blockquote><p><code>flat()</code>和 <code>flatMap()</code>只能用于打平嵌套数组。嵌套的可迭代对象如 Map 和 Set 不能打平</p></blockquote><h4 id="Array-prototype-flatten"><a href="#Array-prototype-flatten" class="headerlink" title="Array.prototype.flatten()"></a>Array.prototype.flatten()</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打平数组的实例实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">sourceArray, flattenedArray = []</span>) {</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> sourceArray) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(element)) {</span><br><span class="line">      <span class="title function_">flatten</span>(element, flattenedArray);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      flattenedArray.<span class="title function_">push</span>(element);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> flattenedArray;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> arr = [[<span class="number">0</span>], <span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]], <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br><span class="line"><span class="comment">//重写邦本 允许指定打平到第几级嵌套</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">sourceArray, depth, flattenedArray = []</span>) {</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> sourceArray) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(element) &amp;&amp; depth &gt; <span class="number">0</span>) {</span><br><span class="line">      <span class="title function_">flatten</span>(element, depth - <span class="number">1</span>, flattenedArray);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      flattenedArray.<span class="title function_">push</span>(element);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> flattenedArray;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> arr = [[<span class="number">0</span>], <span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]], <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, [4, 5], 6]</span></span><br></pre></td></tr></tbody></table></figure><p><code>Array.prototype.flat()</code> 接收一个 depth 参数 默认为 1 返回一个打平 Array 实例的浅复制版本</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [[<span class="number">0</span>], <span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> arr1 = arr.<span class="title function_">flat</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">//[0,1,2,3,4,5,6]</span></span><br><span class="line">arr1.<span class="title function_">push</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">//[0,1,2,3,4,5,6,10]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">//[[0], 1, 2, [3, [4, 5]], 6]</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap()"></a>Array.prototype.flatMap()</h4><p><code>Array.prototype.flatMap()</code>方法会在打平数组之前执行一次映射操作。在功能上，<code>arr.flatMap(f)</code> 与 <code>arr.map(f).flat()</code>等价；但 <code>arr.flatMap()</code>更高效，因为浏览器只需要执行<strong>一次遍历</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [[<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">5</span>]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">map</span>(<span class="function">(<span class="params">[x]</span>) =&gt;</span> [x, x + <span class="number">1</span>]));</span><br><span class="line"><span class="comment">// [[1, 2], [3, 4], [5, 6]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">flatMap</span>(<span class="function">(<span class="params">[x]</span>) =&gt;</span> [x, x + <span class="number">1</span>]));</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure><p><code>flatMap()</code>在非数组对象的方法返回数组时特别有用，例如字符串的 <code>split()</code>方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一组输入字符串分割为单词 然后把这些单词拼接成一个单词数组</span></span><br><span class="line"><span class="keyword">const</span> arr =  [<span class="string">'Lorem ipsum dolor sit amet,'</span>, <span class="string">'consectetur adipiscing elit.'</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="title function_">split</span>(<span class="regexp">/[\W+]/</span>)));</span><br><span class="line"><span class="comment">// ["Lorem", "ipsum", "dolor", "sit", "amet", "", "consectetur", "adipiscing",</span></span><br><span class="line"><span class="string">"elit"</span>, <span class="string">""</span>]</span><br></pre></td></tr></tbody></table></figure><h4 id="Object-formEntries"><a href="#Object-formEntries" class="headerlink" title="Object.formEntries()"></a>Object.formEntries()</h4><p>用于通过键/值对数组的 集合构建对象。这个方法执行与 <code>Object.entries()</code>方法相反的操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">"bar"</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="string">"qux"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> objEntries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objEntries);</span><br><span class="line"><span class="comment">// [["foo", "bar"], ["baz", "qux"]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(objEntries));</span><br><span class="line"><span class="comment">// { foo: "bar", baz: "qux" }</span></span><br></pre></td></tr></tbody></table></figure><p>可以快速地将<code>Map</code>实例转换为<code>Object</code>实例 因为 Map 迭代器返回的结果与<code>formEntries（）</code>的参数恰好匹配</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">formEntries</span>(map)); <span class="comment">//{foo: "bar"}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="字符串修理方法"><a href="#字符串修理方法" class="headerlink" title="字符串修理方法"></a>字符串修理方法</h3><p><code>trimStart():</code>删除字符串开头的空格</p><p><code>trimEnd()</code>;删除末尾的空格</p><p>在只有一个空格的情况下 这两个方法相当于执行与<code>padStart()和padEnd()</code>相反的操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">" foo "</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">trimStart</span>()); <span class="comment">// "foo "</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">trimEnd</span>()); <span class="comment">// " foo"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><p>用于取得可选的符号描述 只读的 如果没有描述 默认为<code>undefined</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="title class_">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">description</span>); <span class="comment">//foo</span></span><br></pre></td></tr></tbody></table></figure><h2 id="可选的-catch-绑定"><a href="#可选的-catch-绑定" class="headerlink" title="可选的 catch 绑定"></a>可选的 catch 绑定</h2><p>在<code>try/catch</code>中 可以忽略<code>catch</code>的错误对象不做任何操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"foo"</span>;</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">  <span class="comment">// 发生错误了，但你不想使用错误对象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学JS第一天</title>
      <link href="/2022/04/20/chong-xue-js-di-yi-tian/"/>
      <url>/2022/04/20/chong-xue-js-di-yi-tian/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-中的-JavaScript"><a href="#HTML-中的-JavaScript" class="headerlink" title="HTML 中的 JavaScript"></a>HTML 中的 JavaScript</h1><h2 id="1-script-元素"><a href="#1-script-元素" class="headerlink" title="1.script 元素"></a>1.script 元素</h2><ul><li>crossorigin：可选。配置相关请求的 CORS（跨源资源共享）设置。默认不使用 CORS。crossorigin= “anonymous”配置文件请求不必设置凭据标志。crossorigin=”use-credentials”设置凭据 标志，意味着出站请求会包含凭据</li><li>defer：可选 表示脚本可以延迟到文档完全被解析和显示之后再执行 只对外部脚本文件有效</li><li>integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性 果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错， 脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提 供恶意内容</li></ul><p>使用了 src 属性的<code>&lt;script&gt;</code>元素不应该再在<code>&lt;script&gt;</code>标签之间再包含其他 js 代码 如果两者都提供的话 浏览器只会下载并执行标本文件 从而忽略行内代码</p><p><strong>浏览器会根据特定的设置缓存所有外部连接的 JavaScript 文件 这意味着如果两个页面都用到同个文件 则该文件只需要下载一次 这最终意味着页面加载更快</strong></p><h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h4 id="const优先-let次之"><a href="#const优先-let次之" class="headerlink" title="const优先 let次之"></a><code>const</code>优先 <code>let</code>次之</h4><p>使用<code>const</code>声明可以让浏览器运行时强制保持变量不变 也可以让静态代码分析工具提前法相不合法的赋值操作。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><p><code>typeof null == object</code> null 被认为是一个对空对象的引用</p><blockquote><p>tips：我们建议在声明变量的同时进行初始化 这样当 <code>typeof</code>返回<code>undefined</code>时我们知道是因为给定的变量尚未声明而不是声明了但没有初始化</p><p>tips：当我们定义一个未来将会赋值对象的变量时 应该初始化为 null（可以保持 null 是空对象指针的语义 并与 undefined 区分开</p><p>.）</p></blockquote><blockquote><p><code>isNaN()</code> 可以用来测试对象 此时会先调用对象的<code>valueOf（）</code>方法 然后再确定返回的值是否可以转换为数值 如果不能 再调用<code>toString()</code>方法 再测试其返回值 这通常是 ES 内置函数和操作符的工作方式</p></blockquote><h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>（）</span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span> || <span class="literal">null</span> - <span class="number">0</span> || <span class="literal">undefined</span> - <span class="title class_">NaN</span> || <span class="title class_">Object</span> 先用valueof 如果是<span class="title class_">NaN</span> 则用toString（）</span><br></pre></td></tr></tbody></table></figure><p><strong>字符串是不可变的 要修改某个变量中的字符串的值 必须先销毁原始的字符串 然后将包括新值的另一个字符串保存到该变量中</strong></p><p>用加号操作符给一个值加上一个<code>“”</code>也可以将其转换为字符串</p><h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><p>符号是原始值 且符号实例唯一 不可变 用于确保对象属性使用唯一标识符 不会发生属性冲突的危险 可以用来创建唯一记号 进而用作非字符串形式的对象属性</p><p>符号没有字面量语法 即只要创建<code>Symbol（）</code>实例并将其用作对象的新属性 就可以保证它不会覆盖以有的对象属性 无论是符号属性还是字符串属性</p><p><code>Symbol（）</code>函数不能与 new 关键字一起作为构造函数使用 这样做是为了避免创建符号包装对象 如果想使用符号包装对象 可以使用<code>Object()</code>函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> myWarpSymbol = <span class="title class_">Object</span>(mySymbol);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> myWarpSymbol); <span class="comment">//object</span></span><br></pre></td></tr></tbody></table></figure><h4 id="使用全局符号注册表"><a href="#使用全局符号注册表" class="headerlink" title="使用全局符号注册表"></a>使用全局符号注册表</h4><p>如果运行时的不同部分需要共享和重用符号实例 可以使用一个字符串作为键 再全局符号注册表中创建并重用符号 需要使用<code>Symbol.for()</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooGolbalSymbol);<span class="comment">//symbol</span></span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">for</span>()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运</span><br><span class="line">行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同</span><br><span class="line">字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例</span><br><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">'foo'</span>); <span class="comment">// 创建新符号</span></span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">'foo'</span>); <span class="comment">// 重用已有符号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooGlobalSymbol === otherFooGlobalSymbol); <span class="comment">// true</span></span><br><span class="line">即使采用相同的符号描述 在全局注册表中定义的符号跟使用<span class="title class_">Symbol</span>（）定义的符号也并不相同</span><br><span class="line"><span class="keyword">let</span> localSymbol = <span class="title class_">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localSymbol === globalSymbol); <span class="comment">// false</span></span><br><span class="line">还可以使用 <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字</span><br><span class="line">符串键。如果查询的不是全局符号，则返回 <span class="literal">undefined</span>。</span><br><span class="line"><span class="comment">// 创建全局符号</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s)); <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 创建普通符号</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2)); <span class="comment">// undefined</span></span><br><span class="line">如果传给 <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>()的不是符号，则该方法抛出 <span class="title class_">TypeError</span>：</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(<span class="number">123</span>); <span class="comment">// TypeError: 123 is not a symbol</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><ul><li>hasOwnProperty（propertyName）：判断当前对象实例（不是原型）上是否存在特定的属性</li><li>isPrototypeOf（object）：判断当前对象是否为另一个对象的原型</li><li>peopertyIsEnumerable（propertyName）：用于判断给定的属性是否可以使用 for-in 循环</li></ul><blockquote><p>由于相等和不相等操作符存在类型转换问题 因此推荐使用全等和不全等操作符 这样有助于在代码中保持数据类型的完整性</p></blockquote><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>为了确保局部变量不被修改 推荐使用 const for-in 不能保证返回对象属性的顺序 如果迭代的变量是 null 或者 undefined 则不执行循环体</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> <span class="variable language_">window</span>) {</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">write</span>(propName);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>for-of</p><p>for-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素。</p><blockquote><p>for-await-of 循环 支持生成 promise 的异步可迭代对象</p></blockquote><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><blockquote><p>switch 语句在比较每个条件的值时会使用全等操作符 因此不会强制转换数据类型</p></blockquote><h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><p>原始值：按值访问</p><p>引用值：对该对象的引用而不是实际的对象本身</p><h4 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h4><ul><li>1.原始值</li></ul><p>在通过变量把原始值赋值给另一个变量时 原始值会被复制到新变量的位置 这两个位置是完全独立的 互不干扰</p><ul><li>2.引用值</li></ul><p>在把引用值从一个变量赋给另一个变量时 储存在变量中的值也会被复制到新变量所在的位置 区别在于这里复制的值实际上时一个指针 它指向储存在堆内存中的对象那个 操作完成后 两个变量实际上指向同一个对象 因此一个对象上面的变化也会从另一个对象上反映出来</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></tbody></table></figure><h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p><strong>ECMAScript 中所有函数的参数都是值传递（ECMAScipt 不可能引用传递）</strong> 这就意味着函数外的值会被复制到函数内部的参数中 就像一个变量复制到另一个变量一样 （如果是原始值 就和原始值变量的复制一样 如果是引用值 就和引用值的复制一样）</p><blockquote><p>按值传递参数时 值会被复制到一个局部变量（一个命名参数 即 arguments 对象中的一个槽位）</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">num</span>) {</span><br><span class="line">  <span class="comment">//这里的num其实是一个局部变量</span></span><br><span class="line">  num += <span class="number">10</span>; <span class="comment">//不会影响到外部的count</span></span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">addTen</span>(count); <span class="comment">//30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">//20</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) { <span class="comment">//obj指向的对象保存在全局作用域的堆内存上 所以也会使外部的对象放映这个变化</span></span><br><span class="line"> obj.<span class="property">name</span> = <span class="string">"Nicholas"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// "Nicholas"</span></span><br><span class="line">----------------------------------<span class="comment">//证明为啥不是引用传递</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) {</span><br><span class="line"> obj.<span class="property">name</span> = <span class="string">"Nicholas"</span>; <span class="comment">//影响到了外部的变量</span></span><br><span class="line"> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//被重写 变成了一个指向本地的指针 函数执行结束后就被销毁了 本来也不会影响到外部的对象</span></span><br><span class="line"> obj.<span class="property">name</span> = <span class="string">"Greg"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// "Nicholas"</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>函数中的参数就是局部变量</p></blockquote><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><p>使用 typeof 判断原始值 使用 instance of 判断引用类型（由原型链决定）</p><blockquote><p>如果想让整个对象都不能被更改 可以使用 freeze（）</p></blockquote><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h4 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h4><p>当变量进入上下文的时候 将变量加上存在于上下文中的标记 当变量离开上下文时 加上离开上下文的标记</p><p>来及回收程序运行的时候 会标记内存中存储的所有变量 然后将所有上下文中的变量以及被在上下文中引用的变量的标记去掉 再次之后再被加上标记的变量就是待删除的 原因是任何在上下文中的变量都访问不到它们了，随后垃圾回收程序做一次内存清理</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>对每个值都记录它被引用的次数 当一个值的引用数为 0 时 就说明没法再访问这个值了 可以安全地回收其内存</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>优化内存占用的最佳手段就是保证再执行代码时只保存必要的数据 如果数据不再必要 就设置为 null 从而释放 这个叫做解除引用（适合全局变量和全局变量的属性 局部变量在超出作用域之后会被自动解除引用）</p><blockquote><p>解除对一个值的引用并不会自动导致相关内存被回收 解除引用的关键在于确保相关的值已经不在上下文中了 因此下一次垃圾回收的时候会被回收</p></blockquote><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>闭包很容易造成内存泄漏</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"Jake"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  };</span><br><span class="line">};</span><br><span class="line"><span class="comment">//调用outer()会导致分配给name的内存被泄漏 因为以上代码执行后创建了一个内部闭包 只要返回的参数存在就不能清理name 因为闭包一直引用着它</span></span><br></pre></td></tr></tbody></table></figure><h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用类型和原始值包装类型（<code>String、Number、Boolean</code>）的主要区别在于对象的生命周期 在通过<code>new</code> 实例化引用类型后 得到的实例会在离开作用域时被销毁 而自动创建的原始值包装对象则指存在于访问它的那行代码执行期间 这意味着不能再运行时给原始值添加属性和方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable constant_">S1</span> - <span class="string">"some text"</span>;</span><br><span class="line">s1.<span class="property">color</span> = <span class="string">'read'</span>;<span class="comment">//临时创建一个String对象 第二行运行后就销毁了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">color</span>)<span class="comment">//undefined//创建了自己的String对象 但是这个对象没有color属性</span></span><br></pre></td></tr></tbody></table></figure><p>在原始值包装类类型的实例上调用 typeof 会返回 object 所有原始值包装对象都会转换为 true</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">"some text"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">String</span>); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>使用<code>new</code>调用原始值包含在那个类型的构造函数和调用同名的转型函数不一样</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">let</span> number = <span class="title class_">Number</span>(value); <span class="comment">// 转型函数 保存的时一个值为25的原始数智</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> number); <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Number</span>(value); <span class="comment">// 构造函数 保存的是一个Number的实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj); <span class="comment">// "object"</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>toFixed()</code>可以表示有 0-20 个小数的数值</p></blockquote><h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><ul><li><p><code>concat()</code>: 将一个或多 i 个字符串拼接成一个新字符串</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello "</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">"world"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// "hello world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// "hello"</span></span><br><span class="line"><span class="comment">//concat()方法可以接收任意多个参数，因此可以一次性拼接多个字符串，</span></span><br></pre></td></tr></tbody></table></figure><p>与 <code>concat()</code>方法一样<code>，slice()、substr() 和 substring()</code>也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>)); <span class="comment">// "lo world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>)); <span class="comment">// "lo world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>)); <span class="comment">// "lo world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// "lo w"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// "lo w"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// "lo worl"</span></span><br><span class="line"><span class="comment">//slice将负值参数当成字符串长度加上负参数值 substr将第一个负参数当成字符串长度加上该值 substring将所有负参数值都当作0</span></span><br><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(-<span class="number">3</span>)); <span class="comment">// "rld"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(-<span class="number">3</span>)); <span class="comment">// "hello world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(-<span class="number">3</span>)); <span class="comment">// "rld"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// "lo w"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// "hel"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// "" (empty string)</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">"o"</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">lastIndexOf</span>(<span class="string">"o"</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">"o"</span>, <span class="number">6</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">lastIndexOf</span>(<span class="string">"o"</span>, <span class="number">6</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></tbody></table></figure><p>判断是否包含另一个字符串的方法：startsWith() endsWith() inclueds()startsWith()检查开始于索引 0 的匹配项，endsWith()检查开始于索 引(string.length - substring.length)的匹配项，而 includes()检查整个字符串</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"foobarbaz"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">"foo"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">"bar"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">"baz"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">"bar"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">"bar"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">"qux"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p><code>trim()</code>:创建字符串的一个副本 删除亲啊后的所有空格符再返回结果 原字符串不受影响 <code>trimLeft()</code>和<code>trimRight（）</code>分别从开始和末尾清理空格</p><p><code>repeat()</code>接收一个参数 表示将字符串复制多少次后返回拼接所有副本后的结果</p><p><code>padStart()</code>和 <code>padEnd()</code>方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至 满足长度条件。</p></li></ul><p>字符串大小写转换：<code>toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()</code></p><h2 id="单例内置对象"><a href="#单例内置对象" class="headerlink" title="单例内置对象"></a>单例内置对象</h2><h3 id="URL-编码方式"><a href="#URL-编码方式" class="headerlink" title="URL 编码方式"></a>URL 编码方式</h3><p><code>encodeURI()</code>和 <code>encodeURIComponent()</code>方法用于编码统一资源标识符（URI），以便传给浏览器</p><blockquote><p>使用 encodeURIComponent()应该比使用 encodeURI()的频率更高， 这是因为编码查询字符串参数比编码基准 URI 的次数更多。</p></blockquote><p><code>encodeURI()</code>和 <code>encodeURIComponent()</code>相对的是 <code>decodeURI()</code>和 <code>decodeURIComponent()</code>。</p><h4 id="eval（）"><a href="#eval（）" class="headerlink" title="eval（）"></a>eval（）</h4><p>解释器 接收一个参数 即耀执行的 js 字符串</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"console.log('h1')"</span>);</span><br><span class="line"><span class="comment">//等价于 console.log("h1")</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>使用 eval 的时候必须慎重 因为这个方法会对 CSS 利用暴露出很大的攻击面 用户可能插入导致你网站或引用奔溃的代码</p></blockquote><h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><blockquote><p>在使用对象字面量表示定义对象时 并不会按实际调用 Object 构造函数</p></blockquote><p><code>from()</code>可用于将类数组结构转换为数组实例 <code>of()</code>用于将一组参数转换为数组实例</p><p><code>Array.from()</code>对数组进行浅复刻</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">form</span>(a1);</span><br><span class="line"><span class="title function_">alert</span>(a1 === a1) <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p><code>Array.from()</code>还可以接收第二个可选的参数 表示直接增强新数组的值 而无需像调用<code>Array.from().map()</code>那样先创建一个中间数组</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1, <span class="function">(<span class="params">x</span>) =&gt;</span> x ** <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(</span><br><span class="line">  a1,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">x</span>) {</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="variable language_">this</span>.<span class="property">exponent</span>;</span><br><span class="line">  },</span><br><span class="line">  { <span class="attr">exponent</span>: <span class="number">2</span> }</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [1, 4, 9, 16]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a3); <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></tbody></table></figure><p><code>Array.of()</code>可以把一组参数转换为数组</p><h4 id="数组的迭代器方法"><a href="#数组的迭代器方法" class="headerlink" title="数组的迭代器方法"></a>数组的迭代器方法</h4><p><code>keys()</code>返回数组索引的迭代器 <code>values()</code>返回数组元素的迭代器 <code>entries()</code>返回索引/值对的迭代器</p><p>使用结构可以非常容易地在循环中拆分键值对</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>, <span class="string">"qux"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [idx, element] <span class="keyword">of</span> a.<span class="title function_">entries</span>()) {</span><br><span class="line">  <span class="title function_">alert</span>(idx);</span><br><span class="line">  <span class="title function_">alert</span>(element);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>fill()</code>静默忽略超出数组边界、零长度以及方向相反的索引范围</p><p><code>copyWithin()</code>会按照指定范围浅复制数组中的部分内容，然后将它们插入到指 定索引开始的位置。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">5</span>); <span class="comment">//从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置</span></span><br><span class="line"><span class="comment">// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始到索引 3 结束的内容</span></span><br><span class="line"><span class="comment">// 插入到索引 4 开始的位置</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// JavaScript 引擎在插值前会完整复制范围内的值</span></span><br><span class="line"><span class="comment">// 因此复制期间不存在重写的风险</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果数组中某一项是 null 或 undefined，则在 join()、toLocaleString()、 toString()和 valueOf()返回的结果中会以空字符串表示</p></blockquote><p><strong>reverse()和 sort()都会返回调用它们的数组的引用</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...arr].<span class="title function_">sort</span>()); <span class="comment">//[1,2,3,4,5,6]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">//[1,3,2,5,4,6]</span></span><br><span class="line"><span class="comment">//使用时需要根据是否可以改变原数组判断创建副本保存</span></span><br></pre></td></tr></tbody></table></figure><p><code>concat()</code>方法可以在现有数组全部元素基础上 创建一个新数组。默认打平 可以使用<code>Symbol.isConcatSpreadable</code>阻止打平</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> newColors = [<span class="string">"black"</span>, <span class="string">"brown"</span>];</span><br><span class="line">newColors[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 强制不打平数组</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">"yellow"</span>, newColors); <span class="comment">// ["red", "green", "blue", "yellow", ["black", "brown"]]</span></span><br></pre></td></tr></tbody></table></figure><p><code>slice()</code>用于创建一个包含原有数组中一个或多个元素的新数组。</p><p><code>splice()</code>的主要目的是 在数组中间插入元素</p><p><code>splice()</code>方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返 回空数组）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,blue</span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// red，只有一个元素的数组</span></span><br><span class="line">removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>, <span class="string">"orange"</span>); <span class="comment">// 在位置 1 插入两个元素</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,yellow,orange,blue</span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// 空数组</span></span><br><span class="line">removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"red"</span>, <span class="string">"purple"</span>); <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,red,purple,orange,blue</span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// yellow，只有一个元素的数组</span></span><br></pre></td></tr></tbody></table></figure><h4 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h4><p>ECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。</p><h5 id="1-严格相等"><a href="#1-严格相等" class="headerlink" title="1.严格相等"></a>1.严格相等</h5><p><code>indexOf()、lastIndexOf()和 includes()。</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">lastIndexOf</span>(<span class="number">4</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">includes</span>(<span class="number">4</span>)); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h5 id="2-断言函数"><a href="#2-断言函数" class="headerlink" title="2.断言函数"></a>2.断言函数</h5><p><code>find()</code>返回 第一个匹配的元素，<code>findIndex()</code>返回第一个匹配元素的索引 找到第一个匹配后就不再进行</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">name</span>: <span class="string">"Matt"</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">name</span>: <span class="string">"Nicholas"</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  },</span><br><span class="line">];</span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>));</span><br><span class="line"><span class="comment">// {name: "Matt", age: 27}</span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>)); <span class="comment">//0</span></span><br></pre></td></tr></tbody></table></figure><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><ul><li><code>every()</code>：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。</li><li><code>filter()</code>：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。</li><li><code>forEach()</code>：对数组每一项都运行传入的函数，没有返回值。</li><li><code>map()</code>：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。</li><li><code>some()</code>：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。 这些方法都不改变调用它们的数组</li></ul><h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><p><code>reduce()</code>和 <code>reduceRight()</code>都会迭代数 组的所有项，并在此基础上构建一个最终返回值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur);</span><br><span class="line"><span class="title function_">alert</span>(sum); <span class="comment">// 15</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>与<code>Object</code>类型的一个主要差异是<code>Map</code>实例会维护键值对的插入顺序 因此可以根据插入顺序执行迭代操作</p><p>映射实例可以提供一个迭代器 能以插入顺序生成[key, value]形式的数组 可以通过 entries（）方法取得迭代器</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">"key1"</span>, <span class="string">"val1"</span>],</span><br><span class="line">  [<span class="string">"key2"</span>, <span class="string">"val2"</span>],</span><br><span class="line">  [<span class="string">"key3"</span>, <span class="string">"val3"</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]]</span></span><br><span class="line"><span class="comment">//keys()和 values()分别返回以插入顺序生成键和值的迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">keys</span>()) {</span><br><span class="line">  <span class="title function_">alert</span>(key); <span class="comment">//key1 key2 key3</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">values</span>()) {</span><br><span class="line">  <span class="title function_">alert</span>(key); <span class="comment">//value1 value2 value3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为 键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">"key1"</span>, <span class="string">"val1"</span>]]);</span><br><span class="line"><span class="comment">// 作为键的字符串原始值是不能修改的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m1.<span class="title function_">keys</span>()) {</span><br><span class="line">  key = <span class="string">"newKey"</span>;</span><br><span class="line">  <span class="title function_">alert</span>(key); <span class="comment">// newKey</span></span><br><span class="line">  <span class="title function_">alert</span>(m1.<span class="title function_">get</span>(<span class="string">"key1"</span>)); <span class="comment">// val1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>选择 Object 还是 Map</p><ul><li>占用内存：储存当个键值对所占用的内存挥着键的数量线性增加 <code>Map</code>大约可以比<code>Object</code>多储存 50%的键值对</li><li>插入性能：涉及到大量插入操作 <code>Map</code>更佳</li><li>查找速度：设计大量查找操作 <code>Object</code>更佳</li><li>删除性能：设计大量删除操作 选择<code>Map</code></li></ul><h2 id="weak-Map"><a href="#weak-Map" class="headerlink" title="weak Map"></a>weak Map</h2><p>键只能是<code>Objec</code>t 或者继承自<code>Object</code>的类型 使用非对象设置键会抛出 TypeError 值没有限制类型</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = { <span class="attr">id</span>: <span class="number">1</span> },</span><br><span class="line">  key2 = { <span class="attr">id</span>: <span class="number">2</span> },</span><br><span class="line">  key3 = { <span class="attr">id</span>: <span class="number">3</span> };</span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个键无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([</span><br><span class="line">  [key1, <span class="string">"val1"</span>],</span><br><span class="line">  [<span class="string">"BADKEY"</span>, <span class="string">"val2"</span>],</span><br><span class="line">  [key3, <span class="string">"val3"</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as WeakMap key</span></span><br><span class="line"><span class="keyword">typeof</span> wm2;</span><br><span class="line"><span class="comment">// ReferenceError: wm2 is not defined</span></span><br></pre></td></tr></tbody></table></figure><p><code>WeakMap</code>的键不属于正式的引用 不会组织垃圾回收 但是只要键存在 键值对就会存在于映射中 并被当作对值的引用 因此不会被垃圾回收</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">wm.<span class="title function_">set</span>({}, <span class="string">"val"</span>);</span><br><span class="line"><span class="comment">//et()方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，</span></span><br><span class="line"><span class="comment">//所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失</span></span><br><span class="line"><span class="comment">//了，使其成为一个空映射。在这个例子中，因为值也没有被引用，所以这对键/值被破坏以后，值本身</span></span><br><span class="line"><span class="comment">//也会成为垃圾回收的目标。</span></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> container = {</span><br><span class="line">  <span class="attr">key</span>: {},</span><br><span class="line">};</span><br><span class="line">wm.<span class="title function_">set</span>(container.<span class="property">key</span>, <span class="string">"val"</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeReference</span>(<span class="params"></span>) {</span><br><span class="line">  container.<span class="property">key</span> = <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//const wm = new WeakMap();</span></span><br><span class="line"><span class="keyword">const</span> container = {</span><br><span class="line">  <span class="attr">key</span>: {},</span><br><span class="line">};</span><br><span class="line">wm.<span class="title function_">set</span>(container.<span class="property">key</span>, <span class="string">"val"</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeReference</span>(<span class="params"></span>) {</span><br><span class="line">  container.<span class="property">key</span> = <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//这一次，container 对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目</span></span><br><span class="line"><span class="comment">//标。不过，如果调用了 removeReference()，就会摧毁键对象的最后一个引用，垃圾回收程序就可以</span></span><br><span class="line"><span class="comment">//把这个键/值对清理掉。</span></span><br></pre></td></tr></tbody></table></figure><p><code>**WeakMap</code> 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值**</p><h4 id="WeakMap-的用处"><a href="#WeakMap-的用处" class="headerlink" title="WeakMap 的用处"></a>WeakMap 的用处</h4><h5 id="1-私有变量"><a href="#1-私有变量" class="headerlink" title="1.私有变量"></a>1.私有变量</h5><h5 id="2-DOM-节点数据"><a href="#2-DOM-节点数据" class="headerlink" title="2.DOM 节点数据"></a>2.DOM 节点数据</h5><p>因为<code>WeakMap</code>实例不会妨碍垃圾回收 所以非常适合保存关联元数据</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">'#login'</span>);</span><br><span class="line"><span class="comment">//给这个节点关联一些元数据</span></span><br><span class="line">m.<span class="title function_">set</span>(loginButton, {<span class="attr">disabled</span>: <span class="literal">true</span>});</span><br><span class="line"><span class="comment">//假设登录按钮被从DOM树删除了 但是由于映射中还保存着对按钮的引用 所以对应的DOM节点仍然会逗留在内存中 除非明确将其从映射中删除或者等到映射本身被销毁</span></span><br><span class="line"><span class="comment">//如果使用WeakMap 当节点从DOM树被删除后 垃圾回收程序就会立即释放其内存（假设其他地方没引用的话</span></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">'#login'</span>);</span><br><span class="line"><span class="comment">// 给这个节点关联一些元数据</span></span><br><span class="line">wm.<span class="title function_">set</span>(loginButton, {<span class="attr">disabled</span>: <span class="literal">true</span>});</span><br></pre></td></tr></tbody></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>Set</code>会维护值插入时的顺序 因此支持按顺序迭代</p><p>修改集合中的值的属性不会影响到其作为集合值的身份</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">"vall"</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s1.<span class="title function_">values</span>()) {</span><br><span class="line">  value = <span class="string">"newVal"</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//newVal</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="title function_">has</span>(<span class="string">"val"</span>)); <span class="comment">//true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>WeakSet</code>可用于给对象打标签</p><h2 id="迭代和扩展操作"><a href="#迭代和扩展操作" class="headerlink" title="迭代和扩展操作"></a>迭代和扩展操作</h2><p>扩展运算符在对可迭代对象执行浅复刻时特别有用 只需要简单的语法就可以复制整个对象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1 === arr2); <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p>浅复制意味着只会复制对象的引用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [{}];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line">arr1[<span class="number">0</span>].<span class="property">foo</span> = <span class="string">"bar"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2[<span class="number">0</span>]); <span class="comment">// { foo: 'bar' }</span></span><br></pre></td></tr></tbody></table></figure><h1 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h1><p>每个迭代器都表示对可迭代对象的一次性有序遍历 不同的迭代器实例直接拿没有联系 只会独立地遍历可迭代对象</p><p>迭代器并不与可迭代对象某个时刻的快照绑定 而仅仅是使用游标来记录遍历可迭代的对象的历程 如果可迭代对象在迭代期间被修改了 那么迭代器也会发生相应的变化</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"foo"</span>, <span class="string">"baz"</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// { done: false, value: 'foo' }</span></span><br><span class="line"><span class="comment">// 在数组中间插入值</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"bar"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// { done: false, value: 'bar' }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// { done: false, value: 'baz' }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// { done: true, value: undefined }</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>迭代器维护着一个指向可迭代对象的引用 因此迭代器会阻止垃圾回收程序回收可迭代对象</p></blockquote><p><strong>自定义一个迭代器（需要将计数器变量放到闭包里 然后通过闭包返回迭代器）</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">limit</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = limit;</span><br><span class="line">  }</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() {</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">      limit = <span class="variable language_">this</span>.<span class="property">limit</span>;</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= limit) {</span><br><span class="line">          <span class="keyword">return</span> { <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ };</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">return</span> { <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> };</span><br><span class="line">        }</span><br><span class="line">      },</span><br><span class="line">    };</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">} <span class="comment">//1 2 3</span></span><br></pre></td></tr></tbody></table></figure><p>如果迭代器没有关闭 则还可以继续从上次离开的地方继续迭代 比如 数组的迭代器就是不能关闭的</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">2</span>) {</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">} <span class="comment">//1 2 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">} <span class="comment">//4 5</span></span><br></pre></td></tr></tbody></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器对象一开始处于暂停执行的状态 具有<code>next()</code>方法 调用这个方法会让生成器开始或恢复执行</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) {}</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn {&lt;suspended&gt;}</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">next</span>); <span class="comment">// f next() { [native code] }</span></span><br></pre></td></tr></tbody></table></figure><p>函数体为 kon 的生成器函数中间不会停留 调用一次<code>next（）</code>就会让生成器达到<code>done:true</code>状态</p><p>生成器函数只会在初次调用<code>next()</code>方法后开始执行</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"foobar"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 初次调用生成器函数并不会打印日志</span></span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>();</span><br><span class="line">generatorObject.<span class="title function_">next</span>(); <span class="comment">// foobar</span></span><br></pre></td></tr></tbody></table></figure><p>yield 可以让生成器停止和开始执行 遇到关键字后 执行停止 作用域的状态会被保留</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"foo"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"bar"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"baz"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// { done: false, value: 'foo' }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// { done: false, value: 'bar' }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// { done: true, value: 'baz' }</span></span><br></pre></td></tr></tbody></table></figure><p>生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用 <code>next()</code> 不会影响其他生成器</p><h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p><code>Object.assign()</code>接收一个目标对象和一个或多个元对象作为参数 然后将每个原对象中可枚举（<code>Object.propertyIsEnumerable()</code>返回 true）和自有（<code>Object.hasOwnProperty()</code>返回 true）属性复制到目标对象以字符串和符号为键的属性 会被复制。对每个符合条件的属性，这个方法会使用源对象上的<code>[[Get]]</code>取得属性的值，然后使用目标 对象上的<code>[[Set]]</code>设置属性的值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = { <span class="attr">id</span>: <span class="string">"src"</span> };</span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// Object.assign 修改目标对象</span></span><br><span class="line"><span class="comment">// 也会返回修改后的目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest === result); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest !== src); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// { id: src }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { id: src }</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dest = {</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">val</span>) {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Invoked dest setter with param <span class="subst">${val}</span>`</span>);</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">src = {</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">a</span>() {</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Invoked src getter'</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 调用 src 的获取方法</span></span><br><span class="line"><span class="comment">// 调用 dest 的设置方法并传入参数"foo"</span></span><br><span class="line"><span class="comment">// 因为这里的设置函数不执行赋值操作</span></span><br><span class="line"><span class="comment">// 所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// Invoked src getter"</span></span><br><span class="line"><span class="string">"Invoked dest setter with param foo"</span> {}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = { <span class="attr">a</span>: {} };</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { a :{} }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest.<span class="property">a</span> === src.<span class="property">a</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest == src)<span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>assign()</code>是浅复制 意味着只会复制对象的引用</p></blockquote><p>如果赋值期间出错 操作会中止并退出 同时抛出错误 因此可能只完成部分复制</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = {};</span><br><span class="line">src = {</span><br><span class="line">  <span class="attr">a</span>: <span class="string">"foo"</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">b</span>() {</span><br><span class="line">    <span class="comment">// Object.assign()在调用这个获取函数时会抛出错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">c</span>: <span class="string">"bar"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line">} <span class="keyword">catch</span> (e) {}</span><br><span class="line"><span class="comment">// Object.assign()没办法回滚已经完成的修改</span></span><br><span class="line"><span class="comment">// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// { a: foo }</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>可计算属性表达式中抛出任何错误都会中断对象创建 如果计算属性的表达式有副作用就要小心 因为如果表达式抛出错误 那么之前完成的计算是不能回滚的</p></blockquote><p>解构并不要求变量必须在解构表达式中说明 不过 如果是事先声明的变量 则赋值表达式必须包含在一对括号中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personName, personAge;</span><br><span class="line"><span class="keyword">let</span> person = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"Matt"</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line">};</span><br><span class="line">({ <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge } = person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName, personAge); <span class="comment">// Matt, 27</span></span><br><span class="line"><span class="comment">//vue的写法</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>({</span><br><span class="line">  <span class="attr">name</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">0</span>,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> response = {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"olddog"</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">}(({ <span class="attr">name</span>: data.<span class="property">name</span>, <span class="attr">age</span>: data.<span class="property">age</span> } = response)); <span class="comment">//data:{name: 'olddog', age: 23}</span></span><br></pre></td></tr></tbody></table></figure><h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><p>可以通过解构来复制对象属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = {</span><br><span class="line"> <span class="attr">name</span>: <span class="string">'Matt'</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line"> <span class="attr">job</span>: {</span><br><span class="line"> <span class="attr">title</span>: <span class="string">'Software engineer'</span></span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> personCopy = {};</span><br><span class="line">({</span><br><span class="line"> <span class="attr">name</span>: personCopy.<span class="property">name</span>,</span><br><span class="line"> <span class="attr">age</span>: personCopy.<span class="property">age</span>,</span><br><span class="line"> <span class="attr">job</span>: personCopy.<span class="property">job</span></span><br><span class="line">} = person);</span><br><span class="line"><span class="comment">// 因为一个对象的引用被赋值给 personCopy，所以修改</span></span><br><span class="line"><span class="comment">// person.job 对象的属性也会影响 personCopy</span></span><br><span class="line">person.<span class="property">job</span>.<span class="property">title</span> = <span class="string">'Hacker'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line"><span class="comment">// { name: 'Matt', age: 27, job: { title: 'Hacker' } }</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personCopy);</span><br><span class="line"><span class="comment">// { name: 'Matt', age: 27, job: { title: 'Hacker' } }</span></span><br><span class="line">--------------------------------</span><br><span class="line">vue的写法</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>({</span><br><span class="line"><span class="attr">name</span>: <span class="string">''</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">address</span>:{</span><br><span class="line">  <span class="attr">home</span>:<span class="string">""</span></span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"><span class="keyword">const</span> response = {</span><br><span class="line"><span class="attr">name</span>: <span class="string">'olddogewqeeqwweq'</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="attr">address</span>:{</span><br><span class="line">    <span class="attr">home</span>: <span class="string">'huilaieqw1341343'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  ({<span class="attr">name</span>: data.<span class="property">name</span>, <span class="attr">age</span>: data.<span class="property">age</span>, <span class="attr">address</span>:{<span class="attr">home</span>: data.<span class="property">address</span>.<span class="property">home</span>}} = response)<span class="comment">//data:{name: 'olddog', age: 23}</span></span><br><span class="line">  response.<span class="property">name</span> = <span class="string">"wdqdw"</span></span><br><span class="line">  response.<span class="property">address</span>.<span class="property">home</span> = <span class="string">'2132'</span></span><br><span class="line">  data.<span class="property">address</span>.<span class="property">home</span> = <span class="string">'qdewqdeqsw'</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="comment">//改变response不会影响data</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><blockquote><p>涉及到多个属性的解构赋值是一个无关输出的顺序化操作 如果一个解构表达式涉及多个赋值 如果开始的赋值成功而后面的赋值出错 则整个赋值表达式只会完成一部分</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学CSS1.0</title>
      <link href="/2022/04/18/chong-xue-css1.0/"/>
      <url>/2022/04/18/chong-xue-css1.0/</url>
      
        <content type="html"><![CDATA[<h2 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h2><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><ul><li>在 font-size 中使用是相对于<strong>父元素</strong>的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px；</li><li>在其他属性中使用是相对于自身的字体大小，如 width/height/padding/margin 等；</li></ul><p>em 在计算的时候是会层层计算的，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">div { font-size: 2em; }</span><br><span class="line">p { font-size: 2em; }</span><br><span class="line">//对于如上一个结构的 HTML，由于根元素 html 的字体大小是 16px，所以 p 标签最终计算出来后的字体大小会是 16 * 2 * 2 = 64px</span><br></pre></td></tr></tbody></table></figure><h4 id="wm、vh"><a href="#wm、vh" class="headerlink" title="wm、vh"></a>wm、vh</h4><ul><li>1vw = 视口宽度均分成 100 份中 1 份的长度；100vw = window.innerWidth</li><li>1vh = 视口高度均分成 100 份中 1 份的长度；100vh = window.innerHeight</li></ul><h4 id="vmin、vmax"><a href="#vmin、vmax" class="headerlink" title="vmin、vmax"></a>vmin、vmax</h4><ul><li>vmin：取 vw 和 vh 中值较小的；</li><li>vmax：取 vw 和 vh 中值较大的；</li></ul><h2 id="颜色体系"><a href="#颜色体系" class="headerlink" title="颜色体系"></a>颜色体系</h2><h4 id="transparent-关键字"><a href="#transparent-关键字" class="headerlink" title="transparent 关键字"></a>transparent 关键字</h4><p>transparent 关键字表示一个完全透明的颜色，即该颜色看上去将是背景色。从技术上说，它是带有 alpha 通道为最小值的黑色，是 rgba(0,0,0,0) 的简写。</p><h5 id="实现三角形"><a href="#实现三角形" class="headerlink" title="实现三角形"></a>实现三角形</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div {</span><br><span class="line">    border-top-color: #ffc107;</span><br><span class="line">    border-right-color: #00bcd4;</span><br><span class="line">    border-bottom-color: #e26b6b;</span><br><span class="line">    border-left-color: #cc7cda;</span><br><span class="line">    border-width: 50px;</span><br><span class="line">    border-style: solid;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="增大点击区域"><a href="#增大点击区域" class="headerlink" title="增大点击区域"></a>增大点击区域</h5><p>常常在移动端的时候点击的按钮的区域特别小，但是由于现实效果又不太好把它做大，所以常用的一个手段就是通过透明的边框来增大按钮的点击区域</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.btn {</span><br><span class="line">    border: 5px solid transparent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><h4 id="BFC-清除浮动"><a href="#BFC-清除浮动" class="headerlink" title="BFC 清除浮动"></a>BFC 清除浮动</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">    overflow: hidden;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="通过-clear-清除浮动"><a href="#通过-clear-清除浮动" class="headerlink" title="通过 clear 清除浮动"></a>通过 clear 清除浮动</h4><img src="https://s3.bmp.ovh/imgs/2022/04/18/42ab48bfd850f525.png" style="zoom:67%;"><h2 id="长文本处理"><a href="#长文本处理" class="headerlink" title="长文本处理"></a>长文本处理</h2><h4 id="超出部分换行"><a href="#超出部分换行" class="headerlink" title="超出部分换行"></a>超出部分换行</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overflow-wrap:break-word;</span><br></pre></td></tr></tbody></table></figure><h4 id="字符超出位置使用连字符"><a href="#字符超出位置使用连字符" class="headerlink" title="字符超出位置使用连字符"></a>字符超出位置使用连字符</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hyphens: auto</span><br></pre></td></tr></tbody></table></figure><h4 id="单行文本超出省略"><a href="#单行文本超出省略" class="headerlink" title="单行文本超出省略"></a>单行文本超出省略</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">white-space: nowrap;</span><br><span class="line">overflow:hidden;</span><br><span class="line">text-overflow: ellipsis</span><br></pre></td></tr></tbody></table></figure><h4 id="多行文本超出省略"><a href="#多行文本超出省略" class="headerlink" title="多行文本超出省略"></a>多行文本超出省略</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">overflow:hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">display:-webkit-box;</span><br><span class="line">-webkit-line-clamp:2;</span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></tbody></table></figure><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h4 id="单行的文本、inline-或-inline-block-元素"><a href="#单行的文本、inline-或-inline-block-元素" class="headerlink" title="单行的文本、inline 或 inline-block 元素"></a>单行的文本、inline 或 inline-block 元素</h4><h5 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-align: center</span><br></pre></td></tr></tbody></table></figure><h5 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h5><ul><li>通过设置上下内边距一致达到垂直居中的效果</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">padding-top: 10px;</span><br><span class="line">padding-bottom: 10px;</span><br></pre></td></tr></tbody></table></figure><ul><li>通过设置<code>height</code>和<code>line-height</code>一致达到垂直居中</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height: 100px;</span><br><span class="line">line-height: 100px;</span><br></pre></td></tr></tbody></table></figure><h4 id="固定宽高的块级盒子"><a href="#固定宽高的块级盒子" class="headerlink" title="固定宽高的块级盒子"></a>固定宽高的块级盒子</h4><ul><li>absolute + 负 margin</li><li>absolute + margin auto</li><li>absolute + calc</li></ul><h4 id="不固定宽高的块级盒子"><a href="#不固定宽高的块级盒子" class="headerlink" title="不固定宽高的块级盒子"></a>不固定宽高的块级盒子</h4><ul><li><p>absolute + transform</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">position:relative;</span><br><span class="line">}</span><br><span class="line">.child {</span><br><span class="line">position: absolute;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">transform: translate(-50%, -50%);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>line-height + vertical-align</p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.parent{</span><br><span class="line">line-height: 150px;</span><br><span class="line">line-height: 150px;</span><br><span class="line">text-align: center;</span><br><span class="line">}</span><br><span class="line">.child {</span><br><span class="line">display: inline-block;</span><br><span class="line">line-height: initial;</span><br><span class="line">vertical-align: middle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>writing-mode</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent{</span><br><span class="line">writing-mode: vertical-lr;</span><br><span class="line">text-align: center;</span><br><span class="line">}</span><br><span class="line">.middle {</span><br><span class="line">display: inlne-block;</span><br><span class="line">writing-mode: horizontal-tb;</span><br><span class="line">text-align: center;</span><br><span class="line">width: 100%</span><br><span class="line">}</span><br><span class="line">.child{</span><br><span class="line"> display: inline-block</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>table-cell</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">display: table-cell;</span><br><span class="line">vertical-align: middle;</span><br><span class="line">text-align: center;</span><br><span class="line">}</span><br><span class="line">.child {</span><br><span class="line">display: inline-block</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>flex</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>grid</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">display: grid</span><br><span class="line">}</span><br><span class="line">.child {</span><br><span class="line">justify-self: center;</span><br><span class="line">align-self: center</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="常用布局"><a href="#常用布局" class="headerlink" title="常用布局"></a>常用布局</h2><h4 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h4><ul><li>float + overflow(BFC 原理)</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aside {</span><br><span class="line">float: left;</span><br><span class="line">width: 200px;</span><br><span class="line">}</span><br><span class="line">main {</span><br><span class="line">overflow: hidden;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>float + margin</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aside {</span><br><span class="line">float: left;</span><br><span class="line">width: 200px;</span><br><span class="line">}</span><br><span class="line">main {</span><br><span class="line">margin-left: 200px;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>flex</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.layout {</span><br><span class="line">display: flex;</span><br><span class="line">}</span><br><span class="line">aside {</span><br><span class="line">width: 200px;</span><br><span class="line">}</span><br><span class="line">main {</span><br><span class="line">flex: 1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>grid</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.layout {</span><br><span class="line">display: grid;</span><br><span class="line">grid-template-columns: 200px auto;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="三栏布局（两侧栏定宽主栏自适应）"><a href="#三栏布局（两侧栏定宽主栏自适应）" class="headerlink" title="三栏布局（两侧栏定宽主栏自适应）"></a>三栏布局（两侧栏定宽主栏自适应）</h4><ul><li>flex</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;layout&gt;</span><br><span class="line">&lt;aside&gt;</span><br><span class="line">&lt;main&gt;</span><br><span class="line">&lt;aside&gt;</span><br><span class="line">&lt;/layout&gt;</span><br><span class="line">.layout{</span><br><span class="line">display: flex;</span><br><span class="line">}</span><br><span class="line">aside{</span><br><span class="line">width: 200px;</span><br><span class="line">}</span><br><span class="line">main{</span><br><span class="line">flex: 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>grid</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.layout{</span><br><span class="line">display: grid;</span><br><span class="line">grid-template-columns: 200px auto 200px;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="三行布局"><a href="#三行布局" class="headerlink" title="三行布局"></a>三行布局</h4><ul><li>flex</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/dd8b4abc814a8935.png"></p><ul><li>grid</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/a3e63f56c012019b.png"></p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><h3 id="父容器"><a href="#父容器" class="headerlink" title="父容器"></a>父容器</h3><h4 id="justify-content-定义如何沿着主轴方向排列子容器"><a href="#justify-content-定义如何沿着主轴方向排列子容器" class="headerlink" title="justify-content:定义如何沿着主轴方向排列子容器"></a>justify-content:定义如何沿着主轴方向排列子容器</h4><blockquote><p>flex-start: 起始端对齐</p><p>flex-end： 末尾端对齐</p><p>center： 居中对齐</p><p>space-around：子容器沿主轴均匀分布 位于首尾末端的子容器到父容器的距离是子容器间距的一半</p><p>space-between：子容器沿主轴均匀分布 位于首位两端的子容器与父容器相切</p></blockquote><h4 id="align-items：设置子元素如何沿交叉轴排列"><a href="#align-items：设置子元素如何沿交叉轴排列" class="headerlink" title="align-items：设置子元素如何沿交叉轴排列"></a>align-items：设置子元素如何沿交叉轴排列</h4><blockquote><p>flex-satrt：起始端对齐</p><p>flex-end：末尾段对齐</p><p>center：居中对齐</p><p>baseline：基线对齐 这里的<code>baseline</code>默认是值首行文字 即<code>first baseline</code> 所有子容器向基线对齐 交 叉轴起点到元素基线距离最大的子容器会将交叉轴起始端相切以确定基线</p><p>stretch：子容器沿交叉方向的尺寸拉伸至与父容器一致</p></blockquote><h3 id="子容器"><a href="#子容器" class="headerlink" title="子容器"></a>子容器</h3><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/cb3978bf844f693d.png"></p><p>每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器 <code>align-items</code> 属性完全一致，如果两者同时设置则以子容器的 <code>align-self</code> 属性为准。</p><blockquote><p>flex-start：起始端对齐</p><p>flex-end：末尾段对齐</p><p>center：居中对齐</p><p>baseline：基线对齐</p><p>stretch：拉伸对齐</p></blockquote><h4 id="轴"><a href="#轴" class="headerlink" title="轴"></a>轴</h4><p><code>jusitify-content</code>决定子容器沿主轴排列方式 align-items 决定子容器沿交叉轴的排列方向 <code>flex-dirextion</code>决定主轴的方向</p><p><strong>主轴的起始端由<code>flex-start</code>表示 末尾以<code>flex-end</code>表示</strong></p><blockquote><p>向右：flex-direction： row</p><p>向下：flex-direction： column</p><p>向左：flex-direction： row-reverse</p><p>向上：flex-direction： column-reverse</p></blockquote><h3 id="flex-进阶概念"><a href="#flex-进阶概念" class="headerlink" title="flex 进阶概念"></a>flex 进阶概念</h3><ul><li>设置换行方式： flex-wrap</li></ul><blockquote><p>nowrap：不换行</p><p>wrap：换行</p><p>wrap-reverse：逆序换行</p></blockquote><ul><li>轴向与换行组合设置：flex-flow</li><li>多行沿交叉轴对齐：<code>align-content</code></li></ul><blockquote><p>flex-start：起始端对齐</p><p>flex-end：末尾端对齐</p><p>center：居中对齐</p><p>space-around：等边距均匀分布</p><p>space-between：等间距均匀分布</p><p>strench：拉伸对齐</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/e524c68a7305f540.png"></p><h2 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h2><h4 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h4><p>通过声明<code>display:grid</code>该容器是一个块级元素 <code>display: inline-grid</code> 则容器元素为行内元素</p><h4 id="grid-template-columns-属性和-grid-template-rows-属性"><a href="#grid-template-columns-属性和-grid-template-rows-属性" class="headerlink" title="grid-template-columns 属性和 grid-template-rows 属性"></a>grid-template-columns 属性和 grid-template-rows 属性</h4><p><code>grid-template-columns</code> 属性设置列宽，<code>grid-template-rows</code> 属性设置行高</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.wrapper {</span><br><span class="line">  display: grid;</span><br><span class="line">  /*  声明了三列，宽度分别为 200px 100px 200px */</span><br><span class="line">  grid-template-columns: 200px 100px 200px;</span><br><span class="line">  grid-gap: 5px;</span><br><span class="line">  /*  声明了两行，行高分别为 50px 50px  */</span><br><span class="line">  grid-template-rows: 50px 50px;</span><br><span class="line">}</span><br><span class="line">repeat函数：可以简化重复的值 第一个参数是重复的次数 第二个对象是重复的值</span><br><span class="line">grid-template-rows: repeat(2, 50px);</span><br></pre></td></tr></tbody></table></figure><h5 id="auto-fill-关键字：表示自动填充-让一行或者一列中尽可能地容纳更多的单元格"><a href="#auto-fill-关键字：表示自动填充-让一行或者一列中尽可能地容纳更多的单元格" class="headerlink" title="auto-fill 关键字：表示自动填充 让一行或者一列中尽可能地容纳更多的单元格"></a>auto-fill 关键字：表示自动填充 让一行或者一列中尽可能地容纳更多的单元格</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: repeat(auto-fill, 200px);</span><br></pre></td></tr></tbody></table></figure><h5 id="fr-关键字：-fr单位代表网格容器中可用空间的一等份"><a href="#fr-关键字：-fr单位代表网格容器中可用空间的一等份" class="headerlink" title="fr 关键字： fr单位代表网格容器中可用空间的一等份"></a>fr 关键字： <code>fr</code>单位代表网格容器中可用空间的一等份</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: 200px 1fr 2fr;//表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3。</span><br></pre></td></tr></tbody></table></figure><h5 id="minmax-函数：产生一个范围-表示长度在这个范围之中都可以应用到网格项目中-接收两个参数表示最大值和最小值"><a href="#minmax-函数：产生一个范围-表示长度在这个范围之中都可以应用到网格项目中-接收两个参数表示最大值和最小值" class="headerlink" title="minmax()函数：产生一个范围 表示长度在这个范围之中都可以应用到网格项目中 接收两个参数表示最大值和最小值"></a>minmax()函数：产生一个范围 表示长度在这个范围之中都可以应用到网格项目中 接收两个参数表示最大值和最小值</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: 1fr 1fr minmax(300px, 2fr);//，第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍</span><br></pre></td></tr></tbody></table></figure><h5 id="auto-关键字：由浏览器决定长度"><a href="#auto-关键字：由浏览器决定长度" class="headerlink" title="auto 关键字：由浏览器决定长度"></a>auto 关键字：由浏览器决定长度</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: 100px auto 100px;//第一列和第三列为100px 中间由浏览器长度决定</span><br></pre></td></tr></tbody></table></figure><h4 id="grid-row-gap-属性、grid-column-gap-属性以及-grid-gap-属性"><a href="#grid-row-gap-属性、grid-column-gap-属性以及-grid-gap-属性" class="headerlink" title="grid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性"></a>grid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性</h4><p><code>grid-row-gap</code> 属性、<code>grid-column-gap</code> 属性分别设置行间距和列间距。<code>grid-gap</code> 属性是两者的简写形式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-row-gap: 10px;//行间距是10px</span><br><span class="line">grid-cloumn-gap：20px;//列间距是20px；</span><br><span class="line">grid-gap: 10px 20px;//行间距10px 列间距20px</span><br></pre></td></tr></tbody></table></figure><h4 id="grid-template-areas-属性"><a href="#grid-template-areas-属性" class="headerlink" title="grid-template-areas 属性"></a>grid-template-areas 属性</h4><p><code>rid-template-areas</code> 属性用于定义区域，一个区域由一个或者多个单元格组成</p><p>一般这个属性跟网格元素的 <code>grid-area</code> 一起使用 <code>grid-area</code> 属性指定项目放在哪一个区域</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.wrapper {</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-gap: 10px;</span><br><span class="line">  grid-template-columns: 120px  120px  120px;</span><br><span class="line">  grid-template-areas://划出六个单元格 .符号代表空的单元格 即没有用到该单元格</span><br><span class="line">    ". header  header"</span><br><span class="line">    "sidebar content content";</span><br><span class="line">  background-color: #fff;</span><br><span class="line">  color: #444;</span><br><span class="line">}</span><br><span class="line">.sidebar {</span><br><span class="line">  grid-area: sidebar;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.content {</span><br><span class="line">  grid-area: content;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.header {</span><br><span class="line">  grid-area: header;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="grid-auto-flow-属性"><a href="#grid-auto-flow-属性" class="headerlink" title="grid-auto-flow 属性"></a>grid-auto-flow 属性</h3><p><code>grid-auto-flow</code> 属性控制着自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-auto-flow: row;</span><br><span class="line">grid-auto-flow: row dense;//表示尽可能填满表格</span><br><span class="line">grid-auto-flow: column;//表示先列后行</span><br></pre></td></tr></tbody></table></figure><h3 id="justify-items-属性、align-items-属性以及-place-items-属性"><a href="#justify-items-属性、align-items-属性以及-place-items-属性" class="headerlink" title="justify-items 属性、align-items 属性以及 place-items 属性"></a>justify-items 属性、align-items 属性以及 place-items 属性</h3><p><code>justify-items</code> 属性设置单元格内容的水平位置（左中右），<code>align-items</code> 属性设置单元格的垂直位置（上中下）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container {</span><br><span class="line">  justify-items: start | end | center | stretch;</span><br><span class="line">  align-items: start | end | center | stretch;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="justify-content-属性、align-content-属性以及-place-content-属性"><a href="#justify-content-属性、align-content-属性以及-place-content-属性" class="headerlink" title="justify-content 属性、align-content 属性以及 place-content 属性"></a>justify-content 属性、align-content 属性以及 place-content 属性</h3><p><code>justify-content</code> 属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code> 属性是整个内容区域的垂直位置（上中下）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container {</span><br><span class="line">  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">  align-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍</p><p>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔</p><p>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</p><p>stretch - 项目大小没有指定时，拉伸占据整个网格容器</p><h2 id="各种简写形式"><a href="#各种简写形式" class="headerlink" title="各种简写形式"></a>各种简写形式</h2><h4 id="Border-radius"><a href="#Border-radius" class="headerlink" title="Border-radius"></a><code>Border-radius</code></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 1em 2em 3em 4em;//top-left、 top-right、 bottom-right 、bottom-left</span><br></pre></td></tr></tbody></table></figure><h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a><code>Background</code></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: #000 url(images/bg.gif) no-repeat top right;//color-image-repeat-position</span><br></pre></td></tr></tbody></table></figure><h4 id="Font"><a href="#Font" class="headerlink" title="Font"></a><code>Font</code></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: italic bold .8em/1.2 Arial, sans-serif;//style-weight-size-height-family</span><br></pre></td></tr></tbody></table></figure><h4 id="Border"><a href="#Border" class="headerlink" title="Border"></a><code>Border</code></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid #000;//wdth-style-color</span><br></pre></td></tr></tbody></table></figure><h4 id="Margin和Padding"><a href="#Margin和Padding" class="headerlink" title="Margin和Padding"></a><code>Margin</code>和<code>Padding</code></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">margin: 10px 5px 10px 5px;</span><br><span class="line">padding: 10px 5px 10px 5px;</span><br><span class="line">//四个值-上下边距和左右边距-上边距和左右边距和下边距-顺时针</span><br></pre></td></tr></tbody></table></figure><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initial 该关键字代表该元素或其父元素的所有属性至初始值</span><br><span class="line">inherit 元素获取其父元素的计算值 通常只在覆盖原有的值的时候使用 继承始终来自文档树中的父元素 即使父元素不是包含块</span><br><span class="line">unset 表示如果有父元素继承 则继承父元素 否则使用默认 即不是inherit就是initial</span><br></pre></td></tr></tbody></table></figure><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/595fa6efc529bdfd.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学Git第一天</title>
      <link href="/2022/04/15/chu-xue-git-di-yi-tian/"/>
      <url>/2022/04/15/chu-xue-git-di-yi-tian/</url>
      
        <content type="html"><![CDATA[<h2 id="运行-Git-前的配置"><a href="#运行-Git-前的配置" class="headerlink" title="运行 Git 前的配置"></a>运行 Git 前的配置</h2><h3 id="查看所有的配置及它们所在的文件"><a href="#查看所有的配置及它们所在的文件" class="headerlink" title="查看所有的配置及它们所在的文件"></a>查看所有的配置及它们所在的文件</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list --show-origin</span><br></pre></td></tr></tbody></table></figure><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name "John Doe"</span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></tbody></table></figure><p>使用了–global 代表全局配置 如果想根据不同项目使用不同的用户名和邮件地址 可以在该项目目录下运行不带–global</p><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --list //查看所有配置</span><br><span class="line">git config &lt;key&gt;//查看某一项配置 eg: git config user.name</span><br><span class="line">git config --show-origin rerere.autoUpdate //查看原始配置</span><br></pre></td></tr></tbody></table></figure><h2 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br><span class="line">//以上三种命令都是等价的</span><br><span class="line">//eg: 想要获取git config的命令手册 执行 git help config</span><br><span class="line">//如果只需要可用选项的快速参考 可以使用-h来获取更简明的</span><br><span class="line">eg: git add -h</span><br></pre></td></tr></tbody></table></figure><h1 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h1><h2 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h2><h3 id="获取-Git-仓库-1"><a href="#获取-Git-仓库-1" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><ul><li>将未进行版本控制的本地目录转换为 Git 仓库</li><li>从其它服务器 <strong>克隆</strong> 一个已存在的 Git 仓库。</li></ul><h4 id="1-从已存在的目录初始化仓库"><a href="#1-从已存在的目录初始化仓库" class="headerlink" title="1.从已存在的目录初始化仓库"></a>1.从已存在的目录初始化仓库</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. cd project // cd /c/user/my_project</span><br><span class="line">2. git init //初始化 将创建一个.git文件 包含Git仓库的所有文件 此时只是初始化 还未被追踪</span><br><span class="line">3 git add // eg: git add *c 追踪指定的文件</span><br><span class="line">4 git commit -m "..."//初始提交 这样我们就已经得到一个被追踪文件与初始提交的Git仓库</span><br></pre></td></tr></tbody></table></figure><h4 id="2-克隆现有的仓库"><a href="#2-克隆现有的仓库" class="headerlink" title="2.克隆现有的仓库"></a>2.克隆现有的仓库</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. git clone "url" //git clone https://github.com/libgit2/libgit2 会在当前目录初始化.git 并将所有拉取的所有数据都存到.git文件夹 当你想自定义拉下来的仓库名 git clone url yourName</span><br></pre></td></tr></tbody></table></figure><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>每一个文件都是两种状态之一：<strong>已跟踪</strong>或<strong>未跟踪</strong></p><p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/15/fd2225fd7d24e098.png"></p><h4 id="检查当前的状态"><a href="#检查当前的状态" class="headerlink" title="检查当前的状态"></a>检查当前的状态</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></tbody></table></figure><h4 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add fileName // eg: git add README.md</span><br><span class="line">git status // 只要出现changes to be committed 就说明已经是暂存状态 如果此时提交 那么该文件在你运行git add时的版本将被留存在后续的历史记录中</span><br></pre></td></tr></tbody></table></figure><p><code>git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p><h4 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h4><p>要暂存这次更新，需要运行 <code>git add</code> 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</p><p>提交时提交的版本是最后一次 git add 的版本而不是运行 git commit 时的版本</p><h4 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status -s</span><br></pre></td></tr></tbody></table></figure><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。 来看一个实际的 <code>.gitignore</code> 例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></tbody></table></figure><p><code>gitignore</code>的格式规范如下</p><ul><li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>**</code>）表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 忽略所有的 .a 文件</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># 忽略任何目录下名为 build 的文件夹</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></tbody></table></figure><h4 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h4><p>查看未暂存部分更新了哪些部分 不加参数直接输入 git diff</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></tbody></table></figure><p>若要查看已暂存的将要添加到下次提交的内容 可以使用<code>git diff --staged</code> 将对比已暂存文件与最后一次提交的文件差异</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged</span><br></pre></td></tr></tbody></table></figure><p><strong>请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</strong></p><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p><code>git commit</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></tbody></table></figure><p>可以在<code>commit</code>命令后面添加<code>-m</code> 将提交信息与命令行放在同一行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "Story 182: Fix benchmarks for speed"</span><br></pre></td></tr></tbody></table></figure><p>请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p><h4 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h4><p>只要在<code>git commit</code>加上<code>-a</code>选项 Git 就会自动把之前所有已经跟踪的文件暂存起来一并提交 从而跳过<code>git add</code>步骤：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m 'added new benchmarks'</span><br></pre></td></tr></tbody></table></figure><p><strong>需要小心使用 有时这个选项会将不需要的文件添加到提交中</strong></p><h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>要从 Git 中移除某文件 需要先从已跟踪的文件清单（暂存区域）移除 然后提交 可以使用<code>git rm</code> 并连带从工作目录中删除指定的文件 以后不会出现在未跟踪的清单中</p><p>如果只是从工作目录中删除文件 运行<code>git status</code>时就会在“Changes not staged for commit” 部分（也就是 _未暂存清单_）看到：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ rm PROJECTS.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with 'origin/master'.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add/rm &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    PROJECTS.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></tbody></table></figure><p>然后再运行<code>git rm</code>记录此次移除文件的操作</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rm PROJECTS.md</span><br><span class="line">rm 'PROJECTS.md'</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with 'origin/master'.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><br><span class="line"></span><br><span class="line">    deleted:    PROJECTS.md</span><br></pre></td></tr></tbody></table></figure><p>如果要删除之前修改过或已经放到暂存区的文件 则必须强制使用<code>-f</code> 用于防止误删尚未添加到快照的数据 这样的数据不能被 Git 恢复</p><p>如果想要将文件从 Git 仓库删除但是又想保留在当前工作目录中（文件留在磁盘但是不再追踪 Git）例如你忘记添加<code>.gitignore</code>文件 但是一不小心将日志文件或<code>.a</code>这样的编译文件添加到暂存区 这一方法很有用</p><p>使用<code>--cached</code>选项</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached README</span><br></pre></td></tr></tbody></table></figure><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm log/\*.log</span><br></pre></td></tr></tbody></table></figure><h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>要在 Git 中对文件改名</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv file_from file_to</span><br></pre></td></tr></tbody></table></figure><p>可以使用<code>git status</code>查看状态信息以及重命名操作的说明</p><p><code>git mv</code>相当于以下的命令</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></tbody></table></figure><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><h4 id="查看提交历史-1"><a href="#查看提交历史-1" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p><code>git log</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></tbody></table></figure><ul><li><p><code>-p</code> 或 <code>-patch</code> 显式每次提交所引入的差异（按补丁的形式输出） 也可以限制显式的日志条目数量</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p -2</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>--stat</code> 查看每次提交的简略统计信息</p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></tbody></table></figure><ul><li><code>--pretty</code>使用不同的默认格式的方式展示提交信息</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br><span class="line">git log --pretty=format:"%h - %an, %ar : %s";//定制记录的显式格式 对后期提取分析格外有用</span><br></pre></td></tr></tbody></table></figure><ul><li><code>git log --pretty=format</code> 常用的选项</li></ul><table><thead><tr><th><code>%H</code></th><th>提交的完整哈希值</th></tr></thead><tbody><tr><td><code>%h</code></td><td>提交的简写哈希值</td></tr><tr><td><code>%T</code></td><td>树的完整哈希值</td></tr><tr><td><code>%t</code></td><td>树的简写哈希值</td></tr><tr><td><code>%P</code></td><td>父提交的完整哈希值</td></tr><tr><td><code>%p</code></td><td>父提交的简写哈希值</td></tr><tr><td><code>%an</code></td><td>作者名字</td></tr><tr><td><code>%ae</code></td><td>作者的电子邮件地址</td></tr><tr><td><code>%ad</code></td><td>作者修订日期（可以用 –date=选项 来定制格式）</td></tr><tr><td><code>%ar</code></td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td><code>%cn</code></td><td>提交者的名字</td></tr><tr><td><code>%ce</code></td><td>提交者的电子邮件地址</td></tr><tr><td><code>%cd</code></td><td>提交日期</td></tr><tr><td><code>%cr</code></td><td>提交日期（距今多长时间）</td></tr><tr><td><code>%s</code></td><td>提交说明</td></tr></tbody></table><ul><li><code>git log</code> 的常用选项</li></ul><table><thead><tr><th><code>-p</code></th><th>按补丁格式显示每个提交引入的差异。</th></tr></thead><tbody><tr><td><code>--stat</code></td><td>显示每次提交的文件修改统计信息。</td></tr><tr><td><code>--shortstat</code></td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td><code>--name-only</code></td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td><code>--name-status</code></td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td><code>--abbrev-commit</code></td><td>仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。</td></tr><tr><td><code>--relative-date</code></td><td>使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）。</td></tr><tr><td><code>--graph</code></td><td>在日志旁以 ASCII 图形显示分支与合并历史。</td></tr><tr><td><code>--pretty</code></td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format（用来定义自己的格式）。</td></tr><tr><td><code>--oneline</code></td><td><code>--pretty=oneline --abbrev-commit</code> 合用的简写。</td></tr></tbody></table><h4 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h4><p><code>--since</code> 和 <code>--until</code> 这种按照时间作限制的选项很有用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --since=2.weeks //列出最近两周的所有提交</span><br></pre></td></tr></tbody></table></figure><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><h4 id="撤销操作-1"><a href="#撤销操作-1" class="headerlink" title="撤销操作"></a>撤销操作</h4><p>有时候我们漏提交了东西或者提交信息写错了 可以使用<code>--amend</code>选项来重新提交</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></tbody></table></figure><p>这个命令会将暂存区的文件提交 如果自从上次提交以来未做任何操修改（上次提交后立马执行次命令）那么快照会保存不变 所修改的只是提交信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m 'initial commit'</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></tbody></table></figure><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p><p>从效果上来说，就像是旧有的提交从未存在过一样，它并不会出现在仓库的历史中。</p><p>修补提交最明显的价值是可以稍微改进你最后的提交，而不会让“啊，忘了添加一个文件”或者 “小修补，修正笔误”这种提交信息弄乱你的仓库历史。</p><h4 id="取消暂存的操作"><a href="#取消暂存的操作" class="headerlink" title="取消暂存的操作"></a>取消暂存的操作</h4><p>如果已经修改了两个文件并且想要将它们作为两次独立的修改提交 但是却意外地输入了 <code>git add .</code> 如果想取消暂存中的一个 使用 git reset HEAD <file>… 来取消暂存</file></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h4><p>使用 git checkout –<file></file></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- CONTRIBUTING.md</span><br></pre></td></tr></tbody></table></figure><p><strong>请务必记得 <code>git checkout -- &lt;file&gt;</code> 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</strong></p><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><h4 id="远程仓库的使用-1"><a href="#远程仓库的使用-1" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h4><p>查看已经配置好的远程仓库服务器 <code>git remote</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/schacon/ticgit</span><br><span class="line">git remote</span><br></pre></td></tr></tbody></table></figure><p>如果指定<code>-v</code> 会显示需要读写远程仓库使用的 Git 保存的简写与之对应的 URL 如果远程仓库不止一个 还会将协作者一起列出来</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br></pre></td></tr></tbody></table></figure><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库 同时指定一个方便使用的简写</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit</span><br><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></tbody></table></figure><p>如果想要拉取仓库的代码 使用 git fetch pb</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch pb</span><br></pre></td></tr></tbody></table></figure><h4 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h4><p>从远程仓库中获取代码 可以执行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></tbody></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你的当前分支设置了跟踪远程分支 那么可以用 <code>git pull</code> 命令来自动抓取后合并该远程分支到当前分支。</p><p>默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 <code>master</code> 分支（或其它名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p><code>git push &lt;remote&gt; &lt;branch&gt;</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master//将master分支推送到origin分支</span><br></pre></td></tr></tbody></table></figure><h4 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h4><p><code>git remote show &lt;remote&gt;</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                               tracked</span><br><span class="line">    dev-branch                           tracked</span><br><span class="line">  Local branch configured for 'git pull':</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for 'git push':</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></tbody></table></figure><h4 id="远程仓库的重命名与移除"><a href="#远程仓库的重命名与移除" class="headerlink" title="远程仓库的重命名与移除"></a>远程仓库的重命名与移除</h4><p><code>git remote rename</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul //将pb重命名未paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></tbody></table></figure><p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p><p>移除一个远程仓库</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote remove paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></tbody></table></figure><p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUEAPI</title>
      <link href="/2022/04/14/vueapi/"/>
      <url>/2022/04/14/vueapi/</url>
      
        <content type="html"><![CDATA[<h1 id="全局-API"><a href="#全局-API" class="headerlink" title="全局 API"></a>全局 API</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="createApp"><a href="#createApp" class="headerlink" title="createApp()"></a>createApp()</h3><ul><li>类型</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function createApp(rootComponent: Component, rootProps?: object): App</span><br></pre></td></tr></tbody></table></figure><ul><li><p>细节</p><p>第一个参数是根组件 第二个是传递给跟组件的 props</p></li><li><p>例子</p><p>使用内联根组件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createApp } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>({</span><br><span class="line">  <span class="comment">/* root component options */</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>使用引用组件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createApp } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">"./App.vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="app-mount"><a href="#app-mount" class="headerlink" title="app.mount()"></a>app.mount()</h3><ul><li><p>类型</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  <span class="title function_">mount</span>(<span class="attr">rootContainer</span>: <span class="title class_">Element</span> | <span class="built_in">string</span>): <span class="title class_">ComponentPublicInstance</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>细节</p><p>参数可以是实际的 DOM 元素或 CSS 选择器 返回根组件实例</p><p>如果组件定义了模板或渲染函数 他将替代容器内现有的 DOM 节点 否则 将在运行时使用容器的 innerHTML 作为模板</p><p>对于每个实例 <code>mount()</code>只能调用一次</p></li></ul><p>app.unmount()</p><p>卸载已挂载的应用程序实例 触发应用程序组件树中所有组件的卸载生命周期</p><ul><li>类型</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  <span class="title function_">unmount</span>(): <span class="built_in">void</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="app-provide"><a href="#app-provide" class="headerlink" title="app.provide"></a>app.provide</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  provide&lt;T&gt;(<span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;T&gt; | <span class="built_in">symbol</span> | <span class="built_in">string</span>, <span class="attr">value</span>: T): <span class="variable language_">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>期望注入值作为第一个参数 提供的值作为第二个参数 返回应用程序实例本身</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { provide } from "vue";</span><br><span class="line"></span><br><span class="line">provide(/* key */ "message", /* value */ "hello!");</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import { inject } from "vue";</span><br><span class="line"></span><br><span class="line">const message = inject("message");</span><br><span class="line">const value = inject("message", "default value"); //注入默认值</span><br><span class="line">const value = inject("key", () =&gt; new ExpensiveClass()); //避免在不适用可选值的情况下产生不必要的计算或副作用 可以使用工厂函数来创建默认值</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="app-component"><a href="#app-component" class="headerlink" title="app.component()"></a>app.component()</h3><ul><li>类型</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  <span class="title function_">component</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Component</span> | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">component</span>(<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">component</span>: <span class="title class_">Component</span>): <span class="variable language_">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>例子</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import { createApp } from 'vue' const app = createApp({}) // register an options</span><br><span class="line">object app.component('my-component', { /* ... */ }) // retrieve a registered</span><br><span class="line">component const MyComponent = app.component('my-component')</span><br></pre></td></tr></tbody></table></figure><h3 id="app-directive"><a href="#app-directive" class="headerlink" title="app.directive()"></a>app.directive()</h3><p>如果定义字符串名称 则同时输入指令和指令 则只要检索已注册的指令</p><ul><li>类型</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  <span class="title function_">directive</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Directive</span> | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">directive</span>(<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">directive</span>: <span class="title class_">Directive</span>): <span class="variable language_">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>例子</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import { createApp } from 'vue' const app = createApp({ /* ... */ }) // register</span><br><span class="line">(object directive) app.directive('my-directive', { /* custom directive hooks */</span><br><span class="line">}) // register (function directive shorthand) app.directive('my-directive', ()</span><br><span class="line">=&gt; { /* ... */ }) // retrieve a registered directive const myDirective =</span><br><span class="line">app.directive('my-directive')</span><br></pre></td></tr></tbody></table></figure><h3 id="app-use"><a href="#app-use" class="headerlink" title="app.use()"></a>app.use()</h3><p>安装一个插件</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  <span class="title function_">use</span>(<span class="attr">plugin</span>: <span class="title class_">Plugin</span>, ...<span class="attr">options</span>: <span class="built_in">any</span>[]): <span class="variable language_">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>期望插件作为第一个参数 可选选项作为第二个参数</p><p>插件可以是带有<code>install()</code>方法的对象 也可以是直接的函数</p><p>当<code>app.use()</code>在同一个插件上多次调用时 插件只会安装一次</p><ul><li>例子</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import { createApp } from 'vue' import MyPlugin from './plugins/MyPlugin' const</span><br><span class="line">app = createApp({ /* ... */ }) app.use(MyPlugin)</span><br></pre></td></tr></tbody></table></figure><h3 id="app-version"><a href="#app-version" class="headerlink" title="app.version"></a>app.version</h3><p>提供创建应用程序时使用的 vue 版本 这在插件中很有用 因为可能需要基于不同的 Vue 版本的条件逻辑</p><ul><li>类型</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">App</span> {</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>例子</li></ul><p>在插件中执行版本检查</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="title function_">install</span>(<span class="params">app</span>) {</span><br><span class="line">    <span class="keyword">const</span> version = <span class="title class_">Number</span>(app.<span class="property">version</span>.<span class="title function_">split</span>(<span class="string">"."</span>)[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (version &lt; <span class="number">3</span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">"This plugin requires Vue 3"</span>);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="app-config"><a href="#app-config" class="headerlink" title="app.config"></a>app.config</h3><h3 id="app-config-errorHandler"><a href="#app-config-errorHandler" class="headerlink" title="app.config.errorHandler"></a>app.config.errorHandler</h3><p>从未应用程序未内部部署的一个内部处理程序</p><ul><li>类型</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">  errorHandler?: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    err: <span class="built_in">unknown</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    instance: ComponentPublicInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// `info` is a Vue-specific error info,</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// e.g. which lifecycle hook the error was thrown in</span></span></span></span><br><span class="line"><span class="params"><span class="function">    info: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>错误处理程序接收三个参数：错误、触发错误的组件实例和指定源类型的信息字符串</p><p>可以捕获到以下错误类型：</p><ul><li>渲染组件</li><li>事件处理程序</li><li>生命周期钩子</li><li>setup()功能</li><li>观察者</li><li>自定义指令钩子</li><li>过度挂载</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.config.errorHandler = (err, instance, info) =&gt; { // handle error, e.g.</span><br><span class="line">report to a service }</span><br></pre></td></tr></tbody></table></figure><h3 id="app-config-warnHandler"><a href="#app-config-warnHandler" class="headerlink" title="app.config.warnHandler"></a>app.config.warnHandler</h3><p>为来自 Vue 的运行时警告分配一个自定义处理程序</p><ul><li>类型</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">  warnHandler?: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    msg: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    instance: ComponentPublicInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    trace: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//第一个参数时接收警告信息 第二个参数是源组件实例 第三个参数是组件跟踪字符串</span></span><br></pre></td></tr></tbody></table></figure><p>用于过滤特定的警告以减少控制台的冗长 所有 Vue 警告都应该在开发期间解决 因此建议在调试会话期间关注许多特定警告并在调试完成后将其删除</p><p><strong>仅在开发期间有效 因此在生成模式下会忽略此配置</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.config.warnHandler = (msg, instance, trace) =&gt; { // `trace` is the component</span><br><span class="line">hierarchy trace }</span><br></pre></td></tr></tbody></table></figure><h3 id="app-config-performance"><a href="#app-config-performance" class="headerlink" title="app.config.performance"></a>app.config.performance</h3><p>设置为 true 在浏览器开发工具性能/事件线面板中启用组件初始化、编译、渲染和修补性能跟踪 仅用于开发模式和支持<a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark">performance.mark</a> API 的浏览器。</p><h3 id="app-compilerOptions-isCustomElement"><a href="#app-compilerOptions-isCustomElement" class="headerlink" title="app.compilerOptions.isCustomElement"></a>app.compilerOptions.isCustomElement</h3><p>指定一个检查方法来识别本机自定义元素</p><ul><li>类型：（tag: string） =&gt; boolean</li><li>细节</li></ul><p>如果标签被视为本机自定义元素 则应返回 对于匹配的标签 Vue 将其呈现为原生元素 而不是尝试将其解析为 Vue 组件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// treat all tags starting with 'ion-' as custom elements</span><br><span class="line">app.config.compilerOptions.isCustomElement = (tag) =&gt; { return</span><br><span class="line">tag.startsWith('ion-') }</span><br></pre></td></tr></tbody></table></figure><h3 id="app-compilerOptions-whitespace"><a href="#app-compilerOptions-whitespace" class="headerlink" title="app.compilerOptions.whitespace"></a>app.compilerOptions.whitespace</h3><p>调整模板空白处理行为</p><ul><li>类型：<code>‘condense' | 'preserve'</code></li><li>默认： <code>'condense'</code></li><li>细节</li></ul><p>Vue 删除/压缩模板中的空白字符以产生更有效的编译输出 默认策略是“浓缩”</p><ul><li>元素内的前导/结束空白字符被压缩成一个字符</li><li>包含换行符的元素之间的空白字符被删除</li><li>文本节点中连续的空白字符被压缩成一个空格</li></ul><p>将吃选项设置为<code>'preserve'</code>将禁用(2) 和 (3)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config.compilerOptions.whitespace = 'preserve'</span><br></pre></td></tr></tbody></table></figure><h3 id="app-compilerOptions-delimiters"><a href="#app-compilerOptions-delimiters" class="headerlink" title="app.compilerOptions.delimiters"></a>app.compilerOptions.delimiters</h3><p>调整用于模板内文本插值的分隔符</p><ul><li>类型： <code>[string, string]</code></li><li>默认： <code>['{{', '}}']</code></li><li>细节</li></ul><p>通常用于避免与使用 mustache 语法的服务器框架发生冲突</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Delimiters changed to ES6 template string style</span><br><span class="line">app.config.compilerOptions.delimiters = ['${', '}']</span><br></pre></td></tr></tbody></table></figure><h3 id="app-compilerOptions-comments"><a href="#app-compilerOptions-comments" class="headerlink" title="app.compilerOptions.comments"></a>app.compilerOptions.comments</h3><p>调整模板中 HTML 注释的处理方法</p><ul><li>boolean</li><li>默认： false</li><li>细节</li></ul><p>默认情况下 Vue 会删除生产环境中的注释 将此选项设置为 true 将强制 vue 即使在生产中也保留注释 在开发过程中始终保留注释</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config.compilerOptions.comments = true</span><br></pre></td></tr></tbody></table></figure><h2 id="app-config-globalProperties"><a href="#app-config-globalProperties" class="headerlink" title="app.config.globalProperties"></a>app.config.globalProperties</h2><p>可用于注册全局属性的对象 可在应用程序内的任何组件实例上访问这些属性</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">  <span class="attr">globalProperties</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>细节</p></li><li><p>与任何全局的东西一样 应该谨慎使用它</p></li><li><p>如果全局属性与自己的属性充裕 组件自己的属性将拥有更高的优先级</p></li><li><p>```vue<br>app.config.globalProperties.msg = ‘hello’ export default { mounted() {<br>console.log(this.msg) // ‘hello’ } }</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### nextTick（）</span><br><span class="line"></span><br><span class="line">等待下一次 DOM 更新刷新的应用程序</span><br><span class="line"></span><br><span class="line">```typescript</span><br><span class="line">function nextTick(callback?: () =&gt; void): Promise&lt;void&gt;;</span><br></pre></td></tr></tbody></table></figure></li><li><p>细节</p></li></ul><p>当你在 Vue 改变响应状态时 生成的 DOM 更新不会同步应用 Vue 会缓存它们直到下一个 nextTick（）以确保无论您进行了多少次状态更改每个组件都只更新一次</p><p>nextTick()可以在状态更改后立即使用以等待 DOM 更新完成 可以将回调作为参数传递 也可以等待返回的 Promise</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { ref, nextTick } from "vue";</span><br><span class="line"></span><br><span class="line">const count = ref(0);</span><br><span class="line"></span><br><span class="line">async function increment() {</span><br><span class="line">  count.value++;</span><br><span class="line"></span><br><span class="line">  // DOM not yet updated</span><br><span class="line">  console.log(document.getElementById("counter").textContent); // 0</span><br><span class="line"></span><br><span class="line">  await nextTick();</span><br><span class="line">  // DOM is now updated</span><br><span class="line">  console.log(document.getElementById("counter").textContent); // 1</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button id="counter" @click="increment"&gt;{{ count }}&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="defineComponent"><a href="#defineComponent" class="headerlink" title="defineComponent()"></a>defineComponent()</h2><p>用于定义具有类型推断的 Vue 组件的类型助手</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  component: ComponentOptions | ComponentOptions[<span class="string">"setup"</span>]</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">ComponentConstructor</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="defineAsyncComponent"><a href="#defineAsyncComponent" class="headerlink" title="defineAsyncComponent()"></a>defineAsyncComponent()</h2><p>定义一个仅在渲染时才延迟加载的异步组件 参数可以是加载器函数 也可以是用于更高级控制加载行为的选项对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineAsyncComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  source: AsyncComponentLoader | AsyncComponentOptions</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AsyncComponentLoader</span> = <span class="function">() =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="title class_">Component</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AsyncComponentOptions</span> {</span><br><span class="line">  <span class="attr">loader</span>: <span class="title class_">AsyncComponentLoader</span>;</span><br><span class="line">  loadingComponent?: <span class="title class_">Component</span>;</span><br><span class="line">  errorComponent?: <span class="title class_">Component</span>;</span><br><span class="line">  delay?: <span class="built_in">number</span>;</span><br><span class="line">  timeout?: <span class="built_in">number</span>;</span><br><span class="line">  suspensible?: <span class="built_in">boolean</span>;</span><br><span class="line">  onError?: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    error: <span class="built_in">Error</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    retry: () =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    fail: () =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    attempts: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Composition-api"><a href="#Composition-api" class="headerlink" title="Composition api"></a>Composition api</h1><h2 id="setup（）"><a href="#setup（）" class="headerlink" title="setup（）"></a>setup（）</h2><p>如果对 props 对象解构 那么将失去响应性</p><p>可以使用 toRefs()或 toRef()程序执行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import { toRefs, toRef } from 'vue' export default { setup(props) { // turn</span><br><span class="line">`props` into an object of refs, then destructure const { title } = toRefs(props)</span><br><span class="line">// `title` is a ref that tracks `props.title` console.log(title.value) // OR,</span><br><span class="line">turn a single property on `props` into a ref const title = toRef(props, 'title')</span><br><span class="line">} }</span><br></pre></td></tr></tbody></table></figure><h3 id="Setup-Context"><a href="#Setup-Context" class="headerlink" title="Setup Context"></a>Setup Context</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default { setup(props, context) { // Attributes (Non-reactive object,</span><br><span class="line">equivalent to $attrs) console.log(context.attrs) // Slots (Non-reactive object,</span><br><span class="line">equivalent to $slots) console.log(context.slots) // Emit events (Function,</span><br><span class="line">equivalent to $emit) console.log(context.emit) // Expose public properties</span><br><span class="line">(Function) console.log(context.expose) } }</span><br></pre></td></tr></tbody></table></figure><p>context 不是响应式的 可以安全地解构</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default { setup(props, { attrs, slots, emit, expose }) { ... } }</span><br></pre></td></tr></tbody></table></figure><p>如果打算对更改执行副作用 应该在生命周期钩子中执行此操作<code>attrsslotsattrsslotsonBeforeUpdate</code></p><p><code>expose</code>是一个函数 可以显式限制父组件通过模板 refs 访问组件实例时暴露的属性：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, { expose }</span>) {</span><br><span class="line">    <span class="comment">// make the instance "closed" -</span></span><br><span class="line">    <span class="comment">// i.e. do not expose anything to the parent</span></span><br><span class="line">    <span class="title function_">expose</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> publicCount = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> privateCount = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// selectively expose local state</span></span><br><span class="line">    <span class="title function_">expose</span>({ <span class="attr">count</span>: publicCount });</span><br><span class="line">  },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="与渲染函数一起使用"><a href="#与渲染函数一起使用" class="headerlink" title="与渲染函数一起使用"></a>与渲染函数一起使用</h3><p><code>setup</code>还可以返回一个渲染函数 该函数可以直接使用同一范围内声明的反应状态</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { h, ref } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">"div"</span>, count.<span class="property">value</span>);</span><br><span class="line">  },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>返回一个渲染函数可以的防止我们返回其他任何东西 可以使用<code>expose()</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { h, ref } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, { expose }</span>) {</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; ++count.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expose</span>({</span><br><span class="line">      increment,</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">"div"</span>, count.<span class="property">value</span>);</span><br><span class="line">  },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>然后 该<code>increment</code>方法将通过模板引用在父组件中可用</p><h2 id="反应性核心"><a href="#反应性核心" class="headerlink" title="反应性核心"></a>反应性核心</h2><h3 id="ref（）"><a href="#ref（）" class="headerlink" title="ref（）"></a>ref（）</h3><p>接收一个内部值并返回一个反应性和响应的 ref 对象 他还有一个<code>.value</code>指向内部值的属性</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> ref&lt;T&gt;(<span class="attr">value</span>: T): <span class="title class_">Ref</span>&lt;<span class="title class_">UnwrapRef</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Ref</span>&lt;T&gt; {</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>如果一个对象被分配为一个 ref 的值 那么该对象将与<code>reactive()</code>进行深度响应 这也意味着如果对象包含嵌套的 ref 它们将被深度展开</p><p>为了避免深度转换 请使用<code>shallowRef()</code></p><h3 id="computed"><a href="#computed" class="headerlink" title="computed()"></a>computed()</h3><p>接收一个函数并未 getter 的返回值返回一个实时的<code>ref</code>对象 可以使用具有<code>get</code>和<code>set</code>函数的对象来创建 ref 对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read-only</span></span><br><span class="line"><span class="keyword">function</span> computed&lt;T&gt;(</span><br><span class="line">  <span class="attr">getter</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  <span class="comment">// see "Computed Debugging" link below</span></span><br><span class="line">  debuggerOptions?: <span class="title class_">DebuggerOptions</span></span><br><span class="line">): <span class="title class_">Readonly</span>&lt;<span class="title class_">Ref</span>&lt;<span class="title class_">Readonly</span>&lt;T&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// writable</span></span><br><span class="line"><span class="keyword">function</span> computed&lt;T&gt;(</span><br><span class="line">  <span class="attr">options</span>: {</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> T;</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">value: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  },</span><br><span class="line">  debuggerOptions?: <span class="title class_">DebuggerOptions</span></span><br><span class="line">): <span class="title class_">Ref</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a>reactive()</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> reactive&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">target</span>: T): <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><p>当使用数组的元素或者集合类型如(<code>Map</code>) 为避免深度转换并仅在根级别保留响应性 可以改用<code>shallowReactive()</code></p><p>返回的对象及其嵌套对象被 ES Proxy 包裹 不等于原始对象 建议只使用响应式代理并避免依赖原始对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>({ count });</span><br><span class="line"></span><br><span class="line"><span class="comment">// ref will be unwrapped</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span> === count.<span class="property">value</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// it will update `obj.count`</span></span><br><span class="line">count.<span class="property">value</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// it will also update `count` ref</span></span><br><span class="line">obj.<span class="property">count</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>); <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><p>当作为数组或集合元素访问时 refs 不会被解构</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = <span class="title function_">reactive</span>([<span class="title function_">ref</span>(<span class="string">"Vue 3 Guide"</span>)]);</span><br><span class="line"><span class="comment">// need .value here</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(books[<span class="number">0</span>].<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="title function_">reactive</span>(<span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">"count"</span>, <span class="title function_">ref</span>(<span class="number">0</span>)]]));</span><br><span class="line"><span class="comment">// need .value here</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">"count"</span>).<span class="property">value</span>);</span><br></pre></td></tr></tbody></table></figure><p>将 ref 分配给 reactive 属性时 该 ref 将自动展开</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>({});</span><br><span class="line"></span><br><span class="line">obj.<span class="property">count</span> = count;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span> === count.<span class="property">value</span>); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly()"></a>readonly()</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">readonly</span>&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">DeepReadonly</span>&lt;<span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;&gt;;</span><br></pre></td></tr></tbody></table></figure><p>它展示的任何属性都将是潜在的<code>reactive()</code></p><p>避免深度转换 请使用<code>shallowReadonly()</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>({ <span class="attr">count</span>: <span class="number">0</span> });</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="title function_">readonly</span>(original);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="comment">// works for reactivity tracking</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(copy.<span class="property">count</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating original will trigger watchers relying on the copy</span></span><br><span class="line">original.<span class="property">count</span>++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating the copy will fail and result in a warning</span></span><br><span class="line">copy.<span class="property">count</span>++; <span class="comment">// warning!</span></span><br></pre></td></tr></tbody></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect()"></a>watchEffect()</h3><p>立即运行一个函数，同时跟随变化时重新关注它的依赖关系，并在依赖关系发生时重新运行它。</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  effect: (onCleanup: OnCleanup) =&gt; <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">  options?: WatchEffectOptions</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">StopHandle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OnCleanup</span> = <span class="function">(<span class="params">cleanupFn: () =&gt; <span class="built_in">void</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">WatchEffectOptions</span> {</span><br><span class="line">  flush?: <span class="string">"pre"</span> | <span class="string">"post"</span> | <span class="string">"sync"</span>; <span class="comment">// default: 'pre'</span></span><br><span class="line">  onTrack?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onTrigger?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StopHandle</span> = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>第一个参数是要运行的效果函数 效果函数接收可用于注册清理回调的函数 清理回调将在下一次重新运行效果之前调用 可用于清理无效的副作用 例如挂起的异步请求</p><p>第二个参数是可选的选项对象 用于调整效果的刷新时间或调试效果的依赖关系</p><p>返回值是一个 handdle 函数可以用来组织效果再次运行</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>));</span><br><span class="line"><span class="comment">// -&gt; logs 0</span></span><br><span class="line"></span><br><span class="line">count.<span class="property">value</span>++;</span><br><span class="line"><span class="comment">// -&gt; logs 1</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>));</span><br><span class="line"><span class="comment">// -&gt; logs 0</span></span><br><span class="line"></span><br><span class="line">count.<span class="property">value</span>++;</span><br></pre></td></tr></tbody></table></figure><p>副作用清理</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">async</span> (onCleanup) =&gt; {</span><br><span class="line">  <span class="keyword">const</span> { response, cancel } = <span class="title function_">doAsyncWork</span>(id.<span class="property">value</span>);</span><br><span class="line">  <span class="comment">// `cancel` will be called if `id` changes</span></span><br><span class="line">  <span class="comment">// so that previous pending request will be cancelled</span></span><br><span class="line">  <span class="comment">// if not yet completed</span></span><br><span class="line">  <span class="title function_">onCleanup</span>(cancel);</span><br><span class="line">  data.<span class="property">value</span> = <span class="keyword">await</span> response;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>停止观察者</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> {});</span><br><span class="line"></span><br><span class="line"><span class="comment">// when the watcher is no longer needed:</span></span><br><span class="line"><span class="title function_">stop</span>();</span><br></pre></td></tr></tbody></table></figure><p>Options:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> {}, {</span><br><span class="line">  <span class="attr">flush</span>: <span class="string">"post"</span>,</span><br><span class="line">  <span class="title function_">onTrack</span>(<span class="params">e</span>) {</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">onTrigger</span>(<span class="params">e</span>) {</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">  },</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch()"></a>watch()</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watching single source</span></span><br><span class="line"><span class="keyword">function</span> watch&lt;T&gt;(</span><br><span class="line">  <span class="attr">source</span>: <span class="title class_">WatchSource</span>&lt;T&gt;,</span><br><span class="line">  <span class="attr">callback</span>: <span class="title class_">WatchCallback</span>&lt;T&gt;,</span><br><span class="line">  options?: <span class="title class_">WatchOptions</span></span><br><span class="line">): <span class="title class_">StopHandle</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// watching multiple sources</span></span><br><span class="line"><span class="keyword">function</span> watch&lt;T&gt;(</span><br><span class="line">  <span class="attr">sources</span>: <span class="title class_">WatchSource</span>&lt;T&gt;[],</span><br><span class="line">  <span class="attr">callback</span>: <span class="title class_">WatchCallback</span>&lt;T[]&gt;,</span><br><span class="line">  options?: <span class="title class_">WatchOptions</span></span><br><span class="line">): <span class="title class_">StopHandle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">WatchCallback</span>&lt;T&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: T,</span></span></span><br><span class="line"><span class="params"><span class="function">  oldValue: T,</span></span></span><br><span class="line"><span class="params"><span class="function">  onCleanup: (cleanupFn: () =&gt; <span class="built_in">void</span>) =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">WatchSource</span>&lt;T&gt; =</span><br><span class="line">  | <span class="title class_">Ref</span>&lt;T&gt; <span class="comment">// ref</span></span><br><span class="line">  | (<span class="function">() =&gt;</span> T) <span class="comment">// getter</span></span><br><span class="line">  | T <span class="keyword">extends</span> <span class="built_in">object</span></span><br><span class="line">  ? T</span><br><span class="line">  : <span class="built_in">never</span>; <span class="comment">// reactive object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">WatchOptions</span> <span class="keyword">extends</span> <span class="title class_">WatchEffectOptions</span> {</span><br><span class="line">  immediate?: <span class="built_in">boolean</span>; <span class="comment">// default: false</span></span><br><span class="line">  deep?: <span class="built_in">boolean</span>; <span class="comment">// default: false</span></span><br><span class="line">  flush?: <span class="string">"pre"</span> | <span class="string">"post"</span> | <span class="string">"sync"</span>; <span class="comment">// default: 'pre'</span></span><br><span class="line">  onTrack?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onTrigger?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p><code>watch</code>默认是惰性的 即当监视的源发生更改时才调用回调</p><p>第三个参数时一个<code>options</code></p><ul><li>**<code>immediate</code>**：在观察者创建时立即触发回调。旧值将<code>undefined</code>在第一次调用时出现。</li><li>**<code>deep</code>**：如果源是对象，则强制深度遍历源，以便回调触发深度突变。</li><li>**<code>flush</code>**：调整回调的刷新时间。</li><li><strong><code>onTrack / onTrigger</code></strong>: 调试观察者的依赖</li></ul><p>相比<a href="https://vuejs.org/api/reactivity-core.html#watcheffect"><code>watchEffect()</code></a>，<code>watch()</code>允许我们：</p><ul><li>懒惰地执行副作用；</li><li>更具体地说明应该触发观察者重新运行的状态；</li><li>访问监视状态的先前值和当前值。</li></ul><p>当观察多个源时 回调函数将接收包含与源数组对应的新/旧值的数组</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>([fooRef, barRef], <span class="function">(<span class="params">[foo, bar], [prevFoo, prevBar]</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>如果希望回调即使在深度突变时也能触发 那么需要使用显式强制观察者进入深度模式{deep: <code>true</code>} <strong>在深度模式下 如果回调是由深度突变触发的 那么新值和旧值将是同一个对象</strong></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>({ <span class="attr">count</span>: <span class="number">0</span> });</span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> state,</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// newValue === oldValue</span></span><br><span class="line">  },</span><br><span class="line">  { <span class="attr">deep</span>: <span class="literal">true</span> }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p><strong>如果直接观察响应式对象 观察者处于深度模式</strong></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>({ <span class="attr">count</span>: <span class="number">0</span> });</span><br><span class="line"><span class="title function_">watch</span>(state, <span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="comment">/* triggers on deep mutation to state */</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h2 id="Reactivity-Utilities"><a href="#Reactivity-Utilities" class="headerlink" title="Reactivity: Utilities"></a>Reactivity: Utilities</h2><h3 id="isRef"><a href="#isRef" class="headerlink" title="isRef()"></a>isRef()</h3><p>检查一个值是否是一个 ref 对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> isRef&lt;T&gt;(<span class="attr">r</span>: <span class="title class_">Ref</span>&lt;T&gt; | <span class="built_in">unknown</span>): r is <span class="title class_">Ref</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><p>返回类型是一个类型谓词 可以作为类型保护</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">unknown</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isRef</span>(foo)) {</span><br><span class="line">  <span class="comment">// foo's type is narrowed to Ref&lt;unknown&gt;</span></span><br><span class="line">  foo.<span class="property">value</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="unref"><a href="#unref" class="headerlink" title="unref()"></a>unref()</h3><p>如果参数是 ref 则返回内部值 否则返回参数本身</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = <span class="title function_">isRef</span>(val) ? val.<span class="property">value</span> : val;</span><br></pre></td></tr></tbody></table></figure><h3 id="toRef（）"><a href="#toRef（）" class="headerlink" title="toRef（）"></a>toRef（）</h3><p>用于为源响应对象上的属性创建 ref 创建的 ref 与其源属性同步 改变原属性将更新 ref</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> toRef&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, K <span class="keyword">extends</span> keyof T&gt;(</span><br><span class="line">  <span class="attr">object</span>: T,</span><br><span class="line">  <span class="attr">key</span>: K,</span><br><span class="line">  defaultValue?: T[K]</span><br><span class="line">): <span class="title class_">ToRef</span>&lt;T[K]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToRef</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">Ref</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>({</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooRef = <span class="title function_">toRef</span>(state, <span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating the ref updates the original</span></span><br><span class="line">fooRef.<span class="property">value</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">foo</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating the original also updates the ref</span></span><br><span class="line">state.<span class="property">foo</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooRef.<span class="property">value</span>); <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><p>当你想将 prop 的 ref 传递给可组合函数时很有用</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> {toRef} <span class="keyword">from</span> <span class="string">'vue'</span> <span class="keyword">const</span> props = <span class="title function_">defineProps</span>(<span class="comment">/* ... */</span>) <span class="comment">// convert</span></span><br><span class="line">  <span class="string">`props.foo`</span> into a ref, then pass into <span class="comment">// a composable</span></span><br><span class="line">  <span class="title function_">useSomeFeature</span>(<span class="title function_">toRef</span>(props, <span class="string">'foo'</span>))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>但是如果尝试为 ref 分配新值时相当直接修改 prop 这是不允许的 这种情况下 可以考虑使用 computed 来替代</p><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs()"></a>toRefs()</h3><p>将响应式对象转换为普通对象 其中结果对象的每个属性都是指向原始对象相应属性的 ref 每个单独的 ref 都是使用 toRef()```创建的</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> toRefs&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(</span><br><span class="line">  <span class="attr">object</span>: T</span><br><span class="line">): {</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: <span class="title class_">ToRef</span>&lt;T[K]&gt;;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToRef</span> = T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">Ref</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>({</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stateAsRefs = <span class="title function_">toRefs</span>(state);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Type of stateAsRefs: {</span></span><br><span class="line"><span class="comment">  foo: Ref&lt;number&gt;,</span></span><br><span class="line"><span class="comment">  bar: Ref&lt;number&gt;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The ref and the original property is "linked"</span></span><br><span class="line">state.<span class="property">foo</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stateAsRefs.<span class="property">foo</span>.<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">stateAsRefs.<span class="property">foo</span>.<span class="property">value</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">foo</span>); <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><p>toRefs 在从可组合函数返回响应式对象时很有用 以便使用组件可以构建/扩展返回的对象而不会失去响应性</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useFeatureX</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">const</span> state = <span class="title function_">reactive</span>({</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...logic operating on state</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// convert to refs when returning</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// can destructure without losing reactivity</span></span><br><span class="line"><span class="keyword">const</span> { foo, bar } = <span class="title function_">useFeatureX</span>();</span><br></pre></td></tr></tbody></table></figure><p><code>toRefs</code>只会在调用时为源对象上可枚举的属性生成引用。要为可能尚不存在的属性创建 ref，请<a href="https://vuejs.org/api/reactivity-utilities.html#toref"><code>toRef</code></a>改用。</p><h3 id="isProxy"><a href="#isProxy" class="headerlink" title="isProxy()"></a>isProxy()</h3><p>Checks if an object is a proxy created by <a href="https://vuejs.org/api/reactivity-core.html#reactive"><code>reactive()</code></a>, <a href="https://vuejs.org/api/reactivity-core.html#readonly"><code>readonly()</code></a>, <a href="https://vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> or <a href="https://vuejs.org/api/reactivity-advanced.html#shallowreadonly"><code>shallowReadonly()</code></a>.</p><h3 id="isReactive"><a href="#isReactive" class="headerlink" title="isReactive()"></a>isReactive()</h3><p>Checks if an object is a proxy created by <a href="https://vuejs.org/api/reactivity-core.html#reactive"><code>reactive()</code></a> or <a href="https://vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a>.</p><h3 id="isReadonly"><a href="#isReadonly" class="headerlink" title="isReadonly()"></a>isReadonly()</h3><p>Checks if an object is a proxy created by <a href="https://vuejs.org/api/reactivity-core.html#readonly"><code>readonly()</code></a> or <a href="https://vuejs.org/api/reactivity-advanced.html#shallowreadonly"><code>shallowReadonly()</code></a>.</p><h2 id="响应式：高级"><a href="#响应式：高级" class="headerlink" title="响应式：高级"></a>响应式：高级</h2><h3 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a>shallowRef</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> shallowRef&lt;T&gt;(<span class="attr">value</span>: T): <span class="title class_">ShallowRef</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ShallowRef</span>&lt;T&gt; {</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与<code>ref()</code>不同 <code>shallowdRef</code>的内部值按原样储存和公开 不会被深度响应 只有.<code>value</code>是响应性的</p><p>通常用于大型数据结构的性能优化 或外部状态管理系统的集成</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">shallowRef</span>({ <span class="attr">count</span>: <span class="number">1</span> });</span><br><span class="line"></span><br><span class="line"><span class="comment">// does NOT trigger change</span></span><br><span class="line">state.<span class="property">value</span>.<span class="property">count</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// does trigger change</span></span><br><span class="line">state.<span class="property">value</span> = { <span class="attr">count</span>: <span class="number">2</span> };</span><br></pre></td></tr></tbody></table></figure><h3 id="triggerRef"><a href="#triggerRef" class="headerlink" title="triggerRef()"></a>triggerRef()</h3><p>强制触发效果取决于<code>shallowRef</code> 这通常在浅反应的内部值进行深度突变后使用</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">triggerRef</span>(<span class="params">ref: ShallowRef</span>): <span class="built_in">void</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallow = <span class="title function_">shallowRef</span>({</span><br><span class="line">  <span class="attr">greet</span>: <span class="string">"Hello, world"</span>,</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs "Hello, world" once for the first run-through</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(shallow.<span class="property">value</span>.<span class="property">greet</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// This won't trigger the effect because the ref is shallow</span></span><br><span class="line">shallow.<span class="property">value</span>.<span class="property">greet</span> = <span class="string">"Hello, universe"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs "Hello, universe"</span></span><br><span class="line"><span class="title function_">triggerRef</span>(shallow);</span><br></pre></td></tr></tbody></table></figure><h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef()"></a>customRef()</h3><p>创建一个自定义的 ref 显式控制其依赖跟踪和更新触发</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> customRef&lt;T&gt;(<span class="attr">factory</span>: <span class="title class_">CustomRefFactory</span>&lt;T&gt;): <span class="title class_">Ref</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CustomRefFactory</span>&lt;T&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  track: () =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  trigger: () =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> {</span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> T;</span><br><span class="line">  <span class="attr">set</span>: <span class="function">(<span class="params">value: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p><code>customRef()</code>需要一个工厂函数 它接收<code>track</code>和<code>trigger</code>函数作为参数 并返回一个带有<code>get</code>和<code>set</code>方法的对象</p><p><code>track</code>应该叫<code>get（）</code> trigger 应该叫<code>set</code> 但是 我们可以控制合适调用以及是否调用它们</p><ul><li>例子</li></ul><p>创建一个 debounced ref 它只在最近一次 set 调用某个超时后的更新值：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { customRef } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useDebouncedRef</span>(<span class="params">value, delay = <span class="number">200</span></span>) {</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">customRef</span>(<span class="function">(<span class="params">track, trigger</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="title function_">track</span>()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      },</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) {</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">          value = newValue</span><br><span class="line">          <span class="title function_">trigger</span>()</span><br><span class="line">        }, delay)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"><span class="comment">//在组件中的用法</span></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> { useDebouncedRef } <span class="keyword">from</span> <span class="string">'./debouncedRef'</span></span><br><span class="line"><span class="keyword">const</span> text = <span class="title function_">useDebouncedRef</span>(<span class="string">'hello'</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"text"</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="comment">//可用于搜索等功能的防抖节流 可以避免频繁的请求 用watch监听</span></span><br></pre></td></tr></tbody></table></figure><h3 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive()"></a>shallowReactive()</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> shallowReactive&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">target</span>: T): T;</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>没有深度响应 只有根级属性是响应性的 属性值按原样储存和公开 这也意味着具有 ref 值的属性不会自动展开</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">shallowReactive</span>({</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">nested</span>: {</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating state's own properties is reactive</span></span><br><span class="line">state.<span class="property">foo</span>++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...but does not convert nested objects</span></span><br><span class="line"><span class="title function_">isReactive</span>(state.<span class="property">nested</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NOT reactive</span></span><br><span class="line">state.<span class="property">nested</span>.<span class="property">bar</span>++;</span><br></pre></td></tr></tbody></table></figure><h3 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly()"></a>shallowReadonly()</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> shallowReadonly&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">target</span>: T): <span class="title class_">Readonly</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><p>与 不同<code>readonly()</code>的是，没有深度转换：只有根级属性是只读的。属性值按原样存储和公开 - 这也意味着具有 ref 值的属性<strong>不会</strong>自动展开。</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">shallowReadonly</span>({</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">nested</span>: {</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating state's own properties will fail</span></span><br><span class="line">state.<span class="property">foo</span>++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...but works on nested objects</span></span><br><span class="line"><span class="title function_">isReadonly</span>(state.<span class="property">nested</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// works</span></span><br><span class="line">state.<span class="property">nested</span>.<span class="property">bar</span>++;</span><br></pre></td></tr></tbody></table></figure><h3 id="toRaw（）"><a href="#toRaw（）" class="headerlink" title="toRaw（）"></a>toRaw（）</h3><p>返回 Vue 创建的代理的原始对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> toRaw&lt;T&gt;(<span class="attr">proxy</span>: T): T;</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p><code>toRaw()</code> can return the original object from proxies created by <a href="https://vuejs.org/api/reactivity-core.html#reactive"><code>reactive()</code></a>, <a href="https://vuejs.org/api/reactivity-core.html#readonly"><code>readonly()</code></a>, <a href="https://vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> or <a href="https://vuejs.org/api/reactivity-advanced.html#shallowreadonly"><code>shallowReadonly()</code></a>.</p><p>可用于临时读取而不会产生代理访问/跟踪开销或写入而部触发更改 不建议持有对原始对象的持久引用 谨慎使用</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = {};</span><br><span class="line"><span class="keyword">const</span> reactiveFoo = <span class="title function_">reactive</span>(foo);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">toRaw</span>(reactiveFoo) === foo); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="effectScope"><a href="#effectScope" class="headerlink" title="effectScope()"></a>effectScope()</h3><p>可以在其中创建一个对象 api 观察对象的范围（computed and watchers）以便观察这些对象的详细使用情况</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">effectScope</span>(<span class="params">detached?: <span class="built_in">boolean</span></span>): <span class="title class_">EffectScope</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">EffectScope</span> {</span><br><span class="line">  run&lt;T&gt;(<span class="attr">fn</span>: <span class="function">() =&gt;</span> T): T | <span class="literal">undefined</span>; <span class="comment">// undefined if scope is inactive</span></span><br><span class="line">  <span class="title function_">stop</span>(): <span class="built_in">void</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scope = <span class="title function_">effectScope</span>();</span><br><span class="line"></span><br><span class="line">scope.<span class="title function_">run</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> doubled = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> counter.<span class="property">value</span> * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">watch</span>(doubled, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(doubled.<span class="property">value</span>));</span><br><span class="line"></span><br><span class="line">  <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Count: "</span>, doubled.<span class="property">value</span>));</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// to dispose all effects in the scope</span></span><br><span class="line">scope.<span class="title function_">stop</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><h3 id="onMounted"><a href="#onMounted" class="headerlink" title="onMounted"></a>onMounted</h3><p>组件在以下情况视为已挂载完成</p><ul><li>他的所有同步子组件都已挂载（不包括异步组件或<code>&lt;Suspense&gt;</code>树内的组件）</li><li>它自己的 DOM 树已创建并插入到父容器中 如果应用程序的根容器也在文档内 它只保证组件的 DOM 树在文档内</li></ul><p>通常用于执行需要访问组件渲染的 DOM 的副作用</p><p><strong>在服务端渲染期间不会调用此钩子</strong></p><h3 id="onUpdated"><a href="#onUpdated" class="headerlink" title="onUpdated()"></a>onUpdated()</h3><p>注册一个回调 以便在组件由于响应式状态改变而更新其 DOM 树后调用</p><ul><li>细节</li></ul><p>父组件的更新钩子在其子组件之后被调用</p><p><strong>在组件的任何 DOM 更新后都会调用此钩子 这可能是由不同的状态更改引起的 如果需要在特定的状态更改后访问更新的 DOM 改用 nextTick()</strong></p><p>服务器渲染期间不会调用此钩子</p><blockquote><p>不要在此钩子中改变组件状态 这可能会导致无限更新循环</p></blockquote><h3 id="onUnmounted"><a href="#onUnmounted" class="headerlink" title="onUnmounted()"></a>onUnmounted()</h3><p>注册一个在组件被卸载后调用的回调</p><ul><li><p>以下情况组件已被卸载</p><ul><li>他的所有子组件都已卸载</li><li>预期相关的响应状态（渲染效果以及期间创建的计算属性及观察者）都已停止</li></ul><p><strong>使用此钩子清除手动创建的副作用 例如计时器 DOM 时间侦听器或服务器连接</strong></p><p>在服务器渲染期间不会调用此钩子</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { onMounted, onUnmounted } from "vue";</span><br><span class="line"></span><br><span class="line">let intervalId;</span><br><span class="line">onMounted(() =&gt; {</span><br><span class="line">  intervalId = setInterval(() =&gt; {</span><br><span class="line">    // ...</span><br><span class="line">  });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">onUnmounted(() =&gt; clearInterval(intervalId));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="onBeforeMount"><a href="#onBeforeMount" class="headerlink" title="onBeforeMount()"></a>onBeforeMount()</h3><p>当这个钩子被调用时 说明组件已经完成了响应状态的设置 但是还没有创建 DOM 节点 它即将第一次执行他的 DOM 渲染效果</p><p><strong>在服务端渲染期间不会被调用</strong></p><h3 id="onBeforeUpdate"><a href="#onBeforeUpdate" class="headerlink" title="onBeforeUpdate()"></a>onBeforeUpdate()</h3><p>由于响应式状态更新 在组件即将更新其 DOM 树之前调用</p><p>可以用于 Vue 更新 DOM 之前访问 DOM 状态 在这个钩子中修改组件的状态也是安全的</p><p><strong>服务端渲染期间不会调用此钩子</strong></p><h3 id="onBeforeUnmount"><a href="#onBeforeUnmount" class="headerlink" title="onBeforeUnmount()"></a>onBeforeUnmount()</h3><p>在组件要卸载之前调用</p><p>调用此钩子时 组件实例仍然可以正常工作</p><p><strong>服务端渲染期间不会调用此钩子</strong></p><h3 id="onErrorCaptured"><a href="#onErrorCaptured" class="headerlink" title="onErrorCaptured()"></a>onErrorCaptured()</h3><p>当捕获到从后代组件传播的错误时 注册要调用的钩子</p><p>可以从以下错误源捕获错误</p><ul><li>组件渲染</li><li>事件处理程序</li><li>生命周期钩子</li><li><code>setup()</code>功能</li><li>观察者</li><li>自定义指令钩子</li><li>过渡挂钩</li></ul><p>钩子接收三个参数：错误、触发错误的组件实例和指定错误类型的信息字符串</p><p>可以修改组件状态以<code>errorCaptured()</code>向用户展示错误状态 但是 重要的错误状态 但是 重要的错误状态不应该呈现导致错误的原始内容 否则组件将抛出无限渲染循环</p><p>钩子可以返回<code>false</code>以阻止错误进一步传播</p><p>错误传播规则</p><ul><li><p>默认情况下 <code>app.config.errorHandler</code>如果已定义 所有错误仍会发送到应用程序级别 因此这些错误仍然可以在一个地方报告给分析服务</p></li><li><p>如果一个组件的继承链或父链上存在多个<code>errorCaptured</code>钩子 它们会在同一个错误时被调用</p></li><li><p>如果<code>errorCaptured</code>钩子本身抛出一个错误 这个错误和原始捕获的错误都会被发送到<code>app.config.errorHandler</code></p></li><li><p><code>errorCaptured</code>钩子可以返回<code>false</code>防止错误进一步传播 这本质上说明这个错误已经被处理 应该被忽略 它将防止任何额外的<code>errorCaptured</code>或<code>app.config,errorHandler</code></p><p>被此错误调用</p></li></ul><h3 id="onRenderTracked"><a href="#onRenderTracked" class="headerlink" title="onRenderTracked()"></a>onRenderTracked()</h3><h3 id="onActivated"><a href="#onActivated" class="headerlink" title="onActivated()"></a>onActivated()</h3><p>为了在组件中插入 DOM 作为缓存的一部分后调用<code>&lt;KeepAlive&gt;</code>专属</p><h3 id="onDeactivated"><a href="#onDeactivated" class="headerlink" title="onDeactivated()"></a>onDeactivated()</h3><p>为了从 DOM 删除后调用 作为缓存的树的部分 <code>&lt;keepAlive&gt;</code></p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="provide（）"><a href="#provide（）" class="headerlink" title="provide（）"></a>provide（）</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> provide&lt;T&gt;(<span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;T&gt; | <span class="built_in">string</span>, <span class="attr">value</span>: T): <span class="built_in">void</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p><code>Symbol</code>可用于在<code>provide()</code>和<code>inject()</code>之间同步值类型</p><p><code>provode</code>必须在组件<code>setup()</code>阶段同步调用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { ref, provide } from "vue";</span><br><span class="line">import { fooSymbol } from "./injectionSymbols";</span><br><span class="line"></span><br><span class="line">// provide static value</span><br><span class="line">provide("foo", "bar");</span><br><span class="line"></span><br><span class="line">// provide reactive value</span><br><span class="line">const count = ref(0);</span><br><span class="line">provide("count", count);</span><br><span class="line"></span><br><span class="line">// provide with Symbol keys</span><br><span class="line">provide(fooSymbol, count);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="inject"><a href="#inject" class="headerlink" title="inject()"></a>inject()</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> inject&lt;T&gt;(<span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;T&gt; | <span class="built_in">string</span>): T | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// with default value</span></span><br><span class="line"><span class="keyword">function</span> inject&lt;T&gt;(<span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;T&gt; | <span class="built_in">string</span>, <span class="attr">defaultValue</span>: T): T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// with factory</span></span><br><span class="line"><span class="keyword">function</span> inject&lt;T&gt;(</span><br><span class="line">  <span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;T&gt; | <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">defaultValue</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  <span class="attr">treatDefaultAsFactory</span>: <span class="literal">true</span></span><br><span class="line">): T;</span><br></pre></td></tr></tbody></table></figure><ul><li>细节</li></ul><p>第一个参数是 key Vue 将沿着父链查找具有匹配键的提供值 如果父链中的多个组件提供相同的 key 则使用最接近注入组件的那个 如果没有找到相匹配的键 则返回 undefined 或提供的默认值</p><p>第二个参数是可选的 在没有找到匹配的 key 的适合作为默认值 也可以是应该工厂函数来返回创建成本高的值 如果默认值是一个函数 那么 false 必须作为第三个参数传递 表示该函数作为值而不是工厂</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { inject } from "vue";</span><br><span class="line">import { fooSymbol } from "./injectionSymbols";</span><br><span class="line"></span><br><span class="line">// inject static value with default</span><br><span class="line">const foo = inject("foo");</span><br><span class="line"></span><br><span class="line">// inject reactive value</span><br><span class="line">const count = inject("count");</span><br><span class="line"></span><br><span class="line">// inject with Symbol keys</span><br><span class="line">const foo2 = inject(fooSymbol);</span><br><span class="line"></span><br><span class="line">// inject with default value</span><br><span class="line">const bar = inject("foo", "default value");</span><br><span class="line"></span><br><span class="line">// inject with default value factory</span><br><span class="line">const baz = inject("foo", () =&gt; new Map());</span><br><span class="line"></span><br><span class="line">// inject with function default value, by passing the 3rd argument</span><br><span class="line">const fn = inject("function", () =&gt; {}, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h1 id="内置插件"><a href="#内置插件" class="headerlink" title="内置插件"></a>内置插件</h1><h2 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h2><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><p>更新元素的文本内容</p><p><code>v-text</code>通过设置元素的 textContent 属性来工作 因此它将覆盖元素内所有的现有内容 如果只需要更新部分内容 可以使用 mustache 插值代替</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- same as --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>{{msg}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>v-for 默认行为将尝试在不移动元素的情况下就地修补元素 要强制它重新排序 应该提供一个带有<code>key</code>的特殊属性的排序提示</p><p>v-for 也可以处理包括 Map 和 Set</p><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>修饰符：</p><ul><li><code>.stop</code>- 触发<code>event.stopPropagation()</code>。</li><li><code>.prevent</code>- 触发<code>event.preventDefault()</code>。</li><li><code>.capture</code>- 在捕获模式下添加事件监听器。</li><li><code>.self</code>- 仅在从该元素分派事件时触发处理程序。</li><li><code>.{keyAlias}</code>- 仅在某些键上触发处理程序。</li><li><code>.once</code>- 最多触发一次处理程序。</li><li><code>.left</code>- 仅触发鼠标左键事件的处理程序。</li><li><code>.right</code>- 仅触发鼠标右键事件的处理程序。</li><li><code>.middle</code>- 仅触发中键鼠标事件的处理程序。</li><li><code>.passive</code>- 附加一个 DOM 事件<code>{ passive: true }</code>。</li></ul><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>.<code>lazy</code>监听的是<code>change</code>事件而不是<code>input</code>事件</p><p>.<code>number</code>将有效的输入字符串转换为数字</p><p>..<code>trim</code>修建输入</p><h3 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h3><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><p>跳过此元素及其所有子元素的编译</p><p>最常用的用力是显式原始标签</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-pre</span>&gt;</span>{{ this will not be compiled }}<span class="tag">&lt;/<span class="name">span</span>&gt;</span> //渲染结果：{{ this will not</span><br><span class="line">be compiled }}</span><br></pre></td></tr></tbody></table></figure><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>仅渲染元素和组件一次 并跳过以后的更新</p><p>在随后的重新渲染中 元素/组件及其所有子元素将被视为静态内容并跳过 这可用于优化更新性能</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- single element --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>This will never change: {{msg}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- the element have children --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{msg}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- component --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-once</span> <span class="attr">:comment</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `v-for` directive --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"i in list"</span> <span class="attr">v-once</span>&gt;</span>{{i}}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="v-memo"><a href="#v-memo" class="headerlink" title="v-memo"></a>v-memo</h3><p>记忆模板的子树 可用于元素和组件 该指令需要一个固定长度的依赖值数组来记忆比较 如果数组中的每个值都和上次渲染相同 则跳过整个子树的更新</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-memo</span>=<span class="string">"[valueA, valueB]"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>当组件重新渲染时 如果 valueA 和 valueB 都和之前用于 那么它和它的子树的更新都会直接被跳过 甚至连虚拟 dom 的创建都被跳过</p><p>正确指定记忆数组很重要 负责我们肯会跳过应该更新的更新 v-memo 具有空依赖数组(v-memo=”[]” ) 在功能上等同于 v-once</p><h4 id="与-v-for-结合"><a href="#与-v-for-结合" class="headerlink" title="与 v-for 结合"></a>与 v-for 结合</h4><p>v-<code>memo</code>仅为性能关键场景的微优化而提供 很少需要用到 最常见的情况可能是渲染大型 v-for 列表时 （其中 length&gt; 1000）</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span> <span class="attr">v-memo</span>=<span class="string">"[item.id === selected]"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID: {{ item.id }} - selected: {{ item.id === selected }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>...more child nodes<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>当组件的<code>selected</code>状态发生变化时，即使大部分项目保持不变，也会创建大量的 VNode。这里的<code>v-memo</code>用法本质上是说“仅当它从未选中变为选中时才更新此项目，或者相反”。这允许每个未受影响的项目重用其先前的 VNode 并完全跳过差异。请注意，我们不需要<code>item.id</code>在此处包含在 memo 依赖数组中，因为 Vue 会自动从项目的<code>:key</code>.</p><p><code>v-memo</code>也可以在组件上使用，以在子组件更新检查已被取消优化的某些边缘情况下手动防止不需要的更新。但同样，开发人员有责任指定正确的依赖数组以避免跳过必要的更新。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>为单个元素或组件提供过度效果</p><ul><li><code>@before-enter</code></li><li><code>@before-leave</code></li><li><code>@enter</code></li><li><code>@leave</code></li><li><code>@appear</code></li><li><code>@after-enter</code></li><li><code>@after-leave</code></li><li><code>@after-appear</code></li><li><code>@enter-cancelled</code></li><li><code>@leave-cancelled</code>（<code>v-show</code>仅限）</li><li><code>@appear-cancelled</code></li></ul><p>简单元素</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Transition&gt;</span><br><span class="line">  &lt;div v-if="ok"&gt;toggled content&lt;/div&gt;</span><br><span class="line">&lt;/Transition&gt;</span><br></pre></td></tr></tbody></table></figure><p>动态组件 出现过度模式 + 动画</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Transition name="fade" mode="out-in" appear&gt;</span><br><span class="line">  &lt;component :is="view"&gt;&lt;/component&gt;</span><br><span class="line">&lt;/Transition&gt;</span><br></pre></td></tr></tbody></table></figure><p>监听事件转换</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Transition @after-enter="onTransitionComplete"&gt;</span><br><span class="line">  &lt;div v-show="ok"&gt;toggled content&lt;/div&gt;</span><br><span class="line">&lt;/Transition&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="TransitionGroup"><a href="#TransitionGroup" class="headerlink" title="TransitionGroup"></a>TransitionGroup</h3><p>为列表中的多个元素或组件提供过度效果</p><h1 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h1><h2 id="脚本设置"><a href="#脚本设置" class="headerlink" title="脚本设置"></a>脚本设置</h2><p><code>&lt;script setup&gt;</code>的优点</p><ul><li>更简洁的代码 更少的样板</li><li>能够使用纯 typescript 声明 props 和发出的事件</li><li>更好的运行时性能（模板编译成同范围内的渲染函数 无需中间代理）</li><li>更好的 IDE 类型推断性能（服务器从代码中提取类型的工作量更少）</li></ul><h3 id="命名空间组件"><a href="#命名空间组件" class="headerlink" title="命名空间组件"></a>命名空间组件</h3><p>可以使用带有点的组件标签来引用嵌套在对象属性下的组件 当从单个文件中导入多个组件时很有用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import * as Form from "./form-components";</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Form.Input&gt;</span><br><span class="line">    &lt;Form.Label&gt;label&lt;/Form.Label&gt;</span><br><span class="line">  &lt;/Form.Input&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="使用自定义指令"><a href="#使用自定义指令" class="headerlink" title="使用自定义指令"></a>使用自定义指令</h3><p>全局注册的自定义指令正常工作 本地自定义指令不需要显式注册 但是必须遵守命名方案<code>vNameOfDirective</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const vMyDirective = {</span><br><span class="line">  beforeMount: (el) =&gt; {</span><br><span class="line">    // do something with the element</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 v-my-directive&gt;This is a Heading&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果从其他地方引入 可以将其重命名以使用所需的方案</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { myDirective as vMyDirective } from "./MyDirective.js";</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="defineProps-和-defineEmits"><a href="#defineProps-和-defineEmits" class="headerlink" title="defineProps() 和 defineEmits()"></a>defineProps() 和 defineEmits()</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps({</span><br><span class="line">  foo: String,</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">const emit = defineEmits(["change", "delete"]);</span><br><span class="line">// setup code</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>传递给<code>defineProps</code>并将<code>defineEmits</code>从设置中提升到模块范围的选项。因此，选项不能引用在设置范围内声明的局部变量。这样做会导致编译错误。但是，它<em>可以引用</em>导入的绑定，因为它们也在模块范围内。</p><h2 id="useSlots-amp-useAttrs"><a href="#useSlots-amp-useAttrs" class="headerlink" title="useSlots()&amp;useAttrs()"></a><code>useSlots()</code>&amp;<code>useAttrs()</code></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { useSlots, useAttrs } from "vue";</span><br><span class="line"></span><br><span class="line">const slots = useSlots();</span><br><span class="line">const attrs = useAttrs();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong><script setup=""> 不能与 src 属性一起使用</strong></p><h2 id="CSS-特性"><a href="#CSS-特性" class="headerlink" title="CSS 特性"></a>CSS 特性</h2><h3 id="深度选择器"><a href="#深度选择器" class="headerlink" title="深度选择器"></a>深度选择器</h3><p>如果希望<code>scoped</code>样式中可以影响子组件 可以使用`:deep()``味蕾</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="selector-class">.a</span> :<span class="built_in">deep</span>(.b) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="开槽选择器"><a href="#开槽选择器" class="headerlink" title="开槽选择器"></a>开槽选择器</h3><p>默认情况下 作用域样式不会影响由<code>&lt;slot/&gt;</code>渲染的内容 因为它们被认为是由传递它们的父组件拥有 要显式定位插槽内容 使用<code>:slotted</code>伪类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="selector-pseudo">:slotted</span>(<span class="selector-tag">div</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="全局选择器"><a href="#全局选择器" class="headerlink" title="全局选择器"></a>全局选择器</h3><p>如果想要全局应用一个规则 可以使用:global 伪类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">:<span class="built_in">global</span>(.red) &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="v-bind-在-css-中"><a href="#v-bind-在-css-中" class="headerlink" title="v-bind 在 css 中"></a>v-bind 在 css 中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const theme = &#123;</span><br><span class="line">  color: &quot;red&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;hello&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">p &#123;</span><br><span class="line">  color: v-bind(&quot;theme.color&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>实际值将被编译成散列的 CSS 自定义属性，因此 CSS 仍然是静态的。自定义属性将通过内联样式应用于组件的根元素，并在源值更改时进行响应式更新。</p><h1 id="高级-API"><a href="#高级-API" class="headerlink" title="高级 API"></a>高级 API</h1><h2 id="渲染函数-API"><a href="#渲染函数-API" class="headerlink" title="渲染函数 API"></a>渲染函数 API</h2><h3 id="H（）"><a href="#H（）" class="headerlink" title="H（）"></a>H（）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// full signature</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">h</span>(<span class="params"></span></span><br><span class="line"><span class="params">  type: string | Component,</span></span><br><span class="line"><span class="params">  props?: object | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  children?: Children | Slot | Slots</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">VNode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// omitting props</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">h</span>(<span class="params">type: string | Component, children?: Children | Slot</span>): <span class="title class_">VNode</span></span><br><span class="line"></span><br><span class="line">type <span class="title class_">Children</span> = string | number | boolean | <span class="title class_">VNode</span> | <span class="literal">null</span> | <span class="title class_">Children</span>[]</span><br><span class="line"></span><br><span class="line">type <span class="title class_">Slot</span> = <span class="function">() =&gt;</span> <span class="title class_">Children</span></span><br><span class="line"></span><br><span class="line">type <span class="title class_">Slots</span> = &#123; [<span class="attr">name</span>: string]: <span class="title class_">Slot</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>细节</li></ul><p>第一个参数是字符串（可用于原生元素）或 Vue 组件 第二个参数这是传递的 props 第三个元素是孩子</p><p>创建 vnode 时 子节点必须作为插槽函数传递 如果组件只需要默认槽 则可以传递单个插槽函数 否则 插槽必须作为槽函数的对象传递</p><p>创建原生元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; h &#125; from &#x27;vue&#x27; // all arguments except the type are optional h(&#x27;div&#x27;)</span><br><span class="line">h(&#x27;div&#x27;, &#123; id: &#x27;foo&#x27; &#125;) // both attributes and properties can be used in props</span><br><span class="line">// Vue automatically picks the right way to assign it h(&#x27;div&#x27;, &#123; class: &#x27;bar&#x27;,</span><br><span class="line">innerHTML: &#x27;hello&#x27; &#125;) // class and style have the same object / array // value</span><br><span class="line">support like in templates h(&#x27;div&#x27;, &#123; class: [foo, &#123; bar &#125;], style: &#123; color:</span><br><span class="line">&#x27;red&#x27; &#125; &#125;) // event listeners should be passed as onXxx h(&#x27;div&#x27;, &#123; onClick: ()</span><br><span class="line">=&gt; &#123;&#125; &#125;) // children can be a string h(&#x27;div&#x27;, &#123; id: &#x27;foo&#x27; &#125;, &#x27;hello&#x27;) // props</span><br><span class="line">can be omitted when there are no props h(&#x27;div&#x27;, &#x27;hello&#x27;) h(&#x27;div&#x27;, [h(&#x27;span&#x27;,</span><br><span class="line">&#x27;hello&#x27;)]) // children array can contain mixed vnodes and strings h(&#x27;div&#x27;,</span><br><span class="line">[&#x27;hello&#x27;, h(&#x27;span&#x27;, &#x27;hello&#x27;)])</span><br></pre></td></tr></table></figure><p>创建组件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Foo</span> <span class="keyword">from</span> <span class="string">&quot;./Foo.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// passing props</span></span><br><span class="line"><span class="title function_">h</span>(<span class="title class_">Foo</span>, &#123;</span><br><span class="line">  <span class="comment">// equivalent of some-prop=&quot;hello&quot;</span></span><br><span class="line">  <span class="attr">someProp</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="comment">// equivalent of @update=&quot;() =&gt; &#123;&#125;&quot;</span></span><br><span class="line">  <span class="attr">onUpdate</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// passing single default slot</span></span><br><span class="line"><span class="title function_">h</span>(<span class="title class_">Foo</span>, <span class="function">() =&gt;</span> <span class="string">&quot;default slot&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// passing named slots</span></span><br><span class="line"><span class="comment">// notice the `null` is required to avoid</span></span><br><span class="line"><span class="comment">// slots object being treated as props</span></span><br><span class="line"><span class="title function_">h</span>(<span class="title class_">MyComponent</span>, <span class="literal">null</span>, &#123;</span><br><span class="line">  <span class="attr">default</span>: <span class="function">() =&gt;</span> <span class="string">&quot;default slot&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&quot;div&quot;</span>, <span class="string">&quot;foo&quot;</span>),</span><br><span class="line">  <span class="attr">bar</span>: <span class="function">() =&gt;</span> [<span class="title function_">h</span>(<span class="string">&quot;span&quot;</span>, <span class="string">&quot;one&quot;</span>), <span class="title function_">h</span>(<span class="string">&quot;span&quot;</span>, <span class="string">&quot;two&quot;</span>)],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="mergeProps"><a href="#mergeProps" class="headerlink" title="mergeProps()"></a>mergeProps()</h2><p>合并多个 props 对象 对某些 props 进行特殊处理</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeProps</span>(<span class="params">...args: <span class="built_in">object</span>[]</span>): <span class="built_in">object</span>;</span><br></pre></td></tr></table></figure><p><code>mergeProps()</code>支持合并多个 props 对象 对以下 props 进行特殊处理</p><ul><li><code>class</code></li><li><code>style</code></li><li><code>onXxx</code>事件监听器-多个具有相同名称的监听器将被合并到一个数组中</li></ul><p>如果不需要合并只是想要简单的覆盖 可以使用原生对象的扩展</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mergeProps &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = &#123;</span><br><span class="line">  <span class="attr">class</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="attr">onClick</span>: handlerA,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> two = &#123;</span><br><span class="line">  <span class="attr">class</span>: &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">onClick</span>: handlerB,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merged = <span class="title function_">mergeProps</span>(one, two);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment">   class: &#x27;foo bar&#x27;,</span></span><br><span class="line"><span class="comment">   onClick: [handlerA, handlerB]</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="cloneVNode"><a href="#cloneVNode" class="headerlink" title="cloneVNode()"></a>cloneVNode()</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cloneVNode</span>(<span class="params">vnode: VNode, extraProps?: <span class="built_in">object</span></span>): <span class="title class_">VNode</span>;</span><br></pre></td></tr></table></figure><ul><li>细节</li></ul><p>返回一个克隆的 vnode 可以选择使用额外的 props 与原始节点合并</p><p>Vnodes 一旦被创建就被认定为不可变的 不应该改变现有的 vnode 的 props</p><p>Vnodes 具有特殊的内部属性 因此克隆它们并不像对象传播那么简单 <code>cloneVnode（）</code>处理大部分的内部逻辑</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, cloneVNode &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> original = <span class="title function_">h</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cloned = <span class="title function_">cloneVNode</span>(original, &#123; <span class="attr">id</span>: <span class="string">&quot;foo&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="resolveComponent"><a href="#resolveComponent" class="headerlink" title="resolveComponent"></a>resolveComponent</h3><p>用于按名称手动解析已注册的组件</p><h2 id="withDirectives"><a href="#withDirectives" class="headerlink" title="withDirectives()"></a>withDirectives()</h2><p>用于向 vnode 添加自定义指令</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withDirectives</span>(<span class="params">vnode: VNode, directives: DirectiveArguments</span>): <span class="title class_">VNode</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Directive, value, argument, modifiers]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DirectiveArguments</span> = <span class="title class_">Array</span>&lt;</span><br><span class="line">  | [<span class="title class_">Directive</span>]</span><br><span class="line">  | [<span class="title class_">Directive</span>, <span class="built_in">any</span>]</span><br><span class="line">  | [<span class="title class_">Directive</span>, <span class="built_in">any</span>, <span class="built_in">string</span>]</span><br><span class="line">  | [<span class="title class_">Directive</span>, <span class="built_in">any</span>, <span class="built_in">string</span>, <span class="title class_">DirectiveModifiers</span>]</span><br><span class="line">&gt;;</span><br></pre></td></tr></table></figure><ul><li>细节</li></ul><p>第二个参数时一个自定义指令数组 ``[Directive, value, argument, modifiers]`</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, withDirectives &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a custom directive</span></span><br><span class="line"><span class="keyword">const</span> pin = &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">updated</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;div v-pin:top.animate=&quot;200&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">withDirectives</span>(<span class="title function_">h</span>(<span class="string">&quot;div&quot;</span>), [[pin, <span class="number">200</span>, <span class="string">&quot;top&quot;</span>, &#123; <span class="attr">animate</span>: <span class="literal">true</span> &#125;]]);</span><br></pre></td></tr></table></figure><h2 id="withModifiers"><a href="#withModifiers" class="headerlink" title="withModifiers()"></a>withModifiers()</h2><p>添加事件修饰符</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, withModifiers &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">h</span>(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// equivalent of v-on.stop.prevent</span></span><br><span class="line">  <span class="attr">onClick</span>: <span class="title function_">withModifiers</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;, [<span class="string">&quot;stop&quot;</span>, <span class="string">&quot;prevent&quot;</span>]),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></script></strong></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目优化</title>
      <link href="/2022/04/11/xiang-mu-you-hua/"/>
      <url>/2022/04/11/xiang-mu-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><h3 id="1-页面加载优化"><a href="#1-页面加载优化" class="headerlink" title="1.页面加载优化"></a>1.页面加载优化</h3><h4 id="1-1Bundle-Size-and-Tree-shaking"><a href="#1-1Bundle-Size-and-Tree-shaking" class="headerlink" title="1.1Bundle Size and Tree-shaking"></a>1.1Bundle Size and Tree-shaking</h4><ul><li>发布使用性能更加全面的 JavaScript 包<ul><li>如果通过现代构建工具捆绑 许多 Vue 的 API 都是 Tree-shaking。例如如果不使用内置的<code>&lt;Transition&gt;</code>组件 他将不会包含在最终的生产包中 Tree-shaking 还可以删除源代码中其他未使用的模块</li><li>使用构建步骤时 模板是预编译的 因此我们不需要将 Vue 编译器发送到浏览器中 这避免了运行时编译成本</li></ul></li><li>引入依赖时要注意大小<ul><li>使用支持 ES 模块格式并且对 Tree-shaking 友好的依赖项 如引入 lodash-es 而不是 lodash</li><li>检查依赖项的大小并评估它是否值得它提供的功能 bundle.js.org 之类的工具可用于快速检查 但使用实际构建设置进行测量始终是最准确的</li></ul></li><li>如果使用 VUE 进行渐进式增强并希望避免构建步骤 可以考虑使用 petite-vue</li></ul><h4 id="1-2-代码拆分"><a href="#1-2-代码拆分" class="headerlink" title="1.2.代码拆分"></a>1.2.代码拆分</h4><p>通过适当的代码拆分 可以立即下载页面加载所需的功能 仅再需要时才延迟加载额外的块 从而提高性能</p><ul><li><p>Rollup（基于 Vite）或 webpack 之类的打包工具可以通过检查 ESM 动态导入元自动创建拆分块</p></li><li><p>```vue<br>function loadLazy() { return import(‘./lazy.js’) }</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 延迟加载最好用于初始页面加载后不需要立即使用的功能。在 Vue 应用程序中 这通常与 vue 的异步组件结合使用 为组件树创建拆分快</span><br><span class="line"></span><br><span class="line">- ```vue</span><br><span class="line">  import { defineAsyncComponent } from 'vue' // a separate chunk is created for</span><br><span class="line">  Foo.vue and its dependencies. // it is only fetched on demand when the async</span><br><span class="line">  component is // rendered on the page. const Foo = defineAsyncComponent(() =&gt;</span><br><span class="line">  import('./Foo.vue'))</span><br></pre></td></tr></tbody></table></figure><p><strong>如果使用 Vue Router</strong>强烈建议使用异步组件作为路由组件</p></li></ul><h4 id="1-3-SSR-SSG"><a href="#1-3-SSR-SSG" class="headerlink" title="1.3.SSR/SSG"></a>1.3.SSR/SSG</h4><p>纯客户端渲染会遇到内容生成时间缓慢的问题。这可以通过服务器端渲染 (SSR) 或静态站点生成 (SSG) 来缓解。</p><h3 id="2-更新优化"><a href="#2-更新优化" class="headerlink" title="2.更新优化"></a>2.更新优化</h3><h4 id="2-1Props-Stability"><a href="#2-1Props-Stability" class="headerlink" title="2.1Props Stability"></a>2.1Props Stability</h4><p>在 Vue 中 子组件仅在接收到至少一个 props 发生改变时才更新</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListItem v-for="item in list" :id="item.id" :active-id="activeId" /&gt;</span><br><span class="line">//在listItem组件内部 它使用的id和activeId来确定它是否是当前活跃的项目</span><br><span class="line">但是这会导致在activeId更改时 列表中的每个listItem都必须更新 //理想状态下</span><br><span class="line">只有活动状态发生变化的项目才必须更新</span><br><span class="line">我们可以通过将活动状态计算移至父级来实现这一点</span><br><span class="line">&lt;ListItem v-for="item in list" :id="item.id" :active="item.id === activeId" /&gt;</span><br><span class="line">//现在 对于大多数组件来说 prop的active在activeId更改时将保持不变</span><br><span class="line">因此它们不再更新</span><br></pre></td></tr></tbody></table></figure><p><strong>思想：保持传递给子组件的 prop 尽量稳定</strong></p><h4 id="2-2-v-once"><a href="#2-2-v-once" class="headerlink" title="2.2 v-once"></a>2.2 v-once</h4><p>依赖于运行时数据但是从不需要高兴的内容 它所使用的整个子树将跳过以进行所有未来的更新</p><h4 id="2-3v-memo"><a href="#2-3v-memo" class="headerlink" title="2.3v-memo"></a>2.3v-memo</h4><p>可用于有条件地跳过大型子树或者 v-for 列表的更新</p><h3 id="3-一般优化：会影响页面加载和更新性能"><a href="#3-一般优化：会影响页面加载和更新性能" class="headerlink" title="3.一般优化：会影响页面加载和更新性能"></a>3.一般优化：会影响页面加载和更新性能</h3><h4 id="3-1-虚拟化大型列表"><a href="#3-1-虚拟化大型列表" class="headerlink" title="3.1 虚拟化大型列表"></a>3.1 虚拟化大型列表</h4><p>我们可以跳过列表虚拟化来极大地提高性能 该技术仅在大列表中呈现当前位于或靠近视口的视图</p><ul><li><a href="https://github.com/Akryum/vue-virtual-scroller">vue-虚拟滚动条</a></li><li><a href="https://github.com/rocwang/vue-virtual-scroll-grid">vue-虚拟滚动网络</a></li></ul><h4 id="3-2-减少大型不可变结构的响应式开销"><a href="#3-2-减少大型不可变结构的响应式开销" class="headerlink" title="3.2 减少大型不可变结构的响应式开销"></a>3.2 减少大型不可变结构的响应式开销</h4><p>vue 的反应系统默认是深度的 可以使用 shallowReactive（）来退出深度响应性</p><p>浅响应性 API 创建仅在根级别具有响应性 并未追踪嵌套对象 这是的嵌套属性访问保持快速 但是我们必须将所有的嵌套对象视为不可变的 并且只能通过替换根状态来触发更新</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowArray = <span class="title function_">shallowRef</span>([</span><br><span class="line">  <span class="comment">/* big list of deep objects */</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// this won't trigger updates...</span></span><br><span class="line">shallowArray.<span class="property">value</span>.<span class="title function_">push</span>(newObject);</span><br><span class="line"><span class="comment">// this does:</span></span><br><span class="line">shallowArray.<span class="property">value</span> = [...shallowArr.<span class="property">value</span>, newObject];</span><br><span class="line"></span><br><span class="line"><span class="comment">// this won't trigger updates...</span></span><br><span class="line">shallowArray.<span class="property">value</span>[<span class="number">0</span>].<span class="property">foo</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// this does:</span></span><br><span class="line">shallowArray.<span class="property">value</span> = [</span><br><span class="line">  {</span><br><span class="line">    ...shallowArray.<span class="property">value</span>[<span class="number">0</span>],</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  },</span><br><span class="line">  ...shallowArray.<span class="property">value</span>.<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">];</span><br></pre></td></tr></tbody></table></figure><p><code>shallowRef()</code>通常用于大型数据结构的性能优化 或者于外部状态管理系统的集成</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">shallowRef</span>({ <span class="attr">count</span>: <span class="number">1</span> });</span><br><span class="line"></span><br><span class="line"><span class="comment">// does NOT trigger change</span></span><br><span class="line">state.<span class="property">value</span>.<span class="property">count</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// does trigger change</span></span><br><span class="line">state.<span class="property">value</span> = { <span class="attr">count</span>: <span class="number">2</span> };</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-避免不必要的组件抽象"><a href="#3-3-避免不必要的组件抽象" class="headerlink" title="3.3 避免不必要的组件抽象"></a>3.3 避免不必要的组件抽象</h4>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学Vue 2.0</title>
      <link href="/2022/04/10/chong-xue-vue2.0/"/>
      <url>/2022/04/10/chong-xue-vue2.0/</url>
      
        <content type="html"><![CDATA[<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>当我们需要访问内联处理程序中的原始 DOM 事件 可以用特殊变量将其传递给方法$event 或者使用内联箭头函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click="warn('Form cannot be submitted yet.', $event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- using inline arrow function --&gt;</span><br><span class="line">&lt;button @click="(event) =&gt; warn('Form cannot be submitted yet.', event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="表单上输入绑定"><a href="#表单上输入绑定" class="headerlink" title="表单上输入绑定"></a>表单上输入绑定</h4><ul><li><code>&lt;input&gt;</code>文本类型和<code>&lt;textarea&gt;</code>元素使用<code>value</code>属性和<code>input</code>事件；</li><li><code>&lt;input type="checkbox"&gt;``&lt;input type="radio"&gt;</code>使用<code>checked</code>和事件<code>change</code>；</li><li><code>&lt;select&gt;</code>用作<code>value</code>和<code>change</code>事件。</li></ul><p><strong>v-model<code>将忽略在任何表单元素上找到的初始或属性</code>value<code>。它将始终将当前绑定的 JavaScript 状态视为事实来源。您应该使用反应性 API在 JavaScript 端声明初始值。</code>checked``selected</strong></p><p>如果您的表达式的初始值<code>v-model</code>与任何选项都不匹配，则该<code>&lt;select&gt;</code>元素将呈现为“未选择”状态。在 iOS 上，这将导致用户无法选择第一项，因为在这种情况下 iOS 不会触发更改事件。因此，建议提供一个带空值的禁用选项</p><p>默认情况下 v-model 在每个事件之后将输入与数据同步 可以添加修饰符<code>lazy</code>修改为在事件后同步</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- synced after "change" instead of "input" --&gt;</span><br><span class="line">&lt;input v-model.lazy="msg" /&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果希望用户输入的自动转化为数字 可以添加.number</p><p>如果希望自动修剪用户输入中的空白 可以加入.trim</p><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><img src="https://s3.bmp.ovh/imgs/2022/04/09/87a9e53a6371f344.png" style="zoom: 50%;"><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { ref, watch } from 'vue'</span><br><span class="line"></span><br><span class="line">const question = ref('')</span><br><span class="line">const answer = ref('Questions usually contain a question mark. ;-)')</span><br><span class="line"></span><br><span class="line">// watch works directly on a ref</span><br><span class="line">watch(question, async (newQuestion, oldQuestion) =&gt; {</span><br><span class="line">  if (newQuestion.indexOf('?') &gt; -1) {</span><br><span class="line">    answer.value = 'Thinking...'</span><br><span class="line">    try {</span><br><span class="line">      const res = await fetch('https://yesno.wtf/api')</span><br><span class="line">      answer.value = (await res.json()).answer</span><br><span class="line">    } catch (error) {</span><br><span class="line">      answer.value = 'Error! Could not reach the API. ' + error</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    &lt;input v-model="question" /&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;{{ answer }}&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>当你在 watch()直接调用一个响应式对象时 它会隐式创建一个深度观察者模式-回调将在所有嵌套突变上触发</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const obj = reactive({ count: 0});</span><br><span class="line">watch(obj, (newValue, oldValue) =&gt; {</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line">obj.count ++;</span><br><span class="line">//而使用getter：() =&gt; state.someObject则只会在放回不同的对象时才会触发回调</span><br><span class="line">可以显示使用deep选项来进入深度观察者模式</span><br><span class="line">watch(</span><br><span class="line">() =&gt; state....,</span><br><span class="line">(newValue, oldValue) =&gt; {}</span><br><span class="line">{ deep: true})</span><br></pre></td></tr></tbody></table></figure><p>**tips:**深度监视需要遍历监控对象中的所有嵌套属性 并且在用于大型数据结构时可能会开销昂贵 所以仅在必要时使用它并注意性能影响</p><h4 id="watchEffect（）"><a href="#watchEffect（）" class="headerlink" title="watchEffect（）"></a>watchEffect（）</h4><p>watch 是惰性的 在观察源发生变化之前不会立即调用 但是如果我们想要获取一些初始数据 然后在相关状态发生变化时重新获取数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const url = ref('https://...')</span><br><span class="line">const data = ref(null)</span><br><span class="line"></span><br><span class="line">async function fetchData() {</span><br><span class="line">  const response = await fetch(url.value)</span><br><span class="line">  data.value = await response.json()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// fetch immediately</span><br><span class="line">fetchData()</span><br><span class="line">// ...then watch for url change</span><br><span class="line">watch(url, fetchData)</span><br></pre></td></tr></tbody></table></figure><p><strong>watchEffect 允许我们在自动追踪效果的反应依赖的同时立即执行副作用函数</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(async () =&gt; {</span><br><span class="line">  const response = await fetch(url.value)</span><br><span class="line">  data.value = await response.json()</span><br><span class="line">})</span><br><span class="line">//在这苦 回调函数立即执行 他还会跟踪url.value为依赖项（类似于计算属性） 当url.value发生变化时 回调将再次运行</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const API_URL = `https://api.github.com/repos/vuejs/core/commits?per_page=3&amp;sha=`</span><br><span class="line">const branches = ['main', 'v2-compat']</span><br><span class="line"></span><br><span class="line">const currentBranch = ref(branches[0])</span><br><span class="line">const commits = ref(null)</span><br><span class="line"></span><br><span class="line">watchEffect(async () =&gt; {</span><br><span class="line">  // this effect will run immediately and then</span><br><span class="line">  // re-run whenever currentBranch.value changes</span><br><span class="line">  const url = `${API_URL}${currentBranch.value}`</span><br><span class="line">  commits.value = await (await fetch(url)).json()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>tips：</strong>watch 仅在其同步执行期间跟踪依赖项 当它与异步回调一起使用时 只会跟踪 await 跟踪第一个 tick 之前访问的属性</p><ul><li>watch 仅跟踪明确监视的源 将依赖跟踪与副作用分开</li><li>将依赖跟踪与副作用结合到一个阶段 会自动跟踪在同步执行期间访问的每一个反应属性 会使代码更简洁 但是依赖关系不明确</li></ul><h4 id="回调刷新时间"><a href="#回调刷新时间" class="headerlink" title="回调刷新时间"></a>回调刷新时间</h4><p>vue 默认在组件更新之前调用用户创建的观察者回调 所以如果尝试在观察者回调中访问 dom 则 dom 将处于 Vue 应用任何更新之前的状态 所以如果想要在 vue 更新后在 watcher 回调中访问 dom 需要指定 flush:’post’</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(source, callback, {</span><br><span class="line">  flush: 'post'</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">watchEffect(callback, {</span><br><span class="line">  flush: 'post'</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="停止观察者"><a href="#停止观察者" class="headerlink" title="停止观察者"></a>停止观察者</h4><p>Watchers 在内部同步声明<code>setup()</code>或<code>&lt;script setup&gt;</code>绑定到所有者组件实例，并在所有者组件卸载时自动停止。如果观察者是<strong>异步</strong>创建的 那么不会绑定到所有者组件 必须手动停止以避免<strong>内存泄漏</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const unwatch = watchEffect(() =&gt; {})</span><br><span class="line"></span><br><span class="line">// ...later, when no longer needed</span><br><span class="line">unwatch()</span><br></pre></td></tr></tbody></table></figure><p>应该军垦首选同步创建 如果需要等待一些异步数据 可以使用逻辑控制异步操作</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(() =&gt; {</span><br><span class="line">  if (data.value) {</span><br><span class="line">    // do something when data is loaded</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><p>如果要将对象的所有属性作为 props 传递 则可以使用 v-bind 不带参数使用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost v-bind="post" /&gt;</span><br><span class="line">//相当于使用</span><br><span class="line">&lt;BlogPost :id="post.id" :title="post.title" /&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>prop 用于传入一个初始值：子组件之后希望将其用作本地数据属性 则定义一个使用 prop 作为其初始值的本地数据属性</p></li><li><p>```<br>const props = defineProps([‘initialCounter’])</p><p>// counter only uses props.initialCounter as the initial value;<br>// it is disconnected from future prop updates.<br>const counter = ref(props.initialCounter)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- prop 作为需要转换的原始值传入 最好使用 prop 的值定义计算属性</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  const props = defineProps(['size'])</span><br><span class="line"></span><br><span class="line">  // computed property that auto-updates when the prop changes</span><br><span class="line">  const normalizedSize = computed(() =&gt; props.size.trim().toLowerCase())</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h2><p><strong>tips：</strong>组件的事件不会冒泡 父组件只能接收直接子组件发出的事件</p><p>可以通过 defineEmits 显示声明</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits(['inFocus', 'submit'])</span><br><span class="line">// type-based</span><br><span class="line">const emit = defineEmits&lt;{</span><br><span class="line">  (e: 'change', id: number): void</span><br><span class="line">  (e: 'update', value: string): void</span><br><span class="line">}&gt;()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果在选项中定义了本地事件如 click 则侦听器现在仅侦听组件发出的 click 而不再响应本地的 click 事件</p><p>如果使用对象语法则可以添加验证 为了添加验证 事件被分配了一个函数 改函数将接收传递给调用的参数并返回一个有效的布尔值以只是事件是否</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits({</span><br><span class="line">  // No validation</span><br><span class="line">  click: null,</span><br><span class="line"></span><br><span class="line">  // Validate submit event</span><br><span class="line">  submit: ({ email, password }) =&gt; {</span><br><span class="line">    if (email &amp;&amp; password) {</span><br><span class="line">      return true</span><br><span class="line">    } else {</span><br><span class="line">      console.warn('Invalid submit event payload!')</span><br><span class="line">      return false</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">function submitForm(email, password) {</span><br><span class="line">  emit('submit', { email, password })</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>自定义事件还能和 v-model 相结合</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- CustomInput.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps(['modelValue'])</span><br><span class="line">defineEmits(['update:modelValue'])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    :value="modelValue"</span><br><span class="line">    @input="$emit('update:modelValue', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">使用：</span><br><span class="line">&lt;CustomInput v-model="searchText" /&gt;</span><br></pre></td></tr></tbody></table></figure><p>v-model 还可以使用 computed 属性和 getter 以及 setter 该 get 方法应该返回 modelValue 属性并且该 set 方法应该发出相应的事件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- CustomInput.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import { computed } from 'vue'</span><br><span class="line"></span><br><span class="line">const props = defineProps(['modelValue'])</span><br><span class="line">const emit = defineEmits(['update:modelValue'])</span><br><span class="line"></span><br><span class="line">const value = computed({</span><br><span class="line">  get() {</span><br><span class="line">    return props.modelValue</span><br><span class="line">  },</span><br><span class="line">  set(value) {</span><br><span class="line">    emit('update:modelValue', value)</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input v-model="value" /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>使用多个 v-model</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserName</span><br><span class="line">  v-model:first-name="firstName"</span><br><span class="line">  v-model:last-name="lastName"</span><br><span class="line">/&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps({</span><br><span class="line">  firstName: String,</span><br><span class="line">  lastName: String</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">defineEmits(['update:firstName', 'update:lastName'])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type="text"</span><br><span class="line">    :value="firstName"</span><br><span class="line">    @input="$emit('update:firstName', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type="text"</span><br><span class="line">    :value="lastName"</span><br><span class="line">    @input="$emit('update:lastName', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>处理 v-model 修饰符：<strong>自定义修饰符</strong></p><p>eg：自定义一个将字符串第一个字母大写</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model.capitalize="myText" /&gt;</span><br><span class="line">添加到组件的修饰符v-model将通过modelModifiers prop提供给组件 我们创建了一个组件 其中包含一个modelModifiers默认为空的对象的prop</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps({</span><br><span class="line">  modelValue: String,</span><br><span class="line">  modelModifiers: { default: () =&gt; ({}) }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">defineEmits(['update:modelValue'])</span><br><span class="line"></span><br><span class="line">console.log(props.modelModifiers) // { capitalize: true }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type="text"</span><br><span class="line">    :value="modelValue"</span><br><span class="line">    @input="$emit('update:modelValue', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">------------------我们可以更改成当触发input事件后就会将字符串大写</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps({</span><br><span class="line">  modelValue: String,</span><br><span class="line">  modelModifiers: { default: () =&gt; ({}) }//即传递过来的{ capitalize: true }</span><br><span class="line">})</span><br><span class="line">//设置默认抛出事件</span><br><span class="line">const emit = defineEmits(['update:modelValue'])</span><br><span class="line"></span><br><span class="line">function emitValue(e) {</span><br><span class="line">  let value = e.target.value</span><br><span class="line">  if (props.modelModifiers.capitalize) {</span><br><span class="line">    value = value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">  }</span><br><span class="line">  emit('update:modelValue', value)//触发事件</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//设置input触发事件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type="text" :value="modelValue" @input="emitValue" /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>对于<code>v-model</code>同时具有参数和修饰符 生成的道具名称将为<code>arg + 'Modifiers'</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model:title.capitalize="myText"&gt;</span><br><span class="line">//对应的声明应该为</span><br><span class="line">const props = defineProps(['title', 'titleModifiers'])</span><br><span class="line">defineEmits(['update:title'])</span><br><span class="line">console.log(props.titleModifiers) // { capitalize: true }</span><br></pre></td></tr></tbody></table></figure><h2 id="Fallthrough-属性"><a href="#Fallthrough-属性" class="headerlink" title="Fallthrough 属性"></a>Fallthrough 属性</h2><p><code>v-on</code>传递给组件的属性或事件监听器 但是未在组件的 props 或 emits 中显示声明 如<code>class</code>、<code>style</code>、<code>id</code></p><p>当组件渲染单个根元素时 将自动添加到根元素的属性中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- template of &lt;MyButton&gt; --&gt;</span><br><span class="line">&lt;button&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;MyButton class="large" /&gt;</span><br><span class="line">---最终渲染为</span><br><span class="line">&lt;button class="large"&gt;click me&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果不希望组件自动继承属性 可以在<code>inheriAttrs： false</code>在组件的选项中进行设置</p><p>如果使用<code>&lt;script setup&gt;</code>，您将需要使用单独的普通<code>&lt;script&gt;</code>块声明此选项：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// use normal &lt;script&gt; to declare options</span><br><span class="line">export default {</span><br><span class="line">  inheritAttrs: false</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// ...setup logic</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>常见场景：当属性需要引用于根节点以为的其他元素时 可以将<code>inheritAttrs</code>选项设置为<code>false</code>，您可以完全控制在何处应用 fallthrough 属性</p><p>可以通过<code>$attrs</code>来访问</p><ul><li>与 props 不同，fallthrough 属性在 JavaScript 中保留了它们的原始大小写，因此<code>foo-bar</code>需要将属性 like 访问为<code>$attrs['foo-bar']</code>.</li><li>像这样的<code>v-on</code>事件侦听<code>@click</code>器将作为<code>$attrs.onClick</code>.</li></ul><p>我们希望所有诸如<code>class</code>和<code>v-on</code>监听器之类的贯穿属性都应用于内部<code>&lt;button&gt;</code>，而不是外部<code>&lt;div&gt;</code>。可以使用 inheritAttrs: false 和</p><p><code>v-bind="$attrs"</code>来使用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="btn-wrapper"&gt;</span><br><span class="line">  &lt;button class="btn" v-bind="$attrs"&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>如果 v-bind 没有参数 则将对象的所有属性绑定为目标元素的属性</strong></p><h4 id="多个根节点的继承"><a href="#多个根节点的继承" class="headerlink" title="多个根节点的继承"></a>多个根节点的继承</h4><p>具有多个根节点的组件没有自动属性失效的行为 需要明确绑定$attrs</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomLayout id="custom-layout" @click="changeValue" /&gt;</span><br><span class="line">&lt;header&gt;...&lt;/header&gt;</span><br><span class="line">&lt;main v-bind="$attrs"&gt;...&lt;/main&gt;</span><br><span class="line">&lt;footer&gt;...&lt;/footer&gt;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { useAttrs } from 'vue'</span><br><span class="line"></span><br><span class="line">const attrs = useAttrs()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//尽管attrs始终反应最新的fallthrough属性 但是并不是响应性的 所以无法使用观察者观察变化 如果需要响应性 可以使用prop 或者在onUpdated（）时执行最新的副作用</span><br></pre></td></tr></tbody></table></figure><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><img src="https://s3.bmp.ovh/imgs/2022/04/10/8d00a97ed8cd1522.png" style="zoom: 50%;"><p>插槽的作用</p><ul><li>使用插槽 子组件负责样式的渲染 而内容由父组件提供</li><li>通过使用插槽 我们可以使<code>&lt;FancyButton&gt;</code>更加灵活和重用 我们可以在不同的地方使用它 具有不同的内部内容 但是都具有同样花哨的样式</li></ul><h4 id="渲染范围"><a href="#渲染范围" class="headerlink" title="渲染范围"></a>渲染范围</h4><ul><li>插槽可以访问父组件的数据范围 因为它是在父组件中定义的</li><li>插槽无权访问子组件的数据 因为父模板中的所有内容都在父范围内编译 子模板中的所有内容都在子范围内编译</li></ul><h4 id="命名插槽"><a href="#命名插槽" class="headerlink" title="命名插槽"></a>命名插槽</h4><p>可以通过使用 name 用来为不同的插槽分配一个唯一的 ID 这样可以控制在哪里呈现内容</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="container"&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name="header"&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name="footer"&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">//当我们要传递指定内容时 可以使用v-slot</span><br><span class="line">&lt;BaseLayout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;!-- content for the header slot --&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/BaseLayout&gt;</span><br><span class="line">//可以使用“#”简写</span><br><span class="line">&lt;template #header&gt;。</span><br></pre></td></tr></tbody></table></figure><p>当组件同时接受默认槽和命名槽时，所有顶级非<code>&lt;template&gt;</code>节点都被隐式视为默认槽的内容。</p><h4 id="动态插槽名称"><a href="#动态插槽名称" class="headerlink" title="动态插槽名称"></a>动态插槽名称</h4><p>动态指令参数也适用于 v-slot 允许定义动态插槽的名称</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:[dynamicSlotName]&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- with shorthand --&gt;</span><br><span class="line">  &lt;template #[dynamicSlotName]&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="命名插槽-1"><a href="#命名插槽-1" class="headerlink" title="命名插槽"></a>命名插槽</h4><p><img src="https://i.bmp.ovh/imgs/2022/04/10/06d1487ae8b60eaa.png"></p><p>可以通过命名插槽访问子组件的数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;slot :text="greetingMessage" :count="1"&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;MyComponent v-slot="slotProps"&gt;</span><br><span class="line">  {{ slotProps.text }} {{ slotProps.count }}</span><br><span class="line">&lt;/MyComponent&gt;</span><br><span class="line">//可以通过解构的方式来取值</span><br><span class="line">&lt;MyComponent v-slot="{ text, count }"&gt;</span><br><span class="line">  {{ text }} {{ count }}</span><br><span class="line">&lt;/MyComponent&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="命名范围插槽"><a href="#命名范围插槽" class="headerlink" title="命名范围插槽"></a><strong>命名范围插槽</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;</span><br><span class="line">  &lt;template #header="headerProps"&gt;</span><br><span class="line">    {{ headerProps }}</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #default="defaultProps"&gt;</span><br><span class="line">    {{ defaultProps }}</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #footer="footerProps"&gt;</span><br><span class="line">    {{ footerProps }}</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/MyComponent&gt;</span><br><span class="line">&lt;slot name="header" message="hello"&gt;&lt;/slot&gt;</span><br></pre></td></tr></tbody></table></figure><p>name 不会包含在 prop 中 所以 headerProps 是<code>{ message: 'hello' }</code>.</p><p><strong>作用域插槽的使用场景</strong></p><p>如果需要一个<fancylist>渲染项目列表的组件–它可以封装加载远程数据的逻辑 使用数据显示列表 甚至是分页或无限滚动等高级功能 但是我们希望它能够灵活处理每个项目的外观 并将每个项目的样式留给使用它的父组件</fancylist></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;FancyList :api-url="url" :per-page="10"&gt;</span><br><span class="line">  &lt;template #item="{ body, username, likes }"&gt;</span><br><span class="line">    &lt;div class="item"&gt;</span><br><span class="line">      &lt;p&gt;{{ body }}&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;by {{ username }} | {{ likes }} likes&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/FancyList&gt;</span><br></pre></td></tr></tbody></table></figure><p>在内部，我们可以使用不同的项目数据多次<code>&lt;FancyList&gt;</code>渲染相同的内容（注意我们使用对象作为插槽道具传递）：<code>&lt;slot&gt;``v-bind</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">App.vue</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import FancyList from './FancyList.vue'</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;FancyList :api-url="url" :per-page="10"&gt;</span><br><span class="line">    &lt;template #item="{ body, username, likes }"&gt;</span><br><span class="line">      &lt;div class="item"&gt;</span><br><span class="line">        &lt;p&gt;{{ body }}&lt;/p&gt;</span><br><span class="line">        &lt;p class="meta"&gt;by {{ username }} | {{ likes }} likes&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/FancyList&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.meta {</span><br><span class="line">  font-size: 0.8em;</span><br><span class="line">  color: #42b883;</span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">FancyList.vue</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import { ref } from 'vue'</span><br><span class="line"></span><br><span class="line">const props = defineProps(['api-url', 'per-page'])</span><br><span class="line"></span><br><span class="line">const items = ref([])</span><br><span class="line"></span><br><span class="line">// mock remote data fetching</span><br><span class="line">setTimeout(() =&gt; {</span><br><span class="line">  items.value = [</span><br><span class="line">    { body: 'Scoped Slots Guide', username: 'Evan You', likes: 20 },</span><br><span class="line">  { body: 'Vue Tutorial', username: 'Natalia Tepluhina', likes: 10 }</span><br><span class="line">  ]</span><br><span class="line">}, 1000)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-if="!items.length"&gt;</span><br><span class="line">      Loading...</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li v-for="item in items"&gt;</span><br><span class="line">      &lt;slot name="item" v-bind="item"/&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  ul {</span><br><span class="line">    list-style-type: none;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    background: linear-gradient(315deg, #42d392 25%, #647eff);</span><br><span class="line">  }</span><br><span class="line">  li {</span><br><span class="line">    padding: 5px 20px;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    background: #fff;</span><br><span class="line">  }</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="Provide-Inject"><a href="#Provide-Inject" class="headerlink" title="Provide/Inject"></a>Provide/Inject</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script setup&gt;</span><br><span class="line"><span class="keyword">import</span> { provide } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">provide</span>(<span class="comment">/* key */</span> <span class="string">'message'</span>, <span class="comment">/* value */</span> <span class="string">'hello!'</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>提供响应式值允许使用提供的值的后代组件建立到提供程序组件的响应式连接。</p><p>如果提供的值是 ref 它是按原样注入 不会自动解构 这允许注入器组件保留与提供者组件的反应性连接</p><h4 id="注入默认值"><a href="#注入默认值" class="headerlink" title="注入默认值"></a>注入默认值</h4><p>如果想要让注入的属性和可选提供者一起工作 那么就需要声明一个默认值 类似于 props</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">inject</span>(<span class="string">"message"</span>, <span class="string">"default value"</span>);</span><br></pre></td></tr></tbody></table></figure><p>在某些情况下，可能需要通过调用函数或实例化新类来创建默认值。为了避免在不使用可选值的情况下产生不必要的计算或副作用，我们可以使用<strong>工厂函数来创建默认值：</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">inject</span>(<span class="string">"key"</span>, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">ExpensiveClas</span>());</span><br></pre></td></tr></tbody></table></figure><h4 id="使用响应式数据"><a href="#使用响应式数据" class="headerlink" title="使用响应式数据"></a>使用响应式数据</h4><p>尽可能将任何对响应式状态的突变保留在提供程序内部 这确保了提供的状态以及可能的突变位于同一组件 从而更容易在将来维护</p><p>有时我们可能从租入器组件更新数据 这种情况我们一般提供一个负责改变状态的函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> { provide, ref } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> location = <span class="title function_">ref</span>(<span class="string">'North Pole'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateLocation</span>(<span class="params"></span>) {</span><br><span class="line">  location.<span class="property">value</span> = <span class="string">'South Pole'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">provide</span>(<span class="string">'location'</span>, {</span><br><span class="line">  location,</span><br><span class="line">  updateLocation</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">------------------------</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> { inject } <span class="keyword">from</span> <span class="string">'vue'</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> { location, updateLocation } = <span class="title function_">inject</span>(<span class="string">'location'</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"updateLocation"</span>&gt;</span>{{ location }}<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>最后 我们想确保 provide 的数据不会被改变 可以使用 readonly</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="string">"read-only-count"</span>, <span class="title function_">readonly</span>(count));</span><br></pre></td></tr></tbody></table></figure><p><strong>最好使用符号注入密钥来避免潜在的冲突 可以将符号到处到专有文件中</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keys.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myInjectionKey = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="comment">// in provider component</span></span><br><span class="line"><span class="keyword">import</span> { provide } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> { myInjectionKey } <span class="keyword">from</span> <span class="string">"./keys.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">provide</span>(myInjectionKey, {</span><br><span class="line">  <span class="comment">/* data to provide */</span></span><br><span class="line">});</span><br><span class="line"><span class="comment">// in injector component</span></span><br><span class="line"><span class="keyword">import</span> { inject } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> { myInjectionKey } <span class="keyword">from</span> <span class="string">"./keys.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> injected = <span class="title function_">inject</span>(myInjectionKey);</span><br></pre></td></tr></tbody></table></figure><h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { defineAsyncComponent } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="title function_">import</span>(<span class="string">"./components/MyComponent.vue"</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>结果<code>AsyncComp</code>是一个包装器组件，它仅在实际呈现在页面上时才调用加载器函数。此外，它会将任何 props 传递给内部组件，因此您可以使用异步包装器无缝替换原始组件，同时实现延迟加载。</p><h4 id="加载和错误状态"><a href="#加载和错误状态" class="headerlink" title="加载和错误状态"></a>加载和错误状态</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>({</span><br><span class="line">  <span class="comment">// the loader function</span></span><br><span class="line">  <span class="attr">loader</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">"./Foo.vue"</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A component to use while the async component is loading</span></span><br><span class="line">  <span class="attr">loadingComponent</span>: <span class="title class_">LoadingComponent</span>,</span><br><span class="line">  <span class="comment">// Delay before showing the loading component. Default: 200ms.</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A component to use if the load fails</span></span><br><span class="line">  <span class="attr">errorComponent</span>: <span class="title class_">ErrorComponent</span>,</span><br><span class="line">  <span class="comment">// The error component will be displayed if a timeout is</span></span><br><span class="line">  <span class="comment">// provided and exceeded. Default: Infinity.</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span>,</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>如果提供了加载组件，它将在加载内部组件时首先显示。在显示加载组件之前有一个默认的 200 毫秒延迟 - 这是因为在快速网络上，即时加载状态可能会被替换得太快并最终看起来像闪烁。</p><p>如果提供了错误组件，当 loader 函数返回的 Promise 被拒绝时会显示。您还可以指定超时以在请求时间过长时显示错误组件。</p><h2 id="Composables"><a href="#Composables" class="headerlink" title="Composables"></a>Composables</h2><p>Composables 是一种可以利用 Vue 组合 API 封装和重用有状态逻辑的函数</p><ul><li><p>鼠标跟踪器示例</p></li><li><p>```js<br>// mouse.js<br>import { ref, onMounted, onUnmounted } from ‘vue’</p><p>// by convention, composable function names start with “use”<br>export function useMouse() {<br>  // state encapsulated and managed by the composable<br>  const x = ref(0)<br>  const y = ref(0)</p><p>  // a composable can update its managed state over time.<br>  function update(event) {</p><pre><code>x.value = event.pageXy.value = event.pageY</code></pre><p>  }</p><p>  // a composable can also hook into its owner component’s<br>  // lifecycle to setup and teardown side effects.<br>  onMounted(() =&gt; window.addEventListener(‘mousemove’, update))<br>  onUnmounted(() =&gt; window.removeEventListener(‘mousemove’, update))</p><p>  // expose managed state as return value<br>  return { x, y }<br>}<br>//组件中的使用方式</p><script setup="">import { useMouse } from './mouse.js'const { x, y } = useMouse()</script><p><template>Mouse position is at: , </template></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">COmposables 还可以嵌套使用：一个可组合函数可以调用另一个或多个其他可组合函数 这是的我们能够使用小的、隔离的单元来组合复杂的逻辑 了类似于使用组件来整合整个应用程序的方式</span><br><span class="line"></span><br><span class="line">实例 2：我们可以将添加和清理 DOM 事件监听器的逻辑提取到它自己的可组合中</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">// event.js</span><br><span class="line">import { onMounted, onUnmounted } from "vue";</span><br><span class="line"></span><br><span class="line">export function useEventListener(target, event, callback) {</span><br><span class="line">  // if you want, you can also make this</span><br><span class="line">  // support selector strings as target</span><br><span class="line">  onMounted(() =&gt; target.addEventListener(event, callback));</span><br><span class="line">  onUnmounted(() =&gt; target.removeEventListener(event, callback));</span><br><span class="line">}</span><br><span class="line">//现在我们的useMouse（）可以简化为</span><br><span class="line">// mouse.js</span><br><span class="line">import { ref } from "vue";</span><br><span class="line">import { useEventListener } from "./event";</span><br><span class="line"></span><br><span class="line">export function useMouse() {</span><br><span class="line">  const x = ref(0);</span><br><span class="line">  const y = ref(0);</span><br><span class="line"></span><br><span class="line">  useEventListener(window, "mousemove", (event) =&gt; {</span><br><span class="line">    x.value = event.pageX;</span><br><span class="line">    y.value = event.pageY;</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  return { x, y };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>**tips:**每个组件实例调用<code>useMouse()</code>都将创建自己的副本<code>x</code>和<code>y</code>状态，因此它们不会相互干扰。如果想管理组件之间的共享状态 可以使用 vuex</p><h4 id="异步状态示例"><a href="#异步状态示例" class="headerlink" title="异步状态示例"></a>异步状态示例</h4><p>在进行异步数据获取时 我们经常需要处理不同的状态：加载、成功和错误 我们可以将其提取到可组合中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch.js</span></span><br><span class="line"><span class="keyword">import</span> { ref } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useFetch</span>(<span class="params">url</span>) {</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetch</span>(url)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> (data.<span class="property">value</span> = json))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> (error.<span class="property">value</span> = err));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> { data, error };</span><br><span class="line">}</span><br><span class="line"><span class="comment">//现在在我们的组件中 可以这样做</span></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> {useFetch} <span class="keyword">from</span> <span class="string">'./fetch.js'</span> <span class="keyword">const</span> {(data, error)} = <span class="title function_">useFetch</span>(<span class="string">'...'</span>)</span><br><span class="line">&lt;/script&gt;;</span><br></pre></td></tr></tbody></table></figure><p>如果我们希望在 URL 更改时重新获取数据 可以使用响应式数据作为参数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch.js</span></span><br><span class="line"><span class="keyword">import</span> { ref, isRef, unref, watchEffect } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useFetch</span>(<span class="params">url</span>) {</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doFetch</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// reset state before fetching..</span></span><br><span class="line">    data.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    error.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// unref() unwraps potential refs</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="title function_">unref</span>(url))</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> (data.<span class="property">value</span> = json))</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> (error.<span class="property">value</span> = err));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(url)) {</span><br><span class="line">    <span class="comment">// setup reactive re-fetch if input URL is a ref</span></span><br><span class="line">    <span class="title function_">watchEffect</span>(doFetch);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// otherwise, just fetch once</span></span><br><span class="line">    <span class="comment">// and avoid the overhead of a watcher</span></span><br><span class="line">    <span class="title function_">doFetch</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> { data, error };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>useFetch（）接收静态 URL 以及 URL 字符串的引用 当检测到 URL 是一个动态引用即 isRef（）时 会设置一个响应式效果 WatchEffect()效果将立即运行 并在这个过程中将 URL ref 作为依赖项进行跟踪 每当 URL 更改时 数据将被重置并再次获取</strong></p></li></ul><h4 id="Conventions-and-Best-Practices"><a href="#Conventions-and-Best-Practices" class="headerlink" title="Conventions and Best Practices"></a>Conventions and Best Practices</h4><ul><li><p>以 use 开头 如 useFetch();</p></li><li><p>如果正在编写一个可能被其他开发人员使用的组合 在处理输入参数时 refs 而不是原始值时是一个好主意 可以使用 unref</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { unref } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useFeature</span>(<span class="params">maybeRef</span>) {</span><br><span class="line">  <span class="comment">// if maybeRef is indeed a ref, its .value will be returned</span></span><br><span class="line">  <span class="comment">// otherwise, maybeRef is returned as-is</span></span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">unref</span>(maybeRef);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果在输入是<code>ref</code>是创建响应性 请确保使用<code>watch()</code>来跟踪<code>ref</code>数据 或者使用<code>unref</code>并在内部使用<code>watchEffect()</code></p></li><li><p>我们推荐返回一个 refs 对象 以便在组件中对其进行解构并保持响应性 如果更喜欢返回对象属性 可以使用<code>reactive()</code>以便解构引用</p></li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mouse = <span class="title function_">reactive</span>(<span class="title function_">useMouse</span>());</span><br><span class="line"><span class="comment">// mouse.x is linked to original ref</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mouse.<span class="property">x</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h4><ul><li>如果正在开发服务端渲染（SSR）的原因程序 确保在安装后生命周期执行特定于 DOM 的副作用 如在 onMounted()确保可以访问 DOM</li><li><strong>确保清除 onUnmounted 在设置事件监听器后记得清理</strong></li></ul><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><p>只能在钩子中同步使用 可以在<code>&lt;script setup&gt;setup()onMounted()</code>中调用</p><ul><li>生命周期钩子可以注册到它</li><li>计算属性和观察者可以追踪并在组件卸载时进行处理</li><li>你只能在<code>&lt;script setup&gt;</code>中使用 await 编译器会在执行异步操作后自动恢复活动实例上下文</li></ul><h4 id="为代码组织提取可组合项"><a href="#为代码组织提取可组合项" class="headerlink" title="为代码组织提取可组合项"></a>为代码组织提取可组合项</h4><p>可组合项不仅可以提取用于重用 还可以用于代码组织</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> {useFeatureA} <span class="keyword">from</span> <span class="string">'./featureA.js'</span> <span class="keyword">import</span> {useFeatureB} <span class="keyword">from</span></span><br><span class="line">  <span class="string">'./featureB.js'</span> <span class="keyword">import</span> {useFeatureC} <span class="keyword">from</span> <span class="string">'./featureC.js'</span> <span class="keyword">const</span> {(foo, bar)} =</span><br><span class="line">  <span class="title function_">useFeatureA</span>() <span class="keyword">const</span> {baz} = <span class="title function_">useFeatureB</span>(foo) <span class="keyword">const</span> {qux} = <span class="title function_">useFeatureC</span>(baz)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p><strong>自定义指令主要用于重用涉及对普通元素进行低级 DOM 访问的逻辑</strong></p><p>自定义指令被定义为包含类似于组件的生命周期钩子的对象 钩子接收指令绑定的元素</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="comment">// enables v-focus in templates</span></span><br><span class="line"><span class="keyword">const</span> vFocus = {</span><br><span class="line">  <span class="attr">mounted</span>: <span class="function">(<span class="params">el</span>) =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue响应式原理</title>
      <link href="/2022/04/09/vue-xiang-ying-shi-yuan-li/"/>
      <url>/2022/04/09/vue-xiang-ying-shi-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-源码解析系列-响应式原理（reactive-篇）"><a href="#Vue3-源码解析系列-响应式原理（reactive-篇）" class="headerlink" title="Vue3 源码解析系列 - 响应式原理（reactive 篇）"></a>Vue3 源码解析系列 - 响应式原理（reactive 篇）</h1><h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h2><h3 id="核心入口"><a href="#核心入口" class="headerlink" title="核心入口"></a>核心入口</h3><p>话不多说，我们先来看下核心的 <code>reactive</code> 的源码，先看下有哪些依赖：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工具方法，isObject 是判断是否是对象，toTypeString 获取数据类型</span></span><br><span class="line"><span class="keyword">import</span> { isObject, toTypeString } <span class="keyword">from</span> <span class="string">"@vue/shared"</span>;</span><br><span class="line"><span class="comment">// Proxy 的 handlers</span></span><br><span class="line"><span class="comment">// mutableHandlers：可变数据的 handler</span></span><br><span class="line"><span class="comment">// readonlyHandlers：只读数据的 handler</span></span><br><span class="line"><span class="keyword">import</span> { mutableHandlers, readonlyHandlers } <span class="keyword">from</span> <span class="string">"./baseHandlers"</span>;</span><br><span class="line"><span class="keyword">import</span> {</span><br><span class="line">  mutableCollectionHandlers, <span class="comment">// 可变集合数据的 handler</span></span><br><span class="line">  readonlyCollectionHandlers, <span class="comment">// 只读集合数据的 handler</span></span><br><span class="line">} <span class="keyword">from</span> <span class="string">"./collectionHandlers"</span>;</span><br><span class="line"><span class="comment">// effect 泛型类型</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">ReactiveEffect</span> } <span class="keyword">from</span> <span class="string">"./effect"</span>;</span><br><span class="line"><span class="comment">// ref 泛型类型</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">UnwrapRef</span>, <span class="title class_">Ref</span> } <span class="keyword">from</span> <span class="string">"./ref"</span>;</span><br><span class="line"><span class="comment">// 工具方法，将字符串转化成 Map，返回 function 来判断是否 这个Map 上包含所给的 key</span></span><br><span class="line"><span class="comment">// 这个在 vue2 里也有</span></span><br><span class="line"><span class="keyword">import</span> { makeMap } <span class="keyword">from</span> <span class="string">"@vue/shared"</span>;</span><br></pre></td></tr></tbody></table></figure><p>可以很清楚的看到，重点依赖项就是那一堆 <code>handler</code> 了，其他都是一些工具方法和泛型类型</p><p>接下来的源码里是一堆变量的定义，不过我们先跳过，先来看下 <code>reactive</code> 的方法和类型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面还有一大坨变量定义，很关键，但是我们先跳过，先看下有哪些方法，类型是什么样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖集合类型</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Dep</span> = <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt;</span><br><span class="line"><span class="comment">// 看名字就知道，是 key 和 Dep 集合的对应关系集合</span></span><br><span class="line"><span class="comment">// key 其实就是我们响应式数据上的 key，Dep 则是有哪些地方依赖到了这个 key</span></span><br><span class="line"><span class="comment">// 比如 const a = { foo: 1 }，如果在其他两处都用到了 a.foo，那么</span></span><br><span class="line"><span class="comment">// 这里的 key 就是 foo，Dep 就是这两处的 依赖集合</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">KeyToDepMap</span> = <span class="title class_">Map</span>&lt;string | symbol, <span class="title class_">Dep</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断对象能不能被观察的</span></span><br><span class="line"><span class="keyword">const</span> canObserve = (<span class="attr">value</span>: any): boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// only unwrap nested ref</span></span><br><span class="line"><span class="comment">// 解套 Ref 类型</span></span><br><span class="line">type <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">UnwrapRef</span>&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应式入口方法，入参是泛型，继承 object，返回值就是上面的解套 Ref 类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> reactive&lt;T <span class="keyword">extends</span> object&gt;(<span class="attr">target</span>: T): <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟 reactive 作用相同，只不过返回值是 Readonly 的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> readonly&lt;T <span class="keyword">extends</span> object&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">Readonly</span>&lt;<span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建响应式对象的关键方法，reactive 和 only 都调用了这个方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  toProxy: <span class="built_in">WeakMap</span>&lt;any, any&gt;,</span></span><br><span class="line"><span class="params">  toRaw: <span class="built_in">WeakMap</span>&lt;any, any&gt;,</span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;any&gt;,</span></span><br><span class="line"><span class="params">  collectionHandlers: ProxyHandler&lt;any&gt;</span></span><br><span class="line"><span class="params"></span>): any</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是响应式数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReactive</span>(<span class="params">value: any</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是只读的响应式数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReadonly</span>(<span class="params">value: any</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将响应式数据转化为原始数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(<span class="attr">observed</span>: T): T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 value 标记为 Readonly，在 reactive 方法里会判断是否是 Readonly 的原始数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> markReadonly&lt;T&gt;(<span class="attr">value</span>: T): T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 value 标记为不可响应数据，这个将会影响 canObserve 方法的判断</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> markNonReactive&lt;T&gt;(<span class="attr">value</span>: T): T</span><br></pre></td></tr></tbody></table></figure><p>看完方法和类型，大致有以下几个问题：</p><ol><li><code>Dep</code> 依赖是如何追踪的？</li><li><code>UnwrapRef</code> 是如何展开嵌套的响应式数据类型的（俗称解套）,比如 <code>reactive({ name: reactive(ref('Jooger')) })</code></li><li>如何判断是否是（只读的）响应式数据？往响应式数据上面挂载一个标记位来标记？还是用一个对象来存储响应式数据？</li><li>如何将响应式数据转化为原始数据？proxy 数据如何转化成 object？</li></ol><p>问题 1，后面的 <code>effect</code> 会讲，这里先不讨论</p><p>问题 2，后面的 <code>ref</code> 会讲，这里先不讨论</p><p>问题 3，4 就需要看下我刚才跳过的一堆变量的定义了：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The main WeakMap that stores {target -&gt; key -&gt; dep} connections.</span></span><br><span class="line"><span class="comment">// Conceptually, it's easier to think of a dependency as a Dep class</span></span><br><span class="line"><span class="comment">// which maintains a Set of subscribers, but we simply store them as</span></span><br><span class="line"><span class="comment">// raw Sets to reduce memory overhead.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// target 和 KeyToDepMap 的映射关系集合</span></span><br><span class="line"><span class="comment">// 一句话理解，有多个 target，每个 target 上有多个 key，每个 key 都有多个依赖</span></span><br><span class="line"><span class="comment">// 至于为什么要把映射关系存到 WeakMap 里，根据上面注释所述，是为了减少内存开销</span></span><br><span class="line"><span class="comment">// 这个在后续的 effect 部分会讲</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, <span class="title class_">KeyToDepMap</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMaps that store {raw &lt;-&gt; observed} pairs.</span></span><br><span class="line"><span class="comment">// 下面这四个变量就是为了解答 问题 3 和 4 的</span></span><br><span class="line"><span class="comment">// 根据上面的原英文注释，这四个变量是 raw 和 observed 的对应关系集合</span></span><br><span class="line"><span class="comment">// raw 是原始数据，observed 则是响应式数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据 -&gt; 响应式数据</span></span><br><span class="line"><span class="keyword">const</span> rawToReactive = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"><span class="comment">// 响应式数据 -&gt; 原始数据</span></span><br><span class="line"><span class="keyword">const</span> reactiveToRaw = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"><span class="comment">// 原始数据 -&gt; 只读响应式数据</span></span><br><span class="line"><span class="keyword">const</span> rawToReadonly = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"><span class="comment">// 只读响应式数据 -&gt; 原始数据</span></span><br><span class="line"><span class="keyword">const</span> readonlyToRaw = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakSets for values that are marked readonly or non-reactive during</span></span><br><span class="line"><span class="comment">// observable creation.</span></span><br><span class="line"><span class="comment">// 前面提到过的 markReadonly 和 markNonReactive 方法用到的</span></span><br><span class="line"><span class="comment">// 用来存储我们标记的特定数据，以便在创建响应式数据是来检查是否被上面两个方法标记过</span></span><br><span class="line"><span class="keyword">const</span> readonlyValues = <span class="keyword">new</span> <span class="title class_">WeakSet</span>&lt;any&gt;()</span><br><span class="line"><span class="keyword">const</span> nonReactiveValues = <span class="keyword">new</span> <span class="title class_">WeakSet</span>&lt;any&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是集合类型（Set, Map, WeakMap, WeakSet）</span></span><br><span class="line"><span class="comment">// 因为集合类型的代理 handler 和普通对象是不同的，需要特殊处理</span></span><br><span class="line"><span class="keyword">const</span> collectionTypes = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="title class_">Function</span>&gt;([<span class="title class_">Set</span>, <span class="title class_">Map</span>, <span class="title class_">WeakMap</span>, <span class="title class_">WeakSet</span>])</span><br><span class="line"><span class="comment">// 判断是否是可观察类型，有以下 6 类，在 canObserve 方法里会用到</span></span><br><span class="line"><span class="keyword">const</span> isObservableType = <span class="comment">/*#__PURE__*/</span> <span class="title function_">makeMap</span>(</span><br><span class="line">  [<span class="string">'Object'</span>, <span class="string">'Array'</span>, <span class="string">'Map'</span>, <span class="string">'Set'</span>, <span class="string">'WeakMap'</span>, <span class="string">'WeakSet'</span>]</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">t</span> =&gt;</span> <span class="string">`[object <span class="subst">${t}</span>]`</span>)</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">','</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>看完上面这些变量定义，我们来解答一下问题 3，4：</p><blockquote><p>问题 3：如何判断是否是（只读的）响应式数据？往响应式数据上面挂载一个标记位来标记？还是用一个对象来存储响应式数据？</p></blockquote><p>用 <code>readonlyToRaw</code> 来存储只读响应式数据的，参见下面代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReadonly</span>(<span class="params">value: any</span>): boolean {</span><br><span class="line">  <span class="keyword">return</span> readonlyToRaw.<span class="title function_">has</span>(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>问题 4：如何将响应式数据转化为原始数据？proxy 数据如何转化成 object？</p></blockquote><p>用 <code>reactiveToRaw</code> 和 <code>readonlyToRaw</code> 来存储<code>响应式数据 -&gt; 原始数据</code> 的映射关系，然后：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(<span class="attr">observed</span>: T): T {</span><br><span class="line">  <span class="keyword">return</span> reactiveToRaw.<span class="title function_">get</span>(observed) || readonlyToRaw.<span class="title function_">get</span>(observed) || observed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>总的来讲，就是利用各种集合来存储原始数据和响应式数据的映射关系，以便快速根据这种映射关系拿到对应的数据。</p><p>再回头看下 <code>canObserve</code> 方法，来看看到底有哪些数据是可以观察的：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canObserve = (<span class="attr">value</span>: any): <span class="function"><span class="params">boolean</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// Vue 实例不可观察，目前库里还没有 _isVue 的逻辑，不过猜测应该是内部在 setup 方法中挂载</span></span><br><span class="line">    !value.<span class="property">_isVue</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// virtual dom 不可观察</span></span><br><span class="line">    !value.<span class="property">_isVNode</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// 'Object', 'Array', 'Map', 'Set', 'WeakMap', 'WeakSet' 类型以外的不可观察</span></span><br><span class="line">    <span class="title function_">isObservableType</span>(<span class="title function_">toTypeString</span>(value)) &amp;&amp;</span><br><span class="line">    <span class="comment">// 已经标记为不可响应数据的不可观察</span></span><br><span class="line">    !nonReactiveValues.<span class="title function_">has</span>(value)</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>相比于 <code>Vue2</code> 的是否可观察判断，则少了很多条件：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我就不解析 Vue2 中的这段判断代码了</span></span><br><span class="line"><span class="comment">// 相比于 Vue2，少了 __ob__ ，ssr 以及 Object.isExtensible 的判断</span></span><br><span class="line"><span class="comment">// 这都是得益于 Proxy</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">hasOwn</span>(value, <span class="string">"__ob__"</span>) &amp;&amp; value.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) {</span><br><span class="line">  ob = value.<span class="property">__ob__</span>;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  shouldObserve &amp;&amp;</span><br><span class="line">  !<span class="title function_">isServerRendering</span>() &amp;&amp;</span><br><span class="line">  (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value) || <span class="title function_">isPlainObject</span>(value)) &amp;&amp;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) &amp;&amp;</span><br><span class="line">  !value.<span class="property">_isVue</span></span><br><span class="line">) {</span><br><span class="line">  ob = <span class="keyword">new</span> <span class="title class_">Observer</span>(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来就讲一下重点的 <code>reactive</code> 和 <code>readonly</code> 这两个核心方法的实现：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面讲过返回值就是上面的解套 Ref 类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: object</span>) {</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="comment">// 如果是一个只读响应式数据，直接返回，因为已经是响应式的了</span></span><br><span class="line">  <span class="keyword">if</span> (readonlyToRaw.<span class="title function_">has</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// target is explicitly marked as readonly by user</span></span><br><span class="line">  <span class="comment">// 如果曾经被标记为只读数据，直接调用 readonly 方法生成只读响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (readonlyValues.<span class="title function_">has</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readonly</span>(target)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建响应式对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target, <span class="comment">// 原始数据</span></span><br><span class="line">    rawToReactive, <span class="comment">// raw -&gt; observed</span></span><br><span class="line">    reactiveToRaw, <span class="comment">// observed -&gt; raw</span></span><br><span class="line">    mutableHandlers, <span class="comment">// 可变数据的 proxy handle</span></span><br><span class="line">    mutableCollectionHandlers <span class="comment">// 可变集合数据的 proxy handler</span></span><br><span class="line">  )</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> readonly&lt;T <span class="keyword">extends</span> object&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">Readonly</span>&lt;<span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;&gt; {</span><br><span class="line">  <span class="comment">// value is a mutable observable, retrieve its original and return</span></span><br><span class="line">  <span class="comment">// a readonly version.</span></span><br><span class="line">  <span class="comment">// 如果是响应式数据，那么获取原始数据来进行观察</span></span><br><span class="line">  <span class="keyword">if</span> (reactiveToRaw.<span class="title function_">has</span>(target)) {</span><br><span class="line">    target = reactiveToRaw.<span class="title function_">get</span>(target)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 创建响应式数据，同样</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target, <span class="comment">// 原始数据</span></span><br><span class="line">    rawToReadonly, <span class="comment">// raw -&gt; readonly observed</span></span><br><span class="line">    readonlyToRaw, <span class="comment">// readonly ovserved -&gt; raw</span></span><br><span class="line">    readonlyHandlers, <span class="comment">// 只读数据的 proxy handler</span></span><br><span class="line">    readonlyCollectionHandlers <span class="comment">// 只读集合数据的 proxy handler</span></span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实我们看 <code>Vue3</code> 的源码会发现，很多入口方法都变得短小精简，不像 <code>Vue2</code> 里的一些 exposed function 那样写的很长，这两个核心方法也一样，逻辑很简单，主要是进行一些原始数据检查和转换，核心实现逻辑都是放在 <code>createReactiveObject</code> 里的</p><p>下面继续看下核心实现方法 <code>createReactiveObject</code>：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建响应式对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any, <span class="comment">// 原始数据</span></span></span><br><span class="line"><span class="params">  toProxy: <span class="built_in">WeakMap</span>&lt;any, any&gt;, <span class="comment">// raw -&gt; (readonly) observed</span></span></span><br><span class="line"><span class="params">  toRaw: <span class="built_in">WeakMap</span>&lt;any, any&gt;, <span class="comment">// (readonly) observed -&gt; raw</span></span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;any&gt;, <span class="comment">// 只读/可变 数据的 proxy handler</span></span></span><br><span class="line"><span class="params">  collectionHandlers: ProxyHandler&lt;any&gt; <span class="comment">// 只读/可变 集合数据的 proxy handler</span></span></span><br><span class="line"><span class="params"></span>) {</span><br><span class="line">  <span class="comment">// 如果不是对象，则直接返回自身，包括 null，reactive(null) =&gt; null</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) {</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">${<span class="built_in">String</span>(target)}</span>`</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// target already has corresponding Proxy</span></span><br><span class="line">  <span class="comment">// 如果原始数据已经被观察过，直接通过 raw -&gt; observed 映射，返回响应式数据</span></span><br><span class="line">  <span class="keyword">let</span> observed = toProxy.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (observed !== <span class="keyword">void</span> <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> observed;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// target is already a Proxy</span></span><br><span class="line">  <span class="comment">// 如果原始数据本身就是响应式的，直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span> (toRaw.<span class="title function_">has</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// only a whitelist of value types can be observed.</span></span><br><span class="line">  <span class="comment">// 如果是不可观察对象，直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">canObserve</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 判断是采用基础数据（object|array）handler 还是集合数据 handler</span></span><br><span class="line">  <span class="keyword">const</span> handlers = collectionTypes.<span class="title function_">has</span>(target.<span class="property">constructor</span>)</span><br><span class="line">    ? collectionHandlers</span><br><span class="line">    : baseHandlers;</span><br><span class="line">  <span class="comment">// Proxy 创建代理对象，即响应式对象</span></span><br><span class="line">  observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handlers);</span><br><span class="line">  <span class="comment">// 创建后，设置好 raw &lt;-&gt; observed 的双向映射关系(*)</span></span><br><span class="line">  toProxy.<span class="title function_">set</span>(target, observed);</span><br><span class="line">  toRaw.<span class="title function_">set</span>(observed, target);</span><br><span class="line">  <span class="comment">// 上面讲到了 targetMap 的作用，这里是创建默认依赖追踪集合</span></span><br><span class="line">  <span class="keyword">if</span> (!targetMap.<span class="title function_">has</span>(target)) {</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, <span class="keyword">new</span> <span class="title class_">Map</span>());</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> observed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到：</p><ul><li>目前来看 <code>reactive</code> 和 <code>readonly</code> 的区别仅有两点：映射关系存储集合不同 and <code>proxy handler</code> 不同</li><li><code>object``array</code> 和集合类型 <code>Set``Map``WeakSet``WeakMap</code> 的 <code>proxy handler</code> 是不同的</li></ul><p>所以下面再来依次看下响应式核心中的核心 - 各种 <code>proxy handler</code></p><h2 id="baseHandler"><a href="#baseHandler" class="headerlink" title="baseHandler"></a>baseHandler</h2><p>方法跟上面一样，先看依赖：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面讲过，不过现在来看感觉像是是在 get set 这些 trap 方法里会调用</span></span><br><span class="line"><span class="keyword">import</span> { reactive, readonly, toRaw } <span class="keyword">from</span> <span class="string">"./reactive"</span>;</span><br><span class="line"><span class="comment">// 操作类型枚举，对应于 proxy handler 里的 trap 方法</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">OperationTypes</span> } <span class="keyword">from</span> <span class="string">"./operations"</span>;</span><br><span class="line"><span class="comment">// 依赖收集和触发依赖回调</span></span><br><span class="line"><span class="keyword">import</span> { track, trigger } <span class="keyword">from</span> <span class="string">"./effect"</span>;</span><br><span class="line"><span class="comment">// 全局锁，用来禁止 set 和 delete</span></span><br><span class="line"><span class="keyword">import</span> { <span class="variable constant_">LOCKED</span> } <span class="keyword">from</span> <span class="string">"./lock"</span>;</span><br><span class="line"><span class="comment">// 工具方法，类型判断</span></span><br><span class="line"><span class="keyword">import</span> { isObject, hasOwn, isSymbol } <span class="keyword">from</span> <span class="string">"@vue/shared"</span>;</span><br><span class="line"><span class="comment">// 判断是否是 ref，后面会讲到</span></span><br><span class="line"><span class="keyword">import</span> { isRef } <span class="keyword">from</span> <span class="string">"./ref"</span>;</span><br></pre></td></tr></tbody></table></figure><p>这里有两个疑问：</p><ol><li><code>track</code> 和 <code>trigger</code> 的实现</li><li><code>LOCKED</code> 的作用？为什么会有这个全局锁？</li></ol><p>问题 1 在后面的 <code>effect</code> 部分会讲到，现在只需要知道是用来追踪依赖和触发依赖回调方法就行</p><p>问题 2 现在我也不是特别了解，只知道是在组件 <code>mount</code> 和 <code>update</code> 的时候会对组件的 <code>props</code>的代理进行修改，因为我们都知道单向数据流中，子组件内部是不能更改 <code>props</code> 的，但是子组件更新，进行 vnode patch 后需要更新子组件的 <code>props</code>，包括一些动态 <code>props</code></p><p>再来看下变量和方法概览：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS 内部语言行为描述符集合，比如 Symbol.iterator 这些，在 get 里会用到</span></span><br><span class="line"><span class="keyword">const</span> builtInSymbols = <span class="keyword">new</span> <span class="title class_">Set</span>(</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Symbol</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">key</span> =&gt;</span> (<span class="title class_">Symbol</span> <span class="keyword">as</span> any)[key])</span><br><span class="line">    .<span class="title function_">filter</span>(isSymbol)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly: boolean</span>) {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  key: string | symbol,</span></span><br><span class="line"><span class="params">  value: any,</span></span><br><span class="line"><span class="params">  receiver: any</span></span><br><span class="line"><span class="params"></span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteProperty</span>(<span class="params">target: any, key: string | symbol</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params">target: any, key: string | symbol</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ownKeys</span>(<span class="params">target: any</span>): (string | number | symbol)[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;any&gt; = {</span><br><span class="line">  <span class="attr">get</span>: <span class="title function_">createGetter</span>(<span class="literal">false</span>),</span><br><span class="line">  set,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">readonlyHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;any&gt; = {</span><br><span class="line">  <span class="attr">get</span>: <span class="title function_">createGetter</span>(<span class="literal">true</span>),</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="attr">target</span>: any, <span class="attr">key</span>: string | symbol, <span class="attr">value</span>: any, <span class="attr">receiver</span>: any): boolean {</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable constant_">LOCKED</span>) {</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Set operation on key "<span class="subst">${<span class="built_in">String</span>(key)}</span>" failed: target is readonly.`</span>,</span><br><span class="line">          target</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="attr">target</span>: any, <span class="attr">key</span>: string | symbol): boolean {</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable constant_">LOCKED</span>) {</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Delete operation on key "<span class="subst">${<span class="built_in">String</span>(</span></span></span><br><span class="line"><span class="subst"><span class="string">            key</span></span></span><br><span class="line"><span class="subst"><span class="string">          )}</span>" failed: target is readonly.`</span>,</span><br><span class="line">          target</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，<code>mutableHandlers</code> 和 <code>readonlyHandlers</code> 都是定义了 5 个 trap 方法：<code>get</code>、<code>set</code>、<code>deleteProperty</code>、<code>has</code>、<code>ownKeys</code>，前 3 个不用多家介绍，<code>has</code> trap 针对与 <code>in</code> 操作符，而 <code>ownKeys</code> 针对于 <code>for in</code> 和 <code>Object.keys</code> 这些遍历操作的</p><p>而 <code>readonlyHandlers</code> 相比于 <code>mutableHandlers</code> 其实只是在 <code>get</code>、<code>set</code> 和 <code>deleteProperty</code> 这三个 trap 方法里有区别，而对于可能改变数据的 <code>set</code> 和 <code>deleteProperty</code> 方法，则是利用 <code>LOCKED</code> 来锁定，不让修改数据，这个变量我在上面也提了一下</p><p>下面来一个一个的看下各个 trap 方法</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 get trap 方法</span></span><br><span class="line"><span class="comment">// 如果是可变数据， isReadonly 是 false</span></span><br><span class="line"><span class="comment">// 如果是只读数据，那么 isReadonly 就是 true</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly: boolean</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: any, key: string | symbol, receiver: any</span>) {</span><br><span class="line">    <span class="comment">// 利用 Reflect 反射来获取原始值</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">    <span class="comment">// 如果是 JS 内置方法，不进行依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) &amp;&amp; builtInSymbols.<span class="title function_">has</span>(key)) {</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果是 ref 类型数据，则直接返回其 value</span></span><br><span class="line">    <span class="comment">// TODO 后面 ref 部分我们会讲到，ref(target) 其实在 get value 的时候做了依赖收集了，</span></span><br><span class="line">    <span class="comment">// 就不需要下面重复收集依赖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) {</span><br><span class="line">      <span class="keyword">return</span> res.<span class="property">value</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 类型操作的依赖收集</span></span><br><span class="line">    <span class="title function_">track</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">GET</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里其实很简单就是递归返回响应式对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isObject</span>(res)</span><br><span class="line">      ? isReadonly</span><br><span class="line">        ? <span class="comment">// need to lazy access readonly and reactive here to avoid</span></span><br><span class="line">          <span class="comment">// circular dependency</span></span><br><span class="line">          <span class="title function_">readonly</span>(res)</span><br><span class="line">        : <span class="title function_">reactive</span>(res)</span><br><span class="line">      : res;</span><br><span class="line">  };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看完 <code>get trap</code> 其实很简单，但是也会有写疑问：</p><h3 id="1-为什么用-Reflect-get，而不是直接-target-key-返回呢"><a href="#1-为什么用-Reflect-get，而不是直接-target-key-返回呢" class="headerlink" title="1. 为什么用 Reflect.get，而不是直接 target[key] 返回呢?"></a>1. 为什么用 <code>Reflect.get</code>，而不是直接 <code>target[key]</code> 返回呢?</h3><p>我们可以看它的第三个参数：</p><blockquote><p>receiver：如果 target 对象中指定了 getter，receiver 则为 getter 调用时的 this 值</p></blockquote><p>举个例子：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() {</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observed = <span class="title function_">reactive</span>(target);</span><br></pre></td></tr></tbody></table></figure><p>此时，如果不用 <code>Reflect.get</code>，而是 <code>target[key]</code>，那么 <code>this.foo</code> 中的 <code>this</code> 就指向的是 <code>target</code>，而不是 <code>observed</code>，此时 <code>this.foo</code> 就不能收集到 <code>foo</code> 的依赖了，如果 <code>observed.foo = 20</code> 改变了 foo 的值，那么是无法触发依赖回调的，所以需要利用 <code>Reflect.get</code> 将 getter 里的 <code>this</code> 指向代理对象</p><h3 id="2-为什么在结尾-return-的时候还要调用-reactive-或者-readoonly-呢？"><a href="#2-为什么在结尾-return-的时候还要调用-reactive-或者-readoonly-呢？" class="headerlink" title="2. 为什么在结尾 return 的时候还要调用 reactive 或者 readoonly 呢？"></a>2. 为什么在结尾 return 的时候还要调用 <code>reactive</code> 或者 <code>readoonly</code> 呢？</h3><p>原注释是这样写的：</p><blockquote><p>need to lazy access readonly and reactive here to avoid circular dependency<br>翻译过来是：需要延迟地使用 readonly 和 readtive 来避免循环引用</p></blockquote><p>为什么这样说呢？这里不得不说一下 <code>Proxy</code> 的特性：只能代理一层，对于嵌套的深层对象，如果不按源码中的方法，那就需要一层层递归来代理劫持对象，即每次递归都判断是否是对象，如果是对象，那么再调用 <code>reactive</code> 来响应式化</p><p>但是问题又来了，JS 里是有循环引用这个概念的，就像下面这样：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = {</span><br><span class="line">  <span class="attr">b</span>: {},</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">a.<span class="property">b</span>.<span class="property">c</span> = a;</span><br></pre></td></tr></tbody></table></figure><p>这样的话，如果每次递归调用 <code>reactive</code> 的话，会造成调用栈溢出 <code>Maximum call stack size exceeded</code>，但是我们只需要加上一个判断条件即可解决，在上面解析的 <code>createReactiveObject</code> 方法里我们知道如果原始数据已经被观察过，则直接返回对应的响应式数据，那么我们可以在递归调用 <code>reactive</code> 的时候判断 <code>toProxy.get(target)</code> 是否存在，如果存在就不往下递归了，我写了一个例子代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环引用对象</span></span><br><span class="line"><span class="keyword">const</span> target = { <span class="attr">b</span>: { <span class="attr">c</span>: <span class="number">1</span> } };</span><br><span class="line">target.<span class="property">b</span>.<span class="property">d</span> = target;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是上面讲的 原始数据 -&gt; 响应式数据的集合</span></span><br><span class="line"><span class="keyword">const</span> rawToReactive = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">data</span>) {</span><br><span class="line">  <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, {</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) {</span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">      <span class="keyword">const</span> observed = rawToReactive.<span class="title function_">get</span>(res);</span><br><span class="line">      <span class="keyword">return</span> observed || res;</span><br><span class="line">    },</span><br><span class="line">  });</span><br><span class="line">  rawToReactive.<span class="title function_">set</span>(data, observed);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) {</span><br><span class="line">    <span class="keyword">const</span> child = data[key];</span><br><span class="line">    <span class="comment">// 这里判断如果没有被观察过，那么继续 reactive 递归观察</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">"object"</span> &amp;&amp; !rawToReactive.<span class="title function_">get</span>(child)) {</span><br><span class="line">      <span class="title function_">reactive</span>(child);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> observed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title function_">reactive</span>(target);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">b</span>.<span class="property">d</span>.<span class="property">b</span>); <span class="comment">// Proxy {c: 1, d: {…}}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我试了一下。跟源码里的 reactive 的 get 结果是一样的</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>可以去看下我在 <a href="https://zhuanlan.zhihu.com/p/87409653">vue3 响应式源码解析-Reactive 篇</a> 这篇文章下的评论部分</p></blockquote><p>而源码中的 <code>lazy access</code> 方式很取巧，只代理一层，当用到某个属性值对象时，再进行响应式观察这一层</p><p>所以相比于初始化时递归劫持，延迟访问劫持的方式更能<strong>提升初始化性能</strong>，也有利于对数据劫持做更细的控制，特别是针对于数据对象比较大时（比如接口返回数据嵌套过深），有些数据并非需要劫持，所以按需劫持代理我们用到的数据这种方式更好</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  key: string | symbol,</span></span><br><span class="line"><span class="params">  value: any,</span></span><br><span class="line"><span class="params">  receiver: any</span></span><br><span class="line"><span class="params"></span>): boolean {</span><br><span class="line">  <span class="comment">// 如果是观察过响应式数据，那么获取它映射的原始数据</span></span><br><span class="line">  value = <span class="title function_">toRaw</span>(value);</span><br><span class="line">  <span class="comment">// 获取旧值</span></span><br><span class="line">  <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">  <span class="comment">// 如果旧值是 ref 类型数据，而新的值不是 ref，那么直接赋值给 oldValue.value</span></span><br><span class="line">  <span class="comment">// 因为 ref 数据在 set value 的时候就已经 trigger 依赖了，所以直接 return 就行</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) {</span><br><span class="line">    oldValue.<span class="property">value</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 对象上是否有这个 key，有则是 set，无则是 add</span></span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line">  <span class="comment">// 利用 Reflect 来执行 set 操作</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">  <span class="comment">// don't trigger if target is something up in the prototype chain of original</span></span><br><span class="line">  <span class="comment">// 如果 target 原型链上的数据，那么就不触发依赖回调</span></span><br><span class="line">  <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) {</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">      <span class="comment">// 开发环境操作，只比正式环境多了个 extraInfo 的调试信息</span></span><br><span class="line">      <span class="keyword">const</span> extraInfo = { oldValue, <span class="attr">newValue</span>: value };</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) {</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">ADD</span>, key, extraInfo);</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (value !== oldValue) {</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">SET</span>, key, extraInfo);</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 上面讲过，有这个 key 则是 set，无则是 add</span></span><br><span class="line">      <span class="keyword">if</span> (!hadKey) {</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">ADD</span>, key);</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (value !== oldValue) {</span><br><span class="line">        <span class="comment">// 只有当 value 改变的时候才触发</span></span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">SET</span>, key);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同样，<code>set trap</code> 看起来也很简单，但是同时也会有一些问题：</p><h3 id="1-target-toRaw-receiver-是什么鬼逻辑"><a href="#1-target-toRaw-receiver-是什么鬼逻辑" class="headerlink" title="1. target === toRaw(receiver) 是什么鬼逻辑?"></a>1. <code>target === toRaw(receiver)</code> 是什么鬼逻辑?</h3><p>首先看下</p><p><a href="https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set%23%E5%8F%82%E6%95%B0">handler.set()developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set#%E5%8F%82%E6%95%B0<img src="https://pic4.zhimg.com/v2-72382e605ce3eba8154aa310a712c403_ipico.jpg" alt="img"></a></p><p>的关于第三个参数的说明：</p><blockquote><p>最初被调用的对象。通常是 proxy 本身，但 handler 的 set 方法也有可能在原型链上或以其他方式被间接地调用（因此不一定是 proxy 本身）。<br>比如，假设有一段代码执行 obj.name = “jen”，obj 不是一个 proxy 且自身不含 name 属性，但它的原型链上有一个 proxy，那么那个 proxy 的 set 拦截函数会被调用，此时 obj 会作为 receiver 参数传进来</p></blockquote><p>上面已经给出例子了，这里我再写一下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child = { <span class="attr">name</span>: <span class="string">"child"</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">"parent"</span> },</span><br><span class="line">  {</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(target, receiver);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(child, parent);</span><br><span class="line"></span><br><span class="line">child.<span class="property">foo</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会打印出</span></span><br><span class="line"><span class="comment">// {name: "parent"} {name: "child"}</span></span><br></pre></td></tr></tbody></table></figure><p>这里有两个先决条件：</p><ol><li>child 的原型链是一个 Proxy</li><li>child 在设置值的时候，本身不包含 key 的</li></ol><p>可以看到，当满足上面两个条件的时候，设置 child 的值，会触发原型链上的 <code>set trap</code> 方法，并且 <code>target</code> 是原型链数据，而 <code>receiver</code> 则是真实数据</p><p>所以，源码中的那个条件逻辑也就不难看懂了，当满足上述两个条件时，我们当然不希望触发 parent 的 <code>set trap</code> 了</p><h3 id="2-像数组的-unshift，splice-这些操作是如何触发-set-trap方法的呢？"><a href="#2-像数组的-unshift，splice-这些操作是如何触发-set-trap方法的呢？" class="headerlink" title="2. 像数组的 unshift，splice 这些操作是如何触发 set trap方法的呢？"></a>2. 像数组的 <code>unshift</code>，<code>splice</code> 这些操作是如何触发 <code>set trap</code>方法的呢？</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 set 里加上这么一个 log</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  !hadKey ? <span class="string">"add"</span> : value !== oldValue ? <span class="string">"set"</span> : <span class="string">"unknow"</span>,</span><br><span class="line">  target,</span><br><span class="line">  key,</span><br><span class="line">  value,</span><br><span class="line">  oldValue</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>然后</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">a.<span class="title function_">unshift</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会打印</span></span><br><span class="line"><span class="comment">// add [1, 2, 3, 3] 3 3 undefined</span></span><br><span class="line"><span class="comment">// set [1, 2, 2, 3] 2 2 3</span></span><br><span class="line"><span class="comment">// set [1, 1, 2, 3] 1 1 2</span></span><br><span class="line"><span class="comment">// set [0, 1, 2, 3] 0 0 1</span></span><br><span class="line"><span class="comment">// unknow [0, 1, 2, 3] length 4 4</span></span><br></pre></td></tr></tbody></table></figure><p>一共打印了 5 次，根据打印内容我们可以看到 <code>unshift</code> 的实际操作过程，即把数组的每一项依次都往后移动一位，然后再把首位设置成 <code>0</code>，至于为什么这么操作，</p><p><a href="https://link.zhihu.com/?target=https://www.ecma-international.org/ecma-262/6.0/%23sec-array.prototype.unshift">ECMA-262 Array.property.unshiftwww.ecma-international.org/ecma-262/6.0/#sec-array.prototype.unshift</a></p><p>标准中有原理介绍，我就不赘述了，还有像 <code>shift</code> 和 <code>splice</code> 也是一样的操作步骤</p><p>可以看到 <code>unshift</code> 或者 <code>splice</code> 是会带来多次的 <code>trigger</code> 的，当然这些会有批量跟新优化的，有时间我再展开讲一下</p><p>细心的同学可能会发现，还触发了 <code>length</code> 属性的 set，而且 <code>value</code> 和 <code>oldValue</code> 是一样的，那么根据源码所示，就不会触发 set 类型的回调了呀，那我们如果在 template 里用到了 <code>a.length</code> 那也不会更新了么？</p><p>肯定是会更新的，解决办法就在 <code>trigger</code> 这个方法里，后续 <code>effect</code> 部分会讲到，先简单说一下，对于会导致数组 <code>length</code> 改变的操作，比如 add 和 delete，在 <code>effect</code> 的 <code>trigger</code> 方法里会单独处理，来触发 <code>length</code> 属性的依赖回调的</p><h3 id="其他-trap-方法"><a href="#其他-trap-方法" class="headerlink" title="其他 trap 方法"></a>其他 trap 方法</h3><p>还有 <code>deleteProperty</code>、<code>has</code> 和 <code>ownKeys</code> 这几个 trap，代码不多，都很简单，直接看下面的源码就能明白，我就不在赘述了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deleteProperty trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteProperty</span>(<span class="params">target: any, key: string | symbol</span>): boolean {</span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line">  <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key);</span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; hadKey) {</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">      <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">DELETE</span>, key, { oldValue });</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">DELETE</span>, key);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// has trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params">target: any, key: string | symbol</span>): boolean {</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, key);</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">HAS</span>, key);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ownKey trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ownKeys</span>(<span class="params">target: any</span>): (string | number | symbol)[] {</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">ITERATE</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>baseHandler</code> 是针对于数组和对象类型的数据的 proxy handler</li><li>每个 <code>trap</code> 方法都是用 <code>Reflect</code> 来反射到原始数据上的</li><li>对于 <code>get</code>、<code>has</code> 和 <code>ownKeys</code> 这一类读操作，会进行 <code>track</code> 来收集依赖，而对于 <code>set</code> 和 <code>deleteProperty</code> 这类写操作，则是会进行 <code>trigger</code> 来触发依赖回调</li><li>响应式数据的读取是 <code>lazy</code> 的，即初始化的时候不会对嵌套对象全盘观察，而是只有用到了每个值才会生成对应的响应式数据</li></ul><h2 id="collectionHandler"><a href="#collectionHandler" class="headerlink" title="collectionHandler"></a>collectionHandler</h2><p>还记得我们在看 <code>reactive</code> 方法那里有个 <code>collectionTypes</code> 的判断对吧，<code>collectionHandler</code> 就是专门来处理 <code>Set|Map|WeakSet|WeakMap</code> 这类集合类型数据的</p><p>这里可以参考相学长的</p><p><a href="https://link.zhihu.com/?target=https://juejin.im/post/5da9d7ebf265da5bbb1e52b7%23heading-12">vue3 响应式源码解析-Reactive 篇 - 掘金 juejin.im/post/5da9d7ebf265da5bbb1e52b7#heading-12</a></p><p>这篇文章，写的很详细，我这里也不再赘述了</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>最开始阅读 <code>reactive</code> 源码时，总体的逻辑是比较清晰的，但是仍然有几个地方当时有疑惑：</p><ul><li><code>rawToReactive|rawToReadonly</code> 等这几个变量是干嘛的？</li><li><code>targetMap</code> 的是干什么的？为什么是 <code>WeakMap&lt;any, KeyToDepMap&gt;</code> 类型</li><li><code>LOCKED</code> 是用来干嘛的?</li><li><code>baseHandler</code> 的 <code>get trap</code> 为什么又返回了一个 <code>reactive(res)</code>？</li><li><code>collectionHandler</code> 里的 trap 方法为什么只有 <code>get</code>？为什么跟 <code>baseHandler</code> 不一样？</li></ul><p>在读完源码后，除了 <code>LOCKED</code> 那个疑惑，其他几个问题我都已经找到答案，并且也在上面解惑了，我相信大家看完这篇文章后也应该都有自己的答案了</p><p>最后再来个源码里的知识点总结吧：</p><ul><li><code>reactive</code> 是利用 <code>Proxy</code> 来进行数据观察，<code>Reflect</code> 相关操作来反射到原始数据的，并且数据的访问是一个 <code>lazy reactive</code> 方式，即按需观察</li><li>普通对象、数组和集合类型数据的代理 handler 是不同的，这是因为 <code>Proxy</code> 的一些限制，参考</li></ul><p><a href="https://link.zhihu.com/?target=https://javascript.info/proxy%23proxy-limitations">Proxy and Reflectjavascript.info/proxy#proxy-limitations<img src="https://pic4.zhimg.com/v2-371dd24f02bbb7f17ea00a910ff8f70b_180x120.jpg" alt="img"></a></p><ul><li>利用几个 <code>WeakMap</code> 来存储原始数据 &lt;-&gt; 响应式数据的双向映射关系，以便在响应式入口方法里判断是否原始数据已经被观察过，这个相比于 Vue2 的直接在原始数据上挂载 <code>__ob__</code>要少一些冗余数据，并且由于 <code>WeakMap</code> 的 GC 特性，在运行时会有一定的内存优化</li><li>响应式数据的读操作会 <code>track</code> 来收集依赖，写操作则是会 <code>trigger</code> 来触发依赖回调</li></ul><p>整个 <code>reactive|readonly</code> 的流程如下：</p><p><img src="https://pic3.zhimg.com/80/v2-849f116c5d6f242c776ab5b8d610ee1a_720w.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 框架原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化</title>
      <link href="/2022/04/09/xing-neng-you-hua/"/>
      <url>/2022/04/09/xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="页面内容的呈现过程"><a href="#页面内容的呈现过程" class="headerlink" title="页面内容的呈现过程"></a>页面内容的呈现过程</h1><h2 id="页面的首屏加载性能-白屏时间是否过长？"><a href="#页面的首屏加载性能-白屏时间是否过长？" class="headerlink" title="页面的首屏加载性能 白屏时间是否过长？"></a>页面的首屏加载性能 白屏时间是否过长？</h2><h2 id="页面加载时的-loading-动画-是否需要骨架屏-骨架屏消失时使得否存在页面抖动"><a href="#页面加载时的-loading-动画-是否需要骨架屏-骨架屏消失时使得否存在页面抖动" class="headerlink" title="页面加载时的 loading 动画 是否需要骨架屏 骨架屏消失时使得否存在页面抖动"></a>页面加载时的 loading 动画 是否需要骨架屏 骨架屏消失时使得否存在页面抖动</h2><h2 id="数据为空时-页面模块的占位方式-数据返回时-是否会出现页面抖动"><a href="#数据为空时-页面模块的占位方式-数据返回时-是否会出现页面抖动" class="headerlink" title="数据为空时 页面模块的占位方式 数据返回时 是否会出现页面抖动"></a>数据为空时 页面模块的占位方式 数据返回时 是否会出现页面抖动</h2><h2 id="页面异常处理时-是否提供了合理的用户反馈"><a href="#页面异常处理时-是否提供了合理的用户反馈" class="headerlink" title="页面异常处理时 是否提供了合理的用户反馈"></a>页面异常处理时 是否提供了合理的用户反馈</h2><h2 id="页面适配-对于不同尺寸的设备-是否都能保证主要内容的首屏透出"><a href="#页面适配-对于不同尺寸的设备-是否都能保证主要内容的首屏透出" class="headerlink" title="页面适配 对于不同尺寸的设备 是否都能保证主要内容的首屏透出"></a>页面适配 对于不同尺寸的设备 是否都能保证主要内容的首屏透出</h2><h2 id="文本超长时是做阶段还是省略处理"><a href="#文本超长时是做阶段还是省略处理" class="headerlink" title="文本超长时是做阶段还是省略处理"></a>文本超长时是做阶段还是省略处理</h2><h2 id="图片加载时如何占位-加载失败时如何处理-是否需要做缩放处理"><a href="#图片加载时如何占位-加载失败时如何处理-是否需要做缩放处理" class="headerlink" title="图片加载时如何占位 加载失败时如何处理 是否需要做缩放处理"></a>图片加载时如何占位 加载失败时如何处理 是否需要做缩放处理</h2><h2 id="页面变化时是否有合理的过渡和动画"><a href="#页面变化时是否有合理的过渡和动画" class="headerlink" title="页面变化时是否有合理的过渡和动画"></a>页面变化时是否有合理的过渡和动画</h2><h1 id="页面交互的体验细节"><a href="#页面交互的体验细节" class="headerlink" title="页面交互的体验细节"></a>页面交互的体验细节</h1><h2 id="用户操作的响应性时间是否过长"><a href="#用户操作的响应性时间是否过长" class="headerlink" title="用户操作的响应性时间是否过长"></a>用户操作的响应性时间是否过长</h2><h2 id="按钮的点击区域是否合理"><a href="#按钮的点击区域是否合理" class="headerlink" title="按钮的点击区域是否合理"></a>按钮的点击区域是否合理</h2><h2 id="文字长按是否可以选中"><a href="#文字长按是否可以选中" class="headerlink" title="文字长按是否可以选中"></a>文字长按是否可以选中</h2><h2 id="页面滚动是否需要滚动栏"><a href="#页面滚动是否需要滚动栏" class="headerlink" title="页面滚动是否需要滚动栏"></a>页面滚动是否需要滚动栏</h2><h2 id="页面浮层是否存在点击或滚动穿透"><a href="#页面浮层是否存在点击或滚动穿透" class="headerlink" title="页面浮层是否存在点击或滚动穿透"></a>页面浮层是否存在点击或滚动穿透</h2><h2 id="图片长按是否可以保存"><a href="#图片长按是否可以保存" class="headerlink" title="图片长按是否可以保存"></a>图片长按是否可以保存</h2><h1 id="页面的可访问性"><a href="#页面的可访问性" class="headerlink" title="页面的可访问性"></a>页面的可访问性</h1>]]></content>
      
      
      <categories>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈设计模式</title>
      <link href="/2022/04/09/qian-tan-she-ji-mo-shi/"/>
      <url>/2022/04/09/qian-tan-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态的思想是把”做什么”和“谁去做”分开来</p><p><strong>多态最根本的作用是通过过程化的条件分支语句转化为对象的多态性 从而消除这些条件分支语句</strong></p><p>将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//不用多态的版本</span><br><span class="line">var googleMap = {</span><br><span class="line"> show: function(){</span><br><span class="line"> console.log( '开始渲染谷歌地图' );</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var baiduMap = {</span><br><span class="line"> show: function(){</span><br><span class="line"> console.log( '开始渲染百度地图' );</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var renderMap = function( type ){</span><br><span class="line"> if ( type === 'google' ){</span><br><span class="line"> googleMap.show();</span><br><span class="line"> }else if ( type === 'baidu' ){</span><br><span class="line"> baiduMap.show();</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">renderMap( 'google' ); // 输出：开始渲染谷歌地图</span><br><span class="line">renderMap( 'baidu' ); // 输出：开始渲染百度地图</span><br><span class="line">//不断地在renderMap中堆砌条件分支语句 导致代码臃肿</span><br><span class="line">var renderMap = function( map ){</span><br><span class="line"> if ( map.show instanceof Function ){</span><br><span class="line"> map.show();</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">//使用多态 只需要关注发出show的动作 不必关心是谁的show做什么动作</span><br></pre></td></tr></tbody></table></figure><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><ul><li>所有数据都是对象</li><li>要得到一个对象 不是通过实例化一个类 而是找到一个对象并作为原型克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求 就会把这个请求委托给它自己的原型</li></ul><h1 id="this、call、apply"><a href="#this、call、apply" class="headerlink" title="this、call、apply"></a>this、call、apply</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this 总是指向一个对象 而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的 而非函数声明的环境</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>使用闭包的同时容易形成循环引用 如果闭包的作用域链中存在一些 DMO 节点 就可能造成内存泄漏</p><p>要解决循环引用带来的内存泄露问题 只需要讲循环引用中的变量设为 null 即可</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证一个类仅有一个实例 并提供一个访问它的全局访问点 <strong>即单例模式的核心是确保只有一个实例并提供全局访问</strong></p><p>作为开发者应该尽量减少全局变量的使用 可以使用闭包封装私有变量来避免对全局的命令污染</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user = (function(){</span><br><span class="line"> var __name = 'sven',</span><br><span class="line"> __age = 29;</span><br><span class="line"> return {</span><br><span class="line"> getUserInfo: function(){</span><br><span class="line"> return __name + '-' + __age;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>定义：定义一系列的算法 把它们一个一个封装起来 并且使它们可以互相替换 <strong>目的是将算法的使用与算法的实现分离开来</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var strategies = {</span><br><span class="line"> "S": function( salary ){</span><br><span class="line"> return salary * 4;</span><br><span class="line"> },</span><br><span class="line"> "A": function( salary ){</span><br><span class="line"> return salary * 3;</span><br><span class="line"> },</span><br><span class="line"> "B": function( salary ){</span><br><span class="line"> return salary * 2;</span><br><span class="line">图灵社区会员 轩辕 专享 尊重版权</span><br><span class="line">76 第 5 章 策略模式</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var calculateBonus = function( level, salary ){</span><br><span class="line"> return strategies[ level ]( salary );</span><br><span class="line">};</span><br><span class="line">console.log( calculateBonus( 'S', 20000 ) ); // 输出：80000</span><br><span class="line">console.log( calculateBonus( 'A', 10000 ) ); // 输出：30000</span><br></pre></td></tr></tbody></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>保护代理：代理可以帮助过滤掉一些请求</p><p>虚拟代理：虚拟代理把一些开销很大的对象延迟到真正需要它的时候才去创建</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">虚拟代理：</span><br><span class="line">var myImage = (function(){</span><br><span class="line"> var imgNode = document.createElement( 'img' );</span><br><span class="line"> document.body.appendChild( imgNode );</span><br><span class="line"> return {</span><br><span class="line"> setSrc: function( src ){</span><br><span class="line"> imgNode.src = src;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">var proxyImage = (function(){</span><br><span class="line"> var img = new Image;</span><br><span class="line"> img.onload = function(){</span><br><span class="line"> myImage.setSrc( this.src );</span><br><span class="line"> }</span><br><span class="line"> return {</span><br><span class="line"> setSrc: function( src ){</span><br><span class="line"> myImage.setSrc( 'file:// /C:/Users/svenzeng/Desktop/loading.gif' );</span><br><span class="line"> img.src = src;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">proxyImage.setSrc( 'http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg' );</span><br><span class="line">//加载中用一张本地图片 加载后才替换为对应url</span><br></pre></td></tr></tbody></table></figure><p>单一职责原则：一个类（通常包括对象和函数等）而言，应该仅有一个引起它变化的原因 如果一个对象承担的职责过多 就会导致脆弱和低内聚</p><p>**代理和本体应该拥有一样的主要逻辑功能 这样用户可以在不需要用到代理的时候直接将请求对象改成本体而无需修改本体的代码 **</p><p><strong>虚拟代理合并 http 请求</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">需求场景：同步文件 如果短时间内连续发送请求会导致服务器压力太大 可以设置代理函数收集一段时间内的请求最后一次性发送给服务器 除非是对实时性要求高的系统 不然延迟都不会带来太大的副作用却可以大大减轻服务器的压力</span><br><span class="line">var synchronousFile = function( id ){</span><br><span class="line"> console.log( '开始同步文件，id 为: ' + id );</span><br><span class="line">};</span><br><span class="line">var proxySynchronousFile = (function(){</span><br><span class="line"> var cache = [], // 保存一段时间内需要同步的 ID</span><br><span class="line"> timer; // 定时器</span><br><span class="line"> return function( id ){</span><br><span class="line"> cache.push( id );</span><br><span class="line"> if ( timer ){ // 保证不会覆盖已经启动的定时器</span><br><span class="line"> return;</span><br><span class="line"> }</span><br><span class="line"> timer = setTimeout(function(){</span><br><span class="line"> synchronousFile( cache.join( ',' ) ); // 2 秒后向本体发送需要同步的 ID 集合</span><br><span class="line"> clearTimeout( timer ); // 清空定时器</span><br><span class="line"> timer = null;</span><br><span class="line"> cache.length = 0; // 清空 ID 集合</span><br><span class="line"> }, 2000 );</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">var checkbox = document.getElementsByTagName( 'input' );</span><br><span class="line">for ( var i = 0, c; c = checkbox[ i++ ]; ){</span><br><span class="line">c.onclick = function(){</span><br><span class="line"> if ( this.checked === true ){</span><br><span class="line"> proxySynchronousFile( this.id );</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>缓存代理可以为一些开销很大的运算结果提供暂时的储存 在下次运算时 如果传递进来的参数跟之前的一样 就可以直接返回之前的计算结果</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">先创建一个用于求乘积的函数：</span><br><span class="line">var mult = function(){</span><br><span class="line"> console.log( '开始计算乘积' );</span><br><span class="line"> var a = 1;</span><br><span class="line"> for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"> a = a * arguments[i];</span><br><span class="line"> }</span><br><span class="line"> return a;</span><br><span class="line">};</span><br><span class="line">mult( 2, 3 ); // 输出：6</span><br><span class="line">mult( 2, 3, 4 ); // 输出：24</span><br><span class="line">现在加入缓存代理函数：</span><br><span class="line">var proxyMult = (function(){</span><br><span class="line"> var cache = {};</span><br><span class="line"> return function(){</span><br><span class="line"> var args = Array.prototype.join.call( arguments, ',' );</span><br><span class="line"> if ( args in cache ){</span><br><span class="line"> return cache[ args ];</span><br><span class="line"> }</span><br><span class="line"> return cache[ args ] = mult.apply( this, arguments );</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line"> proxyMult( 1, 2, 3, 4 ); // 输出：24</span><br><span class="line"> proxyMult( 1, 2, 3, 4 ); // 输出：24第二次并没有进行计算 而是直接返回之前计算好的结果 通过增加缓存代理的方式 mult函数可以继续专注于自身的职责-计算乘积 而缓存的功能时由代理对象实现的</span><br></pre></td></tr></tbody></table></figure><p><strong>缓存代理用于 api 请求</strong></p><p>在进行请求一些不变的数据的时候（分页需求）同一页的数据理论上只需要去后台拉取一次，这些已经拉取到的数据在某个地方被缓存之后 下次再请求同一页的时候 就可以直接使用之前的数据 可以通过缓存代理实现</p><p><strong>使用高阶函数动态创建代理</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**************** 计算乘积 *****************/</span><br><span class="line">var mult = function(){</span><br><span class="line"> var a = 1;</span><br><span class="line"> for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"> a = a * arguments[i];</span><br><span class="line"> }</span><br><span class="line"> return a;</span><br><span class="line">};</span><br><span class="line">/**************** 计算加和 *****************/</span><br><span class="line">var plus = function(){</span><br><span class="line"> var a = 0;</span><br><span class="line"> for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"> a = a + arguments[i];</span><br><span class="line"> }</span><br><span class="line"> return a;</span><br><span class="line">};</span><br><span class="line">/**************** 创建缓存代理的工厂 *****************/</span><br><span class="line">var createProxyFactory = function( fn ){</span><br><span class="line"> var cache = {};</span><br><span class="line"> return function(){</span><br><span class="line"> var args = Array.prototype.join.call( arguments, ',' );</span><br><span class="line"> if ( args in cache ){</span><br><span class="line"> return cache[ args ];</span><br><span class="line"> }</span><br><span class="line"> return cache[ args ] = fn.apply( this, arguments );</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var proxyMult = createProxyFactory( mult ),</span><br><span class="line">proxyPlus = createProxyFactory( plus );</span><br><span class="line">alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24</span><br><span class="line">alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24</span><br><span class="line">alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10</span><br><span class="line">alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10</span><br></pre></td></tr></tbody></table></figure><p>tips：编写业务的时候往往不需要预先去猜测是否需要使用代理模式 当真正发现不方便的时候直接访问某个对象的时候 再编写代理也不迟</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象 的内部表示</p><h1 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h1><p>发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状 态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型 来替代传统的发布—订阅模式。</p><p><strong>发布-订阅模式可以广泛用于异步编程中 是一种可以代替回调函数的方案 在异步编程中使用发布-订阅模式 我们就无需过多关注对象在一异步运行期间的内部状态 而只需要订阅感兴趣的事件发生点</strong></p><p><strong>发布-订阅模式可以取代对象之间的硬编码的通知方式 一个对象不再显式地调用另一个对象的某个接口实现松耦合 可以单独对订阅者和发布者做修改而不用去修改其引用</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">发布-订阅模式的步骤</span><br><span class="line">1.首先要指定谁充当发布者</span><br><span class="line">2.然后给发布者添加一个缓存列表 用于存放回调函数以便通知订阅者</span><br><span class="line">3.最后在发布消息的时候 发布者会遍历这个缓存列表 依次触发里面存放的订阅者函数 另外 可以往回调函数中加入一些参数 订阅者可以接收参数 这很有必要</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">var event = {</span><br><span class="line"> clientList: [],</span><br><span class="line"> listen: function( key, fn ){</span><br><span class="line"> if ( !this.clientList[ key ] ){</span><br><span class="line"> this.clientList[ key ] = [];</span><br><span class="line"> }</span><br><span class="line"> this.clientList[ key ].push( fn ); // 订阅的消息添加进缓存列表</span><br><span class="line"> },</span><br><span class="line"> trigger: function(){</span><br><span class="line"> var key = Array.prototype.shift.call( arguments ), // (1);</span><br><span class="line"> fns = this.clientList[ key ];</span><br><span class="line"> if ( !fns || fns.length === 0 ){ // 如果没有绑定对应的消息</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> for( var i = 0, fn; fn = fns[ i++ ]; ){</span><br><span class="line"> fn.apply( this, arguments ); // (2) // arguments 是 trigger 时带上的参数</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布—订阅功能：</span><br><span class="line">var installEvent = function( obj ){</span><br><span class="line"> for ( var i in event ){</span><br><span class="line"> obj[ i ] = event[ i ];</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">再来测试一番，我们给售楼处对象 salesOffices 动态增加发布—订阅功能：</span><br><span class="line">var salesOffices = {};</span><br><span class="line">installEvent( salesOffices );</span><br><span class="line">salesOffices.listen( 'squareMeter88', function( price ){ // 小明订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.listen( 'squareMeter100', function( price ){ // 小红订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.trigger( 'squareMeter88', 2000000 ); // 输出：2000000</span><br><span class="line">salesOffices.trigger( 'squareMeter100', 3000000 ); // 输出：3000000</span><br><span class="line">取消订阅的事件</span><br><span class="line">event.remove = function( key, fn ){</span><br><span class="line"> var fns = this.clientList[ key ];</span><br><span class="line"> if ( !fns ){ // 如果 key 对应的消息没有被人订阅，则直接返回</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> if ( !fn ){ // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅</span><br><span class="line"> fns &amp;&amp; ( fns.length = 0 );</span><br><span class="line"> }else{</span><br><span class="line"> for ( var l = fns.length - 1; l &gt;=0; l-- ){ // 反向遍历订阅的回调函数列表</span><br><span class="line"> var _fn = fns[ l ];</span><br><span class="line"> if ( _fn === fn ){</span><br><span class="line"> fns.splice( l, 1 ); // 删除订阅者的回调函数</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var salesOffices = {};</span><br><span class="line">var installEvent = function( obj ){</span><br><span class="line"> for ( var i in event ){</span><br><span class="line"> obj[ i ] = event[ i ];</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">installEvent( salesOffices );</span><br><span class="line">salesOffices.listen( 'squareMeter88', fn1 = function( price ){ // 小明订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.listen( 'squareMeter88', fn2 = function( price ){ // 小红订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.remove( 'squareMeter88', fn1 ); // 删除小明的订阅</span><br><span class="line">salesOffices.trigger( 'squareMeter88', 2000000 ); // 输出：2000000</span><br></pre></td></tr></tbody></table></figure><p><strong>全局的发布订阅模式</strong></p><p>发布订阅模式可以用一个全局的 Event 对象来实现 订阅者不需要了解消息来自哪个发布者 发布者也不知道消息会被推送给哪些订阅者 Event 作为一个类似于中介的角色把订阅者和发布者联系起来</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">var Event = (function(){</span><br><span class="line"> var clientList = {},</span><br><span class="line"> listen,</span><br><span class="line"> trigger,</span><br><span class="line"> remove;</span><br><span class="line"> listen = function( key, fn ){</span><br><span class="line"> if ( !clientList[ key ] ){</span><br><span class="line"> clientList[ key ] = [];</span><br><span class="line"> }</span><br><span class="line"> clientList[ key ].push( fn );</span><br><span class="line"> };</span><br><span class="line"> trigger = function(){</span><br><span class="line"> var key = Array.prototype.shift.call( arguments ),</span><br><span class="line"> fns = clientList[ key ];</span><br><span class="line"> if ( !fns || fns.length === 0 ){</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> for( var i = 0, fn; fn = fns[ i++ ]; ){</span><br><span class="line"> fn.apply( this, arguments );</span><br><span class="line">}</span><br><span class="line"> };</span><br><span class="line"> remove = function( key, fn ){</span><br><span class="line"> var fns = clientList[ key ];</span><br><span class="line"> if ( !fns ){</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> if ( !fn ){</span><br><span class="line"> fns &amp;&amp; ( fns.length = 0 );</span><br><span class="line"> }else{</span><br><span class="line"> for ( var l = fns.length - 1; l &gt;=0; l-- ){</span><br><span class="line"> var _fn = fns[ l ];</span><br><span class="line"> if ( _fn === fn ){</span><br><span class="line"> fns.splice( l, 1 );</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> };</span><br><span class="line"> return {</span><br><span class="line"> listen: listen,</span><br><span class="line"> trigger: trigger,</span><br><span class="line"> remove: remove</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">Event.listen( 'squareMeter88', function( price ){ // 小红订阅消息</span><br><span class="line"> console.log( '价格= ' + price ); // 输出：'价格=2000000'</span><br><span class="line">});</span><br><span class="line">Event.trigger( 'squareMeter88', 2000000 ); // 售楼处发布消息</span><br></pre></td></tr></tbody></table></figure><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue框架解读1.0</title>
      <link href="/2022/04/09/vue-kuang-jia-jie-du-1.0/"/>
      <url>/2022/04/09/vue-kuang-jia-jie-du-1.0/</url>
      
        <content type="html"><![CDATA[<h1 id="权衡的艺术"><a href="#权衡的艺术" class="headerlink" title="权衡的艺术"></a>权衡的艺术</h1><h2 id="1-3-虚拟-dom"><a href="#1-3-虚拟-dom" class="headerlink" title="1.3 虚拟 dom"></a>1.3 虚拟 dom</h2><p>虚拟 dom 的耗时：创建 javascript 的计算量 + 创建真实 dom 的计算量 （数据变化量有关）</p><p>innerHtml 的耗时：拼接字符串的计算量 + innerHtml 的 DOM 计算量 （模板大小有关）</p><p><strong>原生 JavaScript &gt; 虚拟 dom &gt; innerHTML</strong></p><h2 id="1-4-运行和编译时"><a href="#1-4-运行和编译时" class="headerlink" title="1.4 运行和编译时"></a>1.4 运行和编译时</h2><h1 id="1-框架设计的核心要素"><a href="#1-框架设计的核心要素" class="headerlink" title="1 框架设计的核心要素"></a>1 框架设计的核心要素</h1><h2 id="2-1-缩减框架代码的体积"><a href="#2-1-缩减框架代码的体积" class="headerlink" title="2.1 缩减框架代码的体积"></a>2.1 缩减框架代码的体积</h2><p>例：vue3 源码的 warn 函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(_DEV_ &amp;&amp; ires) {</span><br><span class="line">warn(</span><br><span class="line">'faile to ....')</span><br><span class="line">};</span><br><span class="line">//vue.js使用rolllup.js对项目进项构建 这里的_DEV_实际上就是通过rollup.js的设置来预定义的 类似于webpack的DefinePlugin插件</span><br><span class="line">当用于开发环境时 _DEV_为true 即 if(true &amp;&amp; ires)</span><br><span class="line">而在构建生产环境中 _DEV_会被翻译为false 即 if(false &amp;&amp; _DEV_) 这样就永远不会执行</span><br><span class="line">**这种永远不会执行的代码称之为dead code 在构建最终项目的时候就会被移除 从而可以在开发环境中提供友好的提示 生产环境中减少代码的体积</span><br><span class="line">**vue3源码多出利用相似逻辑保证了开发环境的友好体验和生产环境的代码体积控制</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2Tree-Shaking"><a href="#2-2Tree-Shaking" class="headerlink" title="2.2Tree-Shaking"></a>2.2Tree-Shaking</h2><p>Tree-Shaking：消除永远不会使用到的代码 如上面说的<em>DEV</em></p><p><strong>能使用 Tree-Shaking 的必须是满足 ESM</strong></p><p>Tree-Shaking 会产生副作用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**加上标记来告诉系统可以安心清除副作用</span><br><span class="line">import {foo} from './utils';</span><br><span class="line">/*#_PURE_*/ foo();//   /*#_PURE_*/会告诉roupull.js可以放心进行Tree-Shaking</span><br><span class="line">vue3的源码多出使用/*#_PURE_*/来标记 都用于顶级调用</span><br><span class="line">export const isHTMLTag = /*#_PURE_*/ makeMap(HTML_TAGS);</span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-框架输出的产物"><a href="#2-3-框架输出的产物" class="headerlink" title="2.3 框架输出的产物"></a>2.3 框架输出的产物</h2><p>无论是 rollup.js 还是 webpack 在寻找资源文件的时候 如果 package.json 中存在 module 字段 都会优先使用 module 字段指向的资源代替 main 字段指向的资源</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">"main": 'index.js',</span><br><span class="line">"module": 'dist/vue.runtime.esm-bundler.js'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用处：当我们使用构建提供工具打包的 ESM 格式的资源时 不能直接把<em>DEV</em>转换成 true 或 false 需要使用(process.env.NODE* !== ‘production’)替换—DEV*常量</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if((process.env.NODE) !== 'production') {</span><br><span class="line">....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需求场景：当进行服务端渲染时 vue.js 的代码是在 Node.js 的环境中运行的 但是 Node.js 时 CommonJS 形式 所以可以更改 roullup.js 中的 format 配置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format: 'cjs'//指定模块形式</span><br></pre></td></tr></tbody></table></figure><h2 id="2-4-特定开关"><a href="#2-4-特定开关" class="headerlink" title="2.4 特定开关"></a>2.4 特定开关</h2><h2 id="2-5-错误处理"><a href="#2-5-错误处理" class="headerlink" title="2.5 错误处理"></a>2.5 错误处理</h2><h1 id="VUE-JS3-的设计思路"><a href="#VUE-JS3-的设计思路" class="headerlink" title="VUE.JS3 的设计思路"></a>VUE.JS3 的设计思路</h1><h2 id="3-2-渲染器"><a href="#3-2-渲染器" class="headerlink" title="3.2 渲染器"></a>3.2 渲染器</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function renderer(vnode, container) {</span><br><span class="line">  // 使用 vnode.tag 作为标签名称创建 DOM 元素</span><br><span class="line">const el = document.createElement(vnode.tag)</span><br><span class="line">  // 遍历 vnode.props 将属性、事件添加到 DOM 元素</span><br><span class="line">  for (const key in vnode.props) {</span><br><span class="line">    if (/^on/.test(key)) {</span><br><span class="line">      // 如果 key 以 on 开头，那么说明它是事件</span><br><span class="line">      el.addEventListener(</span><br><span class="line">        key.substr(2).toLowerCase(), // 事件名称 onClick ---&gt; click</span><br><span class="line">        vnode.props[key] // 事件处理函数</span><br><span class="line">      )</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 处理 children</span><br><span class="line">  if (typeof vnode.children === 'string') {</span><br><span class="line">    // 如果 children 是字符串，说明是元素的文本子节点</span><br><span class="line">    el.appendChild(document.createTextNode(vnode.children))</span><br><span class="line">  } else if (Array.isArray(vnode.children)) {</span><br><span class="line">    // 递归地调用 renderer 函数渲染子节点，使用当前元素 el 作为挂载点</span><br><span class="line">    vnode.children.forEach(child =&gt; renderer(child, el))</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 将元素添加到挂载点下</span><br><span class="line">  container.appendChild(el)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const vnode = {</span><br><span class="line">  tag: 'div',</span><br><span class="line">  props: {</span><br><span class="line">    onClick: () =&gt; alert('hello')</span><br><span class="line">  },</span><br><span class="line">  children: 'click me'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">renderer(vnode, document.body)；</span><br></pre></td></tr></tbody></table></figure><h1 id="响应系统的作用和实现"><a href="#响应系统的作用和实现" class="headerlink" title="响应系统的作用和实现"></a>响应系统的作用和实现</h1><h2 id="4-1-响应式数据与副作用"><a href="#4-1-响应式数据与副作用" class="headerlink" title="4.1 响应式数据与副作用"></a>4.1 响应式数据与副作用</h2><p>副作用函数：会产生副作用的函数 即该函数的执行会直接或间接地影响到其他函数或变量的执行</p><h2 id="4-2-响应式数据的基本实现"><a href="#4-2-响应式数据的基本实现" class="headerlink" title="4.2 响应式数据的基本实现"></a>4.2 响应式数据的基本实现</h2><ul><li><p>通过拦截一个对象的读取和设置操作</p><ul><li><p>```<br>//当读取obj.text的时候 就将副作用函数储存到一个桶里面<br>//当设置obj.text的时候 就将副作用从桶里面取出执行便可<br>/ 存储副作用函数的桶<br>const bucket = new Set()</p><p>// 原始数据<br>const data = { text: ‘hello world’ }<br>// 对原始数据的代理<br>const obj = new Proxy(data, {<br>  // 拦截读取操作<br>  get(target, key) {</p><pre><code>// 将副作用函数 effect 添加到存储副作用函数的桶中bucket.add(effect)// 返回属性值return target[key]</code></pre><p>  },<br>  // 拦截设置操作<br>  set(target, key, newVal) {</p><pre><code>// 设置属性值target[key] = newVal// 把副作用函数从桶里取出并执行bucket.forEach(fn =&gt; fn())</code></pre><p>  }<br>})</p><p>function effect() {<br>  document.body.innerText = obj.text<br>}<br>effect()</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    **缺陷**：如果副作用改名或者是匿名函数 则该响应系统失效</span><br><span class="line"></span><br><span class="line">- 设计一个完善的响应系统</span><br><span class="line"></span><br><span class="line">  - 提供一个用来注册副作用函数的机制来解决上面的问题</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    //用一个变量春促当前激活的effect函数</span><br><span class="line">    let activeEffect;</span><br><span class="line">    function effect(fn) {</span><br><span class="line">    //当调用effect注册副作用函数是 将副作用函数赋值给activeEffect</span><br><span class="line">    activeEffect = fn;</span><br><span class="line">    fn(0);//执行副作用函数</span><br><span class="line">    };</span><br><span class="line">    effect(() =&gt; {</span><br><span class="line">    console.log('effect do');</span><br><span class="line">    documrnt.body.innerText = obj.text;//进行读取操作</span><br><span class="line">    })</span><br><span class="line">    const obj = new Proxy(data, {</span><br><span class="line">    get(target, key) {</span><br><span class="line">    //将当前被调用的副作用函数加入到桶中</span><br><span class="line">    if(activeEffect) {</span><br><span class="line">    bucket.add(activeEffect)//新增</span><br><span class="line">    }</span><br><span class="line">    return target[key];</span><br><span class="line">    },</span><br><span class="line">    set(target, key, newVal) {</span><br><span class="line">    target[key] = newVal;</span><br><span class="line">    bucket.forEach( fn =&gt; fn());</span><br><span class="line">    return true;</span><br><span class="line">    }</span><br><span class="line">    })</span><br></pre></td></tr></tbody></table></figure><p><strong>完成了可以添加匿名或任意名字的副作用函数</strong></p><p><strong>缺陷：无法监听指定属性，即如果进行类似于新增不存在的属性 该副作用函数依然会被执行（正常不应该被执行）</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">测试：新增不存在的obj.text2属性</span><br><span class="line">effect(() =&gt; {</span><br><span class="line">obj.body.innerText = obj.text</span><br><span class="line"></span><br><span class="line">console.log('effect done')</span><br><span class="line">});</span><br><span class="line">setTimeout(() =&gt; {</span><br><span class="line">obj.text2 = 'none exists';//新增一个不存在的属性</span><br><span class="line">})</span><br><span class="line">//运行结果：effect done 执行两次</span><br><span class="line">//分析：每次修改对象obj都会将effect存入桶中 导致读取时执行不该执行的副作用</span><br><span class="line">//没有在副作用函数与被操作的目标之间建立明确的联系</span><br><span class="line">**解决方法：在副作用函数与被操作的字段之间建立联系 可以使用weakMap</span><br><span class="line">//储存副作用的桶</span><br><span class="line">const bucket = new WeakMap();</span><br><span class="line">//修改拦截器</span><br><span class="line">const obj = new Proxy(data, {</span><br><span class="line">//拦截读取行为</span><br><span class="line">get(target, key) {</span><br><span class="line">//没有activeEffect 直接return</span><br><span class="line">if(!activeEffect) return;</span><br><span class="line">//根据traget从桶中取得desMap， ：key --&gt; effects</span><br><span class="line">let desMap = bucket.get(target);</span><br><span class="line">//如果不存在desMap 那么就创建一个WeakMap</span><br><span class="line">if(!desMap) {</span><br><span class="line">bucket.set(target, (desMap = new Map()))</span><br><span class="line">}</span><br><span class="line">//根据key自从desMap中读取deps deps时一个set类型</span><br><span class="line">//里面储存着所有与当前key有相关的副作用函数:effects</span><br><span class="line">let deps = desMap.get(key);</span><br><span class="line">if(!deps) {</span><br><span class="line">desMap.set(key, (deps = new Set()));</span><br><span class="line">}</span><br><span class="line">deps.add(activeEffect);//将激活的副作用函数存储到桶里</span><br><span class="line">return target[key];//返回属性值</span><br><span class="line">};</span><br><span class="line">//拦截设置操作</span><br><span class="line">set(target, key, newVal) {</span><br><span class="line">//设置属性值</span><br><span class="line">target[key] = newVal;</span><br><span class="line">//根据target从decket中取出desMap</span><br><span class="line">let desMap = ducket.get(target);</span><br><span class="line">if(!desMap) return;</span><br><span class="line">//根据key取得所有的副作用函数并依次执行</span><br><span class="line">let deps = desMap.get(key);</span><br><span class="line">deps &amp;&amp; deps.forEach( fn =&gt; fn());//判空再执行</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><img src="https://i.bmp.ovh/imgs/2022/04/01/5648b7ab427b5fd9.jpg" style="zoom: 50%;"></li><li><p><strong>为什么使用 WeakMap 不使用 Map</strong></p><ul><li>weakMap 是弱引用 不会影响垃圾回收</li><li>只有当 key 所引用的对象存在时（没有被回收时）才有价值的信息都优先使用 weakMap 来存储</li></ul></li><li><p>**存在问题：代码耦合度高 **</p></li><li><p><strong>解决方法： 抽离封装</strong></p></li><li><pre><code>function track(target, key) {  let depsMap = bucket.get(target)  if (!depsMap) {    bucket.set(target, (depsMap = new Map()))  }  let deps = depsMap.get(key)  if (!deps) {    depsMap.set(key, (deps = new Set()))  }  deps.add(activeEffect)}function trigger(target, key) {  const depsMap = bucket.get(target)  if (!depsMap) return  const effects = depsMap.get(key)  effects &amp;&amp; effects.forEach(fn =&gt; fn())}// 对原始数据的代理const obj = new Proxy(data, {  // 拦截读取操作  get(target, key) {    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中    track(target, key)    // 返回属性值    return target[key]  },  // 拦截设置操作  set(target, key, newVal) {    // 设置属性值    target[key] = newVal    // 把副作用函数从桶里取出并执行    trigger(target, key)  }})<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 4.4 切换分支与 cleanup</span><br><span class="line"></span><br><span class="line">分支切换可能会产生遗留的副作用函数</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>effect(function effectFn() {    document.body.innerText = obj.ok? obj.text : 'not'})//此时依赖函数被obj.ok和obj.text同时依赖 当obj.ok为false时 无论obj.text怎么变化 都是'not' 所以不应该触发副作用函数//解决方法：每次副作用函数执行时 都把它从所有与之关联的依赖集合中删除//当副作用执行完毕后 会建立联系 但再新的联系中不会包含遗留的副作用函数<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**副作用依赖函数集合**</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>//用一个全局变量储存被注册的副作用函数let activeEffect;function effect(fn) {//当effectFn被执行时 将其设置为当前的激活的副作用函数    const effectFn = () =&gt; {        activeEffect = effectFn;        fn();    }    //effectEffect.deps 用来储存所有与该副作用函数想关联的依赖集合    effectEn.dep = [];    //执行副作用函数    effectFn();}<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **Track 函数**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  function track(target, key) {</span><br><span class="line">  if(!activeEffect) return;</span><br><span class="line">  let depsMap = bucket.get(key);</span><br><span class="line">  if(!depsMap) {</span><br><span class="line">  bucket.set(target, (desMap =&gt; new Map()));</span><br><span class="line">  }</span><br><span class="line">  let deps = depsMap.get(key);</span><br><span class="line">  if(!deps) {</span><br><span class="line">  depsMap.set(key, ( deps =&gt; new Set()))</span><br><span class="line">  };</span><br><span class="line">  //把当前激活的副作用函数添加到依赖集合deps中</span><br><span class="line">  deps.add(activeEffect);</span><br><span class="line">  //deps就是一个与当前副作用函数存在联系的集合</span><br><span class="line">  //将其添加到activeEffects.deps中</span><br><span class="line">  activeEffect.deps.push(deps);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>- 有了这个联系后 再每次执行副作用函数时 根据 effectFn.deps 获取所有的相关联的依赖集合 从而将副作用函数从依赖集合中清除- ```  let activeEffect;  function effect(fn) {      const effectFn = () =&gt; {          //调用cleanUp函数完成清除依赖          cleanup(effectFn);          activeEffect = effectFn;          fn();      }  }  function cleanup(effectFn) {  //遍历effectFn.deps数组    for (let i = 0; i &lt; effectFn.deps.length; i++) {    //deps时依赖集合      const deps = effectFn.deps[i]      //将effectFn从依赖集合中删除      deps.delete(effectFn)    }    //重置effectFn.deps数组    effectFn.deps.length = 0  }  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    -</span><br><span class="line"></span><br><span class="line"># 非原始值的响应式方案</span><br><span class="line"></span><br><span class="line">## 5.1Proxy 以及 Reflect</span><br><span class="line"></span><br><span class="line">**proxy 只能代理对象 不能代理其他类型的数据**</span><br><span class="line"></span><br><span class="line">### 5.1.2 Reflect</span><br><span class="line"></span><br><span class="line">Reflect 可以接受第三个参数 即 receiver 相当于函数调用过程中的 this</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>const obj = {foo: 1};Reflect.get(obj, foo, {foo: 2});//输出2</code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学vue</title>
      <link href="/2022/04/09/chong-xue-vue/"/>
      <url>/2022/04/09/chong-xue-vue/</url>
      
        <content type="html"><![CDATA[<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p><code>app</code>暴露了一些可以全局使用的属性</p><p><code>app.config.errorHandler</code>可以捕获子组件中未被捕获的异常（这在前端异常监控中很有用 就像原生的 <code>window.addEventListener('error', callback, true) | window.addEventListener('unhandledRejection', callback)</code>）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config.errorHandler = (err) =&gt; { //处理错误 }</span><br></pre></td></tr></tbody></table></figure><p><code>app.config.globalProperties</code>可以显式配置一些全局可用的属性（比如附加在<code>window</code>上的自定义属性啥的 模板内的表达式不能访问没有显式声明的全局属性）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config.globalProperties.window.ownPro = 'own'</span><br></pre></td></tr></tbody></table></figure><p><code>app.component</code>可以注册一些全局可用的资源 比如使用其注册一个全局可用的组件 <strong>可以链接调用</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.component('globalComponent', globalComponent)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>所有这些配置都要在应用挂载前配置好（before <code>app.mount</code>）</p></blockquote><h4 id="多个应用实例"><a href="#多个应用实例" class="headerlink" title="多个应用实例"></a>多个应用实例</h4><p>可以使用 多个<code>createVue</code>创建多个 vue 实例 这在我们只想要用 vue 去实现应用的部分功能时很有用比如说使用 vue 来增强服务端渲染<code>SSR</code> （我们可以将多个实例分别挂载在对应的部分上 而不是全部挂载在同一个实例上）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const app1 = createVue(...); app1.mount('route1') const app2 = createVue(...);</span><br><span class="line">app2.mount('route2')</span><br></pre></td></tr></tbody></table></figure><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><blockquote><p>如果使用 jsx 在编译阶段不会像 <code>template</code>一样被底层优化（vue 在编译阶段会将 <code>template</code>模板转换为 ast 在将 ast 转换为对应的<code>render</code>渲染函数）</p></blockquote><p><strong>v-html</strong>可以将渲染<code>html</code>内容而不是转换为字符串(不能使用 <code>v-html</code>来拼接组合模板 因为 vue 不是依靠字符串来解析模板的)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-html="&lt;h1&gt;this is html&lt;/h1&gt;"&gt;&lt;/span&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>v-html</code>具有很大的安全隐患 容易造成<code>xss</code>攻击 应该在确保绝对安全的情况下再使用</p></blockquote><p><strong>动态绑定多个值</strong></p><p>可以通过 <code>v-bind</code>不带参数来动态绑定多个值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const data = { name: 'james', age: 23 }</span><br><span class="line">&lt;Person v-bind="data"&gt;&lt;/Person&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>绑定的表达式中的方法会在组件每次更新时被调用 所以这个方法不应该有副作用（比如改变数据或者触发一异步操作）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Compo :func="funcWithoutEffect(agrs)"&gt;&lt;/Compo&gt;</span><br></pre></td></tr></tbody></table></figure></blockquote><p><strong>动态参数</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const propName = 'href'</span><br><span class="line">&lt;div :[proName]="href"&gt;</span><br><span class="line">    //等价于 :href = 'href'</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p>动态参数的值只能是字符串或者 <code>null</code> （<code>null</code>表示移除这个<code>attribute</code>）</p><blockquote><p>建议使用计算属性来返回动态参数</p></blockquote><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><blockquote><p>当响应式状态（<code>reactive state</code>）被更新时 <code>DOM</code>并不会立马做更新操作 而是会缓存起来 等到下一次更新时一起更新（比如期间改变一百次 最后只会执行一次更新操作）如果想在<code>state</code>改变后立马用改变后的值进行某些操作 可以使用 <code>nextTick()</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { reactive, nextTick } from "vue";</span><br><span class="line">const data = reactive({ name: "james" });</span><br><span class="line">const change = () =&gt; {</span><br><span class="line">  data.name = "curry";</span><br><span class="line">  nextTick(() =&gt; {});</span><br><span class="line">};</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></blockquote><p>响应式默认是深度响应（如果想要创建只有根部具有响应性的浅度响应对象 可以使用 <code>shalldowReactive</code>）</p><p><strong>响应式代理</strong></p><p>响应式代理的本质是返回该对象的<code>proxy</code>（vue2 使用<code>definePropertype</code> vue3 使用<code>proxy</code>）这意味着如果对一个对象使用<code>reactive()</code> 则返回其本身的代理 对该对象进行任何改变都没有响应式 对代理对象才有 对一个已经被<code>reactive（）</code>的对象再次进行 <code>reactive()</code> 返回该对象本身</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同一个对象使用reactive会返回相同对象</span></span><br><span class="line"><span class="title function_">reactive</span>(raw) === proxy; <span class="comment">//true</span></span><br><span class="line"><span class="comment">//对proxy进行reactive返回本身</span></span><br><span class="line"><span class="title function_">reactive</span>(proxy) === proxy; <span class="comment">//true</span></span><br><span class="line"><span class="comment">//对深层次的对象属性进行reactive依然会是poxy</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>({});</span><br><span class="line"><span class="keyword">const</span> raw = {};</span><br><span class="line">proxy.<span class="property">raw</span> = raw;</span><br><span class="line">paoxy.<span class="property">raw</span> === raw; <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>我们必须保持对响应性对象的相同引用才能够保持其响应性（这就是为啥解构会使其失去响应性）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>({</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"james"</span>,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> { name } = data; <span class="comment">//失去了响应性</span></span><br></pre></td></tr></tbody></table></figure><p>可以使用 <code>toRefs（）</code>来使其保持响应性</p></blockquote><p><code>ref()</code>可以在被传递/解构时保持响应性 这使得他经常用于组合函数中（提高代码逻辑的复用性）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">"james"</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params">name</span>) =&gt; {</span><br><span class="line">  name.<span class="property">value</span> = <span class="string">"curry"</span>;</span><br><span class="line">};</span><br><span class="line"><span class="title function_">change</span>(name); <span class="comment">//name = curry 如果传递一个普通字符串 则做不到</span></span><br><span class="line"><span class="comment">//写一个返回坐标的组合函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useLocation</span> = (<span class="params"></span>) =&gt; {</span><br><span class="line">  <span class="keyword">const</span> x = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> y = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="title function_">computedLocation</span>(x, y);</span><br><span class="line">  });</span><br><span class="line">  <span class="keyword">return</span> { x, y };</span><br><span class="line">};</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">const</span> { x, y } = <span class="title function_">useLocation</span>();</span><br></pre></td></tr></tbody></table></figure><p>当一个<code>ref</code>被当成对象的属性时 会被自动解包</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> conunt = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>({</span><br><span class="line">  count,</span><br><span class="line">});</span><br><span class="line">data.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(conunt.<span class="property">value</span>); <span class="comment">//1</span></span><br></pre></td></tr></tbody></table></figure><p>将一个新的 ref 赋值给对象的属性 则旧的 ref 会被替换</p><p>当 ref 作为数组或者 map 的元素时 不会自动解包(<code>map.get(key).value</code>)</p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>vue 的计算属性会自动追踪响应式依赖（计算属性会基于其以来进行缓存 直到依赖发生改变时再重新计算）</p><blockquote><ul><li><code>computed</code>的<code>getter</code>不应该有副作用的操作（异步请求数据或者改变 dom）</li><li>永远不要去改变 computed 返回的值 把它当成一个可读不可写的数据 如果需要更改该数据 应该去改变其依赖的响应式数据</li></ul></blockquote><h3 id="类与-style-绑定"><a href="#类与-style-绑定" class="headerlink" title="类与 style 绑定"></a>类与 style 绑定</h3><p>可以给类绑定一个计算属性 这很有用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isActive = <span class="title function_">ref</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> classObject = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> ({</span><br><span class="line">    <span class="attr">active</span>: isActive.<span class="property">value</span> &amp;&amp; !error.<span class="property">value</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: error.<span class="property">value</span> &amp;&amp; error.<span class="property">value</span>.<span class="property">type</span> === <span class="string">'fatal'</span></span><br><span class="line">}))</span><br><span class="line"></span><br><span class="line">&lt;div :<span class="keyword">class</span>=<span class="string">"classObject"</span>&gt; &lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>在组件上使用</strong></p><p>对于只有一个根元素的组件 当你是用了 <code>class</code>时 这些<code>class</code>会被添加到根元素上 并且与该元素上已有的<code>class</code>合并</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//MyComponent.vue</span><br><span class="line">&lt;p class="child"&gt;</span><br><span class="line">    Child</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">//parent</span><br><span class="line">&lt;MyComponent class="parent"&gt;  //子组件将被渲染成 class="parent child"</span><br><span class="line">&lt;/MyComponent&gt;</span><br><span class="line">//如果组件有多个根元素 那么需要指定接收的子组件根元素 使用$attrs接收</span><br><span class="line">&lt;MyComponent class="baz"&gt;&lt;/MyComponent&gt;</span><br><span class="line">&lt;!-- MyComponent 模板使用 $attrs 时 --&gt;</span><br><span class="line">&lt;p :class="$attrs.class"&gt;Hi!&lt;/p&gt;</span><br><span class="line">&lt;span&gt;This is a child component&lt;/span&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>自动前缀</strong></p><p>当在 <code>:style</code>中是用了需要浏览器前缀的 CSS 属性时 <code>vue</code>绘自动加上对应的前缀（<code>polyfill</code>）</p><p>如果给一个样式属性提供多个不同的前缀值 则只会渲染浏览器支持的最后一个值（在支持不需要特别前缀的浏览器中都会渲染为 <code>display：flex</code>）</p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p><code>v-if</code>和 <code>v-show</code></p><ul><li><code>v-if</code>在切换时 组件会进行重新创建和销毁</li><li><code>v-if</code>是惰性的 初次渲染是<code>false</code>时不会做任何事 等到被改为<code>true</code>才会被渲染 <code>v-show</code>则无论初始条件是啥都会被渲染 只有 <code>display</code>属性会被切换</li><li>如果需要频繁切换 则使用 <code>v-show</code> 否则使用 <code>v-if</code></li></ul><blockquote><p><code>v-if</code>优先级高于 <code>v-for</code></p><p>可以在外层新包装一层 <code>&lt;template&gt;</code>再在上面使用 <code>v-for</code>来解决这个问题</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-for="todo in todos" :key="todo.id"&gt;</span><br><span class="line">  &lt;li v-if="!todo.isComplete"&gt;</span><br><span class="line">    {{ todo.name }}</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure></blockquote><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>vue 可以监听响应式数组的变更方法并在这些方法被调用的时候更新示图</p><p><code>push | pop | shift | unshift | splice | sort | reverse</code></p><p>当你需要展示过滤/排序后的结果时又不想改变原始数据时 可以创建返回已经处理好的数组的计算属性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const numbers = ref([1, 2, 3, 4, 5]) const evenNumbers = computed(() =&gt; { return</span><br><span class="line">numbers.value.filter((n) =&gt; n % 2 === 0) })</span><br><span class="line">&lt;li v-for="n in evenNumbers"&gt;{{ n }}&lt;/li&gt;</span><br><span class="line">//当计算属性不行时 可以使用嵌套的v-for来解决 const sets = ref([ [1, 2, 3, 4, 5],</span><br><span class="line">[6, 7, 8, 9, 10] ]) function even(numbers) { return numbers.filter((number) =&gt;</span><br><span class="line">number % 2 === 0) }</span><br><span class="line">&lt;ul v-for="numbers in sets"&gt;</span><br><span class="line">  &lt;li v-for="n in even(numbers)"&gt;{{ n }}&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在计算属性中使用会改变原数组的方法（比如 <code>reverse | sort</code>）时 应该创建一个副本进行操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">return</span> numbers.<span class="title function_">reverse</span>()</span><br><span class="line">+ <span class="keyword">return</span> [...numbers].<span class="title function_">reverse</span>()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></blockquote><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p><strong>在内联事件处理器中访问事件参数</strong></p><p>应该传入 <code>$event</code>或者使用内联箭头函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用特殊的 $event 变量 --&gt;</span><br><span class="line">&lt;button @click="warn('Form cannot be submitted yet.', $event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用内联箭头函数 --&gt;</span><br><span class="line">&lt;button @click="(event) =&gt; warn('Form cannot be submitted yet.', event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">const warn = (message, event) =&gt; { //.... }</span><br></pre></td></tr></tbody></table></figure><p><strong>事件修饰符</strong></p><p><code>.(stop | prevent | self | capture | once | passive)</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 单击事件将停止传递 --&gt;</span><br><span class="line">&lt;a @click.stop="doThis"&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件将不再重新加载页面 --&gt;</span><br><span class="line">&lt;form @submit.prevent="onSubmit"&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰语可以使用链式书写 --&gt;</span><br><span class="line">&lt;a @click.stop.prevent="doThat"&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 也可以只有修饰符 --&gt;</span><br><span class="line">&lt;form @submit.prevent&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;</span><br><span class="line">&lt;!-- 例如：事件处理器不来自子元素 --&gt;</span><br><span class="line">&lt;div @click.self="doThat"&gt;...&lt;/div&gt;</span><br><span class="line">&lt;!-- 添加事件监听器时，使用 `capture` 捕获模式 --&gt;</span><br><span class="line">&lt;!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 --&gt;</span><br><span class="line">&lt;div @click.capture="doThis"&gt;...&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件最多被触发一次 --&gt;</span><br><span class="line">&lt;a @click.once="doThis"&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 --&gt;</span><br><span class="line">&lt;!-- 以防其中包含 `event.preventDefault()` --&gt;</span><br><span class="line">&lt;div @scroll.passive="onScroll"&gt;...&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>.passive</code>一般用于触摸事件的监听器 可以用来改善移动端的滚屏性能</p><p>不要同时使用 <code>.passive</code>和 <code>.prevent</code> 因为 <code>.passive</code>表示不阻止事件的默认行为 而 <code>.prevent</code>表示阻止事件的默认行为</p><p><code>.exact</code>允许控制触发一个事件所需的确定组合的系统按键修饰符</p></blockquote><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><p><strong>修饰符</strong></p><p>默认情况下 <code>v-model</code>会在每次 <code>input</code>事件后更新数据 可以添加 <code>.lazy</code>修饰符改为每次 <code>change</code>事件后更新数据</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>watch</code>的第一个参数可以是 <code>ref(包括计算属性)、响应式对象、getter、多个数组源的数组</code></p><blockquote><p>不可以直接监听响应式对象的属性值 应该监听其<code>getter</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>({</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">});</span><br><span class="line"><span class="comment">//不要直接监听属性</span></span><br><span class="line"><span class="title function_">watch</span>(obj.<span class="property">count</span>, <span class="function">(<span class="params">count</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">});</span><br><span class="line"><span class="comment">//应该直接监听getter</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> obj.<span class="property">count</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure></blockquote><p><code>watch</code>监听响应式对象时会隐式创建一个深层监听器 如果监听的是<code>getter</code> 则只有在返回不同的对象时才会触发回调（可以使用 <code>{deep: true}</code>强制深层监听）</p><p><strong>watchEffect()</strong></p><p><code>watchEffect</code>会立即执行一遍回调函数 如果这时函数产生了副作用 则 Vue 会自动追踪副作用的依赖关系并自动分析出响应源（<code>watch</code>是惰性的 只有在依赖源发生改变时才会触发）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如我们需要立即获取数据后并更具url改变来重新获取数据</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="title function_">ref</span>(<span class="string">"https://..."</span>);</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url.<span class="property">value</span>);</span><br><span class="line">  data.<span class="property">value</span> = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即获取</span></span><br><span class="line"><span class="title function_">fetchData</span>();</span><br><span class="line"><span class="comment">// ...再侦听 url 变化</span></span><br><span class="line"><span class="title function_">watch</span>(url, fetchData);</span><br><span class="line"><span class="comment">//可以直接使用watchEffect</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">async</span> () =&gt; {</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url.<span class="property">value</span>);</span><br><span class="line">  data.<span class="property">value</span> = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">});</span><br><span class="line"><span class="comment">//回调会立即执行并且自动最终到url.value为依赖</span></span><br></pre></td></tr></tbody></table></figure><p><code>watchEffect</code>尽在同步执行期间才追踪依赖 在异步回调时 只有在第一个<code>await</code>正常工作前访问到的属性才会被追踪</p><p><code>watch</code> <strong>vs</strong> <code>watchEffect</code></p><ul><li><code>watch</code>值追踪明确侦听的数据源 <code>watch</code>避免在发生副作用期间追踪依赖 可以更加精确地控制回调函数的触发时机</li><li><code>watchEffect</code>会在副作用发生期间追踪依赖 会在同步执行过程中自动追踪到所有能访问到的响应式依赖 但是依赖关系不明确</li></ul><p><strong>执行时机</strong></p><p>监听器的回调执行会在<code>vue</code>更新之前被调用 所以意味着我们在回到中访问到的<code>DOM</code>是<code>vue</code>更新之前的状态</p><p>如果想要在访问更新之后的 DOM 可以指明 <code>flush: 'post'</code> 或者使用 <code>watchPostEffect</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(source, callback, {</span><br><span class="line">  <span class="attr">flush</span>: <span class="string">"post"</span>,</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(callback, {</span><br><span class="line">  <span class="attr">flush</span>: <span class="string">"post"</span>,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">import</span> { watchPostEffect } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchPostEffect</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="comment">/* 在 Vue 更新后执行 */</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p><strong>销毁监听器</strong></p><p>正常通过同步语句创建的监听器会在宿主组件卸载时自动停止</p><p>如果是通过异步的方式创建（比如在 <code>setTimeout</code>中创建） 就必须手动停止防止内存泄漏</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = <span class="title function_">watch</span>(source, callback);</span><br><span class="line"><span class="comment">//停止监听器</span></span><br><span class="line"><span class="title function_">unwatch</span>();</span><br><span class="line"><span class="comment">//一般不要异步创建监听器 如果需要等待一些异步数据 可以使用条件式监听器</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="keyword">if</span> (data.<span class="property">value</span>) {</span><br><span class="line">    <span class="comment">//数据加载后执行某些操作</span></span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h3 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h3><p>需要创建一个同名的<code>ref</code>来进行引用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> { ref, onMounted } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 ref 来存放该元素的引用</span></span><br><span class="line"><span class="comment">// 必须和模板里的 ref 同名</span></span><br><span class="line"><span class="keyword">const</span> input = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  input.<span class="property">value</span>.<span class="title function_">focus</span>()</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"input"</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>只有在组件挂载后才可以访问模板引用 这意味着如果想要侦听一个模板引用<code>ref</code>的变化 需要考虑<code>null</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="keyword">if</span> (input.<span class="property">value</span>) {</span><br><span class="line">    input.<span class="property">value</span>.<span class="title function_">focus</span>();</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 此时还未挂载，或此元素已经被卸载（例如通过 v-if 控制）</span></span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p><strong>v-for 中的模板引用</strong></p><p>在<code>v-for</code>中使用模板引用时 对应的<code>ref</code>是一个数组 将在元素被挂载后包含对应整个列表中的所有元素</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> { ref, onMounted } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list = <span class="title function_">ref</span>([</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> itemRefs = <span class="title function_">ref</span>([])</span><br><span class="line"></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(itemRefs.<span class="property">value</span>))</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span> <span class="attr">ref</span>=<span class="string">"itemRefs"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      {{ item }}</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="深入组件"><a href="#深入组件" class="headerlink" title="深入组件"></a>深入组件</h2><p>可以使用 <code>app.component</code>全局注册组件 （可以链式调用）</p><p><strong>全局注册的缺点</strong></p><ul><li>没有被使用到的组件无法在打包时被 <code>three-shaking</code></li><li>依赖关系不明确 不利于维护</li></ul><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>需要使用 <code>defineProps</code>显式声明接收的<code>props</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">defineProps&lt;{</span><br><span class="line">  title?: <span class="built_in">string</span>;</span><br><span class="line">  likes?: <span class="built_in">number</span>;</span><br><span class="line">}&gt;();</span><br></pre></td></tr></tbody></table></figure><p>可以使用没有参数的 <code>v-bind</code>一次性传递所有的<code>props</code></p><p><code>v-bind="post" === :id="post.id" :title="post.title"</code></p><p>如果需要对传入的<code>prop</code>值做进一步的转换 建议使用计算属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">"size"</span>]);</span><br><span class="line"><span class="keyword">const</span> normalizeSize = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> porps.<span class="property">size</span>.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>());</span><br></pre></td></tr></tbody></table></figure><p>除了<code>props</code>的类型时<code>Boolean</code>（默认是<code>false</code>） 其他都是 <code>undefined</code></p><h3 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h3><p><strong>触发和监听事件</strong></p><p>可以通过在子组件使用 <code>$emit</code>定义一个事件并在父组件通过 <code>v-on | @</code>来触发</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click="$emit('someEvent')"&gt;</span><br><span class="line">    click me</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">//parent</span><br><span class="line">&lt;MyComponent @some-event.once="callback" /&gt;</span><br><span class="line">//所有传入 $emit()的额外参数都会被直接传向监听器 $emit('foo', 1, 2,</span><br><span class="line">3)触发后监听函数会接收到三个参数值</span><br></pre></td></tr></tbody></table></figure><blockquote><p>组件触发的事件没有 <strong>冒泡机制</strong> 所以你只能监听直接子组件 而不能监听后代组件或者兄弟组件 如果需要监听其他类型的组件 可以考虑使用 <code>eventBus</code></p></blockquote><p><strong>声明要触发的事件</strong></p><p>可以通过 <code>defineEmits</code>显式声明要触发的事件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const emits = defineEmits(['infocus']);</span><br><span class="line">function handleClick = () =&gt; {</span><br><span class="line">emits('infocus')</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>事件校验</strong></p><p>通过返回一个布尔值来表明事件是否合法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>({</span><br><span class="line">  <span class="comment">// 没有校验</span></span><br><span class="line">  <span class="attr">click</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 校验 submit 事件</span></span><br><span class="line">  <span class="attr">submit</span>: <span class="function">(<span class="params">{ email, password }</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span> (email &amp;&amp; password) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">'Invalid submit event payload!'</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">submitForm</span>(<span class="params">email, password</span>) {</span><br><span class="line">  <span class="title function_">emit</span>(<span class="string">'submit'</span>, { email, password })</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果一个原生事件的名字（比如<code>click</code>）被定义在<code>emits</code>选项中 那么监听器只会监听组件触发的事件而不会响应原生的事件</p></blockquote><p><strong>配合 v-model 使用</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model="data" /&gt;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;input :value="data" @input="data = $event.target.value" /&gt;</span><br><span class="line">//编写组件</span><br><span class="line">&lt;Comp v-model="modalValue" /&gt;</span><br><span class="line">//等价于</span><br><span class="line">&lt;Comp :modelValue="data" @update:modelValue="(newValue) =&gt; (data = newValue)" /&gt;</span><br><span class="line">//Comp.vue</span><br><span class="line">&lt;!-- CustomInput.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps(["modelValue"]);</span><br><span class="line">defineEmits(["update:modelValue"]);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    :value="modelValue"</span><br><span class="line">    @input="$emit('update:modelValue', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">//同时可以使用在get的时候返回modelValue并在set的时候触发相应的事件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import {computed} from vue</span><br><span class="line">const props = defineProps(['modelValue'])</span><br><span class="line">const emit = defineEmits(['update:modelValue'])</span><br><span class="line">const value = computed({</span><br><span class="line">    get() {</span><br><span class="line">        return props.modelValue</span><br><span class="line">    }</span><br><span class="line">    set(value) {</span><br><span class="line">    emit('update:modelValue', value)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//使用多个v-model</span><br><span class="line">&lt;UserName v-model:first-name="first" v-model:last-name="last" /&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps({</span><br><span class="line">  firstName: String,</span><br><span class="line">  lastName: String,</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">defineEmits(["update:firstName", "update:lastName"]);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type="text"</span><br><span class="line">    :value="firstName"</span><br><span class="line">    @input="$emit('update:firstName', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type="text"</span><br><span class="line">    :value="lastName"</span><br><span class="line">    @input="$emit('update:lastName', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>参数修饰符</strong></p><p>对于又有参数又有修饰符的<code>v-model</code> 生成的<code>prop</code>是 <code>arg + Modifiers</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model.capitalize="myText" /&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps({</span><br><span class="line">  modelValue: String,</span><br><span class="line">  modelModifiers: { default: () =&gt; ({}) },</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">const emit = defineEmits(["update:modelValue"]);</span><br><span class="line"></span><br><span class="line">function emitValue(e) {</span><br><span class="line">  let value = e.target.value;</span><br><span class="line">  if (props.modelModifiers.capitalize) {</span><br><span class="line">    value = value.charAt(0).toUpperCase() + value.slice(1);</span><br><span class="line">  }</span><br><span class="line">  emit("update:modelValue", value);</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type="text" :value="modelValue" @input="emitValue" /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="透传-Attributes"><a href="#透传-Attributes" class="headerlink" title="透传 Attributes"></a>透传 Attributes</h3><p>传递给一个组件 却没有被该组件声明为<code>props</code>或者<code>emits</code>的<code>attribute</code>或者 <code>v-on</code>事件监听器 将被自动添加到子元素的根元素上</p><p><strong>v-on 监听器继承</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton @click="onClick" /&gt;</span><br><span class="line">&lt;button @click="childClick" /&gt;</span><br><span class="line">//点击button将会同时触发两个click</span><br><span class="line">//如果原生的button元素自身也通过v-on绑定了一个事件监听器 那么这个监听器和从父组件继承的监听器都会被触发</span><br></pre></td></tr></tbody></table></figure><p><strong>深层组件继承</strong></p><p>如果被<code>defineProps | defineEmits</code>声明过 则认为已经被该组件消费 否则将继续向下透传</p><p><strong>禁用 Attributes 继承</strong></p><p>如果不想要自动继承<code>attributes</code> 可以额外声明一个 <code>script</code>来声明 <code>inheritAttrs: false</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 使用普通的 &lt;script&gt; 来声明选项</span><br><span class="line">export default {</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">};</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// ...setup 部分逻辑</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果 attribute 需要应用在根节点以外的其他元素上 通过设置 <code>inheriAttrs: false</code> 并且通过 <code>$attrs</code>即可访问到除了被声明的<code>props</code>和<code>emits</code>之外的所有其他<code>attributes</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//例如 想要父元素的所有属性都作为attribute应用到目标上 可以使用没有参数的v-bind</span><br><span class="line">//Child.vue</span><br><span class="line">&lt;div class="btn-wrapper"&gt;</span><br><span class="line">  &lt;button class="btn" v-bind="$attrs"&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">//partent.vue</span><br><span class="line">&lt;Child .... /&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>多个根节点的透传</strong></p><p>如果是多个根节点 则不会发生自动透传 需要显式指定 <code>$attrs</code> 否则会报错</p><p>可以使用 <code>useAttrs()</code>来访问一个组件的所有透传 <code>attribute</code></p><h3 id="Solts"><a href="#Solts" class="headerlink" title="Solts"></a>Solts</h3><p><strong>渲染作用域</strong></p><p>由于插槽是在父组件定义的 所以插槽能访问父组件的数据 但是无法访问子组件的数据</p><p><strong>默认值</strong></p><p>使用 <code>&lt;slot&gt;defaultData&lt;slot&gt;</code>给插槽提供默认值并在有填充值时被取代</p><p><strong>具名插槽</strong></p><p>当子组件有多个插槽位置时 就需要 指定对应的插槽名（默认为<code>default</code>）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">BaseLayout</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span> ||<span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- header 插槽的内容放这里 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">BaseLayout</span>&gt;</span></span></span><br><span class="line"><span class="comment">//插槽名也可以使用动态指令参数</span></span><br><span class="line">v-<span class="attr">slot</span>: [dynamicSlotName] || #[dynamicSlotName]</span><br></pre></td></tr></tbody></table></figure><p><strong>作用域插槽</strong></p><p>如果想要同时访问子组件和父组件的数据 则需要使用作用域插槽将子组件的对应数据暴露出去 然后父组件使用 <code>slotProps</code>接收</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;slot class="class"&gt;</span><br><span class="line"></span><br><span class="line">&lt;/slot&gt;</span><br><span class="line">&lt;Comp&gt;</span><br><span class="line">&lt;template v-slot="slotProps"&gt; </span><br><span class="line">{{slotProps.class}}</span><br><span class="line"> &lt;/template&gt;</span><br><span class="line">&lt;/Comp&gt;</span><br></pre></td></tr></tbody></table></figure><p>同样也可以使用 <strong>具名作用域插槽</strong> <code>v-slot:name = "slotProps"</code></p><p>如果混用了具名插槽和默认插槽 则需要为默认插槽使用显式的 <code>&lt;template&gt;</code>标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 该模板无法编译 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;MyComponent v-slot="{ message }"&gt;</span><br><span class="line">    &lt;p&gt;{{ message }}&lt;/p&gt;</span><br><span class="line">    &lt;template #footer&gt;</span><br><span class="line">      &lt;!-- message 属于默认插槽，此处不可用 --&gt;</span><br><span class="line">      &lt;p&gt;{{ message }}&lt;/p&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/MyComponent&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>为默认的插槽使用显式的 <code>&lt;template&gt;</code>标签可以更清晰地标注插槽数据的使用范围</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 使用显式的默认插槽 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">"{ message }"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{ message }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></blockquote><p><strong>用途</strong></p><p>可以用来做无渲染组件（只负责逻辑编写 然后将结果通过 prop 传出去 而样式以及数据的使用则交给父组件）</p><p>在需要同时服装逻辑 组合视图界面很有用（比如列表）</p><h3 id="依赖注入（provide-inject）"><a href="#依赖注入（provide-inject）" class="headerlink" title="依赖注入（provide | inject）"></a>依赖注入（provide | inject）</h3><p><strong>应用层 provide</strong></p><p>可以通过 <code>app.provide(key, value)</code>来提供全局可用的数据 这在编写插件时特别有用 因为插件一般不会使用组件形式来提供值</p><p><strong>inject</strong></p><p>如果<code>provide</code>的是一个<code>ref</code>则会传递整个<code>ref</code>而不是自动解包（这样可以保持响应性）</p><p>为了避免在用不到默认值的情况下进行不必要的计算或者产生副作用 可以使用工厂函数来创建默认值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">inject</span>(<span class="string">"key"</span>, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">ExpensiveClass</span>());</span><br></pre></td></tr></tbody></table></figure><p><strong>和响应式数据配合使用</strong></p><p>为了数据的管理 我们应该避免在<code>inject</code>组件内对<code>provide</code>的响应式数据进行更改 如果有需要 应该在<code>provide</code>组件定义改变数据的方法并<code>provide</code></p><p>对于一些不能在<code>inject</code>组件里更改的数据 可以使用<code>readonly</code>来保护 <code>provide('read-only-count', readonly(count))</code></p><p><strong>命名冲突</strong></p><p>为了避免命名冲突 可以用一个单独的文件管理<code>provide</code>的<code>key</code> 使用<code>Symbol()</code>修饰</p><p><code>export const myInjectionKey = Symbol()</code></p><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><h2 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h2><h3 id="组合式函数"><a href="#组合式函数" class="headerlink" title="组合式函数"></a>组合式函数</h3><p>可以将重复使用的逻辑封装复用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mouse.js</span></span><br><span class="line"><span class="keyword">import</span> {ref, onMounted, onUnmounted} <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">useMouse</span>(<span class="params"></span>) {</span><br><span class="line">     <span class="keyword">const</span> x = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> y = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">function</span> <span class="title function_">update</span>(<span class="params">event</span>) {</span><br><span class="line">    x.<span class="property">value</span> = event.<span class="property">pageX</span></span><br><span class="line">    y.<span class="property">value</span> = event.<span class="property">pageY</span></span><br><span class="line">  }</span><br><span class="line">     <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">'mousemove'</span>, update))</span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">'mousemove'</span>, update))</span><br><span class="line">    <span class="keyword">return</span> {x, y}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//use</span></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> { useMouse } <span class="keyword">from</span> <span class="string">'./mouse.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> { x, y } = <span class="title function_">useMouse</span>()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span>Mouse position is at: {{ x }}, {{ y }}<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="comment">//我们还能将绑定和解绑的操作服装起来</span></span><br><span class="line"><span class="comment">// event.js</span></span><br><span class="line"><span class="keyword">import</span> { onMounted, onUnmounted } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useEventListener</span>(<span class="params">target, event, callback</span>) {</span><br><span class="line">  <span class="comment">// 如果你想的话，</span></span><br><span class="line">  <span class="comment">// 也可以用字符串形式的 CSS 选择器来寻找目标 DOM 元素</span></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> target.<span class="title function_">addEventListener</span>(event, callback))</span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> target.<span class="title function_">removeEventListener</span>(event, callback))</span><br><span class="line">}</span><br><span class="line"><span class="comment">// mouse.js</span></span><br><span class="line"><span class="keyword">import</span> { ref } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> { useEventListener } <span class="keyword">from</span> <span class="string">'./event'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">const</span> x = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> y = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEventListener</span>(<span class="variable language_">window</span>, <span class="string">'mousemove'</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">    x.<span class="property">value</span> = event.<span class="property">pageX</span></span><br><span class="line">    y.<span class="property">value</span> = event.<span class="property">pageY</span></span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> { x, y }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>每一个调用 <code>useMouse()</code>的组件示例会创建独立的状态 不会互相影响</p></blockquote><p><strong>异步组件获取数据</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//useFetch</span></span><br><span class="line"><span class="keyword">import</span> { ref, isRef, unref, watchEffect } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useFetch</span>(<span class="params">url</span>) {</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doFetch</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// reset state before fetching..</span></span><br><span class="line">    data.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    error.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolve the url value synchronously so it's tracked as a</span></span><br><span class="line">    <span class="comment">// dependency by watchEffect()</span></span><br><span class="line">    <span class="keyword">const</span> urlValue = <span class="title function_">unref</span>(url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// artificial delay / random error</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">timeout</span>();</span><br><span class="line">      <span class="comment">// unref() will return the ref value if it's a ref</span></span><br><span class="line">      <span class="comment">// otherwise the value will be returned as-is</span></span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(urlValue);</span><br><span class="line">      data.<span class="property">value</span> = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">    } <span class="keyword">catch</span> (e) {</span><br><span class="line">      error.<span class="property">value</span> = e;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(url)) {</span><br><span class="line">    <span class="comment">//如果输入ref 则在每次url改变时就重新请求</span></span><br><span class="line">    <span class="comment">// setup reactive re-fetch if input URL is a ref</span></span><br><span class="line">    <span class="title function_">watchEffect</span>(doFetch);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// otherwise, just fetch once //如果不是ref 则只请求一次</span></span><br><span class="line">    <span class="title function_">doFetch</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> { data, error, <span class="attr">retry</span>: doFetch };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// artificial delay</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.3</span>) {</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Random Error"</span>));</span><br><span class="line">      }</span><br><span class="line">    }, <span class="number">300</span>);</span><br><span class="line">  });</span><br><span class="line">}</span><br><span class="line"><span class="comment">//use</span></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> {(ref, computed)} <span class="keyword">from</span> <span class="string">'vue'</span> <span class="keyword">import</span> {useFetch} <span class="keyword">from</span> <span class="string">'./useFetch.js'</span></span><br><span class="line">  <span class="keyword">const</span> baseUrl = <span class="string">'https://jsonplaceholder.typicode.com/todos/'</span> <span class="keyword">const</span> id =</span><br><span class="line">  <span class="title function_">ref</span>(<span class="string">'1'</span>) <span class="keyword">const</span> url = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> baseUrl + id.<span class="property">value</span>) <span class="keyword">const</span>{<span class="string">" "</span>}</span><br><span class="line">  {(data, error, retry)} = <span class="title function_">useFetch</span>(url)</span><br><span class="line">&lt;/script&gt;;</span><br></pre></td></tr></tbody></table></figure><p><strong>约定和最佳实践</strong></p><p><strong>输入参数</strong></p><p>如果你的参数是响应性并且可能被其他开发者使用 则应该使用 <code>unref</code>兼容<code>ref</code>而不是原始的值（<code>unref</code>会在是<code>ref</code>的时候返回.<code>.value</code> 在不是的时候返回原样 ）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { unref } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useFeature</span>(<span class="params">maybeRef</span>) {</span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">unref</span>(maybeRef);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果组合式函数在接收<code>ref</code>为参数式会产生响应式<code>effect</code> 去额宝使用<code>watch</code>显式监听此<code>effect</code>或者在<code>watchEffect</code>中用<code>unref</code>进行正确的追踪</p><p><strong>返回结果</strong></p><p>建议使用多个<code>ref</code>构成的非响应式对象 如果非要使用响应式对象 建议用<code>reactive</code>在外面包一层 <code>reactive(useMouse())</code></p><p><strong>副作用</strong></p><ul><li>如果用到了服务端渲染 确保在组件挂载后才调用的生命周期钩子中执行<code>DOM</code>相关的副作用</li><li>确保在 <code>onUnmounted()</code>时清理副作用</li></ul><p>组合式函数应该始终被同步调用</p><p><strong>和无渲染组件的相比</strong></p><p>组合式函数不会产生额外的组件实例开销 当在整个应用中使用时 由无渲染组件产生的额外组件实例会带来无法忽视的性能开销</p><blockquote><p>在纯逻辑复用时使用组合式函数 在需要同时复用逻辑和视图布局时使用无渲染组件</p></blockquote><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>自定义组件主要是为了重用涉及普通元素的底层<code>DOM</code>访问的逻辑</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">    <span class="keyword">const</span> vFocus = {</span><br><span class="line">        <span class="attr">mounted</span>: <span class="function">(<span class="params">el</span>) =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">    }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>当所需功能只能通过直接的 DOM 操作来实现时 才使用自定义指令 其他情况应该尽可能使用 <code>v-bind</code> 这样更高效 也对服务端渲染更好</p></blockquote><p>不推荐在组件上使用自定义指令 因为指令默认会传递给组件的根节点上 且不能像<code>attribute</code>那样通过 <code>$attrs</code>来绑定</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件是一个拥有 <code>install()</code>方法的对象 或者直接是一个<code>install（）</code>函数本身</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPlugin = {</span><br><span class="line">  <span class="title function_">install</span>(<span class="params">app, options</span>) {},</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>插件的应用场景</strong></p><ul><li>通过 <code>app.component() &amp;&amp; app.directive()</code>注册一到多个全局组件或者自定义指令</li><li>通过 <code>app.provide()</code>使一注入全局资源</li><li>向 <code>app.config.globalProperties</code>中添加一些全局实例属性或方法</li><li>一个可能上诉三种都包含的功能库（<code>vue-router</code>）</li></ul><p><strong>编写一个插件</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="attr">install</span>: <span class="function">(<span class="params">app, options</span>) =&gt;</span> {</span><br><span class="line">    app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$translate</span> = <span class="function">(<span class="params">key</span>) =&gt;</span> {</span><br><span class="line">      <span class="keyword">return</span> key.<span class="title function_">split</span>(<span class="string">"."</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">o, i</span>) =&gt;</span> {</span><br><span class="line">        <span class="keyword">if</span> (o) <span class="keyword">return</span> o[i];</span><br><span class="line">      }, options);</span><br><span class="line">    };</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"><span class="comment">//在app.use中注册</span></span><br><span class="line">app.<span class="title function_">use</span>(i18nPlugin, {</span><br><span class="line">  <span class="attr">greetings</span>: {</span><br><span class="line">    <span class="attr">hello</span>: <span class="string">"Bonjour!"</span>,</span><br><span class="line">  },</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>可以在插件中<code>provide</code> 这样在整个应用内部就都能使用了</p><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p><code>&lt;Transition&gt;</code>会在一个元素或组件进入和离开<code>DOM</code>时应用动画</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click="show = !show"&gt;Toggle&lt;/button&gt;</span><br><span class="line">&lt;Transition&gt;</span><br><span class="line">  &lt;p v-if="show"&gt;hello&lt;/p&gt;</span><br><span class="line">&lt;/Transition&gt;</span><br><span class="line">/* 下面我们会解释这些 class 是做什么的 */ .v-enter-active, .v-leave-active {</span><br><span class="line">transition: opacity 0.5s ease; } .v-enter-from, .v-leave-to { opacity: 0; }</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>&lt;Transition&gt;</code>仅支持单个元素或组件作为其插槽内容 如果内容是一个组件 这个组件必须仅有一个根元素</p></blockquote><p>当一个 <code>&lt;Transition&gt;</code>组件中的元素被插入或者移除时</p><ul><li>Vue 会自动检测目标元素是否用了 CSS 过渡或动画 如果是 则一些 CSS 过度<code>class</code>会在适当时机被添加和移除</li><li>如果没有探测到 CSS 过渡或动画、也没有提供 JavaScript 钩子，那么 DOM 的插入、删除操作将在浏览器的下一个动画帧后执行。</li></ul><p><strong>基于 CSS 的过度效果</strong></p><p><strong>CSS 过渡 class</strong></p><p><img src="https://pic.lxtlovely.top/XUXI/image-20221108215022626.png" alt="image-20221108215022626"></p><ol><li><code>v-enter-from</code>：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。</li><li><code>v-enter-active</code>：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。</li><li><code>v-enter-to</code>：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 <code>v-enter-from</code> 被移除的同时)，在过渡或动画完成之后移除。</li><li><code>v-leave-from</code>：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。</li><li><code>v-leave-active</code>：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。</li><li><code>v-leave-to</code>：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 <code>v-leave-from</code> 被移除的同时)，在过渡或动画完成之后移除。</li></ol><p><code>v-enter-active</code> 和 <code>v-leave-active</code> 给我们提供了为进入和离开动画指定不同速度曲线的能力</p><p><strong>为过渡效果命名</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;Transition name="fade"&gt;</span><br><span class="line">&lt;/Transition&gt;</span><br><span class="line">.fade-enter-active,</span><br><span class="line">.fade-leave-active {</span><br><span class="line">  transition: opacity 0.5s ease;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.fade-enter-from,</span><br><span class="line">.fade-leave-to {</span><br><span class="line">  opacity: 0;</span><br><span class="line">}</span><br><span class="line">//&lt;Transition&gt;一般会搭配原生 CSS过渡一起使用</span><br><span class="line">    /*</span><br><span class="line">  进入和离开动画可以使用不同</span><br><span class="line">  持续时间和速度曲线。</span><br><span class="line">*/</span><br><span class="line">.slide-fade-enter-active {</span><br><span class="line">  transition: all 0.3s ease-out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.slide-fade-leave-active {</span><br><span class="line">  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.slide-fade-enter-from,</span><br><span class="line">.slide-fade-leave-to {</span><br><span class="line">  transform: translateX(20px);</span><br><span class="line">  opacity: 0;</span><br><span class="line">}</span><br><span class="line">//*-enter-from 不是在元素插入后立即移除 而是在一个animationend事件触发时被移除</span><br><span class="line">    .bounce-enter-active {</span><br><span class="line">  animation: bounce-in 0.5s;</span><br><span class="line">}</span><br><span class="line">.bounce-leave-active {</span><br><span class="line">  animation: bounce-in 0.5s reverse;</span><br><span class="line">}</span><br><span class="line">@keyframes bounce-in {</span><br><span class="line">  0% {</span><br><span class="line">    transform: scale(0);</span><br><span class="line">  }</span><br><span class="line">  50% {</span><br><span class="line">    transform: scale(1.25);</span><br><span class="line">  }</span><br><span class="line">  100% {</span><br><span class="line">    transform: scale(1);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>性能考量</strong></p><p>动画所用的一般都是 <code>transfrom</code>和 <code>opacity</code>这些属性来制作动画 这些性能比较好</p><ul><li>他们在动画过程中不会影响到 DOM 结构 因此不会每一帧都触发昂贵的 CSS 布局重新计算</li><li>大多数的现代浏览器都可以在 <code>transfrom</code>动画时利用 GPU 进行硬件加速</li></ul><blockquote><p><a href="https://csstriggers.com/">CSS-Triggers</a> 可以查询哪些属性会在执行动画时触发 css 布局变动</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
