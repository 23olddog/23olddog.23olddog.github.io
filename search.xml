<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重学Vue第二天</title>
      <link href="/2022/04/10/chong-xue-vue2.0/"/>
      <url>/2022/04/10/chong-xue-vue2.0/</url>
      
        <content type="html"><![CDATA[<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>当我们需要访问内联处理程序中的原始 DOM 事件 可以用特殊变量将其传递给方法$event 或者使用内联箭头函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click="warn('Form cannot be submitted yet.', $event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- using inline arrow function --&gt;</span><br><span class="line">&lt;button @click="(event) =&gt; warn('Form cannot be submitted yet.', event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="表单上输入绑定"><a href="#表单上输入绑定" class="headerlink" title="表单上输入绑定"></a>表单上输入绑定</h4><ul><li><code>&lt;input&gt;</code>文本类型和<code>&lt;textarea&gt;</code>元素使用<code>value</code>属性和<code>input</code>事件；</li><li><code>&lt;input type="checkbox"&gt;``&lt;input type="radio"&gt;</code>使用<code>checked</code>和事件<code>change</code>；</li><li><code>&lt;select&gt;</code>用作<code>value</code>和<code>change</code>事件。</li></ul><p><strong>v-model<code>将忽略在任何表单元素上找到的初始或属性</code>value<code>。它将始终将当前绑定的 JavaScript 状态视为事实来源。您应该使用反应性 API在 JavaScript 端声明初始值。</code>checked``selected</strong></p><p>如果您的表达式的初始值<code>v-model</code>与任何选项都不匹配，则该<code>&lt;select&gt;</code>元素将呈现为“未选择”状态。在 iOS 上，这将导致用户无法选择第一项，因为在这种情况下 iOS 不会触发更改事件。因此，建议提供一个带空值的禁用选项</p><p>默认情况下 v-model 在每个事件之后将输入与数据同步 可以添加修饰符<code>lazy</code>修改为在事件后同步</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- synced after "change" instead of "input" --&gt;</span><br><span class="line">&lt;input v-model.lazy="msg" /&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果希望用户输入的自动转化为数字 可以添加.number</p><p>如果希望自动修剪用户输入中的空白 可以加入.trim</p><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><img src="https://s3.bmp.ovh/imgs/2022/04/09/87a9e53a6371f344.png" style="zoom: 50%;"><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { ref, watch } from 'vue'</span><br><span class="line"></span><br><span class="line">const question = ref('')</span><br><span class="line">const answer = ref('Questions usually contain a question mark. ;-)')</span><br><span class="line"></span><br><span class="line">// watch works directly on a ref</span><br><span class="line">watch(question, async (newQuestion, oldQuestion) =&gt; {</span><br><span class="line">  if (newQuestion.indexOf('?') &gt; -1) {</span><br><span class="line">    answer.value = 'Thinking...'</span><br><span class="line">    try {</span><br><span class="line">      const res = await fetch('https://yesno.wtf/api')</span><br><span class="line">      answer.value = (await res.json()).answer</span><br><span class="line">    } catch (error) {</span><br><span class="line">      answer.value = 'Error! Could not reach the API. ' + error</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    &lt;input v-model="question" /&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;{{ answer }}&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>当你在 watch()直接调用一个响应式对象时 它会隐式创建一个深度观察者模式-回调将在所有嵌套突变上触发</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const obj = reactive({ count: 0});</span><br><span class="line">watch(obj, (newValue, oldValue) =&gt; {</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line">obj.count ++;</span><br><span class="line">//而使用getter：() =&gt; state.someObject则只会在放回不同的对象时才会触发回调</span><br><span class="line">可以显示使用deep选项来进入深度观察者模式</span><br><span class="line">watch(</span><br><span class="line">() =&gt; state....,</span><br><span class="line">(newValue, oldValue) =&gt; {}</span><br><span class="line">{ deep: true})</span><br></pre></td></tr></tbody></table></figure><p>**tips:**深度监视需要遍历监控对象中的所有嵌套属性 并且在用于大型数据结构时可能会开销昂贵 所以仅在必要时使用它并注意性能影响</p><h4 id="watchEffect（）"><a href="#watchEffect（）" class="headerlink" title="watchEffect（）"></a>watchEffect（）</h4><p>watch 是惰性的 在观察源发生变化之前不会立即调用 但是如果我们想要获取一些初始数据 然后在相关状态发生变化时重新获取数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const url = ref('https://...')</span><br><span class="line">const data = ref(null)</span><br><span class="line"></span><br><span class="line">async function fetchData() {</span><br><span class="line">  const response = await fetch(url.value)</span><br><span class="line">  data.value = await response.json()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// fetch immediately</span><br><span class="line">fetchData()</span><br><span class="line">// ...then watch for url change</span><br><span class="line">watch(url, fetchData)</span><br></pre></td></tr></tbody></table></figure><p><strong>watchEffect 允许我们在自动追踪效果的反应依赖的同时立即执行副作用函数</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(async () =&gt; {</span><br><span class="line">  const response = await fetch(url.value)</span><br><span class="line">  data.value = await response.json()</span><br><span class="line">})</span><br><span class="line">//在这苦 回调函数立即执行 他还会跟踪url.value为依赖项（类似于计算属性） 当url.value发生变化时 回调将再次运行</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const API_URL = `https://api.github.com/repos/vuejs/core/commits?per_page=3&amp;sha=`</span><br><span class="line">const branches = ['main', 'v2-compat']</span><br><span class="line"></span><br><span class="line">const currentBranch = ref(branches[0])</span><br><span class="line">const commits = ref(null)</span><br><span class="line"></span><br><span class="line">watchEffect(async () =&gt; {</span><br><span class="line">  // this effect will run immediately and then</span><br><span class="line">  // re-run whenever currentBranch.value changes</span><br><span class="line">  const url = `${API_URL}${currentBranch.value}`</span><br><span class="line">  commits.value = await (await fetch(url)).json()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>tips：</strong>watch 仅在其同步执行期间跟踪依赖项 当它与异步回调一起使用时 只会跟踪 await 跟踪第一个 tick 之前访问的属性</p><ul><li>watch 仅跟踪明确监视的源 将依赖跟踪与副作用分开</li><li>将依赖跟踪与副作用结合到一个阶段 会自动跟踪在同步执行期间访问的每一个反应属性 会使代码更简洁 但是依赖关系不明确</li></ul><h4 id="回调刷新时间"><a href="#回调刷新时间" class="headerlink" title="回调刷新时间"></a>回调刷新时间</h4><p>vue 默认在组件更新之前调用用户创建的观察者回调 所以如果尝试在观察者回调中访问 dom 则 dom 将处于 Vue 应用任何更新之前的状态 所以如果想要在 vue 更新后在 watcher 回调中访问 dom 需要指定 flush:’post’</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(source, callback, {</span><br><span class="line">  flush: 'post'</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">watchEffect(callback, {</span><br><span class="line">  flush: 'post'</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="停止观察者"><a href="#停止观察者" class="headerlink" title="停止观察者"></a>停止观察者</h4><p>Watchers 在内部同步声明<code>setup()</code>或<code>&lt;script setup&gt;</code>绑定到所有者组件实例，并在所有者组件卸载时自动停止。如果观察者是<strong>异步</strong>创建的 那么不会绑定到所有者组件 必须手动停止以避免<strong>内存泄漏</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const unwatch = watchEffect(() =&gt; {})</span><br><span class="line"></span><br><span class="line">// ...later, when no longer needed</span><br><span class="line">unwatch()</span><br></pre></td></tr></tbody></table></figure><p>应该军垦首选同步创建 如果需要等待一些异步数据 可以使用逻辑控制异步操作</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(() =&gt; {</span><br><span class="line">  if (data.value) {</span><br><span class="line">    // do something when data is loaded</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><p>如果要将对象的所有属性作为 props 传递 则可以使用 v-bind 不带参数使用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost v-bind="post" /&gt;</span><br><span class="line">//相当于使用</span><br><span class="line">&lt;BlogPost :id="post.id" :title="post.title" /&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>prop 用于传入一个初始值：子组件之后希望将其用作本地数据属性 则定义一个使用 prop 作为其初始值的本地数据属性</p></li><li><p>```<br>const props = defineProps([‘initialCounter’])</p><p>// counter only uses props.initialCounter as the initial value;<br>// it is disconnected from future prop updates.<br>const counter = ref(props.initialCounter)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- prop 作为需要转换的原始值传入 最好使用 prop 的值定义计算属性</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  const props = defineProps(['size'])</span><br><span class="line"></span><br><span class="line">  // computed property that auto-updates when the prop changes</span><br><span class="line">  const normalizedSize = computed(() =&gt; props.size.trim().toLowerCase())</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h2><p><strong>tips：</strong>组件的事件不会冒泡 父组件只能接收直接子组件发出的事件</p><p>可以通过 defineEmits 显示声明</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits(['inFocus', 'submit'])</span><br><span class="line">// type-based</span><br><span class="line">const emit = defineEmits&lt;{</span><br><span class="line">  (e: 'change', id: number): void</span><br><span class="line">  (e: 'update', value: string): void</span><br><span class="line">}&gt;()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果在选项中定义了本地事件如 click 则侦听器现在仅侦听组件发出的 click 而不再响应本地的 click 事件</p><p>如果使用对象语法则可以添加验证 为了添加验证 事件被分配了一个函数 改函数将接收传递给调用的参数并返回一个有效的布尔值以只是事件是否</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits({</span><br><span class="line">  // No validation</span><br><span class="line">  click: null,</span><br><span class="line"></span><br><span class="line">  // Validate submit event</span><br><span class="line">  submit: ({ email, password }) =&gt; {</span><br><span class="line">    if (email &amp;&amp; password) {</span><br><span class="line">      return true</span><br><span class="line">    } else {</span><br><span class="line">      console.warn('Invalid submit event payload!')</span><br><span class="line">      return false</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">function submitForm(email, password) {</span><br><span class="line">  emit('submit', { email, password })</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>自定义事件还能和 v-model 相结合</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- CustomInput.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps(['modelValue'])</span><br><span class="line">defineEmits(['update:modelValue'])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    :value="modelValue"</span><br><span class="line">    @input="$emit('update:modelValue', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">使用：</span><br><span class="line">&lt;CustomInput v-model="searchText" /&gt;</span><br></pre></td></tr></tbody></table></figure><p>v-model 还可以使用 computed 属性和 getter 以及 setter 该 get 方法应该返回 modelValue 属性并且该 set 方法应该发出相应的事件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- CustomInput.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import { computed } from 'vue'</span><br><span class="line"></span><br><span class="line">const props = defineProps(['modelValue'])</span><br><span class="line">const emit = defineEmits(['update:modelValue'])</span><br><span class="line"></span><br><span class="line">const value = computed({</span><br><span class="line">  get() {</span><br><span class="line">    return props.modelValue</span><br><span class="line">  },</span><br><span class="line">  set(value) {</span><br><span class="line">    emit('update:modelValue', value)</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input v-model="value" /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>使用多个 v-model</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserName</span><br><span class="line">  v-model:first-name="firstName"</span><br><span class="line">  v-model:last-name="lastName"</span><br><span class="line">/&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps({</span><br><span class="line">  firstName: String,</span><br><span class="line">  lastName: String</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">defineEmits(['update:firstName', 'update:lastName'])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type="text"</span><br><span class="line">    :value="firstName"</span><br><span class="line">    @input="$emit('update:firstName', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type="text"</span><br><span class="line">    :value="lastName"</span><br><span class="line">    @input="$emit('update:lastName', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>处理 v-model 修饰符：<strong>自定义修饰符</strong></p><p>eg：自定义一个将字符串第一个字母大写</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model.capitalize="myText" /&gt;</span><br><span class="line">添加到组件的修饰符v-model将通过modelModifiers prop提供给组件 我们创建了一个组件 其中包含一个modelModifiers默认为空的对象的prop</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps({</span><br><span class="line">  modelValue: String,</span><br><span class="line">  modelModifiers: { default: () =&gt; ({}) }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">defineEmits(['update:modelValue'])</span><br><span class="line"></span><br><span class="line">console.log(props.modelModifiers) // { capitalize: true }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type="text"</span><br><span class="line">    :value="modelValue"</span><br><span class="line">    @input="$emit('update:modelValue', $event.target.value)"</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">------------------我们可以更改成当触发input事件后就会将字符串大写</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps({</span><br><span class="line">  modelValue: String,</span><br><span class="line">  modelModifiers: { default: () =&gt; ({}) }//即传递过来的{ capitalize: true }</span><br><span class="line">})</span><br><span class="line">//设置默认抛出事件</span><br><span class="line">const emit = defineEmits(['update:modelValue'])</span><br><span class="line"></span><br><span class="line">function emitValue(e) {</span><br><span class="line">  let value = e.target.value</span><br><span class="line">  if (props.modelModifiers.capitalize) {</span><br><span class="line">    value = value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">  }</span><br><span class="line">  emit('update:modelValue', value)//触发事件</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//设置input触发事件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type="text" :value="modelValue" @input="emitValue" /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>对于<code>v-model</code>同时具有参数和修饰符 生成的道具名称将为<code>arg + 'Modifiers'</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model:title.capitalize="myText"&gt;</span><br><span class="line">//对应的声明应该为</span><br><span class="line">const props = defineProps(['title', 'titleModifiers'])</span><br><span class="line">defineEmits(['update:title'])</span><br><span class="line">console.log(props.titleModifiers) // { capitalize: true }</span><br></pre></td></tr></tbody></table></figure><h2 id="Fallthrough-属性"><a href="#Fallthrough-属性" class="headerlink" title="Fallthrough 属性"></a>Fallthrough 属性</h2><p><code>v-on</code>传递给组件的属性或事件监听器 但是未在组件的 props 或 emits 中显示声明 如<code>class</code>、<code>style</code>、<code>id</code></p><p>当组件渲染单个根元素时 将自动添加到根元素的属性中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- template of &lt;MyButton&gt; --&gt;</span><br><span class="line">&lt;button&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;MyButton class="large" /&gt;</span><br><span class="line">---最终渲染为</span><br><span class="line">&lt;button class="large"&gt;click me&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果不希望组件自动继承属性 可以在<code>inheriAttrs： false</code>在组件的选项中进行设置</p><p>如果使用<code>&lt;script setup&gt;</code>，您将需要使用单独的普通<code>&lt;script&gt;</code>块声明此选项：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// use normal &lt;script&gt; to declare options</span><br><span class="line">export default {</span><br><span class="line">  inheritAttrs: false</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// ...setup logic</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>常见场景：当属性需要引用于根节点以为的其他元素时 可以将<code>inheritAttrs</code>选项设置为<code>false</code>，您可以完全控制在何处应用 fallthrough 属性</p><p>可以通过<code>$attrs</code>来访问</p><ul><li>与 props 不同，fallthrough 属性在 JavaScript 中保留了它们的原始大小写，因此<code>foo-bar</code>需要将属性 like 访问为<code>$attrs['foo-bar']</code>.</li><li>像这样的<code>v-on</code>事件侦听<code>@click</code>器将作为<code>$attrs.onClick</code>.</li></ul><p>我们希望所有诸如<code>class</code>和<code>v-on</code>监听器之类的贯穿属性都应用于内部<code>&lt;button&gt;</code>，而不是外部<code>&lt;div&gt;</code>。可以使用 inheritAttrs: false 和</p><p><code>v-bind="$attrs"</code>来使用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="btn-wrapper"&gt;</span><br><span class="line">  &lt;button class="btn" v-bind="$attrs"&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>如果 v-bind 没有参数 则将对象的所有属性绑定为目标元素的属性</strong></p><h4 id="多个根节点的继承"><a href="#多个根节点的继承" class="headerlink" title="多个根节点的继承"></a>多个根节点的继承</h4><p>具有多个根节点的组件没有自动属性失效的行为 需要明确绑定$attrs</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomLayout id="custom-layout" @click="changeValue" /&gt;</span><br><span class="line">&lt;header&gt;...&lt;/header&gt;</span><br><span class="line">&lt;main v-bind="$attrs"&gt;...&lt;/main&gt;</span><br><span class="line">&lt;footer&gt;...&lt;/footer&gt;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import { useAttrs } from 'vue'</span><br><span class="line"></span><br><span class="line">const attrs = useAttrs()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//尽管attrs始终反应最新的fallthrough属性 但是并不是响应性的 所以无法使用观察者观察变化 如果需要响应性 可以使用prop 或者在onUpdated（）时执行最新的副作用</span><br></pre></td></tr></tbody></table></figure><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><img src="https://s3.bmp.ovh/imgs/2022/04/10/8d00a97ed8cd1522.png" style="zoom: 50%;"><p>插槽的作用</p><ul><li>使用插槽 子组件负责样式的渲染 而内容由父组件提供</li><li>通过使用插槽 我们可以使<code>&lt;FancyButton&gt;</code>更加灵活和重用 我们可以在不同的地方使用它 具有不同的内部内容 但是都具有同样花哨的样式</li></ul><h4 id="渲染范围"><a href="#渲染范围" class="headerlink" title="渲染范围"></a>渲染范围</h4><ul><li>插槽可以访问父组件的数据范围 因为它是在父组件中定义的</li><li>插槽无权访问子组件的数据 因为父模板中的所有内容都在父范围内编译 子模板中的所有内容都在子范围内编译</li></ul><h4 id="命名插槽"><a href="#命名插槽" class="headerlink" title="命名插槽"></a>命名插槽</h4><p>可以通过使用 name 用来为不同的插槽分配一个唯一的 ID 这样可以控制在哪里呈现内容</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="container"&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name="header"&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name="footer"&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">//当我们要传递指定内容时 可以使用v-slot</span><br><span class="line">&lt;BaseLayout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;!-- content for the header slot --&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/BaseLayout&gt;</span><br><span class="line">//可以使用“#”简写</span><br><span class="line">&lt;template #header&gt;。</span><br></pre></td></tr></tbody></table></figure><p>当组件同时接受默认槽和命名槽时，所有顶级非<code>&lt;template&gt;</code>节点都被隐式视为默认槽的内容。</p><h4 id="动态插槽名称"><a href="#动态插槽名称" class="headerlink" title="动态插槽名称"></a>动态插槽名称</h4><p>动态指令参数也适用于 v-slot 允许定义动态插槽的名称</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:[dynamicSlotName]&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- with shorthand --&gt;</span><br><span class="line">  &lt;template #[dynamicSlotName]&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="命名插槽-1"><a href="#命名插槽-1" class="headerlink" title="命名插槽"></a>命名插槽</h4><p><img src="https://i.bmp.ovh/imgs/2022/04/10/06d1487ae8b60eaa.png"></p><p>可以通过命名插槽访问子组件的数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;slot :text="greetingMessage" :count="1"&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;MyComponent v-slot="slotProps"&gt;</span><br><span class="line">  {{ slotProps.text }} {{ slotProps.count }}</span><br><span class="line">&lt;/MyComponent&gt;</span><br><span class="line">//可以通过解构的方式来取值</span><br><span class="line">&lt;MyComponent v-slot="{ text, count }"&gt;</span><br><span class="line">  {{ text }} {{ count }}</span><br><span class="line">&lt;/MyComponent&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="命名范围插槽"><a href="#命名范围插槽" class="headerlink" title="命名范围插槽"></a><strong>命名范围插槽</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;</span><br><span class="line">  &lt;template #header="headerProps"&gt;</span><br><span class="line">    {{ headerProps }}</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #default="defaultProps"&gt;</span><br><span class="line">    {{ defaultProps }}</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #footer="footerProps"&gt;</span><br><span class="line">    {{ footerProps }}</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/MyComponent&gt;</span><br><span class="line">&lt;slot name="header" message="hello"&gt;&lt;/slot&gt;</span><br></pre></td></tr></tbody></table></figure><p>name 不会包含在 prop 中 所以 headerProps 是<code>{ message: 'hello' }</code>.</p><p><strong>作用域插槽的使用场景</strong></p><p>如果需要一个<fancylist>渲染项目列表的组件–它可以封装加载远程数据的逻辑 使用数据显示列表 甚至是分页或无限滚动等高级功能 但是我们希望它能够灵活处理每个项目的外观 并将每个项目的样式留给使用它的父组件</fancylist></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;FancyList :api-url="url" :per-page="10"&gt;</span><br><span class="line">  &lt;template #item="{ body, username, likes }"&gt;</span><br><span class="line">    &lt;div class="item"&gt;</span><br><span class="line">      &lt;p&gt;{{ body }}&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;by {{ username }} | {{ likes }} likes&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/FancyList&gt;</span><br></pre></td></tr></tbody></table></figure><p>在内部，我们可以使用不同的项目数据多次<code>&lt;FancyList&gt;</code>渲染相同的内容（注意我们使用对象作为插槽道具传递）：<code>&lt;slot&gt;``v-bind</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">App.vue</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import FancyList from './FancyList.vue'</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;FancyList :api-url="url" :per-page="10"&gt;</span><br><span class="line">    &lt;template #item="{ body, username, likes }"&gt;</span><br><span class="line">      &lt;div class="item"&gt;</span><br><span class="line">        &lt;p&gt;{{ body }}&lt;/p&gt;</span><br><span class="line">        &lt;p class="meta"&gt;by {{ username }} | {{ likes }} likes&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/FancyList&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.meta {</span><br><span class="line">  font-size: 0.8em;</span><br><span class="line">  color: #42b883;</span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">FancyList.vue</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import { ref } from 'vue'</span><br><span class="line"></span><br><span class="line">const props = defineProps(['api-url', 'per-page'])</span><br><span class="line"></span><br><span class="line">const items = ref([])</span><br><span class="line"></span><br><span class="line">// mock remote data fetching</span><br><span class="line">setTimeout(() =&gt; {</span><br><span class="line">  items.value = [</span><br><span class="line">    { body: 'Scoped Slots Guide', username: 'Evan You', likes: 20 },</span><br><span class="line">  { body: 'Vue Tutorial', username: 'Natalia Tepluhina', likes: 10 }</span><br><span class="line">  ]</span><br><span class="line">}, 1000)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-if="!items.length"&gt;</span><br><span class="line">      Loading...</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li v-for="item in items"&gt;</span><br><span class="line">      &lt;slot name="item" v-bind="item"/&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  ul {</span><br><span class="line">    list-style-type: none;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    background: linear-gradient(315deg, #42d392 25%, #647eff);</span><br><span class="line">  }</span><br><span class="line">  li {</span><br><span class="line">    padding: 5px 20px;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    background: #fff;</span><br><span class="line">  }</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="Provide-Inject"><a href="#Provide-Inject" class="headerlink" title="Provide/Inject"></a>Provide/Inject</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script setup&gt;</span><br><span class="line"><span class="keyword">import</span> { provide } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">provide</span>(<span class="comment">/* key */</span> <span class="string">'message'</span>, <span class="comment">/* value */</span> <span class="string">'hello!'</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>提供响应式值允许使用提供的值的后代组件建立到提供程序组件的响应式连接。</p><p>如果提供的值是 ref 它是按原样注入 不会自动解构 这允许注入器组件保留与提供者组件的反应性连接</p><h4 id="注入默认值"><a href="#注入默认值" class="headerlink" title="注入默认值"></a>注入默认值</h4><p>如果想要让注入的属性和可选提供者一起工作 那么就需要声明一个默认值 类似于 props</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">inject</span>(<span class="string">"message"</span>, <span class="string">"default value"</span>);</span><br></pre></td></tr></tbody></table></figure><p>在某些情况下，可能需要通过调用函数或实例化新类来创建默认值。为了避免在不使用可选值的情况下产生不必要的计算或副作用，我们可以使用<strong>工厂函数来创建默认值：</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">inject</span>(<span class="string">"key"</span>, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">ExpensiveClas</span>());</span><br></pre></td></tr></tbody></table></figure><h4 id="使用响应式数据"><a href="#使用响应式数据" class="headerlink" title="使用响应式数据"></a>使用响应式数据</h4><p>尽可能将任何对响应式状态的突变保留在提供程序内部 这确保了提供的状态以及可能的突变位于同一组件 从而更容易在将来维护</p><p>有时我们可能从租入器组件更新数据 这种情况我们一般提供一个负责改变状态的函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> { provide, ref } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> location = <span class="title function_">ref</span>(<span class="string">'North Pole'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateLocation</span>(<span class="params"></span>) {</span><br><span class="line">  location.<span class="property">value</span> = <span class="string">'South Pole'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">provide</span>(<span class="string">'location'</span>, {</span><br><span class="line">  location,</span><br><span class="line">  updateLocation</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">------------------------</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> { inject } <span class="keyword">from</span> <span class="string">'vue'</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> { location, updateLocation } = <span class="title function_">inject</span>(<span class="string">'location'</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"updateLocation"</span>&gt;</span>{{ location }}<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>最后 我们想确保 provide 的数据不会被改变 可以使用 readonly</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="string">"read-only-count"</span>, <span class="title function_">readonly</span>(count));</span><br></pre></td></tr></tbody></table></figure><p><strong>最好使用符号注入密钥来避免潜在的冲突 可以将符号到处到专有文件中</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keys.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myInjectionKey = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="comment">// in provider component</span></span><br><span class="line"><span class="keyword">import</span> { provide } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> { myInjectionKey } <span class="keyword">from</span> <span class="string">"./keys.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">provide</span>(myInjectionKey, {</span><br><span class="line">  <span class="comment">/* data to provide */</span></span><br><span class="line">});</span><br><span class="line"><span class="comment">// in injector component</span></span><br><span class="line"><span class="keyword">import</span> { inject } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> { myInjectionKey } <span class="keyword">from</span> <span class="string">"./keys.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> injected = <span class="title function_">inject</span>(myInjectionKey);</span><br></pre></td></tr></tbody></table></figure><h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { defineAsyncComponent } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="title function_">import</span>(<span class="string">"./components/MyComponent.vue"</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>结果<code>AsyncComp</code>是一个包装器组件，它仅在实际呈现在页面上时才调用加载器函数。此外，它会将任何 props 传递给内部组件，因此您可以使用异步包装器无缝替换原始组件，同时实现延迟加载。</p><h4 id="加载和错误状态"><a href="#加载和错误状态" class="headerlink" title="加载和错误状态"></a>加载和错误状态</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>({</span><br><span class="line">  <span class="comment">// the loader function</span></span><br><span class="line">  <span class="attr">loader</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">"./Foo.vue"</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A component to use while the async component is loading</span></span><br><span class="line">  <span class="attr">loadingComponent</span>: <span class="title class_">LoadingComponent</span>,</span><br><span class="line">  <span class="comment">// Delay before showing the loading component. Default: 200ms.</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A component to use if the load fails</span></span><br><span class="line">  <span class="attr">errorComponent</span>: <span class="title class_">ErrorComponent</span>,</span><br><span class="line">  <span class="comment">// The error component will be displayed if a timeout is</span></span><br><span class="line">  <span class="comment">// provided and exceeded. Default: Infinity.</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span>,</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>如果提供了加载组件，它将在加载内部组件时首先显示。在显示加载组件之前有一个默认的 200 毫秒延迟 - 这是因为在快速网络上，即时加载状态可能会被替换得太快并最终看起来像闪烁。</p><p>如果提供了错误组件，当 loader 函数返回的 Promise 被拒绝时会显示。您还可以指定超时以在请求时间过长时显示错误组件。</p><h2 id="Composables"><a href="#Composables" class="headerlink" title="Composables"></a>Composables</h2><p>Composables 是一种可以利用 Vue 组合 API 封装和重用有状态逻辑的函数</p><ul><li><p>鼠标跟踪器示例</p></li><li><p>```js<br>// mouse.js<br>import { ref, onMounted, onUnmounted } from ‘vue’</p><p>// by convention, composable function names start with “use”<br>export function useMouse() {<br>  // state encapsulated and managed by the composable<br>  const x = ref(0)<br>  const y = ref(0)</p><p>  // a composable can update its managed state over time.<br>  function update(event) {</p><pre><code>x.value = event.pageXy.value = event.pageY</code></pre><p>  }</p><p>  // a composable can also hook into its owner component’s<br>  // lifecycle to setup and teardown side effects.<br>  onMounted(() =&gt; window.addEventListener(‘mousemove’, update))<br>  onUnmounted(() =&gt; window.removeEventListener(‘mousemove’, update))</p><p>  // expose managed state as return value<br>  return { x, y }<br>}<br>//组件中的使用方式</p><script setup="">import { useMouse } from './mouse.js'const { x, y } = useMouse()</script><p><template>Mouse position is at: , </template></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">COmposables 还可以嵌套使用：一个可组合函数可以调用另一个或多个其他可组合函数 这是的我们能够使用小的、隔离的单元来组合复杂的逻辑 了类似于使用组件来整合整个应用程序的方式</span><br><span class="line"></span><br><span class="line">实例 2：我们可以将添加和清理 DOM 事件监听器的逻辑提取到它自己的可组合中</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">// event.js</span><br><span class="line">import { onMounted, onUnmounted } from "vue";</span><br><span class="line"></span><br><span class="line">export function useEventListener(target, event, callback) {</span><br><span class="line">  // if you want, you can also make this</span><br><span class="line">  // support selector strings as target</span><br><span class="line">  onMounted(() =&gt; target.addEventListener(event, callback));</span><br><span class="line">  onUnmounted(() =&gt; target.removeEventListener(event, callback));</span><br><span class="line">}</span><br><span class="line">//现在我们的useMouse（）可以简化为</span><br><span class="line">// mouse.js</span><br><span class="line">import { ref } from "vue";</span><br><span class="line">import { useEventListener } from "./event";</span><br><span class="line"></span><br><span class="line">export function useMouse() {</span><br><span class="line">  const x = ref(0);</span><br><span class="line">  const y = ref(0);</span><br><span class="line"></span><br><span class="line">  useEventListener(window, "mousemove", (event) =&gt; {</span><br><span class="line">    x.value = event.pageX;</span><br><span class="line">    y.value = event.pageY;</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  return { x, y };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>**tips:**每个组件实例调用<code>useMouse()</code>都将创建自己的副本<code>x</code>和<code>y</code>状态，因此它们不会相互干扰。如果想管理组件之间的共享状态 可以使用 vuex</p><h4 id="异步状态示例"><a href="#异步状态示例" class="headerlink" title="异步状态示例"></a>异步状态示例</h4><p>在进行异步数据获取时 我们经常需要处理不同的状态：加载、成功和错误 我们可以将其提取到可组合中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch.js</span></span><br><span class="line"><span class="keyword">import</span> { ref } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useFetch</span>(<span class="params">url</span>) {</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetch</span>(url)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> (data.<span class="property">value</span> = json))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> (error.<span class="property">value</span> = err));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> { data, error };</span><br><span class="line">}</span><br><span class="line"><span class="comment">//现在在我们的组件中 可以这样做</span></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> {useFetch} <span class="keyword">from</span> <span class="string">'./fetch.js'</span> <span class="keyword">const</span> {(data, error)} = <span class="title function_">useFetch</span>(<span class="string">'...'</span>)</span><br><span class="line">&lt;/script&gt;;</span><br></pre></td></tr></tbody></table></figure><p>如果我们希望在 URL 更改时重新获取数据 可以使用响应式数据作为参数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch.js</span></span><br><span class="line"><span class="keyword">import</span> { ref, isRef, unref, watchEffect } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useFetch</span>(<span class="params">url</span>) {</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doFetch</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// reset state before fetching..</span></span><br><span class="line">    data.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    error.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// unref() unwraps potential refs</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="title function_">unref</span>(url))</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> (data.<span class="property">value</span> = json))</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> (error.<span class="property">value</span> = err));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(url)) {</span><br><span class="line">    <span class="comment">// setup reactive re-fetch if input URL is a ref</span></span><br><span class="line">    <span class="title function_">watchEffect</span>(doFetch);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// otherwise, just fetch once</span></span><br><span class="line">    <span class="comment">// and avoid the overhead of a watcher</span></span><br><span class="line">    <span class="title function_">doFetch</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> { data, error };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>useFetch（）接收静态 URL 以及 URL 字符串的引用 当检测到 URL 是一个动态引用即 isRef（）时 会设置一个响应式效果 WatchEffect()效果将立即运行 并在这个过程中将 URL ref 作为依赖项进行跟踪 每当 URL 更改时 数据将被重置并再次获取</strong></p></li></ul><h4 id="Conventions-and-Best-Practices"><a href="#Conventions-and-Best-Practices" class="headerlink" title="Conventions and Best Practices"></a>Conventions and Best Practices</h4><ul><li><p>以 use 开头 如 useFetch();</p></li><li><p>如果正在编写一个可能被其他开发人员使用的组合 在处理输入参数时 refs 而不是原始值时是一个好主意 可以使用 unref</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { unref } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useFeature</span>(<span class="params">maybeRef</span>) {</span><br><span class="line">  <span class="comment">// if maybeRef is indeed a ref, its .value will be returned</span></span><br><span class="line">  <span class="comment">// otherwise, maybeRef is returned as-is</span></span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">unref</span>(maybeRef);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果在输入是<code>ref</code>是创建响应性 请确保使用<code>watch()</code>来跟踪<code>ref</code>数据 或者使用<code>unref</code>并在内部使用<code>watchEffect()</code></p></li><li><p>我们推荐返回一个 refs 对象 以便在组件中对其进行解构并保持响应性 如果更喜欢返回对象属性 可以使用<code>reactive()</code>以便解构引用</p></li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mouse = <span class="title function_">reactive</span>(<span class="title function_">useMouse</span>());</span><br><span class="line"><span class="comment">// mouse.x is linked to original ref</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mouse.<span class="property">x</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h4><ul><li>如果正在开发服务端渲染（SSR）的原因程序 确保在安装后生命周期执行特定于 DOM 的副作用 如在 onMounted()确保可以访问 DOM</li><li><strong>确保清除 onUnmounted 在设置事件监听器后记得清理</strong></li></ul><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><p>只能在钩子中同步使用 可以在<code>&lt;script setup&gt;setup()onMounted()</code>中调用</p><ul><li>生命周期钩子可以注册到它</li><li>计算属性和观察者可以追踪并在组件卸载时进行处理</li><li>你只能在<code>&lt;script setup&gt;</code>中使用 await 编译器会在执行异步操作后自动恢复活动实例上下文</li></ul><h4 id="为代码组织提取可组合项"><a href="#为代码组织提取可组合项" class="headerlink" title="为代码组织提取可组合项"></a>为代码组织提取可组合项</h4><p>可组合项不仅可以提取用于重用 还可以用于代码组织</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> {useFeatureA} <span class="keyword">from</span> <span class="string">'./featureA.js'</span> <span class="keyword">import</span> {useFeatureB} <span class="keyword">from</span></span><br><span class="line">  <span class="string">'./featureB.js'</span> <span class="keyword">import</span> {useFeatureC} <span class="keyword">from</span> <span class="string">'./featureC.js'</span> <span class="keyword">const</span> {(foo, bar)} =</span><br><span class="line">  <span class="title function_">useFeatureA</span>() <span class="keyword">const</span> {baz} = <span class="title function_">useFeatureB</span>(foo) <span class="keyword">const</span> {qux} = <span class="title function_">useFeatureC</span>(baz)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p><strong>自定义指令主要用于重用涉及对普通元素进行低级 DOM 访问的逻辑</strong></p><p>自定义指令被定义为包含类似于组件的生命周期钩子的对象 钩子接收指令绑定的元素</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="comment">// enables v-focus in templates</span></span><br><span class="line"><span class="keyword">const</span> vFocus = {</span><br><span class="line">  <span class="attr">mounted</span>: <span class="function">(<span class="params">el</span>) =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue TS 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的reactive</title>
      <link href="/2022/04/09/vue-xiang-ying-shi-yuan-li/"/>
      <url>/2022/04/09/vue-xiang-ying-shi-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-源码解析系列-响应式原理（reactive-篇）"><a href="#Vue3-源码解析系列-响应式原理（reactive-篇）" class="headerlink" title="Vue3 源码解析系列 - 响应式原理（reactive 篇）"></a>Vue3 源码解析系列 - 响应式原理（reactive 篇）</h1><h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h2><h3 id="核心入口"><a href="#核心入口" class="headerlink" title="核心入口"></a>核心入口</h3><p>话不多说，我们先来看下核心的 <code>reactive</code> 的源码，先看下有哪些依赖：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工具方法，isObject 是判断是否是对象，toTypeString 获取数据类型</span></span><br><span class="line"><span class="keyword">import</span> { isObject, toTypeString } <span class="keyword">from</span> <span class="string">"@vue/shared"</span>;</span><br><span class="line"><span class="comment">// Proxy 的 handlers</span></span><br><span class="line"><span class="comment">// mutableHandlers：可变数据的 handler</span></span><br><span class="line"><span class="comment">// readonlyHandlers：只读数据的 handler</span></span><br><span class="line"><span class="keyword">import</span> { mutableHandlers, readonlyHandlers } <span class="keyword">from</span> <span class="string">"./baseHandlers"</span>;</span><br><span class="line"><span class="keyword">import</span> {</span><br><span class="line">  mutableCollectionHandlers, <span class="comment">// 可变集合数据的 handler</span></span><br><span class="line">  readonlyCollectionHandlers, <span class="comment">// 只读集合数据的 handler</span></span><br><span class="line">} <span class="keyword">from</span> <span class="string">"./collectionHandlers"</span>;</span><br><span class="line"><span class="comment">// effect 泛型类型</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">ReactiveEffect</span> } <span class="keyword">from</span> <span class="string">"./effect"</span>;</span><br><span class="line"><span class="comment">// ref 泛型类型</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">UnwrapRef</span>, <span class="title class_">Ref</span> } <span class="keyword">from</span> <span class="string">"./ref"</span>;</span><br><span class="line"><span class="comment">// 工具方法，将字符串转化成 Map，返回 function 来判断是否 这个Map 上包含所给的 key</span></span><br><span class="line"><span class="comment">// 这个在 vue2 里也有</span></span><br><span class="line"><span class="keyword">import</span> { makeMap } <span class="keyword">from</span> <span class="string">"@vue/shared"</span>;</span><br></pre></td></tr></tbody></table></figure><p>可以很清楚的看到，重点依赖项就是那一堆 <code>handler</code> 了，其他都是一些工具方法和泛型类型</p><p>接下来的源码里是一堆变量的定义，不过我们先跳过，先来看下 <code>reactive</code> 的方法和类型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面还有一大坨变量定义，很关键，但是我们先跳过，先看下有哪些方法，类型是什么样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖集合类型</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Dep</span> = <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt;</span><br><span class="line"><span class="comment">// 看名字就知道，是 key 和 Dep 集合的对应关系集合</span></span><br><span class="line"><span class="comment">// key 其实就是我们响应式数据上的 key，Dep 则是有哪些地方依赖到了这个 key</span></span><br><span class="line"><span class="comment">// 比如 const a = { foo: 1 }，如果在其他两处都用到了 a.foo，那么</span></span><br><span class="line"><span class="comment">// 这里的 key 就是 foo，Dep 就是这两处的 依赖集合</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">KeyToDepMap</span> = <span class="title class_">Map</span>&lt;string | symbol, <span class="title class_">Dep</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断对象能不能被观察的</span></span><br><span class="line"><span class="keyword">const</span> canObserve = (<span class="attr">value</span>: any): boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// only unwrap nested ref</span></span><br><span class="line"><span class="comment">// 解套 Ref 类型</span></span><br><span class="line">type <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">UnwrapRef</span>&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应式入口方法，入参是泛型，继承 object，返回值就是上面的解套 Ref 类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> reactive&lt;T <span class="keyword">extends</span> object&gt;(<span class="attr">target</span>: T): <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟 reactive 作用相同，只不过返回值是 Readonly 的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> readonly&lt;T <span class="keyword">extends</span> object&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">Readonly</span>&lt;<span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建响应式对象的关键方法，reactive 和 only 都调用了这个方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  toProxy: <span class="built_in">WeakMap</span>&lt;any, any&gt;,</span></span><br><span class="line"><span class="params">  toRaw: <span class="built_in">WeakMap</span>&lt;any, any&gt;,</span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;any&gt;,</span></span><br><span class="line"><span class="params">  collectionHandlers: ProxyHandler&lt;any&gt;</span></span><br><span class="line"><span class="params"></span>): any</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是响应式数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReactive</span>(<span class="params">value: any</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是只读的响应式数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReadonly</span>(<span class="params">value: any</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将响应式数据转化为原始数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(<span class="attr">observed</span>: T): T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 value 标记为 Readonly，在 reactive 方法里会判断是否是 Readonly 的原始数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> markReadonly&lt;T&gt;(<span class="attr">value</span>: T): T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 value 标记为不可响应数据，这个将会影响 canObserve 方法的判断</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> markNonReactive&lt;T&gt;(<span class="attr">value</span>: T): T</span><br></pre></td></tr></tbody></table></figure><p>看完方法和类型，大致有以下几个问题：</p><ol><li><code>Dep</code> 依赖是如何追踪的？</li><li><code>UnwrapRef</code> 是如何展开嵌套的响应式数据类型的（俗称解套）,比如 <code>reactive({ name: reactive(ref('Jooger')) })</code></li><li>如何判断是否是（只读的）响应式数据？往响应式数据上面挂载一个标记位来标记？还是用一个对象来存储响应式数据？</li><li>如何将响应式数据转化为原始数据？proxy 数据如何转化成 object？</li></ol><p>问题 1，后面的 <code>effect</code> 会讲，这里先不讨论</p><p>问题 2，后面的 <code>ref</code> 会讲，这里先不讨论</p><p>问题 3，4 就需要看下我刚才跳过的一堆变量的定义了：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The main WeakMap that stores {target -&gt; key -&gt; dep} connections.</span></span><br><span class="line"><span class="comment">// Conceptually, it's easier to think of a dependency as a Dep class</span></span><br><span class="line"><span class="comment">// which maintains a Set of subscribers, but we simply store them as</span></span><br><span class="line"><span class="comment">// raw Sets to reduce memory overhead.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// target 和 KeyToDepMap 的映射关系集合</span></span><br><span class="line"><span class="comment">// 一句话理解，有多个 target，每个 target 上有多个 key，每个 key 都有多个依赖</span></span><br><span class="line"><span class="comment">// 至于为什么要把映射关系存到 WeakMap 里，根据上面注释所述，是为了减少内存开销</span></span><br><span class="line"><span class="comment">// 这个在后续的 effect 部分会讲</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, <span class="title class_">KeyToDepMap</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMaps that store {raw &lt;-&gt; observed} pairs.</span></span><br><span class="line"><span class="comment">// 下面这四个变量就是为了解答 问题 3 和 4 的</span></span><br><span class="line"><span class="comment">// 根据上面的原英文注释，这四个变量是 raw 和 observed 的对应关系集合</span></span><br><span class="line"><span class="comment">// raw 是原始数据，observed 则是响应式数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据 -&gt; 响应式数据</span></span><br><span class="line"><span class="keyword">const</span> rawToReactive = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"><span class="comment">// 响应式数据 -&gt; 原始数据</span></span><br><span class="line"><span class="keyword">const</span> reactiveToRaw = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"><span class="comment">// 原始数据 -&gt; 只读响应式数据</span></span><br><span class="line"><span class="keyword">const</span> rawToReadonly = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"><span class="comment">// 只读响应式数据 -&gt; 原始数据</span></span><br><span class="line"><span class="keyword">const</span> readonlyToRaw = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakSets for values that are marked readonly or non-reactive during</span></span><br><span class="line"><span class="comment">// observable creation.</span></span><br><span class="line"><span class="comment">// 前面提到过的 markReadonly 和 markNonReactive 方法用到的</span></span><br><span class="line"><span class="comment">// 用来存储我们标记的特定数据，以便在创建响应式数据是来检查是否被上面两个方法标记过</span></span><br><span class="line"><span class="keyword">const</span> readonlyValues = <span class="keyword">new</span> <span class="title class_">WeakSet</span>&lt;any&gt;()</span><br><span class="line"><span class="keyword">const</span> nonReactiveValues = <span class="keyword">new</span> <span class="title class_">WeakSet</span>&lt;any&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是集合类型（Set, Map, WeakMap, WeakSet）</span></span><br><span class="line"><span class="comment">// 因为集合类型的代理 handler 和普通对象是不同的，需要特殊处理</span></span><br><span class="line"><span class="keyword">const</span> collectionTypes = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="title class_">Function</span>&gt;([<span class="title class_">Set</span>, <span class="title class_">Map</span>, <span class="title class_">WeakMap</span>, <span class="title class_">WeakSet</span>])</span><br><span class="line"><span class="comment">// 判断是否是可观察类型，有以下 6 类，在 canObserve 方法里会用到</span></span><br><span class="line"><span class="keyword">const</span> isObservableType = <span class="comment">/*#__PURE__*/</span> <span class="title function_">makeMap</span>(</span><br><span class="line">  [<span class="string">'Object'</span>, <span class="string">'Array'</span>, <span class="string">'Map'</span>, <span class="string">'Set'</span>, <span class="string">'WeakMap'</span>, <span class="string">'WeakSet'</span>]</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">t</span> =&gt;</span> <span class="string">`[object <span class="subst">${t}</span>]`</span>)</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">','</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>看完上面这些变量定义，我们来解答一下问题 3，4：</p><blockquote><p>问题 3：如何判断是否是（只读的）响应式数据？往响应式数据上面挂载一个标记位来标记？还是用一个对象来存储响应式数据？</p></blockquote><p>用 <code>readonlyToRaw</code> 来存储只读响应式数据的，参见下面代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReadonly</span>(<span class="params">value: any</span>): boolean {</span><br><span class="line">  <span class="keyword">return</span> readonlyToRaw.<span class="title function_">has</span>(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>问题 4：如何将响应式数据转化为原始数据？proxy 数据如何转化成 object？</p></blockquote><p>用 <code>reactiveToRaw</code> 和 <code>readonlyToRaw</code> 来存储<code>响应式数据 -&gt; 原始数据</code> 的映射关系，然后：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(<span class="attr">observed</span>: T): T {</span><br><span class="line">  <span class="keyword">return</span> reactiveToRaw.<span class="title function_">get</span>(observed) || readonlyToRaw.<span class="title function_">get</span>(observed) || observed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>总的来讲，就是利用各种集合来存储原始数据和响应式数据的映射关系，以便快速根据这种映射关系拿到对应的数据。</p><p>再回头看下 <code>canObserve</code> 方法，来看看到底有哪些数据是可以观察的：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canObserve = (<span class="attr">value</span>: any): <span class="function"><span class="params">boolean</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// Vue 实例不可观察，目前库里还没有 _isVue 的逻辑，不过猜测应该是内部在 setup 方法中挂载</span></span><br><span class="line">    !value.<span class="property">_isVue</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// virtual dom 不可观察</span></span><br><span class="line">    !value.<span class="property">_isVNode</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// 'Object', 'Array', 'Map', 'Set', 'WeakMap', 'WeakSet' 类型以外的不可观察</span></span><br><span class="line">    <span class="title function_">isObservableType</span>(<span class="title function_">toTypeString</span>(value)) &amp;&amp;</span><br><span class="line">    <span class="comment">// 已经标记为不可响应数据的不可观察</span></span><br><span class="line">    !nonReactiveValues.<span class="title function_">has</span>(value)</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>相比于 <code>Vue2</code> 的是否可观察判断，则少了很多条件：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我就不解析 Vue2 中的这段判断代码了</span></span><br><span class="line"><span class="comment">// 相比于 Vue2，少了 __ob__ ，ssr 以及 Object.isExtensible 的判断</span></span><br><span class="line"><span class="comment">// 这都是得益于 Proxy</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">hasOwn</span>(value, <span class="string">"__ob__"</span>) &amp;&amp; value.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) {</span><br><span class="line">  ob = value.<span class="property">__ob__</span>;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  shouldObserve &amp;&amp;</span><br><span class="line">  !<span class="title function_">isServerRendering</span>() &amp;&amp;</span><br><span class="line">  (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value) || <span class="title function_">isPlainObject</span>(value)) &amp;&amp;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) &amp;&amp;</span><br><span class="line">  !value.<span class="property">_isVue</span></span><br><span class="line">) {</span><br><span class="line">  ob = <span class="keyword">new</span> <span class="title class_">Observer</span>(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来就讲一下重点的 <code>reactive</code> 和 <code>readonly</code> 这两个核心方法的实现：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面讲过返回值就是上面的解套 Ref 类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: object</span>) {</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="comment">// 如果是一个只读响应式数据，直接返回，因为已经是响应式的了</span></span><br><span class="line">  <span class="keyword">if</span> (readonlyToRaw.<span class="title function_">has</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// target is explicitly marked as readonly by user</span></span><br><span class="line">  <span class="comment">// 如果曾经被标记为只读数据，直接调用 readonly 方法生成只读响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (readonlyValues.<span class="title function_">has</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readonly</span>(target)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建响应式对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target, <span class="comment">// 原始数据</span></span><br><span class="line">    rawToReactive, <span class="comment">// raw -&gt; observed</span></span><br><span class="line">    reactiveToRaw, <span class="comment">// observed -&gt; raw</span></span><br><span class="line">    mutableHandlers, <span class="comment">// 可变数据的 proxy handle</span></span><br><span class="line">    mutableCollectionHandlers <span class="comment">// 可变集合数据的 proxy handler</span></span><br><span class="line">  )</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> readonly&lt;T <span class="keyword">extends</span> object&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">Readonly</span>&lt;<span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;&gt; {</span><br><span class="line">  <span class="comment">// value is a mutable observable, retrieve its original and return</span></span><br><span class="line">  <span class="comment">// a readonly version.</span></span><br><span class="line">  <span class="comment">// 如果是响应式数据，那么获取原始数据来进行观察</span></span><br><span class="line">  <span class="keyword">if</span> (reactiveToRaw.<span class="title function_">has</span>(target)) {</span><br><span class="line">    target = reactiveToRaw.<span class="title function_">get</span>(target)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 创建响应式数据，同样</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target, <span class="comment">// 原始数据</span></span><br><span class="line">    rawToReadonly, <span class="comment">// raw -&gt; readonly observed</span></span><br><span class="line">    readonlyToRaw, <span class="comment">// readonly ovserved -&gt; raw</span></span><br><span class="line">    readonlyHandlers, <span class="comment">// 只读数据的 proxy handler</span></span><br><span class="line">    readonlyCollectionHandlers <span class="comment">// 只读集合数据的 proxy handler</span></span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实我们看 <code>Vue3</code> 的源码会发现，很多入口方法都变得短小精简，不像 <code>Vue2</code> 里的一些 exposed function 那样写的很长，这两个核心方法也一样，逻辑很简单，主要是进行一些原始数据检查和转换，核心实现逻辑都是放在 <code>createReactiveObject</code> 里的</p><p>下面继续看下核心实现方法 <code>createReactiveObject</code>：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建响应式对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any, <span class="comment">// 原始数据</span></span></span><br><span class="line"><span class="params">  toProxy: <span class="built_in">WeakMap</span>&lt;any, any&gt;, <span class="comment">// raw -&gt; (readonly) observed</span></span></span><br><span class="line"><span class="params">  toRaw: <span class="built_in">WeakMap</span>&lt;any, any&gt;, <span class="comment">// (readonly) observed -&gt; raw</span></span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;any&gt;, <span class="comment">// 只读/可变 数据的 proxy handler</span></span></span><br><span class="line"><span class="params">  collectionHandlers: ProxyHandler&lt;any&gt; <span class="comment">// 只读/可变 集合数据的 proxy handler</span></span></span><br><span class="line"><span class="params"></span>) {</span><br><span class="line">  <span class="comment">// 如果不是对象，则直接返回自身，包括 null，reactive(null) =&gt; null</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) {</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">${<span class="built_in">String</span>(target)}</span>`</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// target already has corresponding Proxy</span></span><br><span class="line">  <span class="comment">// 如果原始数据已经被观察过，直接通过 raw -&gt; observed 映射，返回响应式数据</span></span><br><span class="line">  <span class="keyword">let</span> observed = toProxy.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (observed !== <span class="keyword">void</span> <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> observed;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// target is already a Proxy</span></span><br><span class="line">  <span class="comment">// 如果原始数据本身就是响应式的，直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span> (toRaw.<span class="title function_">has</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// only a whitelist of value types can be observed.</span></span><br><span class="line">  <span class="comment">// 如果是不可观察对象，直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">canObserve</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 判断是采用基础数据（object|array）handler 还是集合数据 handler</span></span><br><span class="line">  <span class="keyword">const</span> handlers = collectionTypes.<span class="title function_">has</span>(target.<span class="property">constructor</span>)</span><br><span class="line">    ? collectionHandlers</span><br><span class="line">    : baseHandlers;</span><br><span class="line">  <span class="comment">// Proxy 创建代理对象，即响应式对象</span></span><br><span class="line">  observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handlers);</span><br><span class="line">  <span class="comment">// 创建后，设置好 raw &lt;-&gt; observed 的双向映射关系(*)</span></span><br><span class="line">  toProxy.<span class="title function_">set</span>(target, observed);</span><br><span class="line">  toRaw.<span class="title function_">set</span>(observed, target);</span><br><span class="line">  <span class="comment">// 上面讲到了 targetMap 的作用，这里是创建默认依赖追踪集合</span></span><br><span class="line">  <span class="keyword">if</span> (!targetMap.<span class="title function_">has</span>(target)) {</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, <span class="keyword">new</span> <span class="title class_">Map</span>());</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> observed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到：</p><ul><li>目前来看 <code>reactive</code> 和 <code>readonly</code> 的区别仅有两点：映射关系存储集合不同 and <code>proxy handler</code> 不同</li><li><code>object``array</code> 和集合类型 <code>Set``Map``WeakSet``WeakMap</code> 的 <code>proxy handler</code> 是不同的</li></ul><p>所以下面再来依次看下响应式核心中的核心 - 各种 <code>proxy handler</code></p><h2 id="baseHandler"><a href="#baseHandler" class="headerlink" title="baseHandler"></a>baseHandler</h2><p>方法跟上面一样，先看依赖：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面讲过，不过现在来看感觉像是是在 get set 这些 trap 方法里会调用</span></span><br><span class="line"><span class="keyword">import</span> { reactive, readonly, toRaw } <span class="keyword">from</span> <span class="string">"./reactive"</span>;</span><br><span class="line"><span class="comment">// 操作类型枚举，对应于 proxy handler 里的 trap 方法</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">OperationTypes</span> } <span class="keyword">from</span> <span class="string">"./operations"</span>;</span><br><span class="line"><span class="comment">// 依赖收集和触发依赖回调</span></span><br><span class="line"><span class="keyword">import</span> { track, trigger } <span class="keyword">from</span> <span class="string">"./effect"</span>;</span><br><span class="line"><span class="comment">// 全局锁，用来禁止 set 和 delete</span></span><br><span class="line"><span class="keyword">import</span> { <span class="variable constant_">LOCKED</span> } <span class="keyword">from</span> <span class="string">"./lock"</span>;</span><br><span class="line"><span class="comment">// 工具方法，类型判断</span></span><br><span class="line"><span class="keyword">import</span> { isObject, hasOwn, isSymbol } <span class="keyword">from</span> <span class="string">"@vue/shared"</span>;</span><br><span class="line"><span class="comment">// 判断是否是 ref，后面会讲到</span></span><br><span class="line"><span class="keyword">import</span> { isRef } <span class="keyword">from</span> <span class="string">"./ref"</span>;</span><br></pre></td></tr></tbody></table></figure><p>这里有两个疑问：</p><ol><li><code>track</code> 和 <code>trigger</code> 的实现</li><li><code>LOCKED</code> 的作用？为什么会有这个全局锁？</li></ol><p>问题 1 在后面的 <code>effect</code> 部分会讲到，现在只需要知道是用来追踪依赖和触发依赖回调方法就行</p><p>问题 2 现在我也不是特别了解，只知道是在组件 <code>mount</code> 和 <code>update</code> 的时候会对组件的 <code>props</code>的代理进行修改，因为我们都知道单向数据流中，子组件内部是不能更改 <code>props</code> 的，但是子组件更新，进行 vnode patch 后需要更新子组件的 <code>props</code>，包括一些动态 <code>props</code></p><p>再来看下变量和方法概览：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS 内部语言行为描述符集合，比如 Symbol.iterator 这些，在 get 里会用到</span></span><br><span class="line"><span class="keyword">const</span> builtInSymbols = <span class="keyword">new</span> <span class="title class_">Set</span>(</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Symbol</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">key</span> =&gt;</span> (<span class="title class_">Symbol</span> <span class="keyword">as</span> any)[key])</span><br><span class="line">    .<span class="title function_">filter</span>(isSymbol)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly: boolean</span>) {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  key: string | symbol,</span></span><br><span class="line"><span class="params">  value: any,</span></span><br><span class="line"><span class="params">  receiver: any</span></span><br><span class="line"><span class="params"></span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteProperty</span>(<span class="params">target: any, key: string | symbol</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params">target: any, key: string | symbol</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ownKeys</span>(<span class="params">target: any</span>): (string | number | symbol)[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;any&gt; = {</span><br><span class="line">  <span class="attr">get</span>: <span class="title function_">createGetter</span>(<span class="literal">false</span>),</span><br><span class="line">  set,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">readonlyHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;any&gt; = {</span><br><span class="line">  <span class="attr">get</span>: <span class="title function_">createGetter</span>(<span class="literal">true</span>),</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="attr">target</span>: any, <span class="attr">key</span>: string | symbol, <span class="attr">value</span>: any, <span class="attr">receiver</span>: any): boolean {</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable constant_">LOCKED</span>) {</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Set operation on key "<span class="subst">${<span class="built_in">String</span>(key)}</span>" failed: target is readonly.`</span>,</span><br><span class="line">          target</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="attr">target</span>: any, <span class="attr">key</span>: string | symbol): boolean {</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable constant_">LOCKED</span>) {</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Delete operation on key "<span class="subst">${<span class="built_in">String</span>(</span></span></span><br><span class="line"><span class="subst"><span class="string">            key</span></span></span><br><span class="line"><span class="subst"><span class="string">          )}</span>" failed: target is readonly.`</span>,</span><br><span class="line">          target</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，<code>mutableHandlers</code> 和 <code>readonlyHandlers</code> 都是定义了 5 个 trap 方法：<code>get</code>、<code>set</code>、<code>deleteProperty</code>、<code>has</code>、<code>ownKeys</code>，前 3 个不用多家介绍，<code>has</code> trap 针对与 <code>in</code> 操作符，而 <code>ownKeys</code> 针对于 <code>for in</code> 和 <code>Object.keys</code> 这些遍历操作的</p><p>而 <code>readonlyHandlers</code> 相比于 <code>mutableHandlers</code> 其实只是在 <code>get</code>、<code>set</code> 和 <code>deleteProperty</code> 这三个 trap 方法里有区别，而对于可能改变数据的 <code>set</code> 和 <code>deleteProperty</code> 方法，则是利用 <code>LOCKED</code> 来锁定，不让修改数据，这个变量我在上面也提了一下</p><p>下面来一个一个的看下各个 trap 方法</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 get trap 方法</span></span><br><span class="line"><span class="comment">// 如果是可变数据， isReadonly 是 false</span></span><br><span class="line"><span class="comment">// 如果是只读数据，那么 isReadonly 就是 true</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly: boolean</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: any, key: string | symbol, receiver: any</span>) {</span><br><span class="line">    <span class="comment">// 利用 Reflect 反射来获取原始值</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">    <span class="comment">// 如果是 JS 内置方法，不进行依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) &amp;&amp; builtInSymbols.<span class="title function_">has</span>(key)) {</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果是 ref 类型数据，则直接返回其 value</span></span><br><span class="line">    <span class="comment">// TODO 后面 ref 部分我们会讲到，ref(target) 其实在 get value 的时候做了依赖收集了，</span></span><br><span class="line">    <span class="comment">// 就不需要下面重复收集依赖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) {</span><br><span class="line">      <span class="keyword">return</span> res.<span class="property">value</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 类型操作的依赖收集</span></span><br><span class="line">    <span class="title function_">track</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">GET</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里其实很简单就是递归返回响应式对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isObject</span>(res)</span><br><span class="line">      ? isReadonly</span><br><span class="line">        ? <span class="comment">// need to lazy access readonly and reactive here to avoid</span></span><br><span class="line">          <span class="comment">// circular dependency</span></span><br><span class="line">          <span class="title function_">readonly</span>(res)</span><br><span class="line">        : <span class="title function_">reactive</span>(res)</span><br><span class="line">      : res;</span><br><span class="line">  };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看完 <code>get trap</code> 其实很简单，但是也会有写疑问：</p><h3 id="1-为什么用-Reflect-get，而不是直接-target-key-返回呢"><a href="#1-为什么用-Reflect-get，而不是直接-target-key-返回呢" class="headerlink" title="1. 为什么用 Reflect.get，而不是直接 target[key] 返回呢?"></a>1. 为什么用 <code>Reflect.get</code>，而不是直接 <code>target[key]</code> 返回呢?</h3><p>我们可以看它的第三个参数：</p><blockquote><p>receiver：如果 target 对象中指定了 getter，receiver 则为 getter 调用时的 this 值</p></blockquote><p>举个例子：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() {</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observed = <span class="title function_">reactive</span>(target);</span><br></pre></td></tr></tbody></table></figure><p>此时，如果不用 <code>Reflect.get</code>，而是 <code>target[key]</code>，那么 <code>this.foo</code> 中的 <code>this</code> 就指向的是 <code>target</code>，而不是 <code>observed</code>，此时 <code>this.foo</code> 就不能收集到 <code>foo</code> 的依赖了，如果 <code>observed.foo = 20</code> 改变了 foo 的值，那么是无法触发依赖回调的，所以需要利用 <code>Reflect.get</code> 将 getter 里的 <code>this</code> 指向代理对象</p><h3 id="2-为什么在结尾-return-的时候还要调用-reactive-或者-readoonly-呢？"><a href="#2-为什么在结尾-return-的时候还要调用-reactive-或者-readoonly-呢？" class="headerlink" title="2. 为什么在结尾 return 的时候还要调用 reactive 或者 readoonly 呢？"></a>2. 为什么在结尾 return 的时候还要调用 <code>reactive</code> 或者 <code>readoonly</code> 呢？</h3><p>原注释是这样写的：</p><blockquote><p>need to lazy access readonly and reactive here to avoid circular dependency<br>翻译过来是：需要延迟地使用 readonly 和 readtive 来避免循环引用</p></blockquote><p>为什么这样说呢？这里不得不说一下 <code>Proxy</code> 的特性：只能代理一层，对于嵌套的深层对象，如果不按源码中的方法，那就需要一层层递归来代理劫持对象，即每次递归都判断是否是对象，如果是对象，那么再调用 <code>reactive</code> 来响应式化</p><p>但是问题又来了，JS 里是有循环引用这个概念的，就像下面这样：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = {</span><br><span class="line">  <span class="attr">b</span>: {},</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">a.<span class="property">b</span>.<span class="property">c</span> = a;</span><br></pre></td></tr></tbody></table></figure><p>这样的话，如果每次递归调用 <code>reactive</code> 的话，会造成调用栈溢出 <code>Maximum call stack size exceeded</code>，但是我们只需要加上一个判断条件即可解决，在上面解析的 <code>createReactiveObject</code> 方法里我们知道如果原始数据已经被观察过，则直接返回对应的响应式数据，那么我们可以在递归调用 <code>reactive</code> 的时候判断 <code>toProxy.get(target)</code> 是否存在，如果存在就不往下递归了，我写了一个例子代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环引用对象</span></span><br><span class="line"><span class="keyword">const</span> target = { <span class="attr">b</span>: { <span class="attr">c</span>: <span class="number">1</span> } };</span><br><span class="line">target.<span class="property">b</span>.<span class="property">d</span> = target;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是上面讲的 原始数据 -&gt; 响应式数据的集合</span></span><br><span class="line"><span class="keyword">const</span> rawToReactive = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">data</span>) {</span><br><span class="line">  <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, {</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) {</span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">      <span class="keyword">const</span> observed = rawToReactive.<span class="title function_">get</span>(res);</span><br><span class="line">      <span class="keyword">return</span> observed || res;</span><br><span class="line">    },</span><br><span class="line">  });</span><br><span class="line">  rawToReactive.<span class="title function_">set</span>(data, observed);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) {</span><br><span class="line">    <span class="keyword">const</span> child = data[key];</span><br><span class="line">    <span class="comment">// 这里判断如果没有被观察过，那么继续 reactive 递归观察</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">"object"</span> &amp;&amp; !rawToReactive.<span class="title function_">get</span>(child)) {</span><br><span class="line">      <span class="title function_">reactive</span>(child);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> observed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title function_">reactive</span>(target);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">b</span>.<span class="property">d</span>.<span class="property">b</span>); <span class="comment">// Proxy {c: 1, d: {…}}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我试了一下。跟源码里的 reactive 的 get 结果是一样的</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>可以去看下我在 <a href="https://zhuanlan.zhihu.com/p/87409653">vue3 响应式源码解析-Reactive 篇</a> 这篇文章下的评论部分</p></blockquote><p>而源码中的 <code>lazy access</code> 方式很取巧，只代理一层，当用到某个属性值对象时，再进行响应式观察这一层</p><p>所以相比于初始化时递归劫持，延迟访问劫持的方式更能<strong>提升初始化性能</strong>，也有利于对数据劫持做更细的控制，特别是针对于数据对象比较大时（比如接口返回数据嵌套过深），有些数据并非需要劫持，所以按需劫持代理我们用到的数据这种方式更好</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  key: string | symbol,</span></span><br><span class="line"><span class="params">  value: any,</span></span><br><span class="line"><span class="params">  receiver: any</span></span><br><span class="line"><span class="params"></span>): boolean {</span><br><span class="line">  <span class="comment">// 如果是观察过响应式数据，那么获取它映射的原始数据</span></span><br><span class="line">  value = <span class="title function_">toRaw</span>(value);</span><br><span class="line">  <span class="comment">// 获取旧值</span></span><br><span class="line">  <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">  <span class="comment">// 如果旧值是 ref 类型数据，而新的值不是 ref，那么直接赋值给 oldValue.value</span></span><br><span class="line">  <span class="comment">// 因为 ref 数据在 set value 的时候就已经 trigger 依赖了，所以直接 return 就行</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) {</span><br><span class="line">    oldValue.<span class="property">value</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 对象上是否有这个 key，有则是 set，无则是 add</span></span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line">  <span class="comment">// 利用 Reflect 来执行 set 操作</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">  <span class="comment">// don't trigger if target is something up in the prototype chain of original</span></span><br><span class="line">  <span class="comment">// 如果 target 原型链上的数据，那么就不触发依赖回调</span></span><br><span class="line">  <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) {</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">      <span class="comment">// 开发环境操作，只比正式环境多了个 extraInfo 的调试信息</span></span><br><span class="line">      <span class="keyword">const</span> extraInfo = { oldValue, <span class="attr">newValue</span>: value };</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) {</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">ADD</span>, key, extraInfo);</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (value !== oldValue) {</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">SET</span>, key, extraInfo);</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 上面讲过，有这个 key 则是 set，无则是 add</span></span><br><span class="line">      <span class="keyword">if</span> (!hadKey) {</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">ADD</span>, key);</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (value !== oldValue) {</span><br><span class="line">        <span class="comment">// 只有当 value 改变的时候才触发</span></span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">SET</span>, key);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同样，<code>set trap</code> 看起来也很简单，但是同时也会有一些问题：</p><h3 id="1-target-toRaw-receiver-是什么鬼逻辑"><a href="#1-target-toRaw-receiver-是什么鬼逻辑" class="headerlink" title="1. target === toRaw(receiver) 是什么鬼逻辑?"></a>1. <code>target === toRaw(receiver)</code> 是什么鬼逻辑?</h3><p>首先看下</p><p><a href="https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set%23%E5%8F%82%E6%95%B0">handler.set()developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set#%E5%8F%82%E6%95%B0<img src="https://pic4.zhimg.com/v2-72382e605ce3eba8154aa310a712c403_ipico.jpg" alt="img"></a></p><p>的关于第三个参数的说明：</p><blockquote><p>最初被调用的对象。通常是 proxy 本身，但 handler 的 set 方法也有可能在原型链上或以其他方式被间接地调用（因此不一定是 proxy 本身）。<br>比如，假设有一段代码执行 obj.name = “jen”，obj 不是一个 proxy 且自身不含 name 属性，但它的原型链上有一个 proxy，那么那个 proxy 的 set 拦截函数会被调用，此时 obj 会作为 receiver 参数传进来</p></blockquote><p>上面已经给出例子了，这里我再写一下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child = { <span class="attr">name</span>: <span class="string">"child"</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">"parent"</span> },</span><br><span class="line">  {</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(target, receiver);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(child, parent);</span><br><span class="line"></span><br><span class="line">child.<span class="property">foo</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会打印出</span></span><br><span class="line"><span class="comment">// {name: "parent"} {name: "child"}</span></span><br></pre></td></tr></tbody></table></figure><p>这里有两个先决条件：</p><ol><li>child 的原型链是一个 Proxy</li><li>child 在设置值的时候，本身不包含 key 的</li></ol><p>可以看到，当满足上面两个条件的时候，设置 child 的值，会触发原型链上的 <code>set trap</code> 方法，并且 <code>target</code> 是原型链数据，而 <code>receiver</code> 则是真实数据</p><p>所以，源码中的那个条件逻辑也就不难看懂了，当满足上述两个条件时，我们当然不希望触发 parent 的 <code>set trap</code> 了</p><h3 id="2-像数组的-unshift，splice-这些操作是如何触发-set-trap方法的呢？"><a href="#2-像数组的-unshift，splice-这些操作是如何触发-set-trap方法的呢？" class="headerlink" title="2. 像数组的 unshift，splice 这些操作是如何触发 set trap方法的呢？"></a>2. 像数组的 <code>unshift</code>，<code>splice</code> 这些操作是如何触发 <code>set trap</code>方法的呢？</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 set 里加上这么一个 log</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  !hadKey ? <span class="string">"add"</span> : value !== oldValue ? <span class="string">"set"</span> : <span class="string">"unknow"</span>,</span><br><span class="line">  target,</span><br><span class="line">  key,</span><br><span class="line">  value,</span><br><span class="line">  oldValue</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>然后</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">a.<span class="title function_">unshift</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会打印</span></span><br><span class="line"><span class="comment">// add [1, 2, 3, 3] 3 3 undefined</span></span><br><span class="line"><span class="comment">// set [1, 2, 2, 3] 2 2 3</span></span><br><span class="line"><span class="comment">// set [1, 1, 2, 3] 1 1 2</span></span><br><span class="line"><span class="comment">// set [0, 1, 2, 3] 0 0 1</span></span><br><span class="line"><span class="comment">// unknow [0, 1, 2, 3] length 4 4</span></span><br></pre></td></tr></tbody></table></figure><p>一共打印了 5 次，根据打印内容我们可以看到 <code>unshift</code> 的实际操作过程，即把数组的每一项依次都往后移动一位，然后再把首位设置成 <code>0</code>，至于为什么这么操作，</p><p><a href="https://link.zhihu.com/?target=https://www.ecma-international.org/ecma-262/6.0/%23sec-array.prototype.unshift">ECMA-262 Array.property.unshiftwww.ecma-international.org/ecma-262/6.0/#sec-array.prototype.unshift</a></p><p>标准中有原理介绍，我就不赘述了，还有像 <code>shift</code> 和 <code>splice</code> 也是一样的操作步骤</p><p>可以看到 <code>unshift</code> 或者 <code>splice</code> 是会带来多次的 <code>trigger</code> 的，当然这些会有批量跟新优化的，有时间我再展开讲一下</p><p>细心的同学可能会发现，还触发了 <code>length</code> 属性的 set，而且 <code>value</code> 和 <code>oldValue</code> 是一样的，那么根据源码所示，就不会触发 set 类型的回调了呀，那我们如果在 template 里用到了 <code>a.length</code> 那也不会更新了么？</p><p>肯定是会更新的，解决办法就在 <code>trigger</code> 这个方法里，后续 <code>effect</code> 部分会讲到，先简单说一下，对于会导致数组 <code>length</code> 改变的操作，比如 add 和 delete，在 <code>effect</code> 的 <code>trigger</code> 方法里会单独处理，来触发 <code>length</code> 属性的依赖回调的</p><h3 id="其他-trap-方法"><a href="#其他-trap-方法" class="headerlink" title="其他 trap 方法"></a>其他 trap 方法</h3><p>还有 <code>deleteProperty</code>、<code>has</code> 和 <code>ownKeys</code> 这几个 trap，代码不多，都很简单，直接看下面的源码就能明白，我就不在赘述了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deleteProperty trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteProperty</span>(<span class="params">target: any, key: string | symbol</span>): boolean {</span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line">  <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key);</span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; hadKey) {</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">      <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">DELETE</span>, key, { oldValue });</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">DELETE</span>, key);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// has trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params">target: any, key: string | symbol</span>): boolean {</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, key);</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">HAS</span>, key);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ownKey trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ownKeys</span>(<span class="params">target: any</span>): (string | number | symbol)[] {</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">ITERATE</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>baseHandler</code> 是针对于数组和对象类型的数据的 proxy handler</li><li>每个 <code>trap</code> 方法都是用 <code>Reflect</code> 来反射到原始数据上的</li><li>对于 <code>get</code>、<code>has</code> 和 <code>ownKeys</code> 这一类读操作，会进行 <code>track</code> 来收集依赖，而对于 <code>set</code> 和 <code>deleteProperty</code> 这类写操作，则是会进行 <code>trigger</code> 来触发依赖回调</li><li>响应式数据的读取是 <code>lazy</code> 的，即初始化的时候不会对嵌套对象全盘观察，而是只有用到了每个值才会生成对应的响应式数据</li></ul><h2 id="collectionHandler"><a href="#collectionHandler" class="headerlink" title="collectionHandler"></a>collectionHandler</h2><p>还记得我们在看 <code>reactive</code> 方法那里有个 <code>collectionTypes</code> 的判断对吧，<code>collectionHandler</code> 就是专门来处理 <code>Set|Map|WeakSet|WeakMap</code> 这类集合类型数据的</p><p>这里可以参考相学长的</p><p><a href="https://link.zhihu.com/?target=https://juejin.im/post/5da9d7ebf265da5bbb1e52b7%23heading-12">vue3 响应式源码解析-Reactive 篇 - 掘金 juejin.im/post/5da9d7ebf265da5bbb1e52b7#heading-12</a></p><p>这篇文章，写的很详细，我这里也不再赘述了</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>最开始阅读 <code>reactive</code> 源码时，总体的逻辑是比较清晰的，但是仍然有几个地方当时有疑惑：</p><ul><li><code>rawToReactive|rawToReadonly</code> 等这几个变量是干嘛的？</li><li><code>targetMap</code> 的是干什么的？为什么是 <code>WeakMap&lt;any, KeyToDepMap&gt;</code> 类型</li><li><code>LOCKED</code> 是用来干嘛的?</li><li><code>baseHandler</code> 的 <code>get trap</code> 为什么又返回了一个 <code>reactive(res)</code>？</li><li><code>collectionHandler</code> 里的 trap 方法为什么只有 <code>get</code>？为什么跟 <code>baseHandler</code> 不一样？</li></ul><p>在读完源码后，除了 <code>LOCKED</code> 那个疑惑，其他几个问题我都已经找到答案，并且也在上面解惑了，我相信大家看完这篇文章后也应该都有自己的答案了</p><p>最后再来个源码里的知识点总结吧：</p><ul><li><code>reactive</code> 是利用 <code>Proxy</code> 来进行数据观察，<code>Reflect</code> 相关操作来反射到原始数据的，并且数据的访问是一个 <code>lazy reactive</code> 方式，即按需观察</li><li>普通对象、数组和集合类型数据的代理 handler 是不同的，这是因为 <code>Proxy</code> 的一些限制，参考</li></ul><p><a href="https://link.zhihu.com/?target=https://javascript.info/proxy%23proxy-limitations">Proxy and Reflectjavascript.info/proxy#proxy-limitations<img src="https://pic4.zhimg.com/v2-371dd24f02bbb7f17ea00a910ff8f70b_180x120.jpg" alt="img"></a></p><ul><li>利用几个 <code>WeakMap</code> 来存储原始数据 &lt;-&gt; 响应式数据的双向映射关系，以便在响应式入口方法里判断是否原始数据已经被观察过，这个相比于 Vue2 的直接在原始数据上挂载 <code>__ob__</code>要少一些冗余数据，并且由于 <code>WeakMap</code> 的 GC 特性，在运行时会有一定的内存优化</li><li>响应式数据的读操作会 <code>track</code> 来收集依赖，写操作则是会 <code>trigger</code> 来触发依赖回调</li></ul><p>整个 <code>reactive|readonly</code> 的流程如下：</p><p><img src="https://pic3.zhimg.com/80/v2-849f116c5d6f242c776ab5b8d610ee1a_720w.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 原理 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目优化</title>
      <link href="/2022/04/09/xing-neng-you-hua/"/>
      <url>/2022/04/09/xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="页面内容的呈现过程"><a href="#页面内容的呈现过程" class="headerlink" title="页面内容的呈现过程"></a>页面内容的呈现过程</h1><h2 id="页面的首屏加载性能-白屏时间是否过长？"><a href="#页面的首屏加载性能-白屏时间是否过长？" class="headerlink" title="页面的首屏加载性能 白屏时间是否过长？"></a>页面的首屏加载性能 白屏时间是否过长？</h2><h2 id="页面加载时的-loading-动画-是否需要骨架屏-骨架屏消失时使得否存在页面抖动"><a href="#页面加载时的-loading-动画-是否需要骨架屏-骨架屏消失时使得否存在页面抖动" class="headerlink" title="页面加载时的 loading 动画 是否需要骨架屏 骨架屏消失时使得否存在页面抖动"></a>页面加载时的 loading 动画 是否需要骨架屏 骨架屏消失时使得否存在页面抖动</h2><h2 id="数据为空时-页面模块的占位方式-数据返回时-是否会出现页面抖动"><a href="#数据为空时-页面模块的占位方式-数据返回时-是否会出现页面抖动" class="headerlink" title="数据为空时 页面模块的占位方式 数据返回时 是否会出现页面抖动"></a>数据为空时 页面模块的占位方式 数据返回时 是否会出现页面抖动</h2><h2 id="页面异常处理时-是否提供了合理的用户反馈"><a href="#页面异常处理时-是否提供了合理的用户反馈" class="headerlink" title="页面异常处理时 是否提供了合理的用户反馈"></a>页面异常处理时 是否提供了合理的用户反馈</h2><h2 id="页面适配-对于不同尺寸的设备-是否都能保证主要内容的首屏透出"><a href="#页面适配-对于不同尺寸的设备-是否都能保证主要内容的首屏透出" class="headerlink" title="页面适配 对于不同尺寸的设备 是否都能保证主要内容的首屏透出"></a>页面适配 对于不同尺寸的设备 是否都能保证主要内容的首屏透出</h2><h2 id="文本超长时是做阶段还是省略处理"><a href="#文本超长时是做阶段还是省略处理" class="headerlink" title="文本超长时是做阶段还是省略处理"></a>文本超长时是做阶段还是省略处理</h2><h2 id="图片加载时如何占位-加载失败时如何处理-是否需要做缩放处理"><a href="#图片加载时如何占位-加载失败时如何处理-是否需要做缩放处理" class="headerlink" title="图片加载时如何占位 加载失败时如何处理 是否需要做缩放处理"></a>图片加载时如何占位 加载失败时如何处理 是否需要做缩放处理</h2><h2 id="页面变化时是否有合理的过渡和动画"><a href="#页面变化时是否有合理的过渡和动画" class="headerlink" title="页面变化时是否有合理的过渡和动画"></a>页面变化时是否有合理的过渡和动画</h2><h1 id="页面交互的体验细节"><a href="#页面交互的体验细节" class="headerlink" title="页面交互的体验细节"></a>页面交互的体验细节</h1><h2 id="用户操作的响应性时间是否过长"><a href="#用户操作的响应性时间是否过长" class="headerlink" title="用户操作的响应性时间是否过长"></a>用户操作的响应性时间是否过长</h2><h2 id="按钮的点击区域是否合理"><a href="#按钮的点击区域是否合理" class="headerlink" title="按钮的点击区域是否合理"></a>按钮的点击区域是否合理</h2><h2 id="文字长按是否可以选中"><a href="#文字长按是否可以选中" class="headerlink" title="文字长按是否可以选中"></a>文字长按是否可以选中</h2><h2 id="页面滚动是否需要滚动栏"><a href="#页面滚动是否需要滚动栏" class="headerlink" title="页面滚动是否需要滚动栏"></a>页面滚动是否需要滚动栏</h2><h2 id="页面浮层是否存在点击或滚动穿透"><a href="#页面浮层是否存在点击或滚动穿透" class="headerlink" title="页面浮层是否存在点击或滚动穿透"></a>页面浮层是否存在点击或滚动穿透</h2><h2 id="图片长按是否可以保存"><a href="#图片长按是否可以保存" class="headerlink" title="图片长按是否可以保存"></a>图片长按是否可以保存</h2><h1 id="页面的可访问性"><a href="#页面的可访问性" class="headerlink" title="页面的可访问性"></a>页面的可访问性</h1>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带你剖析设计模式</title>
      <link href="/2022/04/09/qian-tan-she-ji-mo-shi/"/>
      <url>/2022/04/09/qian-tan-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态的思想是把”做什么”和“谁去做”分开来</p><p><strong>多态最根本的作用是通过过程化的条件分支语句转化为对象的多态性 从而消除这些条件分支语句</strong></p><p>将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//不用多态的版本</span><br><span class="line">var googleMap = {</span><br><span class="line"> show: function(){</span><br><span class="line"> console.log( '开始渲染谷歌地图' );</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var baiduMap = {</span><br><span class="line"> show: function(){</span><br><span class="line"> console.log( '开始渲染百度地图' );</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var renderMap = function( type ){</span><br><span class="line"> if ( type === 'google' ){</span><br><span class="line"> googleMap.show();</span><br><span class="line"> }else if ( type === 'baidu' ){</span><br><span class="line"> baiduMap.show();</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">renderMap( 'google' ); // 输出：开始渲染谷歌地图</span><br><span class="line">renderMap( 'baidu' ); // 输出：开始渲染百度地图</span><br><span class="line">//不断地在renderMap中堆砌条件分支语句 导致代码臃肿</span><br><span class="line">var renderMap = function( map ){</span><br><span class="line"> if ( map.show instanceof Function ){</span><br><span class="line"> map.show();</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">//使用多态 只需要关注发出show的动作 不必关心是谁的show做什么动作</span><br></pre></td></tr></tbody></table></figure><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><ul><li>所有数据都是对象</li><li>要得到一个对象 不是通过实例化一个类 而是找到一个对象并作为原型克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求 就会把这个请求委托给它自己的原型</li></ul><h1 id="this、call、apply"><a href="#this、call、apply" class="headerlink" title="this、call、apply"></a>this、call、apply</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this 总是指向一个对象 而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的 而非函数声明的环境</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>使用闭包的同时容易形成循环引用 如果闭包的作用域链中存在一些 DMO 节点 就可能造成内存泄漏</p><p>要解决循环引用带来的内存泄露问题 只需要讲循环引用中的变量设为 null 即可</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证一个类仅有一个实例 并提供一个访问它的全局访问点 <strong>即单例模式的核心是确保只有一个实例并提供全局访问</strong></p><p>作为开发者应该尽量减少全局变量的使用 可以使用闭包封装私有变量来避免对全局的命令污染</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user = (function(){</span><br><span class="line"> var __name = 'sven',</span><br><span class="line"> __age = 29;</span><br><span class="line"> return {</span><br><span class="line"> getUserInfo: function(){</span><br><span class="line"> return __name + '-' + __age;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>定义：定义一系列的算法 把它们一个一个封装起来 并且使它们可以互相替换 <strong>目的是将算法的使用与算法的实现分离开来</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var strategies = {</span><br><span class="line"> "S": function( salary ){</span><br><span class="line"> return salary * 4;</span><br><span class="line"> },</span><br><span class="line"> "A": function( salary ){</span><br><span class="line"> return salary * 3;</span><br><span class="line"> },</span><br><span class="line"> "B": function( salary ){</span><br><span class="line"> return salary * 2;</span><br><span class="line">图灵社区会员 轩辕 专享 尊重版权</span><br><span class="line">76 第 5 章 策略模式</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var calculateBonus = function( level, salary ){</span><br><span class="line"> return strategies[ level ]( salary );</span><br><span class="line">};</span><br><span class="line">console.log( calculateBonus( 'S', 20000 ) ); // 输出：80000</span><br><span class="line">console.log( calculateBonus( 'A', 10000 ) ); // 输出：30000</span><br></pre></td></tr></tbody></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>保护代理：代理可以帮助过滤掉一些请求</p><p>虚拟代理：虚拟代理把一些开销很大的对象延迟到真正需要它的时候才去创建</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">虚拟代理：</span><br><span class="line">var myImage = (function(){</span><br><span class="line"> var imgNode = document.createElement( 'img' );</span><br><span class="line"> document.body.appendChild( imgNode );</span><br><span class="line"> return {</span><br><span class="line"> setSrc: function( src ){</span><br><span class="line"> imgNode.src = src;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">var proxyImage = (function(){</span><br><span class="line"> var img = new Image;</span><br><span class="line"> img.onload = function(){</span><br><span class="line"> myImage.setSrc( this.src );</span><br><span class="line"> }</span><br><span class="line"> return {</span><br><span class="line"> setSrc: function( src ){</span><br><span class="line"> myImage.setSrc( 'file:// /C:/Users/svenzeng/Desktop/loading.gif' );</span><br><span class="line"> img.src = src;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">proxyImage.setSrc( 'http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg' );</span><br><span class="line">//加载中用一张本地图片 加载后才替换为对应url</span><br></pre></td></tr></tbody></table></figure><p>单一职责原则：一个类（通常包括对象和函数等）而言，应该仅有一个引起它变化的原因 如果一个对象承担的职责过多 就会导致脆弱和低内聚</p><p>**代理和本体应该拥有一样的主要逻辑功能 这样用户可以在不需要用到代理的时候直接将请求对象改成本体而无需修改本体的代码 **</p><p><strong>虚拟代理合并 http 请求</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">需求场景：同步文件 如果短时间内连续发送请求会导致服务器压力太大 可以设置代理函数收集一段时间内的请求最后一次性发送给服务器 除非是对实时性要求高的系统 不然延迟都不会带来太大的副作用却可以大大减轻服务器的压力</span><br><span class="line">var synchronousFile = function( id ){</span><br><span class="line"> console.log( '开始同步文件，id 为: ' + id );</span><br><span class="line">};</span><br><span class="line">var proxySynchronousFile = (function(){</span><br><span class="line"> var cache = [], // 保存一段时间内需要同步的 ID</span><br><span class="line"> timer; // 定时器</span><br><span class="line"> return function( id ){</span><br><span class="line"> cache.push( id );</span><br><span class="line"> if ( timer ){ // 保证不会覆盖已经启动的定时器</span><br><span class="line"> return;</span><br><span class="line"> }</span><br><span class="line"> timer = setTimeout(function(){</span><br><span class="line"> synchronousFile( cache.join( ',' ) ); // 2 秒后向本体发送需要同步的 ID 集合</span><br><span class="line"> clearTimeout( timer ); // 清空定时器</span><br><span class="line"> timer = null;</span><br><span class="line"> cache.length = 0; // 清空 ID 集合</span><br><span class="line"> }, 2000 );</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">var checkbox = document.getElementsByTagName( 'input' );</span><br><span class="line">for ( var i = 0, c; c = checkbox[ i++ ]; ){</span><br><span class="line">c.onclick = function(){</span><br><span class="line"> if ( this.checked === true ){</span><br><span class="line"> proxySynchronousFile( this.id );</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>缓存代理可以为一些开销很大的运算结果提供暂时的储存 在下次运算时 如果传递进来的参数跟之前的一样 就可以直接返回之前的计算结果</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">先创建一个用于求乘积的函数：</span><br><span class="line">var mult = function(){</span><br><span class="line"> console.log( '开始计算乘积' );</span><br><span class="line"> var a = 1;</span><br><span class="line"> for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"> a = a * arguments[i];</span><br><span class="line"> }</span><br><span class="line"> return a;</span><br><span class="line">};</span><br><span class="line">mult( 2, 3 ); // 输出：6</span><br><span class="line">mult( 2, 3, 4 ); // 输出：24</span><br><span class="line">现在加入缓存代理函数：</span><br><span class="line">var proxyMult = (function(){</span><br><span class="line"> var cache = {};</span><br><span class="line"> return function(){</span><br><span class="line"> var args = Array.prototype.join.call( arguments, ',' );</span><br><span class="line"> if ( args in cache ){</span><br><span class="line"> return cache[ args ];</span><br><span class="line"> }</span><br><span class="line"> return cache[ args ] = mult.apply( this, arguments );</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line"> proxyMult( 1, 2, 3, 4 ); // 输出：24</span><br><span class="line"> proxyMult( 1, 2, 3, 4 ); // 输出：24第二次并没有进行计算 而是直接返回之前计算好的结果 通过增加缓存代理的方式 mult函数可以继续专注于自身的职责-计算乘积 而缓存的功能时由代理对象实现的</span><br></pre></td></tr></tbody></table></figure><p><strong>缓存代理用于 api 请求</strong></p><p>在进行请求一些不变的数据的时候（分页需求）同一页的数据理论上只需要去后台拉取一次，这些已经拉取到的数据在某个地方被缓存之后 下次再请求同一页的时候 就可以直接使用之前的数据 可以通过缓存代理实现</p><p><strong>使用高阶函数动态创建代理</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**************** 计算乘积 *****************/</span><br><span class="line">var mult = function(){</span><br><span class="line"> var a = 1;</span><br><span class="line"> for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"> a = a * arguments[i];</span><br><span class="line"> }</span><br><span class="line"> return a;</span><br><span class="line">};</span><br><span class="line">/**************** 计算加和 *****************/</span><br><span class="line">var plus = function(){</span><br><span class="line"> var a = 0;</span><br><span class="line"> for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"> a = a + arguments[i];</span><br><span class="line"> }</span><br><span class="line"> return a;</span><br><span class="line">};</span><br><span class="line">/**************** 创建缓存代理的工厂 *****************/</span><br><span class="line">var createProxyFactory = function( fn ){</span><br><span class="line"> var cache = {};</span><br><span class="line"> return function(){</span><br><span class="line"> var args = Array.prototype.join.call( arguments, ',' );</span><br><span class="line"> if ( args in cache ){</span><br><span class="line"> return cache[ args ];</span><br><span class="line"> }</span><br><span class="line"> return cache[ args ] = fn.apply( this, arguments );</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var proxyMult = createProxyFactory( mult ),</span><br><span class="line">proxyPlus = createProxyFactory( plus );</span><br><span class="line">alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24</span><br><span class="line">alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24</span><br><span class="line">alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10</span><br><span class="line">alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10</span><br></pre></td></tr></tbody></table></figure><p>tips：编写业务的时候往往不需要预先去猜测是否需要使用代理模式 当真正发现不方便的时候直接访问某个对象的时候 再编写代理也不迟</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象 的内部表示</p><h1 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h1><p>发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状 态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型 来替代传统的发布—订阅模式。</p><p><strong>发布-订阅模式可以广泛用于异步编程中 是一种可以代替回调函数的方案 在异步编程中使用发布-订阅模式 我们就无需过多关注对象在一异步运行期间的内部状态 而只需要订阅感兴趣的事件发生点</strong></p><p><strong>发布-订阅模式可以取代对象之间的硬编码的通知方式 一个对象不再显式地调用另一个对象的某个接口实现松耦合 可以单独对订阅者和发布者做修改而不用去修改其引用</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">发布-订阅模式的步骤</span><br><span class="line">1.首先要指定谁充当发布者</span><br><span class="line">2.然后给发布者添加一个缓存列表 用于存放回调函数以便通知订阅者</span><br><span class="line">3.最后在发布消息的时候 发布者会遍历这个缓存列表 依次触发里面存放的订阅者函数 另外 可以往回调函数中加入一些参数 订阅者可以接收参数 这很有必要</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">var event = {</span><br><span class="line"> clientList: [],</span><br><span class="line"> listen: function( key, fn ){</span><br><span class="line"> if ( !this.clientList[ key ] ){</span><br><span class="line"> this.clientList[ key ] = [];</span><br><span class="line"> }</span><br><span class="line"> this.clientList[ key ].push( fn ); // 订阅的消息添加进缓存列表</span><br><span class="line"> },</span><br><span class="line"> trigger: function(){</span><br><span class="line"> var key = Array.prototype.shift.call( arguments ), // (1);</span><br><span class="line"> fns = this.clientList[ key ];</span><br><span class="line"> if ( !fns || fns.length === 0 ){ // 如果没有绑定对应的消息</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> for( var i = 0, fn; fn = fns[ i++ ]; ){</span><br><span class="line"> fn.apply( this, arguments ); // (2) // arguments 是 trigger 时带上的参数</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布—订阅功能：</span><br><span class="line">var installEvent = function( obj ){</span><br><span class="line"> for ( var i in event ){</span><br><span class="line"> obj[ i ] = event[ i ];</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">再来测试一番，我们给售楼处对象 salesOffices 动态增加发布—订阅功能：</span><br><span class="line">var salesOffices = {};</span><br><span class="line">installEvent( salesOffices );</span><br><span class="line">salesOffices.listen( 'squareMeter88', function( price ){ // 小明订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.listen( 'squareMeter100', function( price ){ // 小红订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.trigger( 'squareMeter88', 2000000 ); // 输出：2000000</span><br><span class="line">salesOffices.trigger( 'squareMeter100', 3000000 ); // 输出：3000000</span><br><span class="line">取消订阅的事件</span><br><span class="line">event.remove = function( key, fn ){</span><br><span class="line"> var fns = this.clientList[ key ];</span><br><span class="line"> if ( !fns ){ // 如果 key 对应的消息没有被人订阅，则直接返回</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> if ( !fn ){ // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅</span><br><span class="line"> fns &amp;&amp; ( fns.length = 0 );</span><br><span class="line"> }else{</span><br><span class="line"> for ( var l = fns.length - 1; l &gt;=0; l-- ){ // 反向遍历订阅的回调函数列表</span><br><span class="line"> var _fn = fns[ l ];</span><br><span class="line"> if ( _fn === fn ){</span><br><span class="line"> fns.splice( l, 1 ); // 删除订阅者的回调函数</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var salesOffices = {};</span><br><span class="line">var installEvent = function( obj ){</span><br><span class="line"> for ( var i in event ){</span><br><span class="line"> obj[ i ] = event[ i ];</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">installEvent( salesOffices );</span><br><span class="line">salesOffices.listen( 'squareMeter88', fn1 = function( price ){ // 小明订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.listen( 'squareMeter88', fn2 = function( price ){ // 小红订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.remove( 'squareMeter88', fn1 ); // 删除小明的订阅</span><br><span class="line">salesOffices.trigger( 'squareMeter88', 2000000 ); // 输出：2000000</span><br></pre></td></tr></tbody></table></figure><p><strong>全局的发布订阅模式</strong></p><p>发布订阅模式可以用一个全局的 Event 对象来实现 订阅者不需要了解消息来自哪个发布者 发布者也不知道消息会被推送给哪些订阅者 Event 作为一个类似于中介的角色把订阅者和发布者联系起来</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">var Event = (function(){</span><br><span class="line"> var clientList = {},</span><br><span class="line"> listen,</span><br><span class="line"> trigger,</span><br><span class="line"> remove;</span><br><span class="line"> listen = function( key, fn ){</span><br><span class="line"> if ( !clientList[ key ] ){</span><br><span class="line"> clientList[ key ] = [];</span><br><span class="line"> }</span><br><span class="line"> clientList[ key ].push( fn );</span><br><span class="line"> };</span><br><span class="line"> trigger = function(){</span><br><span class="line"> var key = Array.prototype.shift.call( arguments ),</span><br><span class="line"> fns = clientList[ key ];</span><br><span class="line"> if ( !fns || fns.length === 0 ){</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> for( var i = 0, fn; fn = fns[ i++ ]; ){</span><br><span class="line"> fn.apply( this, arguments );</span><br><span class="line">}</span><br><span class="line"> };</span><br><span class="line"> remove = function( key, fn ){</span><br><span class="line"> var fns = clientList[ key ];</span><br><span class="line"> if ( !fns ){</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> if ( !fn ){</span><br><span class="line"> fns &amp;&amp; ( fns.length = 0 );</span><br><span class="line"> }else{</span><br><span class="line"> for ( var l = fns.length - 1; l &gt;=0; l-- ){</span><br><span class="line"> var _fn = fns[ l ];</span><br><span class="line"> if ( _fn === fn ){</span><br><span class="line"> fns.splice( l, 1 );</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> };</span><br><span class="line"> return {</span><br><span class="line"> listen: listen,</span><br><span class="line"> trigger: trigger,</span><br><span class="line"> remove: remove</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">Event.listen( 'squareMeter88', function( price ){ // 小红订阅消息</span><br><span class="line"> console.log( '价格= ' + price ); // 输出：'价格=2000000'</span><br><span class="line">});</span><br><span class="line">Event.trigger( 'squareMeter88', 2000000 ); // 售楼处发布消息</span><br></pre></td></tr></tbody></table></figure><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的原理实现</title>
      <link href="/2022/04/09/vue-kuang-jia-jie-du-1.0/"/>
      <url>/2022/04/09/vue-kuang-jia-jie-du-1.0/</url>
      
        <content type="html"><![CDATA[<h1 id="权衡的艺术"><a href="#权衡的艺术" class="headerlink" title="权衡的艺术"></a>权衡的艺术</h1><h2 id="1-3-虚拟-dom"><a href="#1-3-虚拟-dom" class="headerlink" title="1.3 虚拟 dom"></a>1.3 虚拟 dom</h2><p>虚拟 dom 的耗时：创建 javascript 的计算量 + 创建真实 dom 的计算量 （数据变化量有关）</p><p>innerHtml 的耗时：拼接字符串的计算量 + innerHtml 的 DOM 计算量 （模板大小有关）</p><p><strong>原生 JavaScript &gt; 虚拟 dom &gt; innerHTML</strong></p><h2 id="1-4-运行和编译时"><a href="#1-4-运行和编译时" class="headerlink" title="1.4 运行和编译时"></a>1.4 运行和编译时</h2><h1 id="1-框架设计的核心要素"><a href="#1-框架设计的核心要素" class="headerlink" title="1 框架设计的核心要素"></a>1 框架设计的核心要素</h1><h2 id="2-1-缩减框架代码的体积"><a href="#2-1-缩减框架代码的体积" class="headerlink" title="2.1 缩减框架代码的体积"></a>2.1 缩减框架代码的体积</h2><p>例：vue3 源码的 warn 函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(_DEV_ &amp;&amp; ires) {</span><br><span class="line">warn(</span><br><span class="line">'faile to ....')</span><br><span class="line">};</span><br><span class="line">//vue.js使用rolllup.js对项目进项构建 这里的_DEV_实际上就是通过rollup.js的设置来预定义的 类似于webpack的DefinePlugin插件</span><br><span class="line">当用于开发环境时 _DEV_为true 即 if(true &amp;&amp; ires)</span><br><span class="line">而在构建生产环境中 _DEV_会被翻译为false 即 if(false &amp;&amp; _DEV_) 这样就永远不会执行</span><br><span class="line">**这种永远不会执行的代码称之为dead code 在构建最终项目的时候就会被移除 从而可以在开发环境中提供友好的提示 生产环境中减少代码的体积</span><br><span class="line">**vue3源码多出利用相似逻辑保证了开发环境的友好体验和生产环境的代码体积控制</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2Tree-Shaking"><a href="#2-2Tree-Shaking" class="headerlink" title="2.2Tree-Shaking"></a>2.2Tree-Shaking</h2><p>Tree-Shaking：消除永远不会使用到的代码 如上面说的<em>DEV</em></p><p><strong>能使用 Tree-Shaking 的必须是满足 ESM</strong></p><p>Tree-Shaking 会产生副作用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**加上标记来告诉系统可以安心清除副作用</span><br><span class="line">import {foo} from './utils';</span><br><span class="line">/*#_PURE_*/ foo();//   /*#_PURE_*/会告诉roupull.js可以放心进行Tree-Shaking</span><br><span class="line">vue3的源码多出使用/*#_PURE_*/来标记 都用于顶级调用</span><br><span class="line">export const isHTMLTag = /*#_PURE_*/ makeMap(HTML_TAGS);</span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-框架输出的产物"><a href="#2-3-框架输出的产物" class="headerlink" title="2.3 框架输出的产物"></a>2.3 框架输出的产物</h2><p>无论是 rollup.js 还是 webpack 在寻找资源文件的时候 如果 package.json 中存在 module 字段 都会优先使用 module 字段指向的资源代替 main 字段指向的资源</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">"main": 'index.js',</span><br><span class="line">"module": 'dist/vue.runtime.esm-bundler.js'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用处：当我们使用构建提供工具打包的 ESM 格式的资源时 不能直接把<em>DEV</em>转换成 true 或 false 需要使用(process.env.NODE* !== ‘production’)替换—DEV*常量</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if((process.env.NODE) !== 'production') {</span><br><span class="line">....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需求场景：当进行服务端渲染时 vue.js 的代码是在 Node.js 的环境中运行的 但是 Node.js 时 CommonJS 形式 所以可以更改 roullup.js 中的 format 配置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format: 'cjs'//指定模块形式</span><br></pre></td></tr></tbody></table></figure><h2 id="2-4-特定开关"><a href="#2-4-特定开关" class="headerlink" title="2.4 特定开关"></a>2.4 特定开关</h2><h2 id="2-5-错误处理"><a href="#2-5-错误处理" class="headerlink" title="2.5 错误处理"></a>2.5 错误处理</h2><h1 id="VUE-JS3-的设计思路"><a href="#VUE-JS3-的设计思路" class="headerlink" title="VUE.JS3 的设计思路"></a>VUE.JS3 的设计思路</h1><h2 id="3-2-渲染器"><a href="#3-2-渲染器" class="headerlink" title="3.2 渲染器"></a>3.2 渲染器</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function renderer(vnode, container) {</span><br><span class="line">  // 使用 vnode.tag 作为标签名称创建 DOM 元素</span><br><span class="line">const el = document.createElement(vnode.tag)</span><br><span class="line">  // 遍历 vnode.props 将属性、事件添加到 DOM 元素</span><br><span class="line">  for (const key in vnode.props) {</span><br><span class="line">    if (/^on/.test(key)) {</span><br><span class="line">      // 如果 key 以 on 开头，那么说明它是事件</span><br><span class="line">      el.addEventListener(</span><br><span class="line">        key.substr(2).toLowerCase(), // 事件名称 onClick ---&gt; click</span><br><span class="line">        vnode.props[key] // 事件处理函数</span><br><span class="line">      )</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 处理 children</span><br><span class="line">  if (typeof vnode.children === 'string') {</span><br><span class="line">    // 如果 children 是字符串，说明是元素的文本子节点</span><br><span class="line">    el.appendChild(document.createTextNode(vnode.children))</span><br><span class="line">  } else if (Array.isArray(vnode.children)) {</span><br><span class="line">    // 递归地调用 renderer 函数渲染子节点，使用当前元素 el 作为挂载点</span><br><span class="line">    vnode.children.forEach(child =&gt; renderer(child, el))</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 将元素添加到挂载点下</span><br><span class="line">  container.appendChild(el)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const vnode = {</span><br><span class="line">  tag: 'div',</span><br><span class="line">  props: {</span><br><span class="line">    onClick: () =&gt; alert('hello')</span><br><span class="line">  },</span><br><span class="line">  children: 'click me'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">renderer(vnode, document.body)；</span><br></pre></td></tr></tbody></table></figure><h1 id="响应系统的作用和实现"><a href="#响应系统的作用和实现" class="headerlink" title="响应系统的作用和实现"></a>响应系统的作用和实现</h1><h2 id="4-1-响应式数据与副作用"><a href="#4-1-响应式数据与副作用" class="headerlink" title="4.1 响应式数据与副作用"></a>4.1 响应式数据与副作用</h2><p>副作用函数：会产生副作用的函数 即该函数的执行会直接或间接地影响到其他函数或变量的执行</p><h2 id="4-2-响应式数据的基本实现"><a href="#4-2-响应式数据的基本实现" class="headerlink" title="4.2 响应式数据的基本实现"></a>4.2 响应式数据的基本实现</h2><ul><li><p>通过拦截一个对象的读取和设置操作</p><ul><li><p>```<br>//当读取obj.text的时候 就将副作用函数储存到一个桶里面<br>//当设置obj.text的时候 就将副作用从桶里面取出执行便可<br>/ 存储副作用函数的桶<br>const bucket = new Set()</p><p>// 原始数据<br>const data = { text: ‘hello world’ }<br>// 对原始数据的代理<br>const obj = new Proxy(data, {<br>  // 拦截读取操作<br>  get(target, key) {</p><pre><code>// 将副作用函数 effect 添加到存储副作用函数的桶中bucket.add(effect)// 返回属性值return target[key]</code></pre><p>  },<br>  // 拦截设置操作<br>  set(target, key, newVal) {</p><pre><code>// 设置属性值target[key] = newVal// 把副作用函数从桶里取出并执行bucket.forEach(fn =&gt; fn())</code></pre><p>  }<br>})</p><p>function effect() {<br>  document.body.innerText = obj.text<br>}<br>effect()</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    **缺陷**：如果副作用改名或者是匿名函数 则该响应系统失效</span><br><span class="line"></span><br><span class="line">- 设计一个完善的响应系统</span><br><span class="line"></span><br><span class="line">  - 提供一个用来注册副作用函数的机制来解决上面的问题</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    //用一个变量春促当前激活的effect函数</span><br><span class="line">    let activeEffect;</span><br><span class="line">    function effect(fn) {</span><br><span class="line">    //当调用effect注册副作用函数是 将副作用函数赋值给activeEffect</span><br><span class="line">    activeEffect = fn;</span><br><span class="line">    fn(0);//执行副作用函数</span><br><span class="line">    };</span><br><span class="line">    effect(() =&gt; {</span><br><span class="line">    console.log('effect do');</span><br><span class="line">    documrnt.body.innerText = obj.text;//进行读取操作</span><br><span class="line">    })</span><br><span class="line">    const obj = new Proxy(data, {</span><br><span class="line">    get(target, key) {</span><br><span class="line">    //将当前被调用的副作用函数加入到桶中</span><br><span class="line">    if(activeEffect) {</span><br><span class="line">    bucket.add(activeEffect)//新增</span><br><span class="line">    }</span><br><span class="line">    return target[key];</span><br><span class="line">    },</span><br><span class="line">    set(target, key, newVal) {</span><br><span class="line">    target[key] = newVal;</span><br><span class="line">    bucket.forEach( fn =&gt; fn());</span><br><span class="line">    return true;</span><br><span class="line">    }</span><br><span class="line">    })</span><br></pre></td></tr></tbody></table></figure><p><strong>完成了可以添加匿名或任意名字的副作用函数</strong></p><p><strong>缺陷：无法监听指定属性，即如果进行类似于新增不存在的属性 该副作用函数依然会被执行（正常不应该被执行）</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">测试：新增不存在的obj.text2属性</span><br><span class="line">effect(() =&gt; {</span><br><span class="line">obj.body.innerText = obj.text</span><br><span class="line"></span><br><span class="line">console.log('effect done')</span><br><span class="line">});</span><br><span class="line">setTimeout(() =&gt; {</span><br><span class="line">obj.text2 = 'none exists';//新增一个不存在的属性</span><br><span class="line">})</span><br><span class="line">//运行结果：effect done 执行两次</span><br><span class="line">//分析：每次修改对象obj都会将effect存入桶中 导致读取时执行不该执行的副作用</span><br><span class="line">//没有在副作用函数与被操作的目标之间建立明确的联系</span><br><span class="line">**解决方法：在副作用函数与被操作的字段之间建立联系 可以使用weakMap</span><br><span class="line">//储存副作用的桶</span><br><span class="line">const bucket = new WeakMap();</span><br><span class="line">//修改拦截器</span><br><span class="line">const obj = new Proxy(data, {</span><br><span class="line">//拦截读取行为</span><br><span class="line">get(target, key) {</span><br><span class="line">//没有activeEffect 直接return</span><br><span class="line">if(!activeEffect) return;</span><br><span class="line">//根据traget从桶中取得desMap， ：key --&gt; effects</span><br><span class="line">let desMap = bucket.get(target);</span><br><span class="line">//如果不存在desMap 那么就创建一个WeakMap</span><br><span class="line">if(!desMap) {</span><br><span class="line">bucket.set(target, (desMap = new Map()))</span><br><span class="line">}</span><br><span class="line">//根据key自从desMap中读取deps deps时一个set类型</span><br><span class="line">//里面储存着所有与当前key有相关的副作用函数:effects</span><br><span class="line">let deps = desMap.get(key);</span><br><span class="line">if(!deps) {</span><br><span class="line">desMap.set(key, (deps = new Set()));</span><br><span class="line">}</span><br><span class="line">deps.add(activeEffect);//将激活的副作用函数存储到桶里</span><br><span class="line">return target[key];//返回属性值</span><br><span class="line">};</span><br><span class="line">//拦截设置操作</span><br><span class="line">set(target, key, newVal) {</span><br><span class="line">//设置属性值</span><br><span class="line">target[key] = newVal;</span><br><span class="line">//根据target从decket中取出desMap</span><br><span class="line">let desMap = ducket.get(target);</span><br><span class="line">if(!desMap) return;</span><br><span class="line">//根据key取得所有的副作用函数并依次执行</span><br><span class="line">let deps = desMap.get(key);</span><br><span class="line">deps &amp;&amp; deps.forEach( fn =&gt; fn());//判空再执行</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><img src="https://i.bmp.ovh/imgs/2022/04/01/5648b7ab427b5fd9.jpg" style="zoom: 50%;"></li><li><p><strong>为什么使用 WeakMap 不使用 Map</strong></p><ul><li>weakMap 是弱引用 不会影响垃圾回收</li><li>只有当 key 所引用的对象存在时（没有被回收时）才有价值的信息都优先使用 weakMap 来存储</li></ul></li><li><p>**存在问题：代码耦合度高 **</p></li><li><p><strong>解决方法： 抽离封装</strong></p></li><li><pre><code>function track(target, key) {  let depsMap = bucket.get(target)  if (!depsMap) {    bucket.set(target, (depsMap = new Map()))  }  let deps = depsMap.get(key)  if (!deps) {    depsMap.set(key, (deps = new Set()))  }  deps.add(activeEffect)}function trigger(target, key) {  const depsMap = bucket.get(target)  if (!depsMap) return  const effects = depsMap.get(key)  effects &amp;&amp; effects.forEach(fn =&gt; fn())}// 对原始数据的代理const obj = new Proxy(data, {  // 拦截读取操作  get(target, key) {    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中    track(target, key)    // 返回属性值    return target[key]  },  // 拦截设置操作  set(target, key, newVal) {    // 设置属性值    target[key] = newVal    // 把副作用函数从桶里取出并执行    trigger(target, key)  }})<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 4.4 切换分支与 cleanup</span><br><span class="line"></span><br><span class="line">分支切换可能会产生遗留的副作用函数</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>effect(function effectFn() {    document.body.innerText = obj.ok? obj.text : 'not'})//此时依赖函数被obj.ok和obj.text同时依赖 当obj.ok为false时 无论obj.text怎么变化 都是'not' 所以不应该触发副作用函数//解决方法：每次副作用函数执行时 都把它从所有与之关联的依赖集合中删除//当副作用执行完毕后 会建立联系 但再新的联系中不会包含遗留的副作用函数<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**副作用依赖函数集合**</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>//用一个全局变量储存被注册的副作用函数let activeEffect;function effect(fn) {//当effectFn被执行时 将其设置为当前的激活的副作用函数    const effectFn = () =&gt; {        activeEffect = effectFn;        fn();    }    //effectEffect.deps 用来储存所有与该副作用函数想关联的依赖集合    effectEn.dep = [];    //执行副作用函数    effectFn();}<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **Track 函数**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  function track(target, key) {</span><br><span class="line">  if(!activeEffect) return;</span><br><span class="line">  let depsMap = bucket.get(key);</span><br><span class="line">  if(!depsMap) {</span><br><span class="line">  bucket.set(target, (desMap =&gt; new Map()));</span><br><span class="line">  }</span><br><span class="line">  let deps = depsMap.get(key);</span><br><span class="line">  if(!deps) {</span><br><span class="line">  depsMap.set(key, ( deps =&gt; new Set()))</span><br><span class="line">  };</span><br><span class="line">  //把当前激活的副作用函数添加到依赖集合deps中</span><br><span class="line">  deps.add(activeEffect);</span><br><span class="line">  //deps就是一个与当前副作用函数存在联系的集合</span><br><span class="line">  //将其添加到activeEffects.deps中</span><br><span class="line">  activeEffect.deps.push(deps);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>- 有了这个联系后 再每次执行副作用函数时 根据 effectFn.deps 获取所有的相关联的依赖集合 从而将副作用函数从依赖集合中清除- ```  let activeEffect;  function effect(fn) {      const effectFn = () =&gt; {          //调用cleanUp函数完成清除依赖          cleanup(effectFn);          activeEffect = effectFn;          fn();      }  }  function cleanup(effectFn) {  //遍历effectFn.deps数组    for (let i = 0; i &lt; effectFn.deps.length; i++) {    //deps时依赖集合      const deps = effectFn.deps[i]      //将effectFn从依赖集合中删除      deps.delete(effectFn)    }    //重置effectFn.deps数组    effectFn.deps.length = 0  }  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    -</span><br><span class="line"></span><br><span class="line"># 非原始值的响应式方案</span><br><span class="line"></span><br><span class="line">## 5.1Proxy 以及 Reflect</span><br><span class="line"></span><br><span class="line">**proxy 只能代理对象 不能代理其他类型的数据**</span><br><span class="line"></span><br><span class="line">### 5.1.2 Reflect</span><br><span class="line"></span><br><span class="line">Reflect 可以接受第三个参数 即 receiver 相当于函数调用过程中的 this</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>const obj = {foo: 1};Reflect.get(obj, foo, {foo: 2});//输出2</code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学Vue第一天</title>
      <link href="/2022/04/09/chong-xue-vue/"/>
      <url>/2022/04/09/chong-xue-vue/</url>
      
        <content type="html"><![CDATA[<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span :title="toTitleDate(date)"&gt;</span><br><span class="line">  {{ formatDate(date) }}//formatData不应该时更改数据或者触发异步操作</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>每次组件更新时 都会调用绑定表达式内部调用的函数 因此他们不应该产生任何副作用 例如更改数据或触发异步操作</strong></p><h4 id="受限的全局访问"><a href="#受限的全局访问" class="headerlink" title="受限的全局访问"></a>受限的全局访问</h4><p>魔棒表达式是沙盒化的 只能访问全局的受限列表（该列表公布了常用的内置全局变量 如 Math Date）未明确包含在列表中的全局变量（用户附加属性）</p><p>将无法在模板表达式中访问 可以将所有 Vue 表达式添加到<code>app.config.globalProperties</code>来显式定义其他全局变量（window）</p><h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:[attributeName]="url"&gt; ... &lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- shorthand --&gt;</span><br><span class="line">&lt;a :[attributeName]="url"&gt; ... &lt;/a&gt;</span><br><span class="line">//如果组件实例具有数据属性 则此绑定等价于 attributeName attributeName 'href' v-bind:href</span><br><span class="line">//避免使用大写字符命名键 因为浏览器会强制将属性名称转化为小写 someAttr -&gt; someattr</span><br></pre></td></tr></tbody></table></figure><h4 id="DOM-更新时间"><a href="#DOM-更新时间" class="headerlink" title="DOM 更新时间"></a>DOM 更新时间</h4><p>dom 更新不是同步更新的 vue 会缓冲它们知道更新周期的下一个“next tick” 以确保不管进行了多少状态更改 每个组件都只需要更新依次</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//要在状态更改后等待DOM更新完成 可以使用nextTick全局API</span><br><span class="line">Import {nextTick} form 'vue';</span><br><span class="line">function increment() {</span><br><span class="line">  state.count++</span><br><span class="line">  nextTick(() =&gt; {</span><br><span class="line">    // access updated DOM</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 vue 中默认深度响应的 即在嵌套的对象或数组中也可以检测到更改 也可以显式地创建浅反应对象 仅在跟级别跟踪反应性 但是通常仅在高级用例中需要（后面学到补充）</p><h4 id="反应式代理与原始"><a href="#反应式代理与原始" class="headerlink" title="反应式代理与原始"></a>反应式代理与原始</h4><p><strong>reactive（）是原对象的代理 而不是原对象的返回值</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const raw = {}</span><br><span class="line">const proxy = reactive(raw)//返回的是代理Proxy对象</span><br><span class="line"></span><br><span class="line">// proxy is NOT equal to the original.</span><br><span class="line">console.log(proxy === raw) // false</span><br></pre></td></tr></tbody></table></figure><p>如果只是代理反应 那么改变原始对象不会触发更新 所以 Vue 的响应式系统是使用状态的代理版本 为了确保对代理的始终统一访问 使用 reactive 同一个对象 然后调用 reacitive 一个现有的代理也返回同一个代理</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// calling reactive() on the same object returns the same proxy</span><br><span class="line">console.log(reactive(raw) === proxy) // true</span><br><span class="line"></span><br><span class="line">// calling reactive() on a proxy returns itself</span><br><span class="line">console.log(reactive(proxy) === proxy) // true</span><br></pre></td></tr></tbody></table></figure><p><strong>由于 Vue 的响应式适用于属性访问 因此我们必须保持响应式对象的相同引用 这意味着我们不能轻易地替换反应式对象 以为与第一个引用的反应性连接丢失了</strong></p><p>这也意味着当我们将反应性对象的属性分配或解构为局部变量时 或者将属性传递给函数时 将失去响应性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const state = reactive({ count: 0 })</span><br><span class="line"></span><br><span class="line">// n is a local variable that is disconnected</span><br><span class="line">// from state.count.</span><br><span class="line">let n = state.count</span><br><span class="line">// does not affect original state</span><br><span class="line">n++</span><br><span class="line"></span><br><span class="line">// count is also disconnected from state.count.</span><br><span class="line">let { count } = state</span><br><span class="line">// does not affect original state</span><br><span class="line">count++</span><br><span class="line"></span><br><span class="line">// the function receives a plain number and</span><br><span class="line">// won't be able to track changes to state.count</span><br><span class="line">callSomeFunction(state.count)</span><br></pre></td></tr></tbody></table></figure><h4 id="ref（）"><a href="#ref（）" class="headerlink" title="ref（）"></a>ref（）</h4><p>当持有对象类型时 ref 会自动将其.value 与 reactive（） 包含对象值的 ref 可以反应性替换整个对象</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const objectRef = ref({ count: 0 })</span><br><span class="line"></span><br><span class="line">// this works reactively</span><br><span class="line">objectRef.value = { count: 1 }</span><br></pre></td></tr></tbody></table></figure><p>Refs 也可以传递给函数或从普通对象中解构，而不会失去反应性：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj = {</span><br><span class="line">  foo: ref(1),</span><br><span class="line">  bar: ref(2)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// the function receives a ref</span><br><span class="line">// it needs to access the value via .value but it</span><br><span class="line">// will retain the reactivity connection</span><br><span class="line">callSomeFunction(obj.foo)</span><br><span class="line"></span><br><span class="line">// still reactive</span><br><span class="line">const { foo, bar } = obj</span><br></pre></td></tr></tbody></table></figure><p><strong>换句话说，<code>ref()</code>允许我们创建对任何值的“引用”并在不失去反应性的情况下传递它。此功能非常重要，因为它在将逻辑提取到<a href="https://vuejs.org/guide/reusability/composables.html">Composable Functions</a>时经常使用。</strong></p><p>当 ref 作为响应式对象的属性被访问或改变时 他会自动被解包 因此它的行为类似于普通属性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const count = ref(0)</span><br><span class="line">const state = reactive({</span><br><span class="line">  count</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">console.log(state.count) // 0</span><br><span class="line"></span><br><span class="line">state.count = 1</span><br><span class="line">console.log(count.value) // 1</span><br></pre></td></tr></tbody></table></figure><p>如果将新的 ref 分配给现有的 ref 属性 他将替代旧的 ref</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line">const state = reactive({</span><br><span class="line">  count</span><br><span class="line">})</span><br><span class="line">const otherCount = ref(2)</span><br><span class="line"></span><br><span class="line">state.count = otherCount</span><br><span class="line">console.log(count.value) // 0</span><br><span class="line">console.log(state.count) // 2</span><br><span class="line"></span><br><span class="line">state.count = 3</span><br><span class="line">console.log(count.value) // 0</span><br><span class="line">console.log(otherCount.value)//3</span><br></pre></td></tr></tbody></table></figure><p>*<em>Ref 展开仅在嵌套在深层反应对象时发生 当它作为浅反应对象的属性被访问时 它不适用</em></p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>computed（）函数需要传递一个 getter 函数 返回值是一个计算的 ref 计算属性会自动跟踪其反应性依赖关系</p><p>getters 没有副作用 ：计算属性只执行纯计算并且没有副作用 所以不要发出异步请求或者在计算的 getter 上改变 DOM</p><h2 id="类和样式绑定"><a href="#类和样式绑定" class="headerlink" title="类和样式绑定"></a>类和样式绑定</h2><p>可以绑定到返回对象的计算属性 这是一种常见且强大的模式</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const isActive = ref(true)</span><br><span class="line">const error = ref(null)</span><br><span class="line"></span><br><span class="line">const classObject = computed(() =&gt; ({</span><br><span class="line">  active: isActive.value &amp;&amp; !error.value,</span><br><span class="line">  'text-danger': error.value &amp;&amp; error.value.type === 'fatal'</span><br><span class="line">}))</span><br><span class="line">&lt;div :class="classObject"&gt;&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果想要 有条件切换列表中的值 可以用三元表达式实现</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :class="[isActive ? activeClass : '', errorClass]"&gt;&lt;/div&gt;</span><br><span class="line">//这将始终适用errorClass 但是activeClass仅在为真的时候才适用</span><br><span class="line">//如果有多个条件类 可以使用对象语法</span><br><span class="line">&lt;div :class="[{ active: isActive }, errorClass]"&gt;&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p>当在具有单个根元素的组件上使用该属性时 这些类将添加到组件的根元素中 并与该组件上已有的现有类合并</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- child component template --&gt;</span><br><span class="line">&lt;p class="foo bar"&gt;Hi!&lt;/p&gt;</span><br><span class="line">!-- when using the component --&gt;</span><br><span class="line">&lt;my-component class="baz boo"&gt;&lt;/my-component&gt;</span><br><span class="line">呈线的html将为</span><br><span class="line">&lt;p class="foo bar baz boo"&gt;Hi&lt;/p&gt;</span><br><span class="line">类绑定也是这样</span><br><span class="line">如果组件有多个根元素 则需要定义哪些元素将接收此类 可以使用$attrs组件属性来执行此操作</span><br><span class="line">&lt;!-- my-component template using $attrs --&gt;</span><br><span class="line">&lt;p :class="$attrs.class"&gt;Hi!&lt;/p&gt;</span><br><span class="line">&lt;span&gt;This is a child component&lt;/span&gt;</span><br><span class="line">&lt;my-component class="baz"&gt;&lt;/my-component&gt;</span><br><span class="line">将渲染为</span><br><span class="line">&lt;p class="baz"&gt;Hi!&lt;/p&gt;</span><br><span class="line">&lt;span&gt;This is a child component&lt;/span&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><p>v-if 是一个指令 必须添加到单个元素上 可以将 v-if 在一个 template 上使用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if="ok"&gt;&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>v-show 将始终被渲染在 DOM 中 仅切换 display 元素的 css 属性 不支持使用在 template</p><p>经常切换使用 v-show 不经常使用则用 v-show</p><p><strong>v-for 遍历对象时 顺序基于枚举顺序 Objects.keys(), 这不能保证在 JavaScript 引擎实现中保持一致</strong>、</p><p>可以在 template 中使用 v-for 来渲染一个包含多个元素的块</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;template v-for="item in items"&gt;</span><br><span class="line">    &lt;li&gt;{{ item.msg }}&lt;/li&gt;</span><br><span class="line">    &lt;li class="divider" role="presentation"&gt;&lt;/li&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>为什么 v-for 要提供 key</strong></p><ul><li>当 vue 更新使用渲染的元素列表时 v-for 默认使用就地补丁策略（如果数据项的顺序发生了变化 而不是移动 DOM 元素来匹配项的顺序 VUE 将就地补丁修补每个元素并确保他们反映应该在该特定索引处呈现的内容）但这种模式仅适用于列表的渲染输出不依赖子组件或者临时 DOM 状态（表单输入值）的情况</li><li>为了给 vue 一个提示以便它可以跟踪每个节点的身份 从而重用或重新排序现有元素 需要提供一个唯一的 key</li></ul><h4 id="数组变化侦测"><a href="#数组变化侦测" class="headerlink" title="数组变化侦测"></a>数组变化侦测</h4><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><p>在 vue 中 将一个数组替换为另一个数组包含重叠对象的数组是一种高效的操作 如使用新数组替换旧数组:concact() slice()</p><p>当我们需要显示一个经过过滤或排序的数组版本 而不需要实际改变或重置原始数据 可以创建一个返回过滤或排序数组的计算属性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const numbers = ref([1, 2, 3, 4, 5])</span><br><span class="line"></span><br><span class="line">const evenNumbers = computed(() =&gt; {</span><br><span class="line">  return numbers.value.filter((n) =&gt; n % 2 === 0)</span><br><span class="line">})</span><br><span class="line">&lt;li v-for="n in evenNumbers"&gt;{{ n }}&lt;/li&gt;</span><br></pre></td></tr></tbody></table></figure><p>在计算属性不行使 比如嵌套的 v-for 循环中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const sets = ref([</span><br><span class="line">  [1, 2, 3, 4, 5],</span><br><span class="line">  [6, 7, 8, 9, 10]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">function even(numbers) {</span><br><span class="line">  return numbers.filter((number) =&gt; number % 2 === 0)</span><br><span class="line">}</span><br><span class="line">&lt;ul v-for="numbers in sets"&gt;</span><br><span class="line">  &lt;li v-for="n in even(numbers)"&gt;{{ n }}&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">输出：2 4 6 8 10</span><br></pre></td></tr></tbody></table></figure><p><strong>在计算属性中使用 reverse 和 sort 要小心 因为他们会改变原始数组 在计算属性的 getter 中应该避免这种情况 在调用前先创建原始数据的副本</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- return numbers.reverse()</span><br><span class="line">+ return [...numbers].reverse()</span><br></pre></td></tr></tbody></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>当我们需要访问内联处理程序中的原始 DOM 事件 可以用特殊变量将其传递给方法$event 或者使用内联箭头函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click="warn('Form cannot be submitted yet.', $event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- using inline arrow function --&gt;</span><br><span class="line">&lt;button @click="(event) =&gt; warn('Form cannot be submitted yet.', event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="表单上输入绑定"><a href="#表单上输入绑定" class="headerlink" title="表单上输入绑定"></a>表单上输入绑定</h4><ul><li><code>&lt;input&gt;</code>文本类型和<code>&lt;textarea&gt;</code>元素使用<code>value</code>属性和<code>input</code>事件；</li><li><code>&lt;input type="checkbox"&gt;``&lt;input type="radio"&gt;</code>使用<code>checked</code>和事件<code>change</code>；</li><li><code>&lt;select&gt;</code>用作<code>value</code>和<code>change</code>事件。</li></ul><p><strong>v-model<code>将忽略在任何表单元素上找到的初始或属性</code>value<code>。它将始终将当前绑定的 JavaScript 状态视为事实来源。您应该使用反应性 API在 JavaScript 端声明初始值。</code>checked``selected</strong></p>]]></content>
      
      
      <categories>
          
          <category> -web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue TS 框架 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
