<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>你不知道的reactive</title>
      <link href="/2022/04/09/vue-xiang-ying-shi-yuan-li/"/>
      <url>/2022/04/09/vue-xiang-ying-shi-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-源码解析系列-响应式原理（reactive-篇）"><a href="#Vue3-源码解析系列-响应式原理（reactive-篇）" class="headerlink" title="Vue3 源码解析系列 - 响应式原理（reactive 篇）"></a>Vue3 源码解析系列 - 响应式原理（reactive 篇）</h1><h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h2><h3 id="核心入口"><a href="#核心入口" class="headerlink" title="核心入口"></a>核心入口</h3><p>话不多说，我们先来看下核心的 <code>reactive</code> 的源码，先看下有哪些依赖：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工具方法，isObject 是判断是否是对象，toTypeString 获取数据类型</span></span><br><span class="line"><span class="keyword">import</span> { isObject, toTypeString } <span class="keyword">from</span> <span class="string">"@vue/shared"</span>;</span><br><span class="line"><span class="comment">// Proxy 的 handlers</span></span><br><span class="line"><span class="comment">// mutableHandlers：可变数据的 handler</span></span><br><span class="line"><span class="comment">// readonlyHandlers：只读数据的 handler</span></span><br><span class="line"><span class="keyword">import</span> { mutableHandlers, readonlyHandlers } <span class="keyword">from</span> <span class="string">"./baseHandlers"</span>;</span><br><span class="line"><span class="keyword">import</span> {</span><br><span class="line">  mutableCollectionHandlers, <span class="comment">// 可变集合数据的 handler</span></span><br><span class="line">  readonlyCollectionHandlers, <span class="comment">// 只读集合数据的 handler</span></span><br><span class="line">} <span class="keyword">from</span> <span class="string">"./collectionHandlers"</span>;</span><br><span class="line"><span class="comment">// effect 泛型类型</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">ReactiveEffect</span> } <span class="keyword">from</span> <span class="string">"./effect"</span>;</span><br><span class="line"><span class="comment">// ref 泛型类型</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">UnwrapRef</span>, <span class="title class_">Ref</span> } <span class="keyword">from</span> <span class="string">"./ref"</span>;</span><br><span class="line"><span class="comment">// 工具方法，将字符串转化成 Map，返回 function 来判断是否 这个Map 上包含所给的 key</span></span><br><span class="line"><span class="comment">// 这个在 vue2 里也有</span></span><br><span class="line"><span class="keyword">import</span> { makeMap } <span class="keyword">from</span> <span class="string">"@vue/shared"</span>;</span><br></pre></td></tr></tbody></table></figure><p>可以很清楚的看到，重点依赖项就是那一堆 <code>handler</code> 了，其他都是一些工具方法和泛型类型</p><p>接下来的源码里是一堆变量的定义，不过我们先跳过，先来看下 <code>reactive</code> 的方法和类型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面还有一大坨变量定义，很关键，但是我们先跳过，先看下有哪些方法，类型是什么样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖集合类型</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Dep</span> = <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt;</span><br><span class="line"><span class="comment">// 看名字就知道，是 key 和 Dep 集合的对应关系集合</span></span><br><span class="line"><span class="comment">// key 其实就是我们响应式数据上的 key，Dep 则是有哪些地方依赖到了这个 key</span></span><br><span class="line"><span class="comment">// 比如 const a = { foo: 1 }，如果在其他两处都用到了 a.foo，那么</span></span><br><span class="line"><span class="comment">// 这里的 key 就是 foo，Dep 就是这两处的 依赖集合</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">KeyToDepMap</span> = <span class="title class_">Map</span>&lt;string | symbol, <span class="title class_">Dep</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断对象能不能被观察的</span></span><br><span class="line"><span class="keyword">const</span> canObserve = (<span class="attr">value</span>: any): boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// only unwrap nested ref</span></span><br><span class="line"><span class="comment">// 解套 Ref 类型</span></span><br><span class="line">type <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">UnwrapRef</span>&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应式入口方法，入参是泛型，继承 object，返回值就是上面的解套 Ref 类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> reactive&lt;T <span class="keyword">extends</span> object&gt;(<span class="attr">target</span>: T): <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟 reactive 作用相同，只不过返回值是 Readonly 的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> readonly&lt;T <span class="keyword">extends</span> object&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">Readonly</span>&lt;<span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建响应式对象的关键方法，reactive 和 only 都调用了这个方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  toProxy: <span class="built_in">WeakMap</span>&lt;any, any&gt;,</span></span><br><span class="line"><span class="params">  toRaw: <span class="built_in">WeakMap</span>&lt;any, any&gt;,</span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;any&gt;,</span></span><br><span class="line"><span class="params">  collectionHandlers: ProxyHandler&lt;any&gt;</span></span><br><span class="line"><span class="params"></span>): any</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是响应式数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReactive</span>(<span class="params">value: any</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是只读的响应式数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReadonly</span>(<span class="params">value: any</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将响应式数据转化为原始数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(<span class="attr">observed</span>: T): T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 value 标记为 Readonly，在 reactive 方法里会判断是否是 Readonly 的原始数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> markReadonly&lt;T&gt;(<span class="attr">value</span>: T): T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 value 标记为不可响应数据，这个将会影响 canObserve 方法的判断</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> markNonReactive&lt;T&gt;(<span class="attr">value</span>: T): T</span><br></pre></td></tr></tbody></table></figure><p>看完方法和类型，大致有以下几个问题：</p><ol><li><code>Dep</code> 依赖是如何追踪的？</li><li><code>UnwrapRef</code> 是如何展开嵌套的响应式数据类型的（俗称解套）,比如 <code>reactive({ name: reactive(ref('Jooger')) })</code></li><li>如何判断是否是（只读的）响应式数据？往响应式数据上面挂载一个标记位来标记？还是用一个对象来存储响应式数据？</li><li>如何将响应式数据转化为原始数据？proxy 数据如何转化成 object？</li></ol><p>问题 1，后面的 <code>effect</code> 会讲，这里先不讨论</p><p>问题 2，后面的 <code>ref</code> 会讲，这里先不讨论</p><p>问题 3，4 就需要看下我刚才跳过的一堆变量的定义了：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The main WeakMap that stores {target -&gt; key -&gt; dep} connections.</span></span><br><span class="line"><span class="comment">// Conceptually, it's easier to think of a dependency as a Dep class</span></span><br><span class="line"><span class="comment">// which maintains a Set of subscribers, but we simply store them as</span></span><br><span class="line"><span class="comment">// raw Sets to reduce memory overhead.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// target 和 KeyToDepMap 的映射关系集合</span></span><br><span class="line"><span class="comment">// 一句话理解，有多个 target，每个 target 上有多个 key，每个 key 都有多个依赖</span></span><br><span class="line"><span class="comment">// 至于为什么要把映射关系存到 WeakMap 里，根据上面注释所述，是为了减少内存开销</span></span><br><span class="line"><span class="comment">// 这个在后续的 effect 部分会讲</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, <span class="title class_">KeyToDepMap</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMaps that store {raw &lt;-&gt; observed} pairs.</span></span><br><span class="line"><span class="comment">// 下面这四个变量就是为了解答 问题 3 和 4 的</span></span><br><span class="line"><span class="comment">// 根据上面的原英文注释，这四个变量是 raw 和 observed 的对应关系集合</span></span><br><span class="line"><span class="comment">// raw 是原始数据，observed 则是响应式数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据 -&gt; 响应式数据</span></span><br><span class="line"><span class="keyword">const</span> rawToReactive = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"><span class="comment">// 响应式数据 -&gt; 原始数据</span></span><br><span class="line"><span class="keyword">const</span> reactiveToRaw = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"><span class="comment">// 原始数据 -&gt; 只读响应式数据</span></span><br><span class="line"><span class="keyword">const</span> rawToReadonly = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"><span class="comment">// 只读响应式数据 -&gt; 原始数据</span></span><br><span class="line"><span class="keyword">const</span> readonlyToRaw = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, any&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakSets for values that are marked readonly or non-reactive during</span></span><br><span class="line"><span class="comment">// observable creation.</span></span><br><span class="line"><span class="comment">// 前面提到过的 markReadonly 和 markNonReactive 方法用到的</span></span><br><span class="line"><span class="comment">// 用来存储我们标记的特定数据，以便在创建响应式数据是来检查是否被上面两个方法标记过</span></span><br><span class="line"><span class="keyword">const</span> readonlyValues = <span class="keyword">new</span> <span class="title class_">WeakSet</span>&lt;any&gt;()</span><br><span class="line"><span class="keyword">const</span> nonReactiveValues = <span class="keyword">new</span> <span class="title class_">WeakSet</span>&lt;any&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是集合类型（Set, Map, WeakMap, WeakSet）</span></span><br><span class="line"><span class="comment">// 因为集合类型的代理 handler 和普通对象是不同的，需要特殊处理</span></span><br><span class="line"><span class="keyword">const</span> collectionTypes = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="title class_">Function</span>&gt;([<span class="title class_">Set</span>, <span class="title class_">Map</span>, <span class="title class_">WeakMap</span>, <span class="title class_">WeakSet</span>])</span><br><span class="line"><span class="comment">// 判断是否是可观察类型，有以下 6 类，在 canObserve 方法里会用到</span></span><br><span class="line"><span class="keyword">const</span> isObservableType = <span class="comment">/*#__PURE__*/</span> <span class="title function_">makeMap</span>(</span><br><span class="line">  [<span class="string">'Object'</span>, <span class="string">'Array'</span>, <span class="string">'Map'</span>, <span class="string">'Set'</span>, <span class="string">'WeakMap'</span>, <span class="string">'WeakSet'</span>]</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">t</span> =&gt;</span> <span class="string">`[object <span class="subst">${t}</span>]`</span>)</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">','</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>看完上面这些变量定义，我们来解答一下问题 3，4：</p><blockquote><p>问题 3：如何判断是否是（只读的）响应式数据？往响应式数据上面挂载一个标记位来标记？还是用一个对象来存储响应式数据？</p></blockquote><p>用 <code>readonlyToRaw</code> 来存储只读响应式数据的，参见下面代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReadonly</span>(<span class="params">value: any</span>): boolean {</span><br><span class="line">  <span class="keyword">return</span> readonlyToRaw.<span class="title function_">has</span>(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>问题 4：如何将响应式数据转化为原始数据？proxy 数据如何转化成 object？</p></blockquote><p>用 <code>reactiveToRaw</code> 和 <code>readonlyToRaw</code> 来存储<code>响应式数据 -&gt; 原始数据</code> 的映射关系，然后：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(<span class="attr">observed</span>: T): T {</span><br><span class="line">  <span class="keyword">return</span> reactiveToRaw.<span class="title function_">get</span>(observed) || readonlyToRaw.<span class="title function_">get</span>(observed) || observed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>总的来讲，就是利用各种集合来存储原始数据和响应式数据的映射关系，以便快速根据这种映射关系拿到对应的数据。</p><p>再回头看下 <code>canObserve</code> 方法，来看看到底有哪些数据是可以观察的：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canObserve = (<span class="attr">value</span>: any): <span class="function"><span class="params">boolean</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// Vue 实例不可观察，目前库里还没有 _isVue 的逻辑，不过猜测应该是内部在 setup 方法中挂载</span></span><br><span class="line">    !value.<span class="property">_isVue</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// virtual dom 不可观察</span></span><br><span class="line">    !value.<span class="property">_isVNode</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// 'Object', 'Array', 'Map', 'Set', 'WeakMap', 'WeakSet' 类型以外的不可观察</span></span><br><span class="line">    <span class="title function_">isObservableType</span>(<span class="title function_">toTypeString</span>(value)) &amp;&amp;</span><br><span class="line">    <span class="comment">// 已经标记为不可响应数据的不可观察</span></span><br><span class="line">    !nonReactiveValues.<span class="title function_">has</span>(value)</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>相比于 <code>Vue2</code> 的是否可观察判断，则少了很多条件：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我就不解析 Vue2 中的这段判断代码了</span></span><br><span class="line"><span class="comment">// 相比于 Vue2，少了 __ob__ ，ssr 以及 Object.isExtensible 的判断</span></span><br><span class="line"><span class="comment">// 这都是得益于 Proxy</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">hasOwn</span>(value, <span class="string">"__ob__"</span>) &amp;&amp; value.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) {</span><br><span class="line">  ob = value.<span class="property">__ob__</span>;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  shouldObserve &amp;&amp;</span><br><span class="line">  !<span class="title function_">isServerRendering</span>() &amp;&amp;</span><br><span class="line">  (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value) || <span class="title function_">isPlainObject</span>(value)) &amp;&amp;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) &amp;&amp;</span><br><span class="line">  !value.<span class="property">_isVue</span></span><br><span class="line">) {</span><br><span class="line">  ob = <span class="keyword">new</span> <span class="title class_">Observer</span>(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来就讲一下重点的 <code>reactive</code> 和 <code>readonly</code> 这两个核心方法的实现：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面讲过返回值就是上面的解套 Ref 类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: object</span>) {</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="comment">// 如果是一个只读响应式数据，直接返回，因为已经是响应式的了</span></span><br><span class="line">  <span class="keyword">if</span> (readonlyToRaw.<span class="title function_">has</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// target is explicitly marked as readonly by user</span></span><br><span class="line">  <span class="comment">// 如果曾经被标记为只读数据，直接调用 readonly 方法生成只读响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (readonlyValues.<span class="title function_">has</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readonly</span>(target)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建响应式对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target, <span class="comment">// 原始数据</span></span><br><span class="line">    rawToReactive, <span class="comment">// raw -&gt; observed</span></span><br><span class="line">    reactiveToRaw, <span class="comment">// observed -&gt; raw</span></span><br><span class="line">    mutableHandlers, <span class="comment">// 可变数据的 proxy handle</span></span><br><span class="line">    mutableCollectionHandlers <span class="comment">// 可变集合数据的 proxy handler</span></span><br><span class="line">  )</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> readonly&lt;T <span class="keyword">extends</span> object&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">Readonly</span>&lt;<span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;&gt; {</span><br><span class="line">  <span class="comment">// value is a mutable observable, retrieve its original and return</span></span><br><span class="line">  <span class="comment">// a readonly version.</span></span><br><span class="line">  <span class="comment">// 如果是响应式数据，那么获取原始数据来进行观察</span></span><br><span class="line">  <span class="keyword">if</span> (reactiveToRaw.<span class="title function_">has</span>(target)) {</span><br><span class="line">    target = reactiveToRaw.<span class="title function_">get</span>(target)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 创建响应式数据，同样</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target, <span class="comment">// 原始数据</span></span><br><span class="line">    rawToReadonly, <span class="comment">// raw -&gt; readonly observed</span></span><br><span class="line">    readonlyToRaw, <span class="comment">// readonly ovserved -&gt; raw</span></span><br><span class="line">    readonlyHandlers, <span class="comment">// 只读数据的 proxy handler</span></span><br><span class="line">    readonlyCollectionHandlers <span class="comment">// 只读集合数据的 proxy handler</span></span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实我们看 <code>Vue3</code> 的源码会发现，很多入口方法都变得短小精简，不像 <code>Vue2</code> 里的一些 exposed function 那样写的很长，这两个核心方法也一样，逻辑很简单，主要是进行一些原始数据检查和转换，核心实现逻辑都是放在 <code>createReactiveObject</code> 里的</p><p>下面继续看下核心实现方法 <code>createReactiveObject</code>：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建响应式对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any, <span class="comment">// 原始数据</span></span></span><br><span class="line"><span class="params">  toProxy: <span class="built_in">WeakMap</span>&lt;any, any&gt;, <span class="comment">// raw -&gt; (readonly) observed</span></span></span><br><span class="line"><span class="params">  toRaw: <span class="built_in">WeakMap</span>&lt;any, any&gt;, <span class="comment">// (readonly) observed -&gt; raw</span></span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;any&gt;, <span class="comment">// 只读/可变 数据的 proxy handler</span></span></span><br><span class="line"><span class="params">  collectionHandlers: ProxyHandler&lt;any&gt; <span class="comment">// 只读/可变 集合数据的 proxy handler</span></span></span><br><span class="line"><span class="params"></span>) {</span><br><span class="line">  <span class="comment">// 如果不是对象，则直接返回自身，包括 null，reactive(null) =&gt; null</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) {</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">${<span class="built_in">String</span>(target)}</span>`</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// target already has corresponding Proxy</span></span><br><span class="line">  <span class="comment">// 如果原始数据已经被观察过，直接通过 raw -&gt; observed 映射，返回响应式数据</span></span><br><span class="line">  <span class="keyword">let</span> observed = toProxy.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (observed !== <span class="keyword">void</span> <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> observed;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// target is already a Proxy</span></span><br><span class="line">  <span class="comment">// 如果原始数据本身就是响应式的，直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span> (toRaw.<span class="title function_">has</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// only a whitelist of value types can be observed.</span></span><br><span class="line">  <span class="comment">// 如果是不可观察对象，直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">canObserve</span>(target)) {</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 判断是采用基础数据（object|array）handler 还是集合数据 handler</span></span><br><span class="line">  <span class="keyword">const</span> handlers = collectionTypes.<span class="title function_">has</span>(target.<span class="property">constructor</span>)</span><br><span class="line">    ? collectionHandlers</span><br><span class="line">    : baseHandlers;</span><br><span class="line">  <span class="comment">// Proxy 创建代理对象，即响应式对象</span></span><br><span class="line">  observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handlers);</span><br><span class="line">  <span class="comment">// 创建后，设置好 raw &lt;-&gt; observed 的双向映射关系(*)</span></span><br><span class="line">  toProxy.<span class="title function_">set</span>(target, observed);</span><br><span class="line">  toRaw.<span class="title function_">set</span>(observed, target);</span><br><span class="line">  <span class="comment">// 上面讲到了 targetMap 的作用，这里是创建默认依赖追踪集合</span></span><br><span class="line">  <span class="keyword">if</span> (!targetMap.<span class="title function_">has</span>(target)) {</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, <span class="keyword">new</span> <span class="title class_">Map</span>());</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> observed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到：</p><ul><li>目前来看 <code>reactive</code> 和 <code>readonly</code> 的区别仅有两点：映射关系存储集合不同 and <code>proxy handler</code> 不同</li><li><code>object``array</code> 和集合类型 <code>Set``Map``WeakSet``WeakMap</code> 的 <code>proxy handler</code> 是不同的</li></ul><p>所以下面再来依次看下响应式核心中的核心 - 各种 <code>proxy handler</code></p><h2 id="baseHandler"><a href="#baseHandler" class="headerlink" title="baseHandler"></a>baseHandler</h2><p>方法跟上面一样，先看依赖：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面讲过，不过现在来看感觉像是是在 get set 这些 trap 方法里会调用</span></span><br><span class="line"><span class="keyword">import</span> { reactive, readonly, toRaw } <span class="keyword">from</span> <span class="string">"./reactive"</span>;</span><br><span class="line"><span class="comment">// 操作类型枚举，对应于 proxy handler 里的 trap 方法</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">OperationTypes</span> } <span class="keyword">from</span> <span class="string">"./operations"</span>;</span><br><span class="line"><span class="comment">// 依赖收集和触发依赖回调</span></span><br><span class="line"><span class="keyword">import</span> { track, trigger } <span class="keyword">from</span> <span class="string">"./effect"</span>;</span><br><span class="line"><span class="comment">// 全局锁，用来禁止 set 和 delete</span></span><br><span class="line"><span class="keyword">import</span> { <span class="variable constant_">LOCKED</span> } <span class="keyword">from</span> <span class="string">"./lock"</span>;</span><br><span class="line"><span class="comment">// 工具方法，类型判断</span></span><br><span class="line"><span class="keyword">import</span> { isObject, hasOwn, isSymbol } <span class="keyword">from</span> <span class="string">"@vue/shared"</span>;</span><br><span class="line"><span class="comment">// 判断是否是 ref，后面会讲到</span></span><br><span class="line"><span class="keyword">import</span> { isRef } <span class="keyword">from</span> <span class="string">"./ref"</span>;</span><br></pre></td></tr></tbody></table></figure><p>这里有两个疑问：</p><ol><li><code>track</code> 和 <code>trigger</code> 的实现</li><li><code>LOCKED</code> 的作用？为什么会有这个全局锁？</li></ol><p>问题 1 在后面的 <code>effect</code> 部分会讲到，现在只需要知道是用来追踪依赖和触发依赖回调方法就行</p><p>问题 2 现在我也不是特别了解，只知道是在组件 <code>mount</code> 和 <code>update</code> 的时候会对组件的 <code>props</code>的代理进行修改，因为我们都知道单向数据流中，子组件内部是不能更改 <code>props</code> 的，但是子组件更新，进行 vnode patch 后需要更新子组件的 <code>props</code>，包括一些动态 <code>props</code></p><p>再来看下变量和方法概览：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS 内部语言行为描述符集合，比如 Symbol.iterator 这些，在 get 里会用到</span></span><br><span class="line"><span class="keyword">const</span> builtInSymbols = <span class="keyword">new</span> <span class="title class_">Set</span>(</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Symbol</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">key</span> =&gt;</span> (<span class="title class_">Symbol</span> <span class="keyword">as</span> any)[key])</span><br><span class="line">    .<span class="title function_">filter</span>(isSymbol)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly: boolean</span>) {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  key: string | symbol,</span></span><br><span class="line"><span class="params">  value: any,</span></span><br><span class="line"><span class="params">  receiver: any</span></span><br><span class="line"><span class="params"></span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteProperty</span>(<span class="params">target: any, key: string | symbol</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params">target: any, key: string | symbol</span>): boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ownKeys</span>(<span class="params">target: any</span>): (string | number | symbol)[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;any&gt; = {</span><br><span class="line">  <span class="attr">get</span>: <span class="title function_">createGetter</span>(<span class="literal">false</span>),</span><br><span class="line">  set,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">readonlyHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;any&gt; = {</span><br><span class="line">  <span class="attr">get</span>: <span class="title function_">createGetter</span>(<span class="literal">true</span>),</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="attr">target</span>: any, <span class="attr">key</span>: string | symbol, <span class="attr">value</span>: any, <span class="attr">receiver</span>: any): boolean {</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable constant_">LOCKED</span>) {</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Set operation on key "<span class="subst">${<span class="built_in">String</span>(key)}</span>" failed: target is readonly.`</span>,</span><br><span class="line">          target</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="attr">target</span>: any, <span class="attr">key</span>: string | symbol): boolean {</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable constant_">LOCKED</span>) {</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Delete operation on key "<span class="subst">${<span class="built_in">String</span>(</span></span></span><br><span class="line"><span class="subst"><span class="string">            key</span></span></span><br><span class="line"><span class="subst"><span class="string">          )}</span>" failed: target is readonly.`</span>,</span><br><span class="line">          target</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，<code>mutableHandlers</code> 和 <code>readonlyHandlers</code> 都是定义了 5 个 trap 方法：<code>get</code>、<code>set</code>、<code>deleteProperty</code>、<code>has</code>、<code>ownKeys</code>，前 3 个不用多家介绍，<code>has</code> trap 针对与 <code>in</code> 操作符，而 <code>ownKeys</code> 针对于 <code>for in</code> 和 <code>Object.keys</code> 这些遍历操作的</p><p>而 <code>readonlyHandlers</code> 相比于 <code>mutableHandlers</code> 其实只是在 <code>get</code>、<code>set</code> 和 <code>deleteProperty</code> 这三个 trap 方法里有区别，而对于可能改变数据的 <code>set</code> 和 <code>deleteProperty</code> 方法，则是利用 <code>LOCKED</code> 来锁定，不让修改数据，这个变量我在上面也提了一下</p><p>下面来一个一个的看下各个 trap 方法</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 get trap 方法</span></span><br><span class="line"><span class="comment">// 如果是可变数据， isReadonly 是 false</span></span><br><span class="line"><span class="comment">// 如果是只读数据，那么 isReadonly 就是 true</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly: boolean</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: any, key: string | symbol, receiver: any</span>) {</span><br><span class="line">    <span class="comment">// 利用 Reflect 反射来获取原始值</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">    <span class="comment">// 如果是 JS 内置方法，不进行依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) &amp;&amp; builtInSymbols.<span class="title function_">has</span>(key)) {</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果是 ref 类型数据，则直接返回其 value</span></span><br><span class="line">    <span class="comment">// TODO 后面 ref 部分我们会讲到，ref(target) 其实在 get value 的时候做了依赖收集了，</span></span><br><span class="line">    <span class="comment">// 就不需要下面重复收集依赖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) {</span><br><span class="line">      <span class="keyword">return</span> res.<span class="property">value</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 类型操作的依赖收集</span></span><br><span class="line">    <span class="title function_">track</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">GET</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里其实很简单就是递归返回响应式对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isObject</span>(res)</span><br><span class="line">      ? isReadonly</span><br><span class="line">        ? <span class="comment">// need to lazy access readonly and reactive here to avoid</span></span><br><span class="line">          <span class="comment">// circular dependency</span></span><br><span class="line">          <span class="title function_">readonly</span>(res)</span><br><span class="line">        : <span class="title function_">reactive</span>(res)</span><br><span class="line">      : res;</span><br><span class="line">  };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看完 <code>get trap</code> 其实很简单，但是也会有写疑问：</p><h3 id="1-为什么用-Reflect-get，而不是直接-target-key-返回呢"><a href="#1-为什么用-Reflect-get，而不是直接-target-key-返回呢" class="headerlink" title="1. 为什么用 Reflect.get，而不是直接 target[key] 返回呢?"></a>1. 为什么用 <code>Reflect.get</code>，而不是直接 <code>target[key]</code> 返回呢?</h3><p>我们可以看它的第三个参数：</p><blockquote><p>receiver：如果 target 对象中指定了 getter，receiver 则为 getter 调用时的 this 值</p></blockquote><p>举个例子：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() {</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span>;</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observed = <span class="title function_">reactive</span>(target);</span><br></pre></td></tr></tbody></table></figure><p>此时，如果不用 <code>Reflect.get</code>，而是 <code>target[key]</code>，那么 <code>this.foo</code> 中的 <code>this</code> 就指向的是 <code>target</code>，而不是 <code>observed</code>，此时 <code>this.foo</code> 就不能收集到 <code>foo</code> 的依赖了，如果 <code>observed.foo = 20</code> 改变了 foo 的值，那么是无法触发依赖回调的，所以需要利用 <code>Reflect.get</code> 将 getter 里的 <code>this</code> 指向代理对象</p><h3 id="2-为什么在结尾-return-的时候还要调用-reactive-或者-readoonly-呢？"><a href="#2-为什么在结尾-return-的时候还要调用-reactive-或者-readoonly-呢？" class="headerlink" title="2. 为什么在结尾 return 的时候还要调用 reactive 或者 readoonly 呢？"></a>2. 为什么在结尾 return 的时候还要调用 <code>reactive</code> 或者 <code>readoonly</code> 呢？</h3><p>原注释是这样写的：</p><blockquote><p>need to lazy access readonly and reactive here to avoid circular dependency<br>翻译过来是：需要延迟地使用 readonly 和 readtive 来避免循环引用</p></blockquote><p>为什么这样说呢？这里不得不说一下 <code>Proxy</code> 的特性：只能代理一层，对于嵌套的深层对象，如果不按源码中的方法，那就需要一层层递归来代理劫持对象，即每次递归都判断是否是对象，如果是对象，那么再调用 <code>reactive</code> 来响应式化</p><p>但是问题又来了，JS 里是有循环引用这个概念的，就像下面这样：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = {</span><br><span class="line">  <span class="attr">b</span>: {},</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">a.<span class="property">b</span>.<span class="property">c</span> = a;</span><br></pre></td></tr></tbody></table></figure><p>这样的话，如果每次递归调用 <code>reactive</code> 的话，会造成调用栈溢出 <code>Maximum call stack size exceeded</code>，但是我们只需要加上一个判断条件即可解决，在上面解析的 <code>createReactiveObject</code> 方法里我们知道如果原始数据已经被观察过，则直接返回对应的响应式数据，那么我们可以在递归调用 <code>reactive</code> 的时候判断 <code>toProxy.get(target)</code> 是否存在，如果存在就不往下递归了，我写了一个例子代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环引用对象</span></span><br><span class="line"><span class="keyword">const</span> target = { <span class="attr">b</span>: { <span class="attr">c</span>: <span class="number">1</span> } };</span><br><span class="line">target.<span class="property">b</span>.<span class="property">d</span> = target;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是上面讲的 原始数据 -&gt; 响应式数据的集合</span></span><br><span class="line"><span class="keyword">const</span> rawToReactive = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">data</span>) {</span><br><span class="line">  <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, {</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) {</span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">      <span class="keyword">const</span> observed = rawToReactive.<span class="title function_">get</span>(res);</span><br><span class="line">      <span class="keyword">return</span> observed || res;</span><br><span class="line">    },</span><br><span class="line">  });</span><br><span class="line">  rawToReactive.<span class="title function_">set</span>(data, observed);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) {</span><br><span class="line">    <span class="keyword">const</span> child = data[key];</span><br><span class="line">    <span class="comment">// 这里判断如果没有被观察过，那么继续 reactive 递归观察</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">"object"</span> &amp;&amp; !rawToReactive.<span class="title function_">get</span>(child)) {</span><br><span class="line">      <span class="title function_">reactive</span>(child);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> observed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title function_">reactive</span>(target);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">b</span>.<span class="property">d</span>.<span class="property">b</span>); <span class="comment">// Proxy {c: 1, d: {…}}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我试了一下。跟源码里的 reactive 的 get 结果是一样的</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>可以去看下我在 <a href="https://zhuanlan.zhihu.com/p/87409653">vue3 响应式源码解析-Reactive 篇</a> 这篇文章下的评论部分</p></blockquote><p>而源码中的 <code>lazy access</code> 方式很取巧，只代理一层，当用到某个属性值对象时，再进行响应式观察这一层</p><p>所以相比于初始化时递归劫持，延迟访问劫持的方式更能<strong>提升初始化性能</strong>，也有利于对数据劫持做更细的控制，特别是针对于数据对象比较大时（比如接口返回数据嵌套过深），有些数据并非需要劫持，所以按需劫持代理我们用到的数据这种方式更好</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  key: string | symbol,</span></span><br><span class="line"><span class="params">  value: any,</span></span><br><span class="line"><span class="params">  receiver: any</span></span><br><span class="line"><span class="params"></span>): boolean {</span><br><span class="line">  <span class="comment">// 如果是观察过响应式数据，那么获取它映射的原始数据</span></span><br><span class="line">  value = <span class="title function_">toRaw</span>(value);</span><br><span class="line">  <span class="comment">// 获取旧值</span></span><br><span class="line">  <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">  <span class="comment">// 如果旧值是 ref 类型数据，而新的值不是 ref，那么直接赋值给 oldValue.value</span></span><br><span class="line">  <span class="comment">// 因为 ref 数据在 set value 的时候就已经 trigger 依赖了，所以直接 return 就行</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) {</span><br><span class="line">    oldValue.<span class="property">value</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 对象上是否有这个 key，有则是 set，无则是 add</span></span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line">  <span class="comment">// 利用 Reflect 来执行 set 操作</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">  <span class="comment">// don't trigger if target is something up in the prototype chain of original</span></span><br><span class="line">  <span class="comment">// 如果 target 原型链上的数据，那么就不触发依赖回调</span></span><br><span class="line">  <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) {</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">      <span class="comment">// 开发环境操作，只比正式环境多了个 extraInfo 的调试信息</span></span><br><span class="line">      <span class="keyword">const</span> extraInfo = { oldValue, <span class="attr">newValue</span>: value };</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) {</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">ADD</span>, key, extraInfo);</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (value !== oldValue) {</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">SET</span>, key, extraInfo);</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 上面讲过，有这个 key 则是 set，无则是 add</span></span><br><span class="line">      <span class="keyword">if</span> (!hadKey) {</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">ADD</span>, key);</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (value !== oldValue) {</span><br><span class="line">        <span class="comment">// 只有当 value 改变的时候才触发</span></span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">SET</span>, key);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同样，<code>set trap</code> 看起来也很简单，但是同时也会有一些问题：</p><h3 id="1-target-toRaw-receiver-是什么鬼逻辑"><a href="#1-target-toRaw-receiver-是什么鬼逻辑" class="headerlink" title="1. target === toRaw(receiver) 是什么鬼逻辑?"></a>1. <code>target === toRaw(receiver)</code> 是什么鬼逻辑?</h3><p>首先看下</p><p><a href="https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set%23%E5%8F%82%E6%95%B0">handler.set()developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set#%E5%8F%82%E6%95%B0<img src="https://pic4.zhimg.com/v2-72382e605ce3eba8154aa310a712c403_ipico.jpg" alt="img"></a></p><p>的关于第三个参数的说明：</p><blockquote><p>最初被调用的对象。通常是 proxy 本身，但 handler 的 set 方法也有可能在原型链上或以其他方式被间接地调用（因此不一定是 proxy 本身）。<br>比如，假设有一段代码执行 obj.name = “jen”，obj 不是一个 proxy 且自身不含 name 属性，但它的原型链上有一个 proxy，那么那个 proxy 的 set 拦截函数会被调用，此时 obj 会作为 receiver 参数传进来</p></blockquote><p>上面已经给出例子了，这里我再写一下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child = { <span class="attr">name</span>: <span class="string">"child"</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">"parent"</span> },</span><br><span class="line">  {</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(target, receiver);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(child, parent);</span><br><span class="line"></span><br><span class="line">child.<span class="property">foo</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会打印出</span></span><br><span class="line"><span class="comment">// {name: "parent"} {name: "child"}</span></span><br></pre></td></tr></tbody></table></figure><p>这里有两个先决条件：</p><ol><li>child 的原型链是一个 Proxy</li><li>child 在设置值的时候，本身不包含 key 的</li></ol><p>可以看到，当满足上面两个条件的时候，设置 child 的值，会触发原型链上的 <code>set trap</code> 方法，并且 <code>target</code> 是原型链数据，而 <code>receiver</code> 则是真实数据</p><p>所以，源码中的那个条件逻辑也就不难看懂了，当满足上述两个条件时，我们当然不希望触发 parent 的 <code>set trap</code> 了</p><h3 id="2-像数组的-unshift，splice-这些操作是如何触发-set-trap方法的呢？"><a href="#2-像数组的-unshift，splice-这些操作是如何触发-set-trap方法的呢？" class="headerlink" title="2. 像数组的 unshift，splice 这些操作是如何触发 set trap方法的呢？"></a>2. 像数组的 <code>unshift</code>，<code>splice</code> 这些操作是如何触发 <code>set trap</code>方法的呢？</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 set 里加上这么一个 log</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  !hadKey ? <span class="string">"add"</span> : value !== oldValue ? <span class="string">"set"</span> : <span class="string">"unknow"</span>,</span><br><span class="line">  target,</span><br><span class="line">  key,</span><br><span class="line">  value,</span><br><span class="line">  oldValue</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>然后</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">a.<span class="title function_">unshift</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会打印</span></span><br><span class="line"><span class="comment">// add [1, 2, 3, 3] 3 3 undefined</span></span><br><span class="line"><span class="comment">// set [1, 2, 2, 3] 2 2 3</span></span><br><span class="line"><span class="comment">// set [1, 1, 2, 3] 1 1 2</span></span><br><span class="line"><span class="comment">// set [0, 1, 2, 3] 0 0 1</span></span><br><span class="line"><span class="comment">// unknow [0, 1, 2, 3] length 4 4</span></span><br></pre></td></tr></tbody></table></figure><p>一共打印了 5 次，根据打印内容我们可以看到 <code>unshift</code> 的实际操作过程，即把数组的每一项依次都往后移动一位，然后再把首位设置成 <code>0</code>，至于为什么这么操作，</p><p><a href="https://link.zhihu.com/?target=https://www.ecma-international.org/ecma-262/6.0/%23sec-array.prototype.unshift">ECMA-262 Array.property.unshiftwww.ecma-international.org/ecma-262/6.0/#sec-array.prototype.unshift</a></p><p>标准中有原理介绍，我就不赘述了，还有像 <code>shift</code> 和 <code>splice</code> 也是一样的操作步骤</p><p>可以看到 <code>unshift</code> 或者 <code>splice</code> 是会带来多次的 <code>trigger</code> 的，当然这些会有批量跟新优化的，有时间我再展开讲一下</p><p>细心的同学可能会发现，还触发了 <code>length</code> 属性的 set，而且 <code>value</code> 和 <code>oldValue</code> 是一样的，那么根据源码所示，就不会触发 set 类型的回调了呀，那我们如果在 template 里用到了 <code>a.length</code> 那也不会更新了么？</p><p>肯定是会更新的，解决办法就在 <code>trigger</code> 这个方法里，后续 <code>effect</code> 部分会讲到，先简单说一下，对于会导致数组 <code>length</code> 改变的操作，比如 add 和 delete，在 <code>effect</code> 的 <code>trigger</code> 方法里会单独处理，来触发 <code>length</code> 属性的依赖回调的</p><h3 id="其他-trap-方法"><a href="#其他-trap-方法" class="headerlink" title="其他 trap 方法"></a>其他 trap 方法</h3><p>还有 <code>deleteProperty</code>、<code>has</code> 和 <code>ownKeys</code> 这几个 trap，代码不多，都很简单，直接看下面的源码就能明白，我就不在赘述了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deleteProperty trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteProperty</span>(<span class="params">target: any, key: string | symbol</span>): boolean {</span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line">  <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key);</span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; hadKey) {</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) {</span><br><span class="line">      <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">DELETE</span>, key, { oldValue });</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="title function_">trigger</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">DELETE</span>, key);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// has trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params">target: any, key: string | symbol</span>): boolean {</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, key);</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">HAS</span>, key);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ownKey trap 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ownKeys</span>(<span class="params">target: any</span>): (string | number | symbol)[] {</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">OperationTypes</span>.<span class="property">ITERATE</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>baseHandler</code> 是针对于数组和对象类型的数据的 proxy handler</li><li>每个 <code>trap</code> 方法都是用 <code>Reflect</code> 来反射到原始数据上的</li><li>对于 <code>get</code>、<code>has</code> 和 <code>ownKeys</code> 这一类读操作，会进行 <code>track</code> 来收集依赖，而对于 <code>set</code> 和 <code>deleteProperty</code> 这类写操作，则是会进行 <code>trigger</code> 来触发依赖回调</li><li>响应式数据的读取是 <code>lazy</code> 的，即初始化的时候不会对嵌套对象全盘观察，而是只有用到了每个值才会生成对应的响应式数据</li></ul><h2 id="collectionHandler"><a href="#collectionHandler" class="headerlink" title="collectionHandler"></a>collectionHandler</h2><p>还记得我们在看 <code>reactive</code> 方法那里有个 <code>collectionTypes</code> 的判断对吧，<code>collectionHandler</code> 就是专门来处理 <code>Set|Map|WeakSet|WeakMap</code> 这类集合类型数据的</p><p>这里可以参考相学长的</p><p><a href="https://link.zhihu.com/?target=https://juejin.im/post/5da9d7ebf265da5bbb1e52b7%23heading-12">vue3 响应式源码解析-Reactive 篇 - 掘金 juejin.im/post/5da9d7ebf265da5bbb1e52b7#heading-12</a></p><p>这篇文章，写的很详细，我这里也不再赘述了</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>最开始阅读 <code>reactive</code> 源码时，总体的逻辑是比较清晰的，但是仍然有几个地方当时有疑惑：</p><ul><li><code>rawToReactive|rawToReadonly</code> 等这几个变量是干嘛的？</li><li><code>targetMap</code> 的是干什么的？为什么是 <code>WeakMap&lt;any, KeyToDepMap&gt;</code> 类型</li><li><code>LOCKED</code> 是用来干嘛的?</li><li><code>baseHandler</code> 的 <code>get trap</code> 为什么又返回了一个 <code>reactive(res)</code>？</li><li><code>collectionHandler</code> 里的 trap 方法为什么只有 <code>get</code>？为什么跟 <code>baseHandler</code> 不一样？</li></ul><p>在读完源码后，除了 <code>LOCKED</code> 那个疑惑，其他几个问题我都已经找到答案，并且也在上面解惑了，我相信大家看完这篇文章后也应该都有自己的答案了</p><p>最后再来个源码里的知识点总结吧：</p><ul><li><code>reactive</code> 是利用 <code>Proxy</code> 来进行数据观察，<code>Reflect</code> 相关操作来反射到原始数据的，并且数据的访问是一个 <code>lazy reactive</code> 方式，即按需观察</li><li>普通对象、数组和集合类型数据的代理 handler 是不同的，这是因为 <code>Proxy</code> 的一些限制，参考</li></ul><p><a href="https://link.zhihu.com/?target=https://javascript.info/proxy%23proxy-limitations">Proxy and Reflectjavascript.info/proxy#proxy-limitations<img src="https://pic4.zhimg.com/v2-371dd24f02bbb7f17ea00a910ff8f70b_180x120.jpg" alt="img"></a></p><ul><li>利用几个 <code>WeakMap</code> 来存储原始数据 &lt;-&gt; 响应式数据的双向映射关系，以便在响应式入口方法里判断是否原始数据已经被观察过，这个相比于 Vue2 的直接在原始数据上挂载 <code>__ob__</code>要少一些冗余数据，并且由于 <code>WeakMap</code> 的 GC 特性，在运行时会有一定的内存优化</li><li>响应式数据的读操作会 <code>track</code> 来收集依赖，写操作则是会 <code>trigger</code> 来触发依赖回调</li></ul><p>整个 <code>reactive|readonly</code> 的流程如下：</p><p><img src="https://pic3.zhimg.com/80/v2-849f116c5d6f242c776ab5b8d610ee1a_720w.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 原理 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目优化</title>
      <link href="/2022/04/09/xing-neng-you-hua/"/>
      <url>/2022/04/09/xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="页面内容的呈现过程"><a href="#页面内容的呈现过程" class="headerlink" title="页面内容的呈现过程"></a>页面内容的呈现过程</h1><h2 id="页面的首屏加载性能-白屏时间是否过长？"><a href="#页面的首屏加载性能-白屏时间是否过长？" class="headerlink" title="页面的首屏加载性能 白屏时间是否过长？"></a>页面的首屏加载性能 白屏时间是否过长？</h2><h2 id="页面加载时的-loading-动画-是否需要骨架屏-骨架屏消失时使得否存在页面抖动"><a href="#页面加载时的-loading-动画-是否需要骨架屏-骨架屏消失时使得否存在页面抖动" class="headerlink" title="页面加载时的 loading 动画 是否需要骨架屏 骨架屏消失时使得否存在页面抖动"></a>页面加载时的 loading 动画 是否需要骨架屏 骨架屏消失时使得否存在页面抖动</h2><h2 id="数据为空时-页面模块的占位方式-数据返回时-是否会出现页面抖动"><a href="#数据为空时-页面模块的占位方式-数据返回时-是否会出现页面抖动" class="headerlink" title="数据为空时 页面模块的占位方式 数据返回时 是否会出现页面抖动"></a>数据为空时 页面模块的占位方式 数据返回时 是否会出现页面抖动</h2><h2 id="页面异常处理时-是否提供了合理的用户反馈"><a href="#页面异常处理时-是否提供了合理的用户反馈" class="headerlink" title="页面异常处理时 是否提供了合理的用户反馈"></a>页面异常处理时 是否提供了合理的用户反馈</h2><h2 id="页面适配-对于不同尺寸的设备-是否都能保证主要内容的首屏透出"><a href="#页面适配-对于不同尺寸的设备-是否都能保证主要内容的首屏透出" class="headerlink" title="页面适配 对于不同尺寸的设备 是否都能保证主要内容的首屏透出"></a>页面适配 对于不同尺寸的设备 是否都能保证主要内容的首屏透出</h2><h2 id="文本超长时是做阶段还是省略处理"><a href="#文本超长时是做阶段还是省略处理" class="headerlink" title="文本超长时是做阶段还是省略处理"></a>文本超长时是做阶段还是省略处理</h2><h2 id="图片加载时如何占位-加载失败时如何处理-是否需要做缩放处理"><a href="#图片加载时如何占位-加载失败时如何处理-是否需要做缩放处理" class="headerlink" title="图片加载时如何占位 加载失败时如何处理 是否需要做缩放处理"></a>图片加载时如何占位 加载失败时如何处理 是否需要做缩放处理</h2><h2 id="页面变化时是否有合理的过渡和动画"><a href="#页面变化时是否有合理的过渡和动画" class="headerlink" title="页面变化时是否有合理的过渡和动画"></a>页面变化时是否有合理的过渡和动画</h2><h1 id="页面交互的体验细节"><a href="#页面交互的体验细节" class="headerlink" title="页面交互的体验细节"></a>页面交互的体验细节</h1><h2 id="用户操作的响应性时间是否过长"><a href="#用户操作的响应性时间是否过长" class="headerlink" title="用户操作的响应性时间是否过长"></a>用户操作的响应性时间是否过长</h2><h2 id="按钮的点击区域是否合理"><a href="#按钮的点击区域是否合理" class="headerlink" title="按钮的点击区域是否合理"></a>按钮的点击区域是否合理</h2><h2 id="文字长按是否可以选中"><a href="#文字长按是否可以选中" class="headerlink" title="文字长按是否可以选中"></a>文字长按是否可以选中</h2><h2 id="页面滚动是否需要滚动栏"><a href="#页面滚动是否需要滚动栏" class="headerlink" title="页面滚动是否需要滚动栏"></a>页面滚动是否需要滚动栏</h2><h2 id="页面浮层是否存在点击或滚动穿透"><a href="#页面浮层是否存在点击或滚动穿透" class="headerlink" title="页面浮层是否存在点击或滚动穿透"></a>页面浮层是否存在点击或滚动穿透</h2><h2 id="图片长按是否可以保存"><a href="#图片长按是否可以保存" class="headerlink" title="图片长按是否可以保存"></a>图片长按是否可以保存</h2><h1 id="页面的可访问性"><a href="#页面的可访问性" class="headerlink" title="页面的可访问性"></a>页面的可访问性</h1>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带你剖析设计模式</title>
      <link href="/2022/04/09/qian-tan-she-ji-mo-shi/"/>
      <url>/2022/04/09/qian-tan-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态的思想是把”做什么”和“谁去做”分开来</p><p><strong>多态最根本的作用是通过过程化的条件分支语句转化为对象的多态性 从而消除这些条件分支语句</strong></p><p>将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//不用多态的版本</span><br><span class="line">var googleMap = {</span><br><span class="line"> show: function(){</span><br><span class="line"> console.log( '开始渲染谷歌地图' );</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var baiduMap = {</span><br><span class="line"> show: function(){</span><br><span class="line"> console.log( '开始渲染百度地图' );</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var renderMap = function( type ){</span><br><span class="line"> if ( type === 'google' ){</span><br><span class="line"> googleMap.show();</span><br><span class="line"> }else if ( type === 'baidu' ){</span><br><span class="line"> baiduMap.show();</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">renderMap( 'google' ); // 输出：开始渲染谷歌地图</span><br><span class="line">renderMap( 'baidu' ); // 输出：开始渲染百度地图</span><br><span class="line">//不断地在renderMap中堆砌条件分支语句 导致代码臃肿</span><br><span class="line">var renderMap = function( map ){</span><br><span class="line"> if ( map.show instanceof Function ){</span><br><span class="line"> map.show();</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">//使用多态 只需要关注发出show的动作 不必关心是谁的show做什么动作</span><br></pre></td></tr></tbody></table></figure><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><ul><li>所有数据都是对象</li><li>要得到一个对象 不是通过实例化一个类 而是找到一个对象并作为原型克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求 就会把这个请求委托给它自己的原型</li></ul><h1 id="this、call、apply"><a href="#this、call、apply" class="headerlink" title="this、call、apply"></a>this、call、apply</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this 总是指向一个对象 而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的 而非函数声明的环境</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>使用闭包的同时容易形成循环引用 如果闭包的作用域链中存在一些 DMO 节点 就可能造成内存泄漏</p><p>要解决循环引用带来的内存泄露问题 只需要讲循环引用中的变量设为 null 即可</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证一个类仅有一个实例 并提供一个访问它的全局访问点 <strong>即单例模式的核心是确保只有一个实例并提供全局访问</strong></p><p>作为开发者应该尽量减少全局变量的使用 可以使用闭包封装私有变量来避免对全局的命令污染</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user = (function(){</span><br><span class="line"> var __name = 'sven',</span><br><span class="line"> __age = 29;</span><br><span class="line"> return {</span><br><span class="line"> getUserInfo: function(){</span><br><span class="line"> return __name + '-' + __age;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>定义：定义一系列的算法 把它们一个一个封装起来 并且使它们可以互相替换 <strong>目的是将算法的使用与算法的实现分离开来</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var strategies = {</span><br><span class="line"> "S": function( salary ){</span><br><span class="line"> return salary * 4;</span><br><span class="line"> },</span><br><span class="line"> "A": function( salary ){</span><br><span class="line"> return salary * 3;</span><br><span class="line"> },</span><br><span class="line"> "B": function( salary ){</span><br><span class="line"> return salary * 2;</span><br><span class="line">图灵社区会员 轩辕 专享 尊重版权</span><br><span class="line">76 第 5 章 策略模式</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var calculateBonus = function( level, salary ){</span><br><span class="line"> return strategies[ level ]( salary );</span><br><span class="line">};</span><br><span class="line">console.log( calculateBonus( 'S', 20000 ) ); // 输出：80000</span><br><span class="line">console.log( calculateBonus( 'A', 10000 ) ); // 输出：30000</span><br></pre></td></tr></tbody></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>保护代理：代理可以帮助过滤掉一些请求</p><p>虚拟代理：虚拟代理把一些开销很大的对象延迟到真正需要它的时候才去创建</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">虚拟代理：</span><br><span class="line">var myImage = (function(){</span><br><span class="line"> var imgNode = document.createElement( 'img' );</span><br><span class="line"> document.body.appendChild( imgNode );</span><br><span class="line"> return {</span><br><span class="line"> setSrc: function( src ){</span><br><span class="line"> imgNode.src = src;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">var proxyImage = (function(){</span><br><span class="line"> var img = new Image;</span><br><span class="line"> img.onload = function(){</span><br><span class="line"> myImage.setSrc( this.src );</span><br><span class="line"> }</span><br><span class="line"> return {</span><br><span class="line"> setSrc: function( src ){</span><br><span class="line"> myImage.setSrc( 'file:// /C:/Users/svenzeng/Desktop/loading.gif' );</span><br><span class="line"> img.src = src;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">proxyImage.setSrc( 'http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg' );</span><br><span class="line">//加载中用一张本地图片 加载后才替换为对应url</span><br></pre></td></tr></tbody></table></figure><p>单一职责原则：一个类（通常包括对象和函数等）而言，应该仅有一个引起它变化的原因 如果一个对象承担的职责过多 就会导致脆弱和低内聚</p><p>**代理和本体应该拥有一样的主要逻辑功能 这样用户可以在不需要用到代理的时候直接将请求对象改成本体而无需修改本体的代码 **</p><p><strong>虚拟代理合并 http 请求</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">需求场景：同步文件 如果短时间内连续发送请求会导致服务器压力太大 可以设置代理函数收集一段时间内的请求最后一次性发送给服务器 除非是对实时性要求高的系统 不然延迟都不会带来太大的副作用却可以大大减轻服务器的压力</span><br><span class="line">var synchronousFile = function( id ){</span><br><span class="line"> console.log( '开始同步文件，id 为: ' + id );</span><br><span class="line">};</span><br><span class="line">var proxySynchronousFile = (function(){</span><br><span class="line"> var cache = [], // 保存一段时间内需要同步的 ID</span><br><span class="line"> timer; // 定时器</span><br><span class="line"> return function( id ){</span><br><span class="line"> cache.push( id );</span><br><span class="line"> if ( timer ){ // 保证不会覆盖已经启动的定时器</span><br><span class="line"> return;</span><br><span class="line"> }</span><br><span class="line"> timer = setTimeout(function(){</span><br><span class="line"> synchronousFile( cache.join( ',' ) ); // 2 秒后向本体发送需要同步的 ID 集合</span><br><span class="line"> clearTimeout( timer ); // 清空定时器</span><br><span class="line"> timer = null;</span><br><span class="line"> cache.length = 0; // 清空 ID 集合</span><br><span class="line"> }, 2000 );</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">var checkbox = document.getElementsByTagName( 'input' );</span><br><span class="line">for ( var i = 0, c; c = checkbox[ i++ ]; ){</span><br><span class="line">c.onclick = function(){</span><br><span class="line"> if ( this.checked === true ){</span><br><span class="line"> proxySynchronousFile( this.id );</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>缓存代理可以为一些开销很大的运算结果提供暂时的储存 在下次运算时 如果传递进来的参数跟之前的一样 就可以直接返回之前的计算结果</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">先创建一个用于求乘积的函数：</span><br><span class="line">var mult = function(){</span><br><span class="line"> console.log( '开始计算乘积' );</span><br><span class="line"> var a = 1;</span><br><span class="line"> for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"> a = a * arguments[i];</span><br><span class="line"> }</span><br><span class="line"> return a;</span><br><span class="line">};</span><br><span class="line">mult( 2, 3 ); // 输出：6</span><br><span class="line">mult( 2, 3, 4 ); // 输出：24</span><br><span class="line">现在加入缓存代理函数：</span><br><span class="line">var proxyMult = (function(){</span><br><span class="line"> var cache = {};</span><br><span class="line"> return function(){</span><br><span class="line"> var args = Array.prototype.join.call( arguments, ',' );</span><br><span class="line"> if ( args in cache ){</span><br><span class="line"> return cache[ args ];</span><br><span class="line"> }</span><br><span class="line"> return cache[ args ] = mult.apply( this, arguments );</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line"> proxyMult( 1, 2, 3, 4 ); // 输出：24</span><br><span class="line"> proxyMult( 1, 2, 3, 4 ); // 输出：24第二次并没有进行计算 而是直接返回之前计算好的结果 通过增加缓存代理的方式 mult函数可以继续专注于自身的职责-计算乘积 而缓存的功能时由代理对象实现的</span><br></pre></td></tr></tbody></table></figure><p><strong>缓存代理用于 api 请求</strong></p><p>在进行请求一些不变的数据的时候（分页需求）同一页的数据理论上只需要去后台拉取一次，这些已经拉取到的数据在某个地方被缓存之后 下次再请求同一页的时候 就可以直接使用之前的数据 可以通过缓存代理实现</p><p><strong>使用高阶函数动态创建代理</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**************** 计算乘积 *****************/</span><br><span class="line">var mult = function(){</span><br><span class="line"> var a = 1;</span><br><span class="line"> for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"> a = a * arguments[i];</span><br><span class="line"> }</span><br><span class="line"> return a;</span><br><span class="line">};</span><br><span class="line">/**************** 计算加和 *****************/</span><br><span class="line">var plus = function(){</span><br><span class="line"> var a = 0;</span><br><span class="line"> for ( var i = 0, l = arguments.length; i &lt; l; i++ ){</span><br><span class="line"> a = a + arguments[i];</span><br><span class="line"> }</span><br><span class="line"> return a;</span><br><span class="line">};</span><br><span class="line">/**************** 创建缓存代理的工厂 *****************/</span><br><span class="line">var createProxyFactory = function( fn ){</span><br><span class="line"> var cache = {};</span><br><span class="line"> return function(){</span><br><span class="line"> var args = Array.prototype.join.call( arguments, ',' );</span><br><span class="line"> if ( args in cache ){</span><br><span class="line"> return cache[ args ];</span><br><span class="line"> }</span><br><span class="line"> return cache[ args ] = fn.apply( this, arguments );</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var proxyMult = createProxyFactory( mult ),</span><br><span class="line">proxyPlus = createProxyFactory( plus );</span><br><span class="line">alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24</span><br><span class="line">alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24</span><br><span class="line">alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10</span><br><span class="line">alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10</span><br></pre></td></tr></tbody></table></figure><p>tips：编写业务的时候往往不需要预先去猜测是否需要使用代理模式 当真正发现不方便的时候直接访问某个对象的时候 再编写代理也不迟</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象 的内部表示</p><h1 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h1><p>发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状 态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型 来替代传统的发布—订阅模式。</p><p><strong>发布-订阅模式可以广泛用于异步编程中 是一种可以代替回调函数的方案 在异步编程中使用发布-订阅模式 我们就无需过多关注对象在一异步运行期间的内部状态 而只需要订阅感兴趣的事件发生点</strong></p><p><strong>发布-订阅模式可以取代对象之间的硬编码的通知方式 一个对象不再显式地调用另一个对象的某个接口实现松耦合 可以单独对订阅者和发布者做修改而不用去修改其引用</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">发布-订阅模式的步骤</span><br><span class="line">1.首先要指定谁充当发布者</span><br><span class="line">2.然后给发布者添加一个缓存列表 用于存放回调函数以便通知订阅者</span><br><span class="line">3.最后在发布消息的时候 发布者会遍历这个缓存列表 依次触发里面存放的订阅者函数 另外 可以往回调函数中加入一些参数 订阅者可以接收参数 这很有必要</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">var event = {</span><br><span class="line"> clientList: [],</span><br><span class="line"> listen: function( key, fn ){</span><br><span class="line"> if ( !this.clientList[ key ] ){</span><br><span class="line"> this.clientList[ key ] = [];</span><br><span class="line"> }</span><br><span class="line"> this.clientList[ key ].push( fn ); // 订阅的消息添加进缓存列表</span><br><span class="line"> },</span><br><span class="line"> trigger: function(){</span><br><span class="line"> var key = Array.prototype.shift.call( arguments ), // (1);</span><br><span class="line"> fns = this.clientList[ key ];</span><br><span class="line"> if ( !fns || fns.length === 0 ){ // 如果没有绑定对应的消息</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> for( var i = 0, fn; fn = fns[ i++ ]; ){</span><br><span class="line"> fn.apply( this, arguments ); // (2) // arguments 是 trigger 时带上的参数</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布—订阅功能：</span><br><span class="line">var installEvent = function( obj ){</span><br><span class="line"> for ( var i in event ){</span><br><span class="line"> obj[ i ] = event[ i ];</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">再来测试一番，我们给售楼处对象 salesOffices 动态增加发布—订阅功能：</span><br><span class="line">var salesOffices = {};</span><br><span class="line">installEvent( salesOffices );</span><br><span class="line">salesOffices.listen( 'squareMeter88', function( price ){ // 小明订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.listen( 'squareMeter100', function( price ){ // 小红订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.trigger( 'squareMeter88', 2000000 ); // 输出：2000000</span><br><span class="line">salesOffices.trigger( 'squareMeter100', 3000000 ); // 输出：3000000</span><br><span class="line">取消订阅的事件</span><br><span class="line">event.remove = function( key, fn ){</span><br><span class="line"> var fns = this.clientList[ key ];</span><br><span class="line"> if ( !fns ){ // 如果 key 对应的消息没有被人订阅，则直接返回</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> if ( !fn ){ // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅</span><br><span class="line"> fns &amp;&amp; ( fns.length = 0 );</span><br><span class="line"> }else{</span><br><span class="line"> for ( var l = fns.length - 1; l &gt;=0; l-- ){ // 反向遍历订阅的回调函数列表</span><br><span class="line"> var _fn = fns[ l ];</span><br><span class="line"> if ( _fn === fn ){</span><br><span class="line"> fns.splice( l, 1 ); // 删除订阅者的回调函数</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line">var salesOffices = {};</span><br><span class="line">var installEvent = function( obj ){</span><br><span class="line"> for ( var i in event ){</span><br><span class="line"> obj[ i ] = event[ i ];</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">installEvent( salesOffices );</span><br><span class="line">salesOffices.listen( 'squareMeter88', fn1 = function( price ){ // 小明订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.listen( 'squareMeter88', fn2 = function( price ){ // 小红订阅消息</span><br><span class="line"> console.log( '价格= ' + price );</span><br><span class="line">});</span><br><span class="line">salesOffices.remove( 'squareMeter88', fn1 ); // 删除小明的订阅</span><br><span class="line">salesOffices.trigger( 'squareMeter88', 2000000 ); // 输出：2000000</span><br></pre></td></tr></tbody></table></figure><p><strong>全局的发布订阅模式</strong></p><p>发布订阅模式可以用一个全局的 Event 对象来实现 订阅者不需要了解消息来自哪个发布者 发布者也不知道消息会被推送给哪些订阅者 Event 作为一个类似于中介的角色把订阅者和发布者联系起来</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">var Event = (function(){</span><br><span class="line"> var clientList = {},</span><br><span class="line"> listen,</span><br><span class="line"> trigger,</span><br><span class="line"> remove;</span><br><span class="line"> listen = function( key, fn ){</span><br><span class="line"> if ( !clientList[ key ] ){</span><br><span class="line"> clientList[ key ] = [];</span><br><span class="line"> }</span><br><span class="line"> clientList[ key ].push( fn );</span><br><span class="line"> };</span><br><span class="line"> trigger = function(){</span><br><span class="line"> var key = Array.prototype.shift.call( arguments ),</span><br><span class="line"> fns = clientList[ key ];</span><br><span class="line"> if ( !fns || fns.length === 0 ){</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> for( var i = 0, fn; fn = fns[ i++ ]; ){</span><br><span class="line"> fn.apply( this, arguments );</span><br><span class="line">}</span><br><span class="line"> };</span><br><span class="line"> remove = function( key, fn ){</span><br><span class="line"> var fns = clientList[ key ];</span><br><span class="line"> if ( !fns ){</span><br><span class="line"> return false;</span><br><span class="line"> }</span><br><span class="line"> if ( !fn ){</span><br><span class="line"> fns &amp;&amp; ( fns.length = 0 );</span><br><span class="line"> }else{</span><br><span class="line"> for ( var l = fns.length - 1; l &gt;=0; l-- ){</span><br><span class="line"> var _fn = fns[ l ];</span><br><span class="line"> if ( _fn === fn ){</span><br><span class="line"> fns.splice( l, 1 );</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> };</span><br><span class="line"> return {</span><br><span class="line"> listen: listen,</span><br><span class="line"> trigger: trigger,</span><br><span class="line"> remove: remove</span><br><span class="line"> }</span><br><span class="line">})();</span><br><span class="line">Event.listen( 'squareMeter88', function( price ){ // 小红订阅消息</span><br><span class="line"> console.log( '价格= ' + price ); // 输出：'价格=2000000'</span><br><span class="line">});</span><br><span class="line">Event.trigger( 'squareMeter88', 2000000 ); // 售楼处发布消息</span><br></pre></td></tr></tbody></table></figure><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的原理实现</title>
      <link href="/2022/04/09/vue-kuang-jia-jie-du-1.0/"/>
      <url>/2022/04/09/vue-kuang-jia-jie-du-1.0/</url>
      
        <content type="html"><![CDATA[<h1 id="权衡的艺术"><a href="#权衡的艺术" class="headerlink" title="权衡的艺术"></a>权衡的艺术</h1><h2 id="1-3-虚拟-dom"><a href="#1-3-虚拟-dom" class="headerlink" title="1.3 虚拟 dom"></a>1.3 虚拟 dom</h2><p>虚拟 dom 的耗时：创建 javascript 的计算量 + 创建真实 dom 的计算量 （数据变化量有关）</p><p>innerHtml 的耗时：拼接字符串的计算量 + innerHtml 的 DOM 计算量 （模板大小有关）</p><p><strong>原生 JavaScript &gt; 虚拟 dom &gt; innerHTML</strong></p><h2 id="1-4-运行和编译时"><a href="#1-4-运行和编译时" class="headerlink" title="1.4 运行和编译时"></a>1.4 运行和编译时</h2><h1 id="1-框架设计的核心要素"><a href="#1-框架设计的核心要素" class="headerlink" title="1 框架设计的核心要素"></a>1 框架设计的核心要素</h1><h2 id="2-1-缩减框架代码的体积"><a href="#2-1-缩减框架代码的体积" class="headerlink" title="2.1 缩减框架代码的体积"></a>2.1 缩减框架代码的体积</h2><p>例：vue3 源码的 warn 函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(_DEV_ &amp;&amp; ires) {</span><br><span class="line">warn(</span><br><span class="line">'faile to ....')</span><br><span class="line">};</span><br><span class="line">//vue.js使用rolllup.js对项目进项构建 这里的_DEV_实际上就是通过rollup.js的设置来预定义的 类似于webpack的DefinePlugin插件</span><br><span class="line">当用于开发环境时 _DEV_为true 即 if(true &amp;&amp; ires)</span><br><span class="line">而在构建生产环境中 _DEV_会被翻译为false 即 if(false &amp;&amp; _DEV_) 这样就永远不会执行</span><br><span class="line">**这种永远不会执行的代码称之为dead code 在构建最终项目的时候就会被移除 从而可以在开发环境中提供友好的提示 生产环境中减少代码的体积</span><br><span class="line">**vue3源码多出利用相似逻辑保证了开发环境的友好体验和生产环境的代码体积控制</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2Tree-Shaking"><a href="#2-2Tree-Shaking" class="headerlink" title="2.2Tree-Shaking"></a>2.2Tree-Shaking</h2><p>Tree-Shaking：消除永远不会使用到的代码 如上面说的<em>DEV</em></p><p><strong>能使用 Tree-Shaking 的必须是满足 ESM</strong></p><p>Tree-Shaking 会产生副作用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**加上标记来告诉系统可以安心清除副作用</span><br><span class="line">import {foo} from './utils';</span><br><span class="line">/*#_PURE_*/ foo();//   /*#_PURE_*/会告诉roupull.js可以放心进行Tree-Shaking</span><br><span class="line">vue3的源码多出使用/*#_PURE_*/来标记 都用于顶级调用</span><br><span class="line">export const isHTMLTag = /*#_PURE_*/ makeMap(HTML_TAGS);</span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-框架输出的产物"><a href="#2-3-框架输出的产物" class="headerlink" title="2.3 框架输出的产物"></a>2.3 框架输出的产物</h2><p>无论是 rollup.js 还是 webpack 在寻找资源文件的时候 如果 package.json 中存在 module 字段 都会优先使用 module 字段指向的资源代替 main 字段指向的资源</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">"main": 'index.js',</span><br><span class="line">"module": 'dist/vue.runtime.esm-bundler.js'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用处：当我们使用构建提供工具打包的 ESM 格式的资源时 不能直接把<em>DEV</em>转换成 true 或 false 需要使用(process.env.NODE* !== ‘production’)替换—DEV*常量</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if((process.env.NODE) !== 'production') {</span><br><span class="line">....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需求场景：当进行服务端渲染时 vue.js 的代码是在 Node.js 的环境中运行的 但是 Node.js 时 CommonJS 形式 所以可以更改 roullup.js 中的 format 配置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format: 'cjs'//指定模块形式</span><br></pre></td></tr></tbody></table></figure><h2 id="2-4-特定开关"><a href="#2-4-特定开关" class="headerlink" title="2.4 特定开关"></a>2.4 特定开关</h2><h2 id="2-5-错误处理"><a href="#2-5-错误处理" class="headerlink" title="2.5 错误处理"></a>2.5 错误处理</h2><h1 id="VUE-JS3-的设计思路"><a href="#VUE-JS3-的设计思路" class="headerlink" title="VUE.JS3 的设计思路"></a>VUE.JS3 的设计思路</h1><h2 id="3-2-渲染器"><a href="#3-2-渲染器" class="headerlink" title="3.2 渲染器"></a>3.2 渲染器</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function renderer(vnode, container) {</span><br><span class="line">  // 使用 vnode.tag 作为标签名称创建 DOM 元素</span><br><span class="line">const el = document.createElement(vnode.tag)</span><br><span class="line">  // 遍历 vnode.props 将属性、事件添加到 DOM 元素</span><br><span class="line">  for (const key in vnode.props) {</span><br><span class="line">    if (/^on/.test(key)) {</span><br><span class="line">      // 如果 key 以 on 开头，那么说明它是事件</span><br><span class="line">      el.addEventListener(</span><br><span class="line">        key.substr(2).toLowerCase(), // 事件名称 onClick ---&gt; click</span><br><span class="line">        vnode.props[key] // 事件处理函数</span><br><span class="line">      )</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 处理 children</span><br><span class="line">  if (typeof vnode.children === 'string') {</span><br><span class="line">    // 如果 children 是字符串，说明是元素的文本子节点</span><br><span class="line">    el.appendChild(document.createTextNode(vnode.children))</span><br><span class="line">  } else if (Array.isArray(vnode.children)) {</span><br><span class="line">    // 递归地调用 renderer 函数渲染子节点，使用当前元素 el 作为挂载点</span><br><span class="line">    vnode.children.forEach(child =&gt; renderer(child, el))</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 将元素添加到挂载点下</span><br><span class="line">  container.appendChild(el)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const vnode = {</span><br><span class="line">  tag: 'div',</span><br><span class="line">  props: {</span><br><span class="line">    onClick: () =&gt; alert('hello')</span><br><span class="line">  },</span><br><span class="line">  children: 'click me'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">renderer(vnode, document.body)；</span><br></pre></td></tr></tbody></table></figure><h1 id="响应系统的作用和实现"><a href="#响应系统的作用和实现" class="headerlink" title="响应系统的作用和实现"></a>响应系统的作用和实现</h1><h2 id="4-1-响应式数据与副作用"><a href="#4-1-响应式数据与副作用" class="headerlink" title="4.1 响应式数据与副作用"></a>4.1 响应式数据与副作用</h2><p>副作用函数：会产生副作用的函数 即该函数的执行会直接或间接地影响到其他函数或变量的执行</p><h2 id="4-2-响应式数据的基本实现"><a href="#4-2-响应式数据的基本实现" class="headerlink" title="4.2 响应式数据的基本实现"></a>4.2 响应式数据的基本实现</h2><ul><li><p>通过拦截一个对象的读取和设置操作</p><ul><li><p>```<br>//当读取obj.text的时候 就将副作用函数储存到一个桶里面<br>//当设置obj.text的时候 就将副作用从桶里面取出执行便可<br>/ 存储副作用函数的桶<br>const bucket = new Set()</p><p>// 原始数据<br>const data = { text: ‘hello world’ }<br>// 对原始数据的代理<br>const obj = new Proxy(data, {<br>  // 拦截读取操作<br>  get(target, key) {</p><pre><code>// 将副作用函数 effect 添加到存储副作用函数的桶中bucket.add(effect)// 返回属性值return target[key]</code></pre><p>  },<br>  // 拦截设置操作<br>  set(target, key, newVal) {</p><pre><code>// 设置属性值target[key] = newVal// 把副作用函数从桶里取出并执行bucket.forEach(fn =&gt; fn())</code></pre><p>  }<br>})</p><p>function effect() {<br>  document.body.innerText = obj.text<br>}<br>effect()</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    **缺陷**：如果副作用改名或者是匿名函数 则该响应系统失效</span><br><span class="line"></span><br><span class="line">- 设计一个完善的响应系统</span><br><span class="line"></span><br><span class="line">  - 提供一个用来注册副作用函数的机制来解决上面的问题</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    //用一个变量春促当前激活的effect函数</span><br><span class="line">    let activeEffect;</span><br><span class="line">    function effect(fn) {</span><br><span class="line">    //当调用effect注册副作用函数是 将副作用函数赋值给activeEffect</span><br><span class="line">    activeEffect = fn;</span><br><span class="line">    fn(0);//执行副作用函数</span><br><span class="line">    };</span><br><span class="line">    effect(() =&gt; {</span><br><span class="line">    console.log('effect do');</span><br><span class="line">    documrnt.body.innerText = obj.text;//进行读取操作</span><br><span class="line">    })</span><br><span class="line">    const obj = new Proxy(data, {</span><br><span class="line">    get(target, key) {</span><br><span class="line">    //将当前被调用的副作用函数加入到桶中</span><br><span class="line">    if(activeEffect) {</span><br><span class="line">    bucket.add(activeEffect)//新增</span><br><span class="line">    }</span><br><span class="line">    return target[key];</span><br><span class="line">    },</span><br><span class="line">    set(target, key, newVal) {</span><br><span class="line">    target[key] = newVal;</span><br><span class="line">    bucket.forEach( fn =&gt; fn());</span><br><span class="line">    return true;</span><br><span class="line">    }</span><br><span class="line">    })</span><br></pre></td></tr></tbody></table></figure><p><strong>完成了可以添加匿名或任意名字的副作用函数</strong></p><p><strong>缺陷：无法监听指定属性，即如果进行类似于新增不存在的属性 该副作用函数依然会被执行（正常不应该被执行）</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">测试：新增不存在的obj.text2属性</span><br><span class="line">effect(() =&gt; {</span><br><span class="line">obj.body.innerText = obj.text</span><br><span class="line"></span><br><span class="line">console.log('effect done')</span><br><span class="line">});</span><br><span class="line">setTimeout(() =&gt; {</span><br><span class="line">obj.text2 = 'none exists';//新增一个不存在的属性</span><br><span class="line">})</span><br><span class="line">//运行结果：effect done 执行两次</span><br><span class="line">//分析：每次修改对象obj都会将effect存入桶中 导致读取时执行不该执行的副作用</span><br><span class="line">//没有在副作用函数与被操作的目标之间建立明确的联系</span><br><span class="line">**解决方法：在副作用函数与被操作的字段之间建立联系 可以使用weakMap</span><br><span class="line">//储存副作用的桶</span><br><span class="line">const bucket = new WeakMap();</span><br><span class="line">//修改拦截器</span><br><span class="line">const obj = new Proxy(data, {</span><br><span class="line">//拦截读取行为</span><br><span class="line">get(target, key) {</span><br><span class="line">//没有activeEffect 直接return</span><br><span class="line">if(!activeEffect) return;</span><br><span class="line">//根据traget从桶中取得desMap， ：key --&gt; effects</span><br><span class="line">let desMap = bucket.get(target);</span><br><span class="line">//如果不存在desMap 那么就创建一个WeakMap</span><br><span class="line">if(!desMap) {</span><br><span class="line">bucket.set(target, (desMap = new Map()))</span><br><span class="line">}</span><br><span class="line">//根据key自从desMap中读取deps deps时一个set类型</span><br><span class="line">//里面储存着所有与当前key有相关的副作用函数:effects</span><br><span class="line">let deps = desMap.get(key);</span><br><span class="line">if(!deps) {</span><br><span class="line">desMap.set(key, (deps = new Set()));</span><br><span class="line">}</span><br><span class="line">deps.add(activeEffect);//将激活的副作用函数存储到桶里</span><br><span class="line">return target[key];//返回属性值</span><br><span class="line">};</span><br><span class="line">//拦截设置操作</span><br><span class="line">set(target, key, newVal) {</span><br><span class="line">//设置属性值</span><br><span class="line">target[key] = newVal;</span><br><span class="line">//根据target从decket中取出desMap</span><br><span class="line">let desMap = ducket.get(target);</span><br><span class="line">if(!desMap) return;</span><br><span class="line">//根据key取得所有的副作用函数并依次执行</span><br><span class="line">let deps = desMap.get(key);</span><br><span class="line">deps &amp;&amp; deps.forEach( fn =&gt; fn());//判空再执行</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><img src="https://i.bmp.ovh/imgs/2022/04/01/5648b7ab427b5fd9.jpg" style="zoom: 50%;"></li><li><p><strong>为什么使用 WeakMap 不使用 Map</strong></p><ul><li>weakMap 是弱引用 不会影响垃圾回收</li><li>只有当 key 所引用的对象存在时（没有被回收时）才有价值的信息都优先使用 weakMap 来存储</li></ul></li><li><p>**存在问题：代码耦合度高 **</p></li><li><p><strong>解决方法： 抽离封装</strong></p></li><li><pre><code>function track(target, key) {  let depsMap = bucket.get(target)  if (!depsMap) {    bucket.set(target, (depsMap = new Map()))  }  let deps = depsMap.get(key)  if (!deps) {    depsMap.set(key, (deps = new Set()))  }  deps.add(activeEffect)}function trigger(target, key) {  const depsMap = bucket.get(target)  if (!depsMap) return  const effects = depsMap.get(key)  effects &amp;&amp; effects.forEach(fn =&gt; fn())}// 对原始数据的代理const obj = new Proxy(data, {  // 拦截读取操作  get(target, key) {    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中    track(target, key)    // 返回属性值    return target[key]  },  // 拦截设置操作  set(target, key, newVal) {    // 设置属性值    target[key] = newVal    // 把副作用函数从桶里取出并执行    trigger(target, key)  }})<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 4.4 切换分支与 cleanup</span><br><span class="line"></span><br><span class="line">分支切换可能会产生遗留的副作用函数</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>effect(function effectFn() {    document.body.innerText = obj.ok? obj.text : 'not'})//此时依赖函数被obj.ok和obj.text同时依赖 当obj.ok为false时 无论obj.text怎么变化 都是'not' 所以不应该触发副作用函数//解决方法：每次副作用函数执行时 都把它从所有与之关联的依赖集合中删除//当副作用执行完毕后 会建立联系 但再新的联系中不会包含遗留的副作用函数<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**副作用依赖函数集合**</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>//用一个全局变量储存被注册的副作用函数let activeEffect;function effect(fn) {//当effectFn被执行时 将其设置为当前的激活的副作用函数    const effectFn = () =&gt; {        activeEffect = effectFn;        fn();    }    //effectEffect.deps 用来储存所有与该副作用函数想关联的依赖集合    effectEn.dep = [];    //执行副作用函数    effectFn();}<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **Track 函数**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  function track(target, key) {</span><br><span class="line">  if(!activeEffect) return;</span><br><span class="line">  let depsMap = bucket.get(key);</span><br><span class="line">  if(!depsMap) {</span><br><span class="line">  bucket.set(target, (desMap =&gt; new Map()));</span><br><span class="line">  }</span><br><span class="line">  let deps = depsMap.get(key);</span><br><span class="line">  if(!deps) {</span><br><span class="line">  depsMap.set(key, ( deps =&gt; new Set()))</span><br><span class="line">  };</span><br><span class="line">  //把当前激活的副作用函数添加到依赖集合deps中</span><br><span class="line">  deps.add(activeEffect);</span><br><span class="line">  //deps就是一个与当前副作用函数存在联系的集合</span><br><span class="line">  //将其添加到activeEffects.deps中</span><br><span class="line">  activeEffect.deps.push(deps);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>- 有了这个联系后 再每次执行副作用函数时 根据 effectFn.deps 获取所有的相关联的依赖集合 从而将副作用函数从依赖集合中清除- ```  let activeEffect;  function effect(fn) {      const effectFn = () =&gt; {          //调用cleanUp函数完成清除依赖          cleanup(effectFn);          activeEffect = effectFn;          fn();      }  }  function cleanup(effectFn) {  //遍历effectFn.deps数组    for (let i = 0; i &lt; effectFn.deps.length; i++) {    //deps时依赖集合      const deps = effectFn.deps[i]      //将effectFn从依赖集合中删除      deps.delete(effectFn)    }    //重置effectFn.deps数组    effectFn.deps.length = 0  }  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    -</span><br><span class="line"></span><br><span class="line"># 非原始值的响应式方案</span><br><span class="line"></span><br><span class="line">## 5.1Proxy 以及 Reflect</span><br><span class="line"></span><br><span class="line">**proxy 只能代理对象 不能代理其他类型的数据**</span><br><span class="line"></span><br><span class="line">### 5.1.2 Reflect</span><br><span class="line"></span><br><span class="line">Reflect 可以接受第三个参数 即 receiver 相当于函数调用过程中的 this</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>const obj = {foo: 1};Reflect.get(obj, foo, {foo: 2});//输出2</code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学Vue第一天</title>
      <link href="/2022/04/09/chong-xue-vue/"/>
      <url>/2022/04/09/chong-xue-vue/</url>
      
        <content type="html"><![CDATA[<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span :title="toTitleDate(date)"&gt;</span><br><span class="line">  {{ formatDate(date) }}//formatData不应该时更改数据或者触发异步操作</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>每次组件更新时 都会调用绑定表达式内部调用的函数 因此他们不应该产生任何副作用 例如更改数据或触发异步操作</strong></p><h4 id="受限的全局访问"><a href="#受限的全局访问" class="headerlink" title="受限的全局访问"></a>受限的全局访问</h4><p>魔棒表达式是沙盒化的 只能访问全局的受限列表（该列表公布了常用的内置全局变量 如 Math Date）未明确包含在列表中的全局变量（用户附加属性）</p><p>将无法在模板表达式中访问 可以将所有 Vue 表达式添加到<code>app.config.globalProperties</code>来显式定义其他全局变量（window）</p><h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:[attributeName]="url"&gt; ... &lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- shorthand --&gt;</span><br><span class="line">&lt;a :[attributeName]="url"&gt; ... &lt;/a&gt;</span><br><span class="line">//如果组件实例具有数据属性 则此绑定等价于 attributeName attributeName 'href' v-bind:href</span><br><span class="line">//避免使用大写字符命名键 因为浏览器会强制将属性名称转化为小写 someAttr -&gt; someattr</span><br></pre></td></tr></tbody></table></figure><h4 id="DOM-更新时间"><a href="#DOM-更新时间" class="headerlink" title="DOM 更新时间"></a>DOM 更新时间</h4><p>dom 更新不是同步更新的 vue 会缓冲它们知道更新周期的下一个“next tick” 以确保不管进行了多少状态更改 每个组件都只需要更新依次</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//要在状态更改后等待DOM更新完成 可以使用nextTick全局API</span><br><span class="line">Import {nextTick} form 'vue';</span><br><span class="line">function increment() {</span><br><span class="line">  state.count++</span><br><span class="line">  nextTick(() =&gt; {</span><br><span class="line">    // access updated DOM</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 vue 中默认深度响应的 即在嵌套的对象或数组中也可以检测到更改 也可以显式地创建浅反应对象 仅在跟级别跟踪反应性 但是通常仅在高级用例中需要（后面学到补充）</p><h4 id="反应式代理与原始"><a href="#反应式代理与原始" class="headerlink" title="反应式代理与原始"></a>反应式代理与原始</h4><p><strong>reactive（）是原对象的代理 而不是原对象的返回值</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const raw = {}</span><br><span class="line">const proxy = reactive(raw)//返回的是代理Proxy对象</span><br><span class="line"></span><br><span class="line">// proxy is NOT equal to the original.</span><br><span class="line">console.log(proxy === raw) // false</span><br></pre></td></tr></tbody></table></figure><p>如果只是代理反应 那么改变原始对象不会触发更新 所以 Vue 的响应式系统是使用状态的代理版本 为了确保对代理的始终统一访问 使用 reactive 同一个对象 然后调用 reacitive 一个现有的代理也返回同一个代理</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// calling reactive() on the same object returns the same proxy</span><br><span class="line">console.log(reactive(raw) === proxy) // true</span><br><span class="line"></span><br><span class="line">// calling reactive() on a proxy returns itself</span><br><span class="line">console.log(reactive(proxy) === proxy) // true</span><br></pre></td></tr></tbody></table></figure><p><strong>由于 Vue 的响应式适用于属性访问 因此我们必须保持响应式对象的相同引用 这意味着我们不能轻易地替换反应式对象 以为与第一个引用的反应性连接丢失了</strong></p><p>这也意味着当我们将反应性对象的属性分配或解构为局部变量时 或者将属性传递给函数时 将失去响应性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const state = reactive({ count: 0 })</span><br><span class="line"></span><br><span class="line">// n is a local variable that is disconnected</span><br><span class="line">// from state.count.</span><br><span class="line">let n = state.count</span><br><span class="line">// does not affect original state</span><br><span class="line">n++</span><br><span class="line"></span><br><span class="line">// count is also disconnected from state.count.</span><br><span class="line">let { count } = state</span><br><span class="line">// does not affect original state</span><br><span class="line">count++</span><br><span class="line"></span><br><span class="line">// the function receives a plain number and</span><br><span class="line">// won't be able to track changes to state.count</span><br><span class="line">callSomeFunction(state.count)</span><br></pre></td></tr></tbody></table></figure><h4 id="ref（）"><a href="#ref（）" class="headerlink" title="ref（）"></a>ref（）</h4><p>当持有对象类型时 ref 会自动将其.value 与 reactive（） 包含对象值的 ref 可以反应性替换整个对象</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const objectRef = ref({ count: 0 })</span><br><span class="line"></span><br><span class="line">// this works reactively</span><br><span class="line">objectRef.value = { count: 1 }</span><br></pre></td></tr></tbody></table></figure><p>Refs 也可以传递给函数或从普通对象中解构，而不会失去反应性：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj = {</span><br><span class="line">  foo: ref(1),</span><br><span class="line">  bar: ref(2)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// the function receives a ref</span><br><span class="line">// it needs to access the value via .value but it</span><br><span class="line">// will retain the reactivity connection</span><br><span class="line">callSomeFunction(obj.foo)</span><br><span class="line"></span><br><span class="line">// still reactive</span><br><span class="line">const { foo, bar } = obj</span><br></pre></td></tr></tbody></table></figure><p><strong>换句话说，<code>ref()</code>允许我们创建对任何值的“引用”并在不失去反应性的情况下传递它。此功能非常重要，因为它在将逻辑提取到<a href="https://vuejs.org/guide/reusability/composables.html">Composable Functions</a>时经常使用。</strong></p><p>当 ref 作为响应式对象的属性被访问或改变时 他会自动被解包 因此它的行为类似于普通属性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const count = ref(0)</span><br><span class="line">const state = reactive({</span><br><span class="line">  count</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">console.log(state.count) // 0</span><br><span class="line"></span><br><span class="line">state.count = 1</span><br><span class="line">console.log(count.value) // 1</span><br></pre></td></tr></tbody></table></figure><p>如果将新的 ref 分配给现有的 ref 属性 他将替代旧的 ref</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line">const state = reactive({</span><br><span class="line">  count</span><br><span class="line">})</span><br><span class="line">const otherCount = ref(2)</span><br><span class="line"></span><br><span class="line">state.count = otherCount</span><br><span class="line">console.log(count.value) // 0</span><br><span class="line">console.log(state.count) // 2</span><br><span class="line"></span><br><span class="line">state.count = 3</span><br><span class="line">console.log(count.value) // 0</span><br><span class="line">console.log(otherCount.value)//3</span><br></pre></td></tr></tbody></table></figure><p>*<em>Ref 展开仅在嵌套在深层反应对象时发生 当它作为浅反应对象的属性被访问时 它不适用</em></p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>computed（）函数需要传递一个 getter 函数 返回值是一个计算的 ref 计算属性会自动跟踪其反应性依赖关系</p><p>getters 没有副作用 ：计算属性只执行纯计算并且没有副作用 所以不要发出异步请求或者在计算的 getter 上改变 DOM</p><h2 id="类和样式绑定"><a href="#类和样式绑定" class="headerlink" title="类和样式绑定"></a>类和样式绑定</h2><p>可以绑定到返回对象的计算属性 这是一种常见且强大的模式</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const isActive = ref(true)</span><br><span class="line">const error = ref(null)</span><br><span class="line"></span><br><span class="line">const classObject = computed(() =&gt; ({</span><br><span class="line">  active: isActive.value &amp;&amp; !error.value,</span><br><span class="line">  'text-danger': error.value &amp;&amp; error.value.type === 'fatal'</span><br><span class="line">}))</span><br><span class="line">&lt;div :class="classObject"&gt;&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果想要 有条件切换列表中的值 可以用三元表达式实现</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :class="[isActive ? activeClass : '', errorClass]"&gt;&lt;/div&gt;</span><br><span class="line">//这将始终适用errorClass 但是activeClass仅在为真的时候才适用</span><br><span class="line">//如果有多个条件类 可以使用对象语法</span><br><span class="line">&lt;div :class="[{ active: isActive }, errorClass]"&gt;&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p>当在具有单个根元素的组件上使用该属性时 这些类将添加到组件的根元素中 并与该组件上已有的现有类合并</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- child component template --&gt;</span><br><span class="line">&lt;p class="foo bar"&gt;Hi!&lt;/p&gt;</span><br><span class="line">!-- when using the component --&gt;</span><br><span class="line">&lt;my-component class="baz boo"&gt;&lt;/my-component&gt;</span><br><span class="line">呈线的html将为</span><br><span class="line">&lt;p class="foo bar baz boo"&gt;Hi&lt;/p&gt;</span><br><span class="line">类绑定也是这样</span><br><span class="line">如果组件有多个根元素 则需要定义哪些元素将接收此类 可以使用$attrs组件属性来执行此操作</span><br><span class="line">&lt;!-- my-component template using $attrs --&gt;</span><br><span class="line">&lt;p :class="$attrs.class"&gt;Hi!&lt;/p&gt;</span><br><span class="line">&lt;span&gt;This is a child component&lt;/span&gt;</span><br><span class="line">&lt;my-component class="baz"&gt;&lt;/my-component&gt;</span><br><span class="line">将渲染为</span><br><span class="line">&lt;p class="baz"&gt;Hi!&lt;/p&gt;</span><br><span class="line">&lt;span&gt;This is a child component&lt;/span&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><p>v-if 是一个指令 必须添加到单个元素上 可以将 v-if 在一个 template 上使用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if="ok"&gt;&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>v-show 将始终被渲染在 DOM 中 仅切换 display 元素的 css 属性 不支持使用在 template</p><p>经常切换使用 v-show 不经常使用则用 v-show</p><p><strong>v-for 遍历对象时 顺序基于枚举顺序 Objects.keys(), 这不能保证在 JavaScript 引擎实现中保持一致</strong>、</p><p>可以在 template 中使用 v-for 来渲染一个包含多个元素的块</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;template v-for="item in items"&gt;</span><br><span class="line">    &lt;li&gt;{{ item.msg }}&lt;/li&gt;</span><br><span class="line">    &lt;li class="divider" role="presentation"&gt;&lt;/li&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>为什么 v-for 要提供 key</strong></p><ul><li>当 vue 更新使用渲染的元素列表时 v-for 默认使用就地补丁策略（如果数据项的顺序发生了变化 而不是移动 DOM 元素来匹配项的顺序 VUE 将就地补丁修补每个元素并确保他们反映应该在该特定索引处呈现的内容）但这种模式仅适用于列表的渲染输出不依赖子组件或者临时 DOM 状态（表单输入值）的情况</li><li>为了给 vue 一个提示以便它可以跟踪每个节点的身份 从而重用或重新排序现有元素 需要提供一个唯一的 key</li></ul><h4 id="数组变化侦测"><a href="#数组变化侦测" class="headerlink" title="数组变化侦测"></a>数组变化侦测</h4><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><p>在 vue 中 将一个数组替换为另一个数组包含重叠对象的数组是一种高效的操作 如使用新数组替换旧数组:concact() slice()</p><p>当我们需要显示一个经过过滤或排序的数组版本 而不需要实际改变或重置原始数据 可以创建一个返回过滤或排序数组的计算属性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const numbers = ref([1, 2, 3, 4, 5])</span><br><span class="line"></span><br><span class="line">const evenNumbers = computed(() =&gt; {</span><br><span class="line">  return numbers.value.filter((n) =&gt; n % 2 === 0)</span><br><span class="line">})</span><br><span class="line">&lt;li v-for="n in evenNumbers"&gt;{{ n }}&lt;/li&gt;</span><br></pre></td></tr></tbody></table></figure><p>在计算属性不行使 比如嵌套的 v-for 循环中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const sets = ref([</span><br><span class="line">  [1, 2, 3, 4, 5],</span><br><span class="line">  [6, 7, 8, 9, 10]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">function even(numbers) {</span><br><span class="line">  return numbers.filter((number) =&gt; number % 2 === 0)</span><br><span class="line">}</span><br><span class="line">&lt;ul v-for="numbers in sets"&gt;</span><br><span class="line">  &lt;li v-for="n in even(numbers)"&gt;{{ n }}&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">输出：2 4 6 8 10</span><br></pre></td></tr></tbody></table></figure><p><strong>在计算属性中使用 reverse 和 sort 要小心 因为他们会改变原始数组 在计算属性的 getter 中应该避免这种情况 在调用前先创建原始数据的副本</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- return numbers.reverse()</span><br><span class="line">+ return [...numbers].reverse()</span><br></pre></td></tr></tbody></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>当我们需要访问内联处理程序中的原始 DOM 事件 可以用特殊变量将其传递给方法$event 或者使用内联箭头函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click="warn('Form cannot be submitted yet.', $event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- using inline arrow function --&gt;</span><br><span class="line">&lt;button @click="(event) =&gt; warn('Form cannot be submitted yet.', event)"&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="表单上输入绑定"><a href="#表单上输入绑定" class="headerlink" title="表单上输入绑定"></a>表单上输入绑定</h4><ul><li><code>&lt;input&gt;</code>文本类型和<code>&lt;textarea&gt;</code>元素使用<code>value</code>属性和<code>input</code>事件；</li><li><code>&lt;input type="checkbox"&gt;``&lt;input type="radio"&gt;</code>使用<code>checked</code>和事件<code>change</code>；</li><li><code>&lt;select&gt;</code>用作<code>value</code>和<code>change</code>事件。</li></ul><p><strong>v-model<code>将忽略在任何表单元素上找到的初始或属性</code>value<code>。它将始终将当前绑定的 JavaScript 状态视为事实来源。您应该使用反应性 API在 JavaScript 端声明初始值。</code>checked``selected</strong></p>]]></content>
      
      
      <categories>
          
          <category> -web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue TS 框架 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
